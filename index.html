<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ç†è«–ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯å‹‰å¼·ãƒãƒ¼ãƒˆï¼ˆæš«å®šç‰ˆï¼‰</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans JP", sans-serif;
            line-height: 1.8;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background: 
                linear-gradient(135deg, rgba(201, 234, 102, 0) 0%, rgba(126, 206, 255, 0) 100%),
                url('./header_image01_orchard.png') center 75%/cover no-repeat;
            color: white;
            padding: 60px 40px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .header h1,
        .header .subtitle {
            background: rgba(0, 0, 0, 0.2);
            padding: 0px 8px;
            border-radius: 0px;
            margin: 0;
            display: inline-block;
        }
        .header .subtitle {
            margin-top: 4px;
        }
        h1 {
            font-size: 2.5em;
        }
        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }
        .section {
            background: white;
            padding: 30px;
            margin-bottom: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        h2 {
            color: #666;
            border-bottom: 3px solid #666;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        h3 {
            color: #444;
            margin-top: 25px;
        }
        .dimension-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .dimension-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 5px solid #667eea;
        }
        .phase-container {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .phase-card {
            flex: 1;
            min-width: 250px;
            background: #fff;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .phase-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .phase-1 { border-color: #ff6b6b; }
        .phase-2 { border-color: #ffd43b; }
        .phase-3 { border-color: #51cf66; }
        .principle {
            background: #e3f2fd;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border-left: 5px solid #2196f3;
        }
        .checklist {
            background: #f0f4ff;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .checklist h4 {
            color: #666;
            margin-bottom: 15px;
        }
        .checklist ul {
            list-style: none;
            padding: 0;
        }
        .checklist li {
            padding: 8px 0;
            padding-left: 30px;
            position: relative;
        }
        .checklist li:before {
            content: "â–¡";
            position: absolute;
            left: 0;
            color: #667eea;
            font-weight: bold;
        }
        .highlight {
            background: #ffeb3b;
            padding: 2px 6px;
            border-radius: 3px;
        }
        .example {
            background: #e8f5e9;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 4px solid #4caf50;
            font-style: italic;
        }
        .arrow {
            text-align: center;
            font-size: 2em;
            color: #667eea;
            margin: 20px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background: #667eea;
            color: white;
        }
        tr:nth-child(even) {
            background: #f9f9f9;
        }
        .practical-tips {
            background: #fff3cd;
            padding: 20px;
            border-radius: 8px;
            border-left: 5px solid #ffc107;
            margin: 20px 0;
        }
        .advanced-section {
            background: #f0f7ff;
            padding: 30px;
            margin: 20px 0;
            border-radius: 10px;
            border: 2px solid #667eea;
        }
        .sub-phase {
            background: #fafbfc;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }
        .sub-phase h4 {
            margin: 0 0 10px 0;
            color: #667eea;
        }
        .lpm-step {
            background: #f8f9fa;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 4px solid #2196f3;
        }
        .lpm-step h5 {
            margin: 0 0 10px 0;
            color: #2196f3;
        }
        .toggle-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px 0;
            transition: background 0.3s;
        }
        .toggle-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            text-decoration: none;
            color: white;
        }
        .collapsible {
            display: none;
            margin-top: 20px;
        }
        .collapsible.active {
            display: block;
        }
        .journey-table {
            overflow-x: auto;
        }
        .journey-table table {
            font-size: 0.9em;
        }
        .journey-table td {
            vertical-align: top;
        }
        @media (max-width: 768px) {
            .phase-container {
                flex-direction: column;
            }
            .dimension-grid {
                grid-template-columns: 1fr;
            }
            .journey-table {
                overflow-x: scroll;
            }
        }
        
        /* 3D Integration Styles */
        .sa-3d-integration {
            margin: 30px 0;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0);
        }
        
        .sa-3d-integration h4 {
            color: #667eea;
            margin: 0 0 15px 0;
            font-size: 1.3em;
        }
        
        .sa-3d-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .sa-3d-loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            z-index: 10;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(102, 126, 234, 0.3);
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Canvas 2D ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³çµ±åˆã‚¹ã‚¿ã‚¤ãƒ« */
        .canvas-2d-integration {
            margin: 25px 0;
            padding: 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            border: 2px solid #dee2e6;
        }
        
        .canvas-2d-integration h4 {
            color: #667eea;
            margin: 0 0 15px 0;
            font-size: 1.3em;
        }
        
        .journey-canvas-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        #journey-canvas {
            display: block;
            cursor: crosshair;
            background: transparent;
            width: 100%;
            height: 100%;
        }
        
        .journey-controls {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 10;
            background: rgba(26, 26, 46, 0.95);
            padding: 12px;
            border-radius: 12px;
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 240px;
            color: white;
            font-size: 0.9em;
        }
        
        .journey-controls h5 {
            color: #ffffff;
            margin: 0 0 8px 0;
            font-size: 1em;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            text-align: center;
        }
        
        .journey-stage-info {
            margin-bottom: 10px;
            padding: 8px 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            font-size: 0.8em;
            line-height: 1.3;
            box-shadow: 0 3px 12px rgba(102, 126, 234, 0.3);
            text-align: center;
        }
        
        .journey-stage-info small {
            display: block;
            opacity: 0.9;
            font-size: 0.85em;
            margin-top: 2px;
        }
        
        .journey-button-group {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
        }
        
        .journey-controls button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
            font-weight: 500;
            transition: all 0.3s ease;
            flex: 1;
            box-shadow: 0 3px 12px rgba(102, 126, 234, 0.2);
        }
        
        .journey-controls button.reset-btn {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            padding: 6px 10px;
            font-size: 0.75em;
        }
        
        .journey-controls button:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .journey-controls button.reset-btn:hover {
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }
        
        .journey-controls button:disabled {
            cursor: not-allowed;
            opacity: 0.4;
            transform: none !important;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1) !important;
        }
        
        .journey-stage-indicator {
            display: flex;
            gap: 6px;
            margin-top: 8px;
            justify-content: center;
        }
        
        .journey-stage-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .journey-stage-dot.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transform: scale(1.3);
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.6);
        }
        
        .journey-instructions {
            position: absolute;
            top: 185px;
            left: 15px;
            background: rgba(26, 26, 46, 0.95);
            padding: 12px;
            border-radius: 12px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            width: 240px;
            font-size: 0.75em;
            line-height: 1.2;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            z-index: 10;
        }
        
        .journey-instructions:hover {
            background: rgba(102, 126, 234, 0.2);
            border-color: rgba(102, 126, 234, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.3);
        }
        
        .journey-instructions-detail {
            display: none;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.9em;
            line-height: 1.3;
            opacity: 0;
            animation: fadeIn 0.3s ease forwards;
        }
        
        .journey-instructions-detail.show {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .journey-physics-info {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(26, 26, 46, 0.95);
            padding: 10px 12px;
            border-radius: 8px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 0.8em;
            line-height: 1.3;
        }
        
        .sa-3d-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        .stage-info-display {
            color: white;
            text-align: center;
            margin-bottom: 10px;
            min-height: 40px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .stage-info-display h5 {
            margin: 0 0 5px 0;
            color: #667eea;
            font-size: 1em;
        }
        
        .stage-info-display p {
            margin: 0;
            font-size: 0.85em;
            opacity: 0.9;
        }
        
        .stage-controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .stage-btn {
            background: #334155;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s;
            min-width: 40px;
        }
        
        .stage-btn:hover {
            background: #475569;
            transform: translateY(-2px);
        }
        
        .stage-btn.active {
            background: #667eea;
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
        }
        
        .tool-link {
            display: inline-block;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            text-decoration: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: 500;
            text-align: center;
            margin-top: 15px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
        }
        
        .tool-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            text-decoration: none;
            color: white;
        }
        
        .view-controls {
            display: flex;
            gap: 10px;
        }
        
        .view-controls button {
            background: #1e293b;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background 0.3s;
        }
        
        .view-controls button:hover {
            background: #475569;
        }
        
        /* æµ®éŠè¦–ç‚¹ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ */
        .floating-view-control {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 100;
            background: rgba(30, 41, 59, 0.9);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.2);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .floating-view-control:hover {
            background: rgba(59, 130, 246, 0.9);
            border-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
        }
        
        .floating-view-control:active {
            transform: scale(0.95);
        }
        
        .floating-view-control .tooltip {
            position: absolute;
            bottom: -35px;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .floating-view-control:hover .tooltip {
            opacity: 1;
        }

        .sa-3d-description {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .sub-phase h4 {
            transition: all 0.3s;
        }
        
        .sub-phase h4:hover {
            color: #764ba2;
            cursor: pointer;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            .sa-3d-container {
                height: 350px;
            }
            
            .sa-3d-controls {
                padding: 12px 15px;
                bottom: 10px;
            }
            
            .stage-controls {
                gap: 6px;
            }
            
            .stage-btn {
                padding: 6px 8px;
                font-size: 0.75em;
                min-width: 35px;
            }
            
            /* Canvas 2D ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
            .journey-canvas-container {
                height: 400px;
            }
            
            .journey-controls {
                padding: 10px;
                width: 200px;
                font-size: 0.85em;
            }
            
            .journey-controls button {
                padding: 6px 8px;
                font-size: 0.75em;
            }
            
            .journey-controls button.reset-btn {
                padding: 5px 8px;
                font-size: 0.7em;
            }
            
            .journey-instructions {
                top: 155px;
                left: 10px;
                right: auto;
                bottom: auto;
                width: 200px;
                padding: 10px;
                font-size: 0.65em;
            }
            
            .journey-physics-info {
                right: 10px;
                bottom: 70px;
                padding: 8px 10px;
                font-size: 0.75em;
            }
        }
        
        /* ã‚¸ãƒ£ãƒ¼ãƒ‹ãƒ¼ãƒãƒƒãƒ—ã‚»ã‚¯ã‚·ãƒ§ãƒ³ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
        .journey-map-section {
            background: #f8f9fa;
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
            border: 1px solid #e9ecef;
        }
        
        
        .toggle-icon {
            font-size: 1em;
            margin-left: 8px;
            transition: transform 0.3s ease;
        }
        
        .toggle-icon.rotated {
            transform: rotate(180deg);
        }
        
        .journey-map-container {
            padding: 0;
            transition: max-height 0.5s ease;
            overflow: hidden;
        }
        
        .journey-iframe-wrapper {
            padding: 20px;
            background: white;
        }
        
        .journey-map-description {
            padding: 20px 30px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
        }
        
        .journey-map-description h4 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .journey-map-description ul {
            margin-left: 20px;
        }
        
        .journey-map-description li {
            margin-bottom: 8px;
        }
        
        /* ãƒ•ãƒ¬ãƒ¼ã‚ºã‚¯ãƒ©ã‚¦ãƒ‰ã‚»ã‚¯ã‚·ãƒ§ãƒ³ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
        .phrases-cloud-section {
            background: #f8f9fa;
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
            border: 1px solid #e9ecef;
        }
        
        .phrases-cloud-container {
            padding: 0;
            transition: max-height 0.5s ease;
            overflow: hidden;
        }
        
        .phrases-iframe-wrapper {
            padding: 20px;
            background: white;
        }
        
        .phrases-cloud-description {
            padding: 20px 30px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
        }
        
        .phrases-cloud-description h4 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .phrases-cloud-description ul {
            margin-left: 20px;
        }
        
        .phrases-cloud-description li {
            margin-bottom: 8px;
        }
        
        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
        @media (max-width: 768px) {
            .journey-iframe-wrapper {
                padding: 10px;
            }
            
            #journey-map-iframe {
                height: 550px; /* ãƒ¢ãƒã‚¤ãƒ«ã§ã‚‚ã‚°ãƒ©ãƒ•ãŒè¦‹ãˆã‚‹é«˜ã• */
            }
        }
        
        @media (max-width: 480px) {
            .journey-iframe-wrapper {
                padding: 8px;
            }
            
            #journey-map-iframe {
                height: 500px; /* å°ç”»é¢ã§ã‚‚ã§ãã‚‹ã ã‘ã‚°ãƒ©ãƒ•ã‚’è¡¨ç¤º */
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ç†è«–ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯å‹‰å¼·ãƒãƒ¼ãƒˆ<br>ï¼ˆæš«å®šç‰ˆï¼‰</h1>
        <p class="subtitle">å¤§å­¦ã«ãŠã‘ã‚‹å­¦ç”Ÿã®æˆé•·æ”¯æ´ã®å–ã‚Šçµ„ã¿æ¤œè¨ç”¨ï¼ˆéšæ™‚æ›´æ–°ä¸­ï¼‰</p>
    </div>

    <div class="section">
        <h2>ğŸ“š å‚è€ƒæƒ…å ±</h2>
        <p>ä¸‹è¨˜ã®å†…å®¹ã¯ã€Baxter Magoldaã«ã‚ˆã‚‹ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ç†è«–ã€ãŠã‚ˆã³æ²³äº•äº¨ï¼ˆ2022ï¼‰ã€Œ<a href="https://ritsumei.repo.nii.ac.jp/records/16164" target="_blank">å¤§å­¦ç”Ÿã«ãŠã‘ã‚‹ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ç†è«– : æˆé•·ç†è«–ã®ãªã‹ã®ä½ç½®ã¥ã‘ãŠã‚ˆã³æˆé•·çµŒè·¯ã¨å½±éŸ¿è¦å› ã®æå‡º</a>ã€ã‚’å‚ç…§ã—ãªãŒã‚‰ä½œæˆã—ã¦ã„ã¾ã™ã€‚</p>
        <p>è«–æ–‡ã®å†…å®¹ã‹ã‚‰ç™ºæƒ³ã‚’åºƒã’ã¦è¿½åŠ ã—ã¦ã„ã‚‹å†…å®¹ã‚‚ã‚ã‚Šã€å¿…ãšã—ã‚‚å¿ å®Ÿã«è«–æ–‡ã®å†…å®¹ã‚’ç´¹ä»‹ã—ã¦ã„ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
        <p>ã‚ˆã‚Šè©³ç´°ãªç†è«–çš„èƒŒæ™¯ã‚„å®Ÿè·µäº‹ä¾‹ã«ã¤ã„ã¦ã¯ã€åŸè‘—è«–æ–‡ã‚’ã”å‚ç…§ãã ã•ã„ã€‚</p>
    </div>

    <div class="section">
        <h2>ğŸ¯ ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã¨ã¯ï¼Ÿ</h2>
        <p><strong>ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—</strong>ã¨ã¯ã€<span class="highlight">ã€Œè‡ªå·±ã®ä¿¡å¿µã€ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã€ç¤¾ä¼šé–¢ä¿‚ã‚’å®šç¾©ã™ã‚‹å†…çš„èƒ½åŠ›ã€</span>ã®ã“ã¨ã§ã™ã€‚</p>
        <p>äººãŒå¤–éƒ¨ã®æ¨©å¨ã‚„æœŸå¾…ã«ä¾å­˜ã™ã‚‹ã®ã§ã¯ãªãã€è‡ªåˆ†è‡ªèº«ã®å†…ãªã‚‹å£°ã«åŸºã¥ã„ã¦äººç”Ÿã‚’åˆ‡ã‚Šé–‹ã„ã¦ã„ãåŠ›ã‚’æŒ‡ã—ã¾ã™ã€‚ã“ã‚Œã¯21ä¸–ç´€ã®é«˜ç­‰æ•™è‚²ã«ãŠã‘ã‚‹é‡è¦ãªå­¦ç¿’æˆæœã¨ã—ã¦ä½ç½®ã¥ã‘ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚</p>
        
        <div class="practical-tips">
            <strong>ğŸ’¡ ãªãœé‡è¦ï¼Ÿ</strong>
            <ul>
                <li>æ‰¹åˆ¤çš„æ€è€ƒåŠ›ã¨ä¸»ä½“çš„ãªå­¦ç¿’æ…‹åº¦ã®è‚²æˆ</li>
                <li>è¤‡é›‘ãªç¤¾ä¼šã§è‡ªå¾‹çš„ã«ç”Ÿãã‚‹åŠ›ã®ç²å¾—</li>
                <li>å¤šæ§˜ãªä¾¡å€¤è¦³ã®ä¸­ã§è‡ªåˆ†ã®è»¸ã‚’æŒã¤åŠ›ã®å½¢æˆ</li>
            </ul>
        </div>
        
        <!-- æ–°è¦è¿½åŠ ï¼šãƒ•ãƒ¬ãƒ¼ã‚ºã‚¯ãƒ©ã‚¦ãƒ‰ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <button class="toggle-button" onclick="togglePhrasesCloud()">ğŸ’­ å¤šæ§˜ãªå£°ãƒ»å•ã„ã‚’è¡¨ç¤ºã™ã‚‹ <span class="toggle-icon" id="phrases-toggle-icon">â–¼</span></button>
        
        <div class="phrases-cloud-section">
            
            <div class="phrases-cloud-container" id="phrases-cloud-container" style="display: none;">
                <div class="phrases-iframe-wrapper">
                    <iframe id="phrases-cloud-iframe"
                            src="./3d_phrases_cloud_embed.html"
                            width="100%"
                            height="800px"
                            frameborder="0"
                            style="border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    </iframe>
                </div>
                
                <div class="phrases-cloud-description">
                    <h4>ä¸Šã®ç”»é¢ã«ã¤ã„ã¦</h4>
                    <p>ã“ã®ãƒ“ãƒ¥ãƒ¼ã‚¢ã¯ã€è¨­å®šã—ãŸãƒ•ãƒ¬ãƒ¼ã‚ºã‚’3Dç©ºé–“ã«è¡¨ç¤ºã•ã›ã‚‹ã‚‚ã®ã§ã™ã€‚ï¼ˆâ€»æœ€åˆã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆã¯ã‚µãƒ³ãƒ—ãƒ«ã¨ã—ã¦ä½œæˆã—ãŸã‚‚ã®ã§ã™ï¼‰</p>
                    <ul>
                        <li><strong>ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–è¡¨ç¤ºï¼š</strong>ãƒã‚¦ã‚¹ã§è¦–ç‚¹ã‚’è‡ªç”±ã«å¤‰æ›´å¯èƒ½</li>
                        <li><strong>ã‚«ãƒ†ã‚´ãƒªåˆ†é¡ï¼š</strong>è‰²åˆ†ã‘ã«ã‚ˆã‚‹é–¢å¿ƒé ˜åŸŸã®å¯è¦–åŒ–</li>
                        <li><strong>è©³ç´°ç¢ºèªï¼š</strong>å„ãƒ•ãƒ¬ãƒ¼ã‚ºã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è©³ç´°ã‚’ç¢ºèª</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>ğŸ“Š 3ã¤ã®æˆé•·æ¬¡å…ƒ</h2>
        <p>ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã¯ã€ä»¥ä¸‹ã®3ã¤ã®æ¬¡å…ƒã§æ‰ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼š</p>
        
        <div class="dimension-grid">
            <div class="dimension-card">
                <h3>ğŸ§  èªè­˜è«–çš„æ¬¡å…ƒ</h3>
                <p><strong>å•ã„ï¼šã€Œç§ã¯ã©ã®ã‚ˆã†ã«çŸ¥ã‚‹ã®ã‹ï¼Ÿã€</strong></p>
                <p>çŸ¥è­˜ã‚„çœŸå®Ÿã‚’ã©ã®ã‚ˆã†ã«æ‰ãˆã€ç†è§£ã™ã‚‹ã‹ã«é–¢ã™ã‚‹æˆé•·</p>
                <div class="example">
                    ä¾‹ï¼šã€Œæ•™ç§‘æ›¸ã«æ›¸ã„ã¦ã‚ã‚‹ã‹ã‚‰æ­£ã—ã„ã€ã‹ã‚‰ã€Œè¤‡æ•°ã®è¦–ç‚¹ã‚’æ¯”è¼ƒæ¤œè¨ã—ã¦è‡ªåˆ†ã®è€ƒãˆã‚’å½¢æˆã™ã‚‹ã€ã¸
                </div>
            </div>
            
            <div class="dimension-card">
                <h3>ğŸª å¯¾è‡ªé–¢ä¿‚æ¬¡å…ƒ</h3>
                <p><strong>å•ã„ï¼šã€Œç§ã¯ä½•è€…ã‹ï¼Ÿã€</strong></p>
                <p>è‡ªå·±ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚„ä¾¡å€¤è¦³ã®å½¢æˆã«é–¢ã™ã‚‹æˆé•·</p>
                <div class="example">
                    ä¾‹ï¼šã€Œè¦ªã‚„å‘¨å›²ãŒæœŸå¾…ã™ã‚‹è‡ªåˆ†ã€ã‹ã‚‰ã€Œè‡ªåˆ†è‡ªèº«ã§é¸æŠã—ãŸä¾¡å€¤è¦³ã«åŸºã¥ãè‡ªåˆ†ã€ã¸
                </div>
            </div>
            
            <div class="dimension-card">
                <h3>ğŸ¤ å¯¾äººé–¢ä¿‚æ¬¡å…ƒ</h3>
                <p><strong>å•ã„ï¼šã€Œä»–è€…ã¨ã©ã®ã‚ˆã†ã«é–¢ã‚ã‚‹ã‹ï¼Ÿã€</strong></p>
                <p>ä»–è€…ã¨ã®é–¢ä¿‚æ€§ã‚’ã„ã‹ã«æ§‹ç¯‰ã™ã‚‹ã‹ã«é–¢ã™ã‚‹æˆé•·</p>
                <div class="example">
                    ä¾‹ï¼šã€Œæ‰¿èªã‚’ã—ã¦ã‚‚ã‚‰ã†ãŸã‚ã®é–¢ä¿‚ã€ã‹ã‚‰ã€Œç›¸äº’ã«è‡ªç«‹ã—ãŸå¯¾ç­‰ãªé–¢ä¿‚æ€§ã§ã®å”åƒã€ã¸
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>ğŸš€ æˆé•·ã®3å±€é¢ï¼ˆåŸºæœ¬ï¼‰</h2>
        <p>å­¦ç”Ÿã¯ä»¥ä¸‹ã®3ã¤ã®å±€é¢ã‚’é€šã˜ã¦æˆé•·ã—ã¦ã„ãã¾ã™ï¼š</p>
        
        <div class="phase-container">
            <div class="phase-card phase-1">
                <h3>1ï¸âƒ£ å¤–çš„å…¬å¼ã«å¾“ã†å±€é¢</h3>
                <p><strong>ç‰¹å¾´ï¼š</strong></p>
                <ul>
                    <li>æ¨©å¨è€…ã®è¨€ã†ã“ã¨ã‚’éµœå‘‘ã¿ã«ã™ã‚‹</li>
                    <li>ä»–è€…ã‹ã‚‰ã®æ‰¿èªã‚’æ±‚ã‚ã‚‹</li>
                    <li>å¤–çš„ãªæœŸå¾…ã«è‡ªå·±ã‚’åˆã‚ã›ã‚‹</li>
                </ul>
                <p><strong>å­¦ç”Ÿã®çŠ¶æ…‹ï¼š</strong><br>
                ã€Œå…ˆç”ŸãŒè¨€ã£ãŸã‹ã‚‰ã€ã€Œã¿ã‚“ãªãŒãã†ã—ã¦ã„ã‚‹ã‹ã‚‰ã€ã¨ã„ã†ç†ç”±ã§è¡Œå‹•</p>
            </div>
            
            <div class="phase-card phase-2">
                <h3>2ï¸âƒ£ å²è·¯ã®å±€é¢</h3>
                <p><strong>ç‰¹å¾´ï¼š</strong></p>
                <ul>
                    <li>å¤–çš„æ¨©å¨ã¸ã®ç–‘å•ãŒç”Ÿã˜ã‚‹</li>
                    <li>å†…ãªã‚‹å£°ã®å¿…è¦æ€§ã‚’èªè­˜</li>
                    <li>è‘›è—¤ã‚„ä¸å”å’Œã‚’çµŒé¨“</li>
                </ul>
                <p><strong>å­¦ç”Ÿã®çŠ¶æ…‹ï¼š</strong><br>
                ã€Œæœ¬å½“ã«ãã‚Œã§ã„ã„ã®ã‹ï¼Ÿã€ã€Œè‡ªåˆ†ã®è€ƒãˆã¯ï¼Ÿã€ã¨ã„ã†å•ã„ãŒç”Ÿã¾ã‚Œã‚‹</p>
            </div>
            
            <div class="phase-card phase-3">
                <h3>3ï¸âƒ£ ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—å±€é¢</h3>
                <p><strong>ç‰¹å¾´ï¼š</strong></p>
                <ul>
                    <li>å†…ãªã‚‹å£°ã‚’ä¿¡é ¼ã™ã‚‹</li>
                    <li>è‡ªå·±æ±ºå®šã«åŸºã¥ãè¡Œå‹•</li>
                    <li>å†…ãªã‚‹åŸºç›¤ã®æ§‹ç¯‰</li>
                </ul>
                <p><strong>å­¦ç”Ÿã®çŠ¶æ…‹ï¼š</strong><br>
                ã€Œç§ã¯ã“ã†è€ƒãˆã‚‹ã€ã€Œç§ã®ä¾¡å€¤è¦³ã«åŸºã¥ã„ã¦è¡Œå‹•ã™ã‚‹ã€</p>
            </div>
        </div>
        
        <button class="toggle-button" onclick="toggleSection('detailed-journey')">ğŸ” ã‚ˆã‚Šè©³ç´°ãªæˆé•·ã®æ—…ã‚’è¦‹ã‚‹</button>
        
        <div id="detailed-journey" class="collapsible">
            <div class="advanced-section">
                <h3>ğŸ—ºï¸ ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã®æ—…</h3>
                <p>å„æ¬¡å…ƒã«ãŠã‘ã‚‹æˆé•·ã®è©³ç´°ãªæ§˜ç›¸ã‚’ä»¥ä¸‹ã®è¡¨ã«ç¤ºã—ã¾ã™ï¼š</p>
                
                <!-- Canvas 2Dãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³çµ±åˆã‚¨ãƒªã‚¢ -->
                <div class="canvas-2d-integration">
                    <h4>ğŸ—ºï¸ æˆé•·ã®æ—…ã®ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³</h4>
                    <p>ä»¥ä¸‹ã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã‚¤ãƒ¡ãƒ¼ã‚¸ã®è¡¨ç¾ã§ã™ã€‚ãƒã‚¦ã‚¹ã§æ“ä½œã—ã¦ã¿ã¦ãã ã•ã„ã€‚<br>ğŸ¨ï¼šã“ã‚Œã¯ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã‚’é›†å›£ãƒ»é›†åˆçš„ãªè¦–ç‚¹ã‹ã‚‰æ¯”å–©çš„ã«è¡¨ç¾ã—ãŸä¾‹ã§ã™ã€‚</p>

                    <div id="journey-canvas-container" class="journey-canvas-container">
                        <canvas id="journey-canvas"></canvas>
                        <div class="journey-controls">
                            <h5>ğŸ—ºï¸ æˆé•·ã®æ—…</h5>
                            <div class="journey-stage-info" id="journey-stageInfo">
                                é‡åŠ›ã®æ”¯é…<br><small>å¤–éƒ¨ã®æ¨©å¨ã«å¾“å±ã—ã¦ã„ã‚‹çŠ¶æ…‹</small>
                            </div>
                            
                            <div class="journey-button-group">
                                <button onclick="previousJourneyStage()" id="journey-prevButton" title="å‰ã®ã‚¹ãƒ†ãƒ¼ã‚¸">â†</button>
                                <button onclick="nextJourneyStage()" id="journey-nextButton" title="æ¬¡ã®ã‚¹ãƒ†ãƒ¼ã‚¸">â†’</button>
                                <button onclick="resetJourney()" class="reset-btn" title="ãƒªã‚»ãƒƒãƒˆ">ğŸ”„</button>
                            </div>
                            
                            <div class="journey-stage-indicator">
                                <div class="journey-stage-dot active" id="journey-dot0"></div>
                                <div class="journey-stage-dot" id="journey-dot1"></div>
                                <div class="journey-stage-dot" id="journey-dot2"></div>
                                <div class="journey-stage-dot" id="journey-dot3"></div>
                            </div>
                        </div>
                        
                        <div class="journey-instructions" onclick="toggleInstructions()" id="journey-instructions">
                            <p><small>ğŸ’¡ æ“ä½œã‚¬ã‚¤ãƒ‰ <span id="instructions-arrow">â–¼</span></small></p>
                            <div class="journey-instructions-detail" id="instructions-detail">
                                <p><small>
                                    ğŸ–±ï¸ <strong>ãƒã‚¦ã‚¹/ã‚¿ãƒƒãƒ</strong><br>
                                    ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã«å½±éŸ¿ã‚’ä¸ãˆã‚‹<br><br>
                                    ğŸ¯ <strong>ã‚¹ãƒ†ãƒ¼ã‚¸æ“ä½œ</strong><br>
                                    â†â†’ãƒœã‚¿ãƒ³ã§æ®µéšåˆ‡ã‚Šæ›¿ãˆ<br><br>
                                    ğŸ”„ <strong>ãƒªã‚»ãƒƒãƒˆ</strong><br>
                                    åˆæœŸçŠ¶æ…‹ã«æˆ»ã™
                                </small></p>
                            </div>
                        </div>
                        
                        <!-- ç‰©ç†æƒ…å ±è¡¨ç¤ºã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’éè¡¨ç¤ºåŒ–
                        <div class="journey-physics-info" id="journey-physicsInfo">
                            é‡åŠ›å¼·åº¦: å¼·<br>
                            è‡ªå¾‹æ€§: 0%<br>
                            èª¿å’Œåº¦: 0%
                        </div>
                        -->
                    </div>
                </div>
                
                <div class="journey-table">
                    <table>
                        <thead>
                            <tr>
                                <th>æ¬¡å…ƒ</th>
                                <th>å¤–çš„å…¬å¼</th>
                                <th>å²è·¯</th>
                                <th>ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>èªè­˜è«–çš„</strong></td>
                                <td>
                                    â€¢ çŸ¥è­˜ã®æºæ³‰ã¨ã—ã¦æ¨©å¨ã«ä¿¡é ¼ã‚’è­²ã‚‹<br>
                                    â€¢ çŸ¥è­˜ã‚’ç¢ºå®Ÿï¼ˆã¾ãŸã¯éƒ¨åˆ†çš„ã«ç¢ºå®Ÿï¼‰ã¨è¦‹ã‚‹<br>
                                    â€¢ å¤–çš„ã«è¦å®šã•ã‚Œã‚‹ä¿¡å¿µã¨ãªã‚‹ã‚ˆã†ãªçŸ¥è­˜å‘½é¡Œã‚’è©•ä¾¡ã™ã‚‹ãŸã‚ã®å†…ãªã‚‹åŸºç›¤ã‚’æ¬ ã
                                </td>
                                <td>
                                    â€¢ ä¸ç¢ºå®Ÿæ€§ã¨å¤šå…ƒçš„è¦–ç‚¹ã®è‡ªè¦šã¨å—å®¹ã‚’é€²ã‚ã‚‹<br>
                                    â€¢ æ¨©å¨è€…ã®çŸ¥è­˜ã‚’å—å®¹ã™ã‚‹ã“ã¨ã‹ã‚‰çŸ¥è­˜å‘½é¡Œã‚’æ¡ç”¨ã™ã‚‹ãƒ‘ãƒ¼ã‚½ãƒŠãƒ«ãªãƒ—ãƒ­ã‚»ã‚¹ã¸ç§»ã‚‹<br>
                                    â€¢ ä¿¡å¿µã‚’é¸æŠã™ã‚‹ãŸã‚ã«è²¬ä»»ã‚’æŒã¤å¿…è¦æ€§ã‚’èªã‚ã‚‹
                                </td>
                                <td>
                                    â€¢ çŸ¥è­˜ã‚’æ–‡è„ˆçš„ãªã‚‚ã®ã¨è¦‹ã‚‹<br>
                                    â€¢ åˆ©ç”¨å¯èƒ½ãªã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹ã‚„å‚ç…§æ çµ„ã¿ã®è¦³ç‚¹ã§åˆ¤æ–­ã‚’æ§‹ç¯‰ãƒ»è©•ä¾¡ãƒ»è§£é‡ˆã™ã‚‹<br>
                                    â€¢ å†…çš„ä¿¡å¿µã‚·ã‚¹ãƒ†ãƒ ã‚’ç™ºé”ã•ã›ã‚‹
                                </td>
                            </tr>
                            <tr>
                                <td><strong>å¯¾è‡ªé–¢ä¿‚</strong></td>
                                <td>
                                    â€¢ è‡ªåˆ†ã®ä¾¡å€¤è¦³ã‚„ç¤¾ä¼šçš„ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®è‡ªè¦šã‚’æ¬ ã<br>
                                    â€¢ ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®è«¸è¦ç´ ã®èª¿æ•´ã‚’æ¬ ã<br>
                                    â€¢ ä»–è€…ã‹ã‚‰ã®è‚¯å®šã‚’è¦ã™ã‚‹
                                </td>
                                <td>
                                    â€¢ å¤–çš„ãªä»–è€…ã®ç‰©ã®è¦‹æ–¹ã‹ã‚‰åŒºåˆ¥ã•ã‚Œã‚‹ã€è‡ªèº«ã®ä¾¡å€¤è¦³ã¨ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®æ„Ÿè¦šã®è‡ªè¦šã‚’é€²ã‚ã‚‹<br>
                                    â€¢ ç”Ÿã˜ã¤ã¤ã‚ã‚‹å†…çš„ä¾¡å€¤è¦³ã¨å¤–çš„åœ§åŠ›ã¨ã®é–“ã«ç·Šå¼µãŒã‚ã‚‹<br>
                                    â€¢ è‡ªã‚‰ã®ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ä½œã‚Šå‡ºã™ãŸã‚ã«è²¬ä»»ã‚’æŒã¤å¿…è¦æ€§ã‚’èªã‚ã‚‹
                                </td>
                                <td>
                                    â€¢ å†…çš„ã«ç”Ÿæˆã—ã€çµŒé¨“ã¨é¸æŠã®è§£é‡ˆã‚’èª¿æ•´ã™ã‚‹<br>
                                    â€¢ è‡ªå·±ã®æ„Ÿè¦šã‚’ã¤ãã‚‹éš›ã«è‡ªèº«ã®ä¾¡å€¤è¦³ã¨ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’é¸æŠã™ã‚‹<br>
                                    â€¢ ä¸€è²«ã—ãŸå†…çš„ãªè‡ªå·±ã®æ„Ÿè¦šã«æ ¹ã–ã™
                                </td>
                            </tr>
                            <tr>
                                <td><strong>å¯¾äººé–¢ä¿‚</strong></td>
                                <td>
                                    â€¢ åŒã˜ã‚ˆã†ãªä»–è€…ãŸã¡ã¨ã®ä¾å­˜é–¢ä¿‚ãŒã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã¨å¿…è¦ãªè‚¯å®šã®æºæ³‰ã¨ãªã‚‹<br>
                                    â€¢ ä»–è€…ã®è‚¯å®šã‚’å¾—ã¦ã„ãã“ã¨ã¨ã—ã¦ã®é–¢ä¿‚ã¸ã®å‚åŠ 
                                </td>
                                <td>
                                    â€¢ ä¾å­˜é–¢ä¿‚ã®é™ç•Œã¸ã®è‡ªè¦šã‚’é€²ã‚ã‚‹<br>
                                    â€¢ è‡ªèº«ã®ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’è‡ªç«‹çš„ãªè«¸é–¢ä¿‚ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ã¸æŒã£ã¦ã„ãå¿…è¦æ€§ã‚’èªã‚ã‚‹<br>
                                    â€¢ è‡ªå·±ã‚’å†æ§‹ç¯‰ã™ã‚‹ã€ã¾ãŸã¯ä¾å­˜é–¢ä¿‚ã‹ã‚‰è„±å‡ºã•ã›ã‚‹ãŸã‚ã«é—˜ã†
                                </td>
                                <td>
                                    â€¢ å¤šæ§˜ãªä»–è€…ãŸã¡ã¨çœŸæ­£ãªç›¸äº’ä¾å­˜é–¢ä¿‚ã«å–ã‚Šçµ„ã‚€ã“ã¨ãŒã§ãã‚‹<br>
                                    â€¢ é–¢ä¿‚æ€§ã®å¿…è¦æ€§ã‚’ç›¸äº’çš„ã«äº¤æ¸‰ã™ã‚‹<br>
                                    â€¢ ä»–è€…ã®è¦–ç‚¹ã‚’æœ¬å½“ã®æ„å‘³ã§è€ƒæ…®ã«å…¥ã‚Œã‚‹
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>ğŸ”¬ æˆé•·å±€é¢ã®ç²¾ç·»åŒ–</h2>
        <p>ã‚¦ã‚©ãƒã‚·ãƒ¥å…¨å›½èª¿æŸ»ç ”ç©¶ã«ã‚ˆã‚Šã€ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã®å„å±€é¢ã«ã¯ã•ã‚‰ã«è©³ç´°ãªä¸‹ä½å±€é¢ãŒã‚ã‚‹ã“ã¨ãŒæ˜ã‚‰ã‹ã«ãªã‚Šã¾ã—ãŸã€‚å¤–çš„ãªæ¨©å¨ã«å¾“ã†å±€é¢ã‹ã‚‰ã€è‘›è—¤ã‚„ä¸å”å’Œã®çµŒé¨“ã‚’çµŒã¦å†…ãªã‚‹å£°ã®å¿…è¦æ€§ã‚’èªè­˜ã—ã€å†…ãªã‚‹åŸºç›¤ã‚’æ§‹ç¯‰ã™ã‚‹ã¾ã§ã®è©³ã—ã„å¤‰å®¹éç¨‹ã‚„ç§»è¡Œã®å¥‘æ©ŸãŒç¤ºã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
        
        <button class="toggle-button" onclick="toggleSection('refined-phases')">ğŸ”¬ ç²¾ç·»åŒ–ã•ã‚ŒãŸæˆé•·å±€é¢ã‚’è¦‹ã‚‹</button>
        
        <div id="refined-phases" class="collapsible">
            <div class="advanced-section">
                <!-- 3Då¯è¦–åŒ–çµ±åˆã‚¨ãƒªã‚¢ -->
                <div class="sa-3d-integration">
                    <h4>ğŸ”¬ æˆé•·å±€é¢ã®å¤‰å®¹ã®ã‚¤ãƒ¡ãƒ¼ã‚¸</h4>
                    <p>ä»¥ä¸‹ã®3Dã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§ã€å„æˆé•·æ®µéšã‚’è¦–è¦šçš„ã«ä½“é¨“ã§ãã¾ã™ã€‚ä¸‹ã®ãƒ†ã‚­ã‚¹ãƒˆã®æ®µéšåã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦åˆ‡ã‚Šæ›¿ãˆã¦ãã ã•ã„ã€‚<br>ğŸ¨ï¼šã“ã‚Œã¯å€‹äººå†…ã®ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã‚’æ¯”å–©çš„ã«è¡¨ç¾ã—ãŸä¸€ä¾‹ã§ã™ã€‚</p>

                    <div id="refined-3d-container" class="sa-3d-container">
                        <div id="refined-3d-scene">
                            <!-- 3Dã‚·ãƒ¼ãƒ³å†…æµ®éŠãƒœã‚¿ãƒ³ -->
                            <button id="reset-view-btn" class="floating-view-control">
                                <span>â†º</span>
                                <span class="tooltip">è¦–ç‚¹ãƒªã‚»ãƒƒãƒˆ</span>
                            </button>
                            <button id="reinit-3d-btn" class="floating-view-control" style="right: 60px;">
                                <span>âŸ²</span>
                                <span class="tooltip">3Dç’°å¢ƒåˆæœŸåŒ–</span>
                            </button>
                            <button id="explanation-toggle-btn" class="floating-view-control" style="right: 120px;">
                                <span>â“</span>
                                <span class="tooltip">è¦ç´ èª¬æ˜è¡¨ç¤º</span>
                            </button>
                        </div>
                        <div class="sa-3d-loading" id="refined-3d-loading">
                            <div class="loading-spinner"></div>
                            <p>3Dç’°å¢ƒã‚’åˆæœŸåŒ–ä¸­...</p>
                        </div>
                        <div class="sa-3d-controls" id="refined-3d-controls" style="display: none;">
                            <div class="stage-info-display" id="stage-info-display">
                                <!-- titleElement ã‚’ä¸€æ™‚çš„ã«éè¡¨ç¤ºåŒ–ï¼ˆé‡è¤‡è¡¨ç¤ºå›é¿ã®ãŸã‚ï¼‰ -->
                                <!-- <h5 id="current-stage-title">Ea: å¤–çš„æ¨©å¨ã‚’ä¿¡é ¼ã™ã‚‹</h5> -->
                                <p id="current-stage-description">å¤–çš„æ¨©å¨ã‚’ä¿¡é ¼</p>
                            </div>
                            <div class="stage-controls">
                                <button data-stage="Ea" class="stage-btn active">Ea</button>
                                <button data-stage="Eb" class="stage-btn">Eb</button>
                                <button data-stage="Ec" class="stage-btn">Ec</button>
                                <button data-stage="EI" class="stage-btn">E(I)</button>
                                <button data-stage="E-I" class="stage-btn">E-I</button>
                                <button data-stage="I-E" class="stage-btn">I-E</button>
                                <button data-stage="IE" class="stage-btn">I(E)</button>
                                <button data-stage="Ia" class="stage-btn">Ia</button>
                                <button data-stage="Ib" class="stage-btn">Ib</button>
                                <button data-stage="Ic" class="stage-btn">Ic</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="sa-3d-description">
                        <p><small>ğŸ’¡ 3Dç©ºé–“ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦è¦–ç‚¹ã‚’å¤‰æ›´ã€ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ ã‚¤ãƒ³ãƒ»ã‚¢ã‚¦ãƒˆã€ä¸‹ã®ãƒ†ã‚­ã‚¹ãƒˆã®æ®µéšåã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦æˆé•·æ®µéšã‚’åˆ‡ã‚Šæ›¿ãˆã‚‰ã‚Œã¾ã™ã€‚</small></p>
                    </div>
                </div>
                
                <h3>å¤–çš„ãªæ„å‘³å½¢æˆå±€é¢ã®è©³ç´°</h3>
                
                <div class="sub-phase">
                    <h4>Ea: å¤–çš„æ¨©å¨ã‚’ä¿¡é ¼ã™ã‚‹</h4>
                    <p>ä¸€è²«ã—ã¦ç›²ç›®çš„ã«å¤–çš„è³‡æºã‚’ä¿¡é ¼ã—ã€ãã®ã“ã¨ã®æ¬ ç‚¹ã®å¯èƒ½æ€§ã‚’èªè­˜ã™ã‚‹ã“ã¨ã‚‚ãªã„ã€‚</p>
                </div>
                
                <div class="sub-phase">
                    <h4>Eb: å¤–çš„æ¨©å¨ã‚’ä¿¡é ¼ã™ã‚‹ã“ã¨ã¨ã®ç·Šå¼µ</h4>
                    <p>ä¸€è²«ã—ã¦å¤–çš„è³‡æºã‚’ä¿¡é ¼ã™ã‚‹ãŒã€ãã†ã™ã‚‹ã“ã¨ã®ç·Šå¼µã‚’çµŒé¨“ã™ã‚‹ï¼ˆã¨ãã«å¤–çš„è³‡æºã®é–“ã«è‘›è—¤ãŒã‚ã‚‹å ´åˆï¼‰ã€‚è‘›è—¤ã‚’è§£æ¶ˆã—ã‚ˆã†ã¨ã—ã¦è¤‡æ•°ã®æ¨©å¨ã®æ–¹ã‚’è¦‹ã‚‹ã€‚</p>
                </div>
                
                <div class="sub-phase">
                    <h4>Ec: å¤–çš„æ¨©å¨ã‚’ä¿¡é ¼ã™ã‚‹ã“ã¨ã®æ¬ ç‚¹ã‚’èªè­˜ã™ã‚‹</h4>
                    <p>å¤–çš„æ¨©å¨ã¸ã®ä¿¡é ¼ã‚’ç¶™ç¶šã™ã‚‹ãŒã€ãã®ã“ã¨ã®æ¬ ç‚¹ã‚’èªè­˜ã—ã¦ã„ã‚‹ã€‚</p>
                </div>
                
                <h3>å²è·¯å±€é¢ã®è©³ç´°</h3>
                
                <div class="sub-phase">
                    <h4>E(I): å¤–çš„æ¨©å¨ã«ç–‘å•ã‚’æŒã¤ï¼ˆå²è·¯ã«å…¥ã‚‹ï¼‰</h4>
                    <p>å†…ãªã‚‹å£°ã®å¿…è¦æ€§ã‚’è‡ªè¦šã™ã‚‹ã‚‚ã€å¤–çš„è³‡æºã¸ã®ä¿¡é ¼ã‚’ç¶™ç¶šã™ã‚‹ã€‚å¤–çš„æ„å‘³å½¢æˆã®ã‚¸ãƒ¬ãƒ³ãƒã‚’è‡ªè¦šã™ã‚‹ãŒã€ã©ã†é€²ã‚ã°ã„ã„ã‹ã‚ã‹ã‚‰ãªã„ã€‚</p>
                </div>
                
                <div class="sub-phase">
                    <h4>E-I: å†…ãªã‚‹å£°ã‚’æ§‹ç¯‰ã™ã‚‹</h4>
                    <p>æ„å‘³å½¢æˆã®æ–°ã—ã„ä»•æ–¹ã‚’æ§‹ç¯‰ã™ã‚‹ã‚ˆã†èƒ½å‹•çš„ã«å‹•ãå§‹ã‚ã‚‹ãŒã€ä»¥å‰ã®å¤–çš„ä½ç½®ã«ã€Œå¾Œé€€ã™ã‚‹ã€ã“ã¨ã‚‚ã‚ã‚‹ã€‚</p>
                </div>
                
                <div class="sub-phase">
                    <h4>I-E: å†…ãªã‚‹å£°ã‚’è´ãï¼ˆå²è·¯ã‹ã‚‰å‡ºã‚‹ï¼‰</h4>
                    <p>å†…ãªã‚‹å£°ã‚’æ³¨æ„æ·±ãèãå–ã‚Šå§‹ã‚ã€å¤–çš„è³‡æºã‚’æŠ¼ã—ã®ã‘ã¤ã¤ã‚ã‚‹ã€‚å¤–çš„è³‡æºãŒã¾ã å¼·ãã€å†…ãªã‚‹å£°ã‚’ä¸€è²«ã—ã¦ç¶­æŒã™ã‚‹ã“ã¨ã‚’é›£ã—ãã—ã¦ã„ã‚‹ã€‚</p>
                </div>
                
                <div class="sub-phase">
                    <h4>I(E): å†…ãªã‚‹å£°ã‚’è‚²ã‚€</h4>
                    <p>å†…ãªã‚‹å£°ã‚’èƒ½å‹•çš„ã«è‚²ã¿å§‹ã‚ã€å†…ãªã‚‹å£°ãŒå¤šãã®å¤–çš„è³‡æºã‚’åª’ä»‹ã™ã‚‹ã€‚ä»–è€…ã®è¦–ç‚¹ãŒè‡ªèº«ã®è¦–ç‚¹ã‚’åŒ…æ‘‚ã—ã¦ã—ã¾ã†ãã‚Œã¾ã§ã®å‚¾æ€§ã«æˆ»ã‚‰ãªã„ã‚ˆã†ã«æ„è­˜ã™ã‚‹ã€‚</p>
                </div>
                
                <h3>å†…çš„ãªæ„å‘³å½¢æˆï¼ˆã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ï¼‰å±€é¢ã®è©³ç´°</h3>
                
                <div class="sub-phase">
                    <h4>Ia: å†…ãªã‚‹å£°ã‚’ä¿¡é ¼ã™ã‚‹</h4>
                    <p>ä¿¡å¿µã€ä¾¡å€¤ã€ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã€é–¢ä¿‚ã‚’æ´—ç·´ã™ã‚‹ã®ã«ååˆ†ãªã»ã©å†…ãªã‚‹å£°ã‚’ä¿¡é ¼ã™ã‚‹ã€‚åå¿œã‚’å½¢ä½œã‚Šã€å¤–çš„è³‡æºã‚’ç®¡ç†ã™ã‚‹ã®ã«å†…ãªã‚‹å£°ã‚’æ´»ç”¨ã™ã‚‹ã€‚</p>
                </div>
                
                <div class="sub-phase">
                    <h4>Ib: å†…ãªã‚‹åŸºç›¤ã‚’ç¯‰ã</h4>
                    <p>å¤–çš„è³‡æºã«ã©ã†åå¿œã™ã‚‹ã‹ã‚’å°ãäººç”Ÿå“²å­¦ã¸ã®ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒ³ãƒˆã‚’å½¢æˆã™ã‚‹ã®ã«ååˆ†ãªã»ã©å†…ãªã‚‹å£°ã‚’ä¿¡é ¼ã™ã‚‹ã€‚</p>
                </div>
                
                <div class="sub-phase">
                    <h4>Ic: å†…ãªã‚‹ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒ³ãƒˆã‚’ç¢ºä¿ã™ã‚‹</h4>
                    <p>äººç”Ÿå“²å­¦ã‚’è‡ªåˆ†ã®å­˜åœ¨ã®æ ¸ã¨ã—ã¦å›ºã‚ã€ãã‚Œã‚’ç¬¬äºŒã®æ€§è³ªã¨ã—ã¦ç”Ÿãã‚‹ã€‚</p>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>ğŸ› ï¸ å®Ÿè·µåŸå‰‡ï¼šãƒ©ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ»ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ã‚·ãƒƒãƒ—ãƒ»ãƒ¢ãƒ‡ãƒ«ï¼ˆLPMï¼‰</h2>
        <p>å­¦ç”Ÿã®ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—æˆé•·ã‚’æ”¯æ´ã™ã‚‹3ã¤ã®å®Ÿè·µåŸå‰‡ï¼š</p>
        
        <div class="principle">
            <h3>1. å­¦ç¿’è€…ã®çŸ¥ã‚‹èƒ½åŠ›ã‚’ç¢ºã‹ã‚ã‚‹</h3>
            <p>å­¦ç”ŸãŒã©ã®ã‚ˆã†ã«çŸ¥è­˜ã‚’æ‰ãˆã¦ã„ã‚‹ã‹ã‚’ç†è§£ã—ã€ãã®æ®µéšã«å¿œã˜ãŸã‚µãƒãƒ¼ãƒˆã‚’æä¾›ã™ã‚‹</p>
            <p><strong>å®Ÿè·µä¾‹ï¼š</strong>ã€Œãªãœãã†æ€ã†ã®ï¼Ÿã€ã€Œã©ã†ã‚„ã£ã¦ãã®çµè«–ã«è‡³ã£ãŸï¼Ÿã€ã¨ã„ã†å•ã„ã‹ã‘</p>
        </div>
        
        <div class="principle">
            <h3>2. å­¦ç”Ÿã®å­¦ã³ã‚’ãã®å­¦ç”Ÿã®çµŒé¨“ã®ä¸­ã«ä½ç½®ã¥ã‘ã‚‹</h3>
            <p>æŠ½è±¡çš„ãªå­¦ã³ã§ã¯ãªãã€å­¦ç”Ÿè‡ªèº«ã®çµŒé¨“ã¨çµã³ã¤ã‘ã¦ç†è§£ã‚’æ·±ã‚ã‚‹</p>
            <p><strong>å®Ÿè·µä¾‹ï¼š</strong>ã€Œã“ã®ç†è«–ã¯ã‚ãªãŸã®çµŒé¨“ã¨ã©ã†é–¢é€£ã™ã‚‹ï¼Ÿã€ã¨ã„ã†æŒ¯ã‚Šè¿”ã‚Š</p>
        </div>
        
        <div class="principle">
            <h3>3. å­¦ã³ã‚’ç›¸äº’çš„ãªæ„å‘³æ§‹æˆã¨å®šç¾©ã™ã‚‹</h3>
            <p>æ•™å“¡ã¨å­¦ç”Ÿã€å­¦ç”ŸåŒå£«ãŒå¯¾ç­‰ãªç«‹å ´ã§æ„å‘³ã‚’æ§‹ç¯‰ã—ã¦ã„ã</p>
            <p><strong>å®Ÿè·µä¾‹ï¼š</strong>ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ã‚„ã‚°ãƒ«ãƒ¼ãƒ—ãƒ¯ãƒ¼ã‚¯ã§ã®å”åƒçš„ãªçŸ¥è­˜æ§‹ç¯‰</p>
        </div>
        
        <button class="toggle-button" onclick="toggleSection('lpm-steps')">ğŸ“‹ LPMå®Ÿè·µã®10ã‚¹ãƒ†ãƒƒãƒ—ã‚’è¦‹ã‚‹</button>
        
        <div id="lpm-steps" class="collapsible">
            <div class="advanced-section">
                <h3>ãƒ©ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ»ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ã‚·ãƒƒãƒ—ãƒ»ãƒ¢ãƒ‡ãƒ«ï¼ˆLPMï¼‰å®Ÿè·µã®10ã‚¹ãƒ†ãƒƒãƒ—</h3>
                
                <h4>ãƒ•ã‚§ãƒ¼ã‚º1ï¼šå­¦ç¿’ç›®æ¨™ã¨å­¦ç¿’è€…ã®ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—èƒ½åŠ›ã‚’ã‚¢ã‚»ã‚¹ãƒ¡ãƒ³ãƒˆã™ã‚‹</h4>
                
                <div class="lpm-step">
                    <h5>ã‚¹ãƒ†ãƒƒãƒ—1ï¼šæ–‡è„ˆã®é¸å®š</h5>
                    <p>å­¦ç”Ÿã‚„åŒåƒšã¨ã®é–¢ã‚ã‚Šã‹ã‚‰ã€LPMã‚’ç”¨ã„ã¦ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã‚’å‘ä¸Šã™ã‚‹ã®ã«é©ã—ãŸå®Ÿè·µã¯ä½•ã‹ï¼Ÿ</p>
                    <p><em>ä¾‹ï¼šå’æ¥­è«–æ–‡ã€ãƒ”ã‚¢ãƒ»ã‚µãƒãƒ¼ãƒˆã€ã‚­ãƒ£ãƒªã‚¢ç›¸è«‡</em></p>
                </div>
                
                <div class="lpm-step">
                    <h5>ã‚¹ãƒ†ãƒƒãƒ—2ï¼šãã®æ–‡è„ˆã§ã®å­¦ç¿’ç›®æ¨™ã®è¨­å®š</h5>
                    <ul>
                        <li>ãã®æ–‡è„ˆã§ç¾åœ¨ã€é”æˆã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹å­¦ç¿’æˆæœã¯ä½•ã‹ï¼Ÿ</li>
                        <li>ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã‚’ã‚ˆã‚ŠåŒ…æ‹¬çš„ãªç›®æ¨™ã¨è€ƒãˆã‚‹ã¨ã€ç¾åœ¨è¨­å®šã—ã¦ã„ã‚‹å­¦ç¿’æˆæœï¼ç›®æ¨™ã‚’ã©ã®ã‚ˆã†ã«è¨­å®šã™ã‚‹ã“ã¨ã«ãªã‚‹ã‹ï¼Ÿ</li>
                        <li>å‚åŠ è€…ã«ä½•ã‚’ã‚ˆã‚Šã‚ˆãç†è§£ã—ã¦ã‚‚ã‚‰ã„ãŸã„ã‹ï¼Ÿä½•ã‚’ã‚ˆã‚Šã†ã¾ãå–ã‚Šçµ„ã‚ã‚‹ã‚ˆã†ã«ãªã£ã¦ã‚‚ã‚‰ã„ãŸã„ã‹ï¼Ÿ</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ã‚¹ãƒ†ãƒƒãƒ—3ï¼šã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®è¦–ç‚¹ã‹ã‚‰å­¦ç¿’ç›®æ¨™ã®æ¤œè¨</h5>
                    <ul>
                        <li><strong>èªçŸ¥èƒ½åŠ›ï¼š</strong>ãã‚Œã‚‰ã®å­¦ç¿’ç›®æ¨™ã‚’é”æˆã™ã‚‹ã®ã«ã€ã©ã®ã‚ˆã†ãªä»•æ–¹ã§çŸ¥è­˜ã‚’æ§‹ç¯‰ã™ã‚‹ã‹ï¼Ÿ</li>
                        <li><strong>å¯¾è‡ªé–¢ä¿‚èƒ½åŠ›ï¼š</strong>è‡ªåˆ†è‡ªèº«ã‚’ã©ã®ã‚ˆã†ãªä»•æ–¹ã§è¦‹ã¦ç†è§£ã™ã‚‹ã“ã¨ãŒæ±‚ã‚ã‚‰ã‚Œã‚‹ã‹ï¼Ÿ</li>
                        <li><strong>å¯¾äººé–¢ä¿‚èƒ½åŠ›ï¼š</strong>ä»–è€…ã¨ã®é–¢ä¿‚ã®ä¸­ã®è‡ªåˆ†è‡ªèº«ã‚’ã©ã®ã‚ˆã†ãªä»•æ–¹ã§ç†è§£ã™ã‚‹ã“ã¨ãŒæ±‚ã‚ã‚‰ã‚Œã‚‹ã‹ï¼Ÿ</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ã‚¹ãƒ†ãƒƒãƒ—4ï¼šãã®æ–‡è„ˆã§ã®å­¦ç¿’è€…ã®ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ç‰¹å¾´ã®è€ƒæ…®</h5>
                    <ul>
                        <li>å­¦ç¿’è€…ãŒå…±é€šã—ã¦ç”¨ã„ã‚‹çŸ¥è­˜æ§‹ç¯‰ã®ä»•æ–¹ã¯ï¼Ÿ</li>
                        <li>å­¦ç¿’è€…ã«ã‚ˆã£ã¦ç¤ºã•ã‚Œã‚‹è‡ªåˆ†è‡ªèº«ã®è¦‹æ–¹ã¯ï¼Ÿ</li>
                        <li>å­¦ç¿’è€…ãŒç¤ºã™ä»–è€…ã¨ã®é–¢ä¿‚ã®ä¸­ã®è‡ªåˆ†è‡ªèº«ã®è¦‹æ–¹ã¯ï¼Ÿ</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ã‚¹ãƒ†ãƒƒãƒ—5ï¼šå­¦ç¿’ç›®æ¨™ã¨å­¦ç¿’è€…èƒ½åŠ›ã®é–“ã®æ•´åˆæ€§ã¨ä¸æ•´åˆã®ç‰¹å®š</h5>
                    <ul>
                        <li>å­¦ç¿’ç›®æ¨™ã¨å­¦ç¿’è€…ã®ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—èƒ½åŠ›ã¯ã©ã®ã‚ˆã†ã«çµã³ã¤ãã‹ï¼Ÿ</li>
                        <li>ãã‚Œã‚‰ã®é–“ã«ã‚ã‚‹ä¸æ•´åˆã¯ã©ã“ã‹ï¼Ÿ</li>
                        <li>ã©ã‚“ãªæˆé•·ç›®æ¨™ãŒã€å¿…è¦ãªèƒ½åŠ›ã¨ç‹™ã„ã¨ã™ã‚‹å­¦ç¿’æˆæœã®é–“ã‚’æ©‹æ¸¡ã—ã™ã‚‹ã®ã«å½¹ç«‹ã¤ã‹ï¼Ÿ</li>
                    </ul>
                </div>
                
                <h4>ãƒ•ã‚§ãƒ¼ã‚º2ï¼šã€Œæˆé•·ã®æ¶ã‘æ©‹ã€ã‚’ãƒ‡ã‚¶ã‚¤ãƒ³ã™ã‚‹</h4>
                
                <div class="lpm-step">
                    <h5>ã‚¹ãƒ†ãƒƒãƒ—6ï¼šæˆé•·ã™ã‚‹ã€Œã‚«ãƒªã‚­ãƒ¥ãƒ©ãƒ ã€ã®ç´ æ</h5>
                    <ul>
                        <li>å­¦ç¿’ç›®æ¨™ã¨æˆé•·ç›®æ¨™ã¯ã€ã©ã®ã‚ˆã†ã«æ™‚é–“ã‚’ã‹ã‘ã¦ã‚¹ãƒ†ãƒƒãƒ—ã«å¤‰æ›ã•ã‚Œã‚‹ã‹ï¼Ÿ</li>
                        <li>å­¦ç¿’è€…ã¸ã®é–¢ä¸ã®é•·ã•ã«ã¨ã‚‚ãªã£ã¦ã€æœ€åˆã®æ™‚ç‚¹ã§ã€å­¦ç¿’ç›®æ¨™ã¨æˆé•·ç›®æ¨™ã¯ã©ã®ã‚ˆã†ãªå½¢æ…‹ã¨ãªã‚‹ã‹ï¼Ÿ</li>
                        <li>ã‚¹ãƒ†ãƒƒãƒ—ã®ã©ã‚ŒãŒã“ã‚Œã¾ã§ã«é€šéã—ã€ã©ã‚ŒãŒã“ã‚Œã‹ã‚‰å‘ã‹ã†å¿…è¦ã®ã‚ã‚‹ã‚‚ã®ã‹ï¼Ÿ</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ã‚¹ãƒ†ãƒƒãƒ—7ï¼š3ã¤ã®æƒ³å®šã«å–ã‚Šçµ„ã‚€</h5>
                    <p><strong>çŸ¥è­˜ã¯è¤‡é›‘ã§ç¤¾ä¼šçš„ã«æ§‹ç¯‰ã•ã‚Œã‚‹ / è‡ªå·±ãŒçŸ¥è­˜æ§‹ç¯‰ã®ä¸­å¿ƒã§ã‚ã‚‹ / ç†Ÿç·´ã¨æ¨©å¨ã¯ç›¸äº’ã«å…±æœ‰ã•ã‚Œã‚‹</strong></p>
                    <ul>
                        <li>ã‚ãªãŸã®å®Ÿè·µé ˜åŸŸã«ãŠã„ã¦ã€ã“ã‚Œã‚‰ã®æƒ³å®šã¯ç¾åœ¨ã©ã®ã‚ˆã†ãªä»•æ–¹ã§ç¤ºã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ</li>
                        <li>ã©ã†ã™ã‚Œã°ã‚ˆã‚ŠåŠ¹æœçš„ã«ã“ã‚Œã‚‰ã®æƒ³å®šã‚’å­¦ç¿’è€…ã«ä¼ãˆã‚‰ã‚Œã‚‹ã‹ï¼Ÿ</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ã‚¹ãƒ†ãƒƒãƒ—8ï¼š3ã¤ã®åŸå‰‡ã«å–ã‚Šçµ„ã‚€</h5>
                    <p>å­¦ç¿’è€…ã®çŸ¥ã‚‹èƒ½åŠ›ã‚’ç¢ºã‹ã‚ã‚‹ / å­¦ç¿’ã‚’å­¦ç¿’è€…ã®çµŒé¨“ã«ä½ç½®ã¥ã‘ã‚‹ / å­¦ç¿’è€…ã¨æ„å‘³ã‚’ç›¸äº’æ§‹ç¯‰ã™ã‚‹</p>
                    <ul>
                        <li>ã“ã‚Œã‚‰ã®åŸå‰‡ã¯ç¾åœ¨ã©ã®ã‚ˆã†ãªä»•æ–¹ã§ç¤ºã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ</li>
                        <li>ã©ã†ã™ã‚Œã°ã‚ˆã‚ŠåŠ¹æœçš„ã«ã“ã‚Œã‚‰ã®åŸå‰‡ã‚’å­¦ç¿’è€…ã«ä¼ãˆã‚‰ã‚Œã‚‹ã‹ï¼Ÿ</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ã‚¹ãƒ†ãƒƒãƒ—9ï¼šæ•´åˆæ€§ã¨ä¸æ•´åˆã‚’å†åŸå‘³ã™ã‚‹</h5>
                    <ul>
                        <li>æ–°ã—ã„è¨ˆç”»ã¯ã€æ•´åˆã—ã¦ã„ã‚‹ã¨ã“ã‚ã‚’æºã‚‹ãŒã•ãªã„ã‹ï¼Ÿ</li>
                        <li>ã“ã®è¨ˆç”»ã¯ã€ã©ã®ä¸æ•´åˆã«å–ã‚Šçµ„ã‚€ã®ã‹ï¼Ÿ</li>
                        <li>å–ã‚Šçµ„ã‚€ã¹ãä¸æ•´åˆã®ã†ã¡ã€æ®‹ã‚‹ã‚‚ã®ã¯ã©ã‚Œã‹ï¼Ÿ</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ã‚¹ãƒ†ãƒƒãƒ—10ï¼šåŠ¹æœã‚’è©•ä¾¡ã™ã‚‹ãŸã‚ã®è¨ˆç”»ã‚’ç´ æã™ã‚‹</h5>
                    <ul>
                        <li>å‚åŠ è€…ã®ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—èƒ½åŠ›ã‚’ä¿ƒé€²ã™ã‚‹ã®ã«ã©ã‚Œã»ã©åŠ¹æœãŒã‚ã£ãŸã‹ã‚’æ±ºã‚ã‚‹ã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹ã¨ã—ã¦ä½¿ãˆã‚‹ã‚‚ã®ã¯ä½•ã‹ï¼Ÿ</li>
                        <li>ãã®ã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹ã¯ã©ã®ã‚ˆã†ã«é›†ã‚ã‚‰ã‚Œã‚‹ã ã‚ã†ã‹ï¼Ÿ</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>ğŸ“‹ å®Ÿè·µãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã®ä¾‹</h2>
        
        <div class="checklist">
            <h4>å–ã‚Šçµ„ã¿æ¤œè¨æ™‚ã®æ´»ç”¨</h4>
            <ul>
                <li>å­¦ç”Ÿã«ã€Œè‡ªåˆ†ã®è€ƒãˆã€ã‚’æ±‚ã‚ã‚‹æ©Ÿä¼šã‚’è¨­ã‘ã¦ã„ã‚‹ã‹</li>
                <li>å¤šæ§˜ãªè¦–ç‚¹ã«è§¦ã‚Œã‚‹æ©Ÿä¼šã‚’æä¾›ã—ã¦ã„ã‚‹ã‹</li>
                <li>å¤±æ•—ã‚’æã‚ŒãšæŒ‘æˆ¦ã§ãã‚‹ç’°å¢ƒã‚’ä½œã£ã¦ã„ã‚‹ã‹</li>
                <li>æŒ¯ã‚Šè¿”ã‚Šã¨çœå¯Ÿã®æ™‚é–“ã‚’ç¢ºä¿ã—ã¦ã„ã‚‹ã‹</li>
                <li>å­¦ç”Ÿã®æˆé•·æ®µéšã«å¿œã˜ãŸèª²é¡Œè¨­å®šã‚’ã—ã¦ã„ã‚‹ã‹</li>
            </ul>
        </div>
        
        <div class="checklist">
            <h4>å­¦ç”Ÿæ”¯æ´ãƒ»ã‚¢ãƒ‰ãƒã‚¤ã‚¸ãƒ³ã‚°ã§ã®æ´»ç”¨</h4>
            <ul>
                <li>å­¦ç”Ÿã®ç¾åœ¨ã®æˆé•·å±€é¢ã‚’æŠŠæ¡ã—ã¦ã„ã‚‹ã‹</li>
                <li>ç­”ãˆã‚’ä¸ãˆã‚‹ã®ã§ã¯ãªãã€å•ã„ã‚’æŠ•ã’ã‹ã‘ã¦ã„ã‚‹ã‹</li>
                <li>å­¦ç”Ÿã®å†…ãªã‚‹å£°ã«è€³ã‚’å‚¾ã‘ã¦ã„ã‚‹ã‹</li>
                <li>é©åˆ‡ãªãƒãƒ£ãƒ¬ãƒ³ã‚¸ã¨ã‚µãƒãƒ¼ãƒˆã®ãƒãƒ©ãƒ³ã‚¹ã‚’å–ã£ã¦ã„ã‚‹ã‹</li>
                <li>å­¦ç”Ÿã®è‡ªå·±æ±ºå®šã‚’å°Šé‡ã—ã¦ã„ã‚‹ã‹</li>
            </ul>
        </div>
    </div>

    <div class="section">
        <h2>ğŸ“ˆ æˆé•·ã‚’ä¿ƒã™å…·ä½“çš„ãªå–ã‚Šçµ„ã¿ä¾‹</h2>
        
        <table>
            <thead>
                <tr>
                    <th>å–ã‚Šçµ„ã¿</th>
                    <th>æœŸå¾…ã•ã‚Œã‚‹åŠ¹æœ</th>
                    <th>å¯¾å¿œã™ã‚‹æ¬¡å…ƒ</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªä½œæˆ</td>
                    <td>è‡ªå·±ã®æˆé•·éç¨‹ã®å¯è¦–åŒ–ã¨çœå¯Ÿ</td>
                    <td>å¯¾è‡ªé–¢ä¿‚</td>
                </tr>
                <tr>
                    <td>ãƒ‡ã‚£ãƒ™ãƒ¼ãƒˆãƒ»è¨è«–</td>
                    <td>å¤šæ§˜ãªè¦–ç‚¹ã®ç†è§£ã¨è‡ªå·±ã®ç«‹å ´ã®æ˜ç¢ºåŒ–</td>
                    <td>èªè­˜è«–çš„</td>
                </tr>
                <tr>
                    <td>å”åƒãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ</td>
                    <td>ç›¸äº’ä¾å­˜çš„ãªé–¢ä¿‚æ§‹ç¯‰ã®çµŒé¨“</td>
                    <td>å¯¾äººé–¢ä¿‚</td>
                </tr>
                <tr>
                    <td>ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãƒ»ã‚¸ãƒ£ãƒ¼ãƒŠãƒ«</td>
                    <td>å†…ãªã‚‹å£°ã®ç™ºè¦‹ã¨è‚²æˆ</td>
                    <td>å…¨æ¬¡å…ƒ</td>
                </tr>
                <tr>
                    <td>ãƒ¡ãƒ³ã‚¿ãƒªãƒ³ã‚°ãƒ»ãƒ—ãƒ­ã‚°ãƒ©ãƒ </td>
                    <td>å¯¾è©±ã‚’é€šã˜ãŸè‡ªå·±ç†è§£ã®æ·±åŒ–</td>
                    <td>å…¨æ¬¡å…ƒ</td>
                </tr>
                <tr>
                    <td>ã‚µãƒ¼ãƒ“ã‚¹ãƒ»ãƒ©ãƒ¼ãƒ‹ãƒ³ã‚°</td>
                    <td>ç¤¾ä¼šçš„æ–‡è„ˆã§ã®è‡ªå·±ã®ä½ç½®ã¥ã‘ã®ç†è§£</td>
                    <td>å…¨æ¬¡å…ƒ</td>
                </tr>
                <tr>
                    <td>ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°ãƒ»ã‚«ãƒªã‚­ãƒ¥ãƒ©ãƒ </td>
                    <td>æ®µéšçš„ãªçŸ¥çš„æˆé•·ã¨è‡ªå·±è¡¨ç¾åŠ›ã®è‚²æˆ</td>
                    <td>èªè­˜è«–çš„ãƒ»å¯¾è‡ªé–¢ä¿‚</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="section">
        <h2>ğŸ’¡ å®Ÿè·µã®ãƒã‚¤ãƒ³ãƒˆ</h2>
        
        <div class="practical-tips">
            <h3>æˆé•·ã‚’æ”¯æ´ã™ã‚‹éš›ã®ç•™æ„ç‚¹</h3>
            <ul>
                <li><strong>éç·šå½¢ãªæˆé•·ã‚’ç†è§£ã™ã‚‹ï¼š</strong>å­¦ç”Ÿã¯3ã¤ã®å±€é¢ã‚’è¡Œãã¤æˆ»ã‚Šã¤ã—ãªãŒã‚‰æˆé•·ã—ã¾ã™</li>
                <li><strong>æ¬¡å…ƒé–“ã®é€£å‹•ã‚’æ„è­˜ã™ã‚‹ï¼š</strong>3ã¤ã®æ¬¡å…ƒã¯ç›¸äº’ã«å½±éŸ¿ã—åˆã„ã¾ã™</li>
                <li><strong>æ–‡è„ˆã®é‡è¦æ€§ï¼š</strong>å­¦ç”Ÿã®èƒŒæ™¯ã‚„ç’°å¢ƒã‚’è€ƒæ…®ã—ãŸã‚µãƒãƒ¼ãƒˆãŒå¿…è¦ã§ã™</li>
                <li><strong>ä¸å”å’Œã®æ´»ç”¨ï¼š</strong>è‘›è—¤ã‚„çŸ›ç›¾ã¯æˆé•·ã®å¥‘æ©Ÿã¨ãªã‚Šã¾ã™</li>
                <li><strong>é•·æœŸçš„è¦–ç‚¹ï¼š</strong>ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã¯æ™‚é–“ãŒã‹ã‹ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã§ã™</li>
                <li><strong>å¯¾è‡ªé–¢ä¿‚æ¬¡å…ƒãŒä¸­å¿ƒï¼š</strong>ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã¯å¯¾è‡ªé–¢ä¿‚æ¬¡å…ƒã‚’è»¸ã¨ã™ã‚‹æˆé•·ã§ã™</li>
            </ul>
        </div>
        
        <div class="practical-tips">
            <h3>æˆé•·ã®å¥‘æ©Ÿã¨ãªã‚‹ã‚‚ã®</h3>
            <ul>
                <li><strong>å¤–çš„æ„å‘³å½¢æˆæ®µéšï¼š</strong>å¤–çš„æ¨©å¨ã‚„æœŸå¾…ã®é–“ã®è¡çªãƒ»è‘›è—¤ï¼ˆä¸å”å’Œï¼‰</li>
                <li><strong>å²è·¯æ®µéšï¼š</strong>å†…ãªã‚‹å£°ã®ç™ºè¦‹ã¨æ´»ç”¨çµŒé¨“</li>
                <li><strong>ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—æ®µéšï¼š</strong>å†…ãªã‚‹åŸºç›¤ã«åŸºã¥ãè‡ªå·±æ±ºå®šã¨è¡Œå‹•ã®ç©ã¿é‡ã­</li>
            </ul>
        </div>
        
        <!-- æ–°è¦è¿½åŠ ï¼šã‚¸ãƒ£ãƒ¼ãƒ‹ãƒ¼ãƒãƒƒãƒ—ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <button class="toggle-button" onclick="toggleJourneyMap()">ğŸ“Š æˆé•·ã®é“ã®ã‚Šï¼ˆä¾‹ï¼‰ã‚’è¦‹ã‚‹ <span class="toggle-icon" id="journey-toggle-icon">â–¼</span></button>
        
        <div class="journey-map-section">
            
            <div class="journey-map-container" id="journey-map-container" style="display: none;">
                <div class="journey-iframe-wrapper">
                    <iframe id="journey-map-iframe"
                            src="./journey-map-embed.html"
                            width="100%"
                            height="800px"
                            frameborder="0"
                            style="border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    </iframe>
                </div>
                
                <div class="journey-map-description">
                    <h4>ã‚¸ãƒ£ãƒ¼ãƒ‹ãƒ¼ãƒãƒƒãƒ—ã«ã¤ã„ã¦</h4>
                    <p>ã“ã®ãƒ“ãƒ¥ãƒ¼ã‚¢ã¯ã€ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ç†è«–ã«åŸºã¥ã„ãŸå­¦ç”Ÿã®æˆé•·éç¨‹ã‚’è¦–è¦šåŒ–ã—ãŸã‚‚ã®ã§ã™ã€‚ã‚·ãƒŠãƒªã‚ªã¯ç”ŸæˆAIã‚’ç”¨ã„ã¦ä½œæˆã—ãŸä»®æƒ³ã®ã‚‚ã®ã§ã™ã€‚</p>
                    <ul>
                        <li><strong>ãƒšãƒ«ã‚½ãƒŠæ¯”è¼ƒï¼š</strong>ç•°ãªã‚‹å­¦ç¿’ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¯”è¼ƒåˆ†æ</li>
                        <li><strong>æˆé•·/åœæ»åˆ†æï¼š</strong>æˆé•·ãƒ»åœæ»ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å¯è¦–åŒ–</li>
                        <li><strong>åˆ†å²ç‚¹ç‰¹å®šï¼š</strong>é‡è¦ãªè»¢æ›ç‚¹ã®è©³ç´°åˆ†æ</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>ğŸ¤– ä»˜éŒ²ï¼šã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·æ”¯æ´ã®ãŸã‚ã®ç”ŸæˆAIæ´»ç”¨ãƒ„ãƒ¼ãƒ«ï¼ˆéšæ™‚è¿½åŠ äºˆå®šï¼‰</h2>
        <p>ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®å„æ®µéšã«ãŠã‘ã‚‹æˆé•·æ”¯æ´ã®æ¤œè¨ã«ã‚ãŸã‚Šã€ä»¥ä¸‹ã®ãƒ„ãƒ¼ãƒ«ã‚‚æ´»ç”¨ã„ãŸã ã‘ã¾ã™ã€‚</p>
        
        <div class="dimension-grid">
            <div class="dimension-card">
                <h3>ğŸ’­ ã‚¢ã‚¤ãƒ‡ã‚¢ç‹¬ã‚Šè¨€ãƒ„ãƒ¼ãƒ«</h3>
                <p>ç¾åœ¨æ¤œè¨ä¸­ã®ã‚¢ã‚¤ãƒ‡ã‚¢ã‚„ä¼ç”»ã«ã¤ã„ã¦ã€ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã‚’å¤§åˆ‡ã«ã™ã‚‹è¦³ç‚¹ã‹ã‚‰ç”ŸæˆAIã«ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’ã—ã¦ã‚‚ã‚‰ã†ãŸã‚ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç”Ÿæˆãƒ„ãƒ¼ãƒ«ã§ã™ã€‚</p>
                <a href="javascript:void(0)" onclick="openIdeaFeedbackTool()" class="tool-link">
                    ãƒ„ãƒ¼ãƒ«ã‚’é–‹ã â†’
                </a>
            </div>
            
            <div class="dimension-card">
                <h3>ğŸ“‹ å­¦ç”Ÿãƒšãƒ«ã‚½ãƒŠä½œæˆãƒ„ãƒ¼ãƒ«</h3>
                <p>å¤šæ§˜ãªå­¦ç”Ÿãƒšãƒ«ã‚½ãƒŠã‚’ä½œæˆã—ã€å€‹ã€…äººã®æ§˜ã€…ãªæˆé•·ã‚·ãƒŠãƒªã‚ªã®ç†è§£ã‚„å­¦ç¿’ãƒ»æˆé•·æ”¯æ´ã®æ¤œè¨ã‚’åŠ¹æœçš„ã«é€²ã‚ã‚‰ã‚Œã‚‹ã‚ˆã†è¨­è¨ˆã•ã‚ŒãŸãƒ„ãƒ¼ãƒ«ã§ã™ã€‚</p>
                <a href="https://hirokioshiro.github.io/persona_selection_tool/" target="_blank" class="tool-link">
                    ãƒ„ãƒ¼ãƒ«ã‚’é–‹ã â†’
                </a>
            </div>
            
            <div class="dimension-card">
                <h3>ğŸ› ï¸ å­¦ç”Ÿãƒšãƒ«ã‚½ãƒŠæ´»ç”¨ãƒ„ãƒ¼ãƒ«</h3>
                <p>ä½œæˆã—ãŸå­¦ç”Ÿãƒšãƒ«ã‚½ãƒŠã‚’æ´»ç”¨ã—ã€ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã‚’é‡è¦–ã—ãŸå–ã‚Šçµ„ã¿ã‚’æ§˜ã€…ãªãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚‚å‚è€ƒã«ã—ãªãŒã‚‰æ¤œè¨ã‚’é€²ã‚ã‚‹ãŸã‚ã®ãƒ„ãƒ¼ãƒ«ã§ã™ã€‚</p>
                <a href="https://hirokioshiro.github.io/support_design_prompt_generator/" target="_blank" class="tool-link">
                    ãƒ„ãƒ¼ãƒ«ã‚’é–‹ã â†’
                </a>
            </div>

            <div class="dimension-card">
                <h3>ğŸ¯ æ¦‚å¿µå¯è¦–åŒ–ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç”Ÿæˆ</h3>
                <p>è¤‡é›‘ãªæ¦‚å¿µã‚„ç†è«–ã‚’è¦–è¦šçš„ã«ç†è§£ã—ã‚„ã™ã„å½¢ã§è¡¨ç¾ã™ã‚‹ãŸã‚ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’è‡ªå‹•ç”Ÿæˆã—ã€ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚„å¯¾è©±ã‚’ä¿ƒé€²ã™ã‚‹ç´ æã¨ã—ã¦æ´»ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
                <a href="https://hirokioshiro.github.io/concept_visualization_prompt_generator/" target="_blank" class="tool-link">
                    ãƒ„ãƒ¼ãƒ«ã‚’é–‹ã â†’
                </a>
            </div>
            
            <div class="dimension-card">
                <h3>ğŸƒ ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ»ã‚«ãƒ¼ãƒ‰ä½œæˆ</h3>
                <p>ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã‚’å¾ŒæŠ¼ã—ã™ã‚‹ã‚ˆã†ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã‚«ãƒ¼ãƒ‰ã¨ã—ã¦ä½œæˆã—ã€å­¦ç¿’è€…ãŒå„è‡ªã®çŠ¶æ³ã«å¿œã˜ã¦è‡ªåˆ†è‡ªèº«ã¸å•ã„ã‹ã‘ã‚’è¡Œã†æ©Ÿä¼šã‚’æä¾›ã§ãã¾ã™ã€‚</p>
                <a href="https://hirokioshiro.github.io/pattern_card_generator/" target="_blank" class="tool-link">
                    ãƒ„ãƒ¼ãƒ«ã‚’é–‹ã â†’
                </a>
            </div>

            <div class="dimension-card">
                <h3>ğŸƒ å•ã„ã‹ã‘ã‚«ãƒ¼ãƒ‰ä½œæˆ</h3>
                <p>ãµã¨ç«‹ã¡æ­¢ã¾ã£ã¦è‡ªåˆ†ã«å•ã„ã‹ã‘ã¦ã¿ãŸããªã‚‹ã‚ˆã†ãªæ§˜ã€…ãªå•ã„ã‚’ã‚«ãƒ¼ãƒ‰ã¨ã—ã¦ä½œæˆã—ã€å­¦ç¿’è€…ãŒå„è‡ªã®çŠ¶æ³ã«å¿œã˜ã¦è‡ªåˆ†è‡ªèº«ã¸å•ã„ã‹ã‘ã‚’è¡Œã†æ©Ÿä¼šã‚’æä¾›ã§ãã¾ã™ã€‚</p>
                <a href="https://hirokioshiro.github.io/question_card_generator/" target="_blank" class="tool-link">
                    ãƒ„ãƒ¼ãƒ«ã‚’é–‹ã â†’
                </a>
            </div>
        </div>
    </div>

    <script>
        // Self-Authorship 3D Integration Module
        
        // åœ°é¢ç§»å‹•ã‚·ã‚¹ãƒ†ãƒ  - ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®äººç”Ÿã®æ—…è·¯ã‚’åœ°é¢ã®æµã‚Œã§è¡¨ç¾
        class GroundMovementSystem {
            constructor(scene, camera) {
                this.scene = scene;
                this.camera = camera;
                this.groundDots = [];
                this.currentDirection = { x: 0, z: 1 }; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼šå‰é€²
                this.speed = 0.1;
                this.gridSize = 50;
                this.spacing = 4;
                this.depth = 200;
                this.isActive = false;
                this.currentStage = 'Ea'; // ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’è¿½è·¡
                this.behaviorState = null; // è¡Œå‹•çŠ¶æ…‹ç®¡ç†
                this.stageConfig = null; // æ®µéšå›ºæœ‰ã®è¨­å®š
                this.originalSpeed = 0.1; // å…ƒã®é€Ÿåº¦ã‚’ä¿å­˜
                
                // ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—æ®µéšåˆ¥ã®å‹•ä½œãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆåœ°é¢ã¯å‰å¾Œã®ã¿æµã‚Œã‚‹ï¼‰
                this.movementPatterns = {
                    // EAæ®µéš: å¤–éƒ¨æ¨©å¨ä¾å­˜æœŸ - åˆ¶é™çš„ã§æ…é‡ãªå‹•ã
                    'Ea': { type: 'guided', speed: 0.06, direction: { x: 0, z: 0.8 }, pause: true },
                    'Eb': { type: 'guided', speed: 0.05, direction: { x: 0, z: 0.9 }, pause: true },
                    'Ec': { type: 'guided', speed: 0.04, direction: { x: 0, z: 1.0 }, pause: false },
                    
                    // å²è·¯æ®µéš: æ¢ç´¢ã¨è¿·ã„ã®æœŸ - å‰å¾Œã®å‹•ãã®ã¿ã§è¡¨ç¾
                    'EI': { type: 'exploring', speed: 0.03, direction: { x: 0, z: 0.7 }, pause: true },
                    'E-I': { type: 'wandering', speed: 0.02, direction: { x: 0, z: 0.5 }, pause: true },
                    'I-E': { type: 'questioning', speed: 0.02, direction: { x: 0, z: 0.2 }, pause: true },
                    
                    // IAæ®µéš: å†…çš„æ¨©å¨ç¢ºç«‹æœŸ - è‡ªå¾‹çš„ã§ç¢ºä¿¡ã«æº€ã¡ãŸå‹•ã
                    'IE': { type: 'emerging', speed: 0.025, direction: { x: 0, z: 1.2 }, pause: false },
                    'Ia': { type: 'confident', speed: 0.03, direction: { x: 0, z: 1.3 }, pause: false },
                    'Ib': { type: 'integrating', speed: 0.04, direction: { x: 0, z: 1.1 }, pause: false },
                    'Ic': { type: 'authoring', speed: 0.05, direction: { x: 0, z: 1.4 }, pause: false }
                };
            }
            
            // åœ°é¢ãƒ‰ãƒƒãƒˆé…åˆ—ã®åˆæœŸåŒ–
            initializeGroundDots() {
                // æ—¢å­˜ã®ãƒ‰ãƒƒãƒˆã‚’ã‚¯ãƒªã‚¢
                this.clearGroundDots();
                
                const dotGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const dotMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.6
                });
                
                // æ ¼å­çŠ¶ã«ãƒ‰ãƒƒãƒˆã‚’é…ç½®ï¼ˆæ³¢æ‰“ã¤åœ°å½¢ï¼‰
                const extraMargin = 20; // ãƒ«ãƒ¼ãƒ—å‡¦ç†ç”¨ã®ä½™è£•ç¯„å›²
                for (let x = -this.gridSize - extraMargin; x <= this.gridSize + extraMargin; x += this.spacing) {
                    for (let z = -this.depth; z <= this.depth; z += this.spacing) {
                        const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                        
                        // æ³¢æ‰“ã¤åœ°å½¢ã®è¨ˆç®—ï¼ˆäººç”Ÿã®èµ·ä¼ã‚’è¡¨ç¾ï¼‰
                        const waveHeight = this.calculateTerrainHeight(x, z);
                        
                        dot.position.set(x, -5 + waveHeight, z); // åœ°é¢ãƒ¬ãƒ™ãƒ« + æ³¢ã®é«˜ã•
                        
                        // æ³¢ã®é«˜ã•ã«å¿œã˜ã¦é€æ˜åº¦ã‚’èª¿æ•´ï¼ˆé«˜ã„ã¨ã“ã‚ã¯å°‘ã—æ˜ã‚‹ãï¼‰
                        const heightOpacity = 0.4 + (waveHeight + 1) * 0.1; // 0.4ã€œ0.6ã®ç¯„å›²
                        dot.material = dotMaterial.clone();
                        dot.material.opacity = Math.min(heightOpacity, 0.7);
                        
                        this.groundDots.push(dot);
                        this.scene.add(dot);
                    }
                }
                
                console.log(`[GroundSystem] Initialized ${this.groundDots.length} ground dots`);
            }
            
            // æ³¢æ‰“ã¤åœ°å½¢ã®é«˜ã•ã‚’è¨ˆç®—ï¼ˆäººç”Ÿã®é“ã®ã‚Šã®èµ·ä¼ã‚’è¡¨ç¾ï¼‰
            calculateTerrainHeight(x, z) {
                // è¤‡æ•°ã®æ³¢ã‚’é‡ã­åˆã‚ã›ã¦è‡ªç„¶ãªèµ·ä¼ã‚’ä½œæˆ
                const time = Date.now() * 0.0001; // ã‚†ã£ãã‚Šã¨ã—ãŸæ™‚é–“å¤‰åŒ–
                
                // æ®µéšã«å¿œã˜ãŸæ³¢ã®å¼·åº¦èª¿æ•´
                const stageIntensity = this.getWaveIntensityForStage();
                
                // å¤§ããªæ³¢ï¼ˆäººç”Ÿã®å¤§ããªèµ·ä¼ï¼‰
                const largeWave = Math.sin(x * 0.05 + time) * Math.cos(z * 0.03 + time * 0.5) * 0.8 * stageIntensity.large;
                
                // ä¸­ç¨‹åº¦ã®æ³¢ï¼ˆæ—¥å¸¸ã®å¤‰åŒ–ï¼‰
                const mediumWave = Math.sin(x * 0.15 + z * 0.1 + time * 2) * 0.4 * stageIntensity.medium;
                
                // å°ã•ãªæ³¢ï¼ˆç´°ã‹ã„å¤‰å‹•ï¼‰
                const smallWave = Math.sin(x * 0.3 + z * 0.4 + time * 3) * 0.2 * stageIntensity.small;
                
                // è·é›¢ã«åŸºã¥ãæ¸›è¡°ï¼ˆä¸­å¤®ã‹ã‚‰é›¢ã‚Œã‚‹ã»ã©å¹³å¦ã«ï¼‰
                const distanceFromCenter = Math.sqrt(x * x + z * z);
                const dampingFactor = Math.max(0.1, Math.exp(-distanceFromCenter * 0.02));
                
                // æ³¢ã‚’åˆæˆã—ã€é©åº¦ãªèµ·ä¼ã«èª¿æ•´
                const combinedHeight = (largeWave + mediumWave + smallWave) * dampingFactor;
                
                // æœ€çµ‚çš„ãªé«˜ã•ï¼ˆ-1ã€œ1ã®ç¯„å›²ã«åˆ¶é™ï¼‰
                return Math.max(-1, Math.min(1, combinedHeight));
            }
            
            // æ®µéšã«å¿œã˜ãŸæ³¢ã®å¼·åº¦ã‚’å–å¾—
            getWaveIntensityForStage() {
                const stage = this.currentStage || 'Ea';
                
                // å„æ®µéšã®ç‰¹å¾´ã«å¿œã˜ãŸæ³¢ã®å¼·åº¦è¨­å®š
                const intensityMap = {
                    // Eaæ®µéš: ç©ã‚„ã‹ãªæ³¢ï¼ˆå®‰å®šã—ãŸç’°å¢ƒï¼‰
                    'Ea': { large: 0.6, medium: 0.8, small: 1.0 },
                    // Ecæ®µéš: æ¿€ã—ã„æ³¢ï¼ˆè‘›è—¤ã¨æ··ä¹±ï¼‰
                    'Ec': { large: 1.2, medium: 1.4, small: 1.6 },
                    // EIæ®µéš: ã‚„ã‚„ä¸å®‰å®šãªæ³¢ï¼ˆè‡ªåˆ†ã‚‰ã—ã•ã®æ¨¡ç´¢ï¼‰
                    'EI': { large: 0.9, medium: 1.1, small: 1.3 },
                    // E-Iæ®µéš: å¤‰å‹•ã®å¤§ãã„æ³¢ï¼ˆä¾¡å€¤è¦³ã®è¡çªï¼‰
                    'E-I': { large: 1.1, medium: 1.3, small: 1.1 },
                    // I-Eæ®µéš: å¾ã€…ã«å®‰å®šã™ã‚‹æ³¢ï¼ˆå†…ãªã‚‹å£°ã®ç¢ºç«‹ï¼‰
                    'I-E': { large: 0.8, medium: 1.0, small: 0.9 },
                    // Iaæ®µéš: è¤‡é›‘ãªæ³¢ï¼ˆè¤‡æ•°ã®ä¾¡å€¤è¦³ã®çµ±åˆï¼‰
                    'Ia': { large: 1.0, medium: 1.2, small: 1.0 },
                    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
                    'default': { large: 0.8, medium: 1.0, small: 1.0 }
                };
                
                return intensityMap[stage] || intensityMap['default'];
            }
            
            // æ®µéšã«å¿œã˜ãŸå‹•ä½œãƒ‘ã‚¿ãƒ¼ãƒ³ã®è¨­å®š
            setMovementPattern(stage) {
                if (!this.movementPatterns[stage]) {
                    console.warn(`[GroundSystem] Unknown stage: ${stage}`);
                    return;
                }
                
                const pattern = this.movementPatterns[stage];
                this.speed = pattern.speed;
                this.currentDirection = { ...pattern.direction };
                this.currentStage = stage; // ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’æ›´æ–°
                
                // æ®µéšå›ºæœ‰ã®è¡Œå‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆæœŸåŒ–
                this.initializeStageSpecificBehaviors(stage, pattern);
                
                console.log(`[GroundSystem] Set pattern for stage ${stage}:`, pattern);
            }
            
            // æ®µéšå›ºæœ‰ã®è¡Œå‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆæœŸåŒ–
            initializeStageSpecificBehaviors(stage, pattern) {
                // æ®µéšåˆ¥ã®ç‰¹æ®Šè¡Œå‹•é »åº¦è¨­å®šã‚’å…ˆã«è¨­å®š
                this.stageConfig = this.getStageSpecificConfig(stage);
                
                // è¡Œå‹•çŠ¶æ…‹ã®åˆæœŸåŒ–
                this.behaviorState = {
                    currentBehavior: 'normal', // normal, pausing, wandering
                    behaviorStartTime: Date.now(),
                    behaviorDuration: 0,
                    pauseCounter: 0,
                    wanderDirection: { x: 0, z: 1 },
                    // æŒ¯ã‚Šè¿”ã‚Šé–¢é€£ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
                    shouldReflect: false,           // ç«‹ã¡æ­¢ã¾ã‚Šä¸­ã«æŒ¯ã‚Šè¿”ã‚‹ã‹ã©ã†ã‹
                    reflectionAngle: 0,             // æŒ¯ã‚Šè¿”ã‚Šè§’åº¦
                    reflectionStartTime: null,      // æŒ¯ã‚Šè¿”ã‚Šé–‹å§‹æ™‚åˆ»
                    nextBehaviorTime: Date.now() + this.calculateNextBehaviorDelay()
                };
            }
            
            // æ®µéšåˆ¥ã®è©³ç´°è¨­å®šã‚’å–å¾—
            getStageSpecificConfig(stage) {
                const configs = {
                    // EAæ®µéš: æ…é‡ã§è¦å‰‡çš„ãªå‹•ã
                    'Ea': {
                        pauseFrequency: 0.1, // é«˜ã„ç«‹ã¡æ­¢ã¾ã‚Šé »åº¦
                        pauseDuration: [800, 1000], // 1-2.5ç§’ã®ç«‹ã¡æ­¢ã¾ã‚Š
                        wanderFrequency: 0.1, // å°‘ãªã„è¿·ã„
                        wanderIntensity: 0.2, // è»½ã„è¿·ã„
                        reflectionFrequency: 0.4, // é«˜ã„æŒ¯ã‚Šè¿”ã‚Šé »åº¦
                        reflectionAngle: Math.PI / 4, // 45åº¦ã®æŒ¯ã‚Šè¿”ã‚Š
                        behaviorTransition: 3000 // 3ç§’é–“éš”ã§ã®è¡Œå‹•å¤‰åŒ–
                    },
                    'Eb': {
                        pauseFrequency: 0.5, // ã‚ˆã‚Šé«˜ã„ç«‹ã¡æ­¢ã¾ã‚Šé »åº¦ï¼ˆè¤‡æ•°æ¨©å¨ç¢ºèªã®ãŸã‚ï¼‰
                        pauseDuration: [1200, 2500], // é•·ã‚ã®åœæ­¢ï¼ˆè¤‡æ•°æ–¹å‘ç¢ºèªæ™‚é–“ï¼‰
                        wanderFrequency: 0.1, // è¿·ã„ã¯æ§ãˆã‚ï¼ˆæŒ¯ã‚Šè¿”ã‚Šã‚’é‡è¦–ï¼‰
                        wanderIntensity: 0.25,
                        reflectionFrequency: 0.8, // éå¸¸ã«é«˜ã„æŒ¯ã‚Šè¿”ã‚Šé »åº¦
                        reflectionAngle: Math.PI, // 180åº¦ã‚’åŸºæœ¬ã¨ã—ã€è¤‡æ•°æ®µéšã§å®Ÿè£…
                        behaviorTransition: 2200, // ã‚„ã‚„çŸ­ã‚ã®é–“éš”ã§é »ç¹ãªæ¨©å¨ç¢ºèª
                        // Ebå°‚ç”¨: è¤‡æ•°æ¨©å¨ç¢ºèªãƒ‘ã‚¿ãƒ¼ãƒ³
                        isMultiAuthorityScanning: true,
                        authorityDirections: [
                            Math.PI / 6,      // å³30åº¦
                            -Math.PI / 6,     // å·¦30åº¦  
                            Math.PI / 3,      // å³60åº¦
                            -Math.PI / 3,     // å·¦60åº¦
                            Math.PI * 0.75,   // å³135åº¦
                            -Math.PI * 0.75,  // å·¦135åº¦
                            Math.PI           // å¾Œæ–¹180åº¦
                        ]
                    },
                    'Ec': {
                        pauseFrequency: 0.25,
                        pauseDuration: [600, 1500],
                        wanderFrequency: 0.2,
                        wanderIntensity: 0.4,
                        reflectionFrequency: 0.3,
                        reflectionAngle: Math.PI / 1,
                        behaviorTransition: 2500
                    },
                    
                    // å²è·¯æ®µéš: æœ€ã‚‚è¤‡é›‘ã§å¤‰åŒ–ã«å¯Œã‚“ã å‹•ã
                    'EI': {
                        pauseFrequency: 0.4, // éå¸¸ã«é«˜ã„ç«‹ã¡æ­¢ã¾ã‚Šé »åº¦
                        pauseDuration: [1500, 3000], // é•·ã„æ€è€ƒæ™‚é–“
                        wanderFrequency: 0.6, // é«˜ã„è¿·ã„é »åº¦
                        wanderIntensity: 0.8, // å¼·ã„è¿·ã„
                        reflectionFrequency: 0.5,
                        reflectionAngle: Math.PI * 1, // 180åº¦ã®æŒ¯ã‚Šè¿”ã‚Š
                        behaviorTransition: 1500 // é »ç¹ãªè¡Œå‹•å¤‰åŒ–
                    },
                    'E-I': {
                        pauseFrequency: 0.5, // æœ€é«˜ã®ç«‹ã¡æ­¢ã¾ã‚Šé »åº¦
                        pauseDuration: [2000, 4000], // æœ€ã‚‚é•·ã„æ€è€ƒæ™‚é–“
                        wanderFrequency: 0.7, // æœ€é«˜ã®è¿·ã„é »åº¦
                        wanderIntensity: 1.0, // æœ€å¼·ã®è¿·ã„
                        reflectionFrequency: 0.6,
                        reflectionAngle: Math.PI * 1.5, // 270åº¦ã®æŒ¯ã‚Šè¿”ã‚Š
                        behaviorTransition: 1200, // æœ€ã‚‚é »ç¹ãªè¡Œå‹•å¤‰åŒ–
                        isMultiAuthorityScanning: true, // E-Iã‚¹ãƒ†ãƒ¼ã‚¸ã§ã‚‚ã‚¹ã‚­ãƒ£ãƒ‹ãƒ³ã‚°æ©Ÿèƒ½ã‚’æœ‰åŠ¹
                        authorityDirections: [
                            { angle: Math.PI * 2/3, weight: 0.2 },   // å³å‰120åº¦
                            { angle: -Math.PI * 2/3, weight: 0.2 },  // å·¦å‰120åº¦
                            { angle: Math.PI/2, weight: 0.2 },       // å³æ¨ª90åº¦
                            { angle: -Math.PI/2, weight: 0.2 },      // å·¦æ¨ª90åº¦
                            { angle: Math.PI/3, weight: 0.1 },       // å³å‰60åº¦
                            { angle: -Math.PI/3, weight: 0.1 },      // å·¦å‰60åº¦
                            { angle: Math.PI * 5/6, weight: 0.1 },   // å³å¾Œ150åº¦
                            { angle: -Math.PI * 5/6, weight: 0.1 }   // å·¦å¾Œ150åº¦
                        ]
                    },
                    'I-E': {
                        pauseFrequency: 0.4,
                        pauseDuration: [1500, 3500],
                        wanderFrequency: 0.5,
                        wanderIntensity: 0.9,
                        reflectionFrequency: 0.7, // æœ€é«˜ã®æŒ¯ã‚Šè¿”ã‚Šé »åº¦
                        reflectionAngle: Math.PI * 0.75, // 135åº¦ã®æŒ¯ã‚Šè¿”ã‚Š
                        behaviorTransition: 1800
                    },
                    
                    // IAæ®µéš: ç¢ºä¿¡ã‚’æŒã£ãŸå‹•ãã ãŒæ™‚æŠ˜ã®ç†Ÿè€ƒ
                    'IE': {
                        pauseFrequency: 0.15, // ä½ã„ç«‹ã¡æ­¢ã¾ã‚Šé »åº¦
                        pauseDuration: [500, 1200], // çŸ­ã„æ€è€ƒæ™‚é–“
                        wanderFrequency: 0.1, // å°‘ãªã„è¿·ã„
                        wanderIntensity: 0.3, // è»½ã„è¿·ã„
                        reflectionFrequency: 0.2, // å°‘ãªã„æŒ¯ã‚Šè¿”ã‚Š
                        reflectionAngle: Math.PI / 6, // 30åº¦ã®è»½ã„æŒ¯ã‚Šè¿”ã‚Š
                        behaviorTransition: 4000 // ã‚†ã£ãã‚Šã¨ã—ãŸè¡Œå‹•å¤‰åŒ–
                    },
                    'Ia': {
                        pauseFrequency: 0.1,
                        pauseDuration: [300, 800],
                        wanderFrequency: 0.05,
                        wanderIntensity: 0.2,
                        reflectionFrequency: 0.15,
                        reflectionAngle: Math.PI / 8,
                        behaviorTransition: 5000
                    },
                    'Ib': {
                        pauseFrequency: 0.12,
                        pauseDuration: [400, 1000],
                        wanderFrequency: 0.08,
                        wanderIntensity: 0.25,
                        reflectionFrequency: 0.18,
                        reflectionAngle: Math.PI / 6,
                        behaviorTransition: 4500
                    },
                    'Ic': {
                        pauseFrequency: 0.08, // æœ€ã‚‚ä½ã„ç«‹ã¡æ­¢ã¾ã‚Šé »åº¦
                        pauseDuration: [200, 600], // æœ€ã‚‚çŸ­ã„æ€è€ƒæ™‚é–“
                        wanderFrequency: 0.03, // æœ€ã‚‚å°‘ãªã„è¿·ã„
                        wanderIntensity: 0.15, // æœ€ã‚‚è»½ã„è¿·ã„
                        reflectionFrequency: 0.1, // æœ€ã‚‚å°‘ãªã„æŒ¯ã‚Šè¿”ã‚Š
                        reflectionAngle: Math.PI / 12, // 15åº¦ã®éå¸¸ã«è»½ã„æŒ¯ã‚Šè¿”ã‚Š
                        behaviorTransition: 6000 // æœ€ã‚‚ã‚†ã£ãã‚Šã¨ã—ãŸè¡Œå‹•å¤‰åŒ–
                    }
                };
                
                return configs[stage] || configs['Ea']; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯Eaæ®µéš
            }
            
            // åœ°é¢ãƒ‰ãƒƒãƒˆã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
            updateGroundMovement() {
                if (!this.isActive || this.groundDots.length === 0) return;
                
                const currentTime = Date.now();
                
                // æ®µéšå›ºæœ‰ã®è¡Œå‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ›´æ–°
                this.updateStageSpecificBehaviors(currentTime);
                
                // ç¾åœ¨ã®è¡Œå‹•ã«åŸºã¥ã„ã¦ç§»å‹•æ–¹å‘ã¨é€Ÿåº¦ã‚’æ±ºå®š
                const adjustedMovement = this.calculateAdjustedMovement();
                
                // ãƒ‰ãƒƒãƒˆã‚’ç¾åœ¨ã®æ–¹å‘ã«ç§»å‹•ï¼ˆåœ°é¢ã¯å‰å¾Œã®ã¿ã€å·¦å³ã«ã¯å‹•ã‹ãªã„ï¼‰
                this.groundDots.forEach(dot => {
                    // Xæ–¹å‘ï¼ˆå·¦å³ï¼‰ã®ç§»å‹•ã¯ç„¡åŠ¹åŒ–ã—ã€Zæ–¹å‘ï¼ˆå‰å¾Œï¼‰ã®ã¿é©ç”¨
                    // dot.position.x += adjustedMovement.speed * adjustedMovement.direction.x; // å·¦å³ç§»å‹•ã‚’ç„¡åŠ¹åŒ–
                    dot.position.z += adjustedMovement.speed * adjustedMovement.direction.z; // å‰å¾Œç§»å‹•ã®ã¿
                    
                    // æ³¢æ‰“ã¤åœ°å½¢ã®å‹•çš„æ›´æ–°ï¼ˆæ™‚é–“ã¨ã¨ã‚‚ã«å¤‰åŒ–ã™ã‚‹èµ·ä¼ï¼‰
                    const waveHeight = this.calculateTerrainHeight(dot.position.x, dot.position.z);
                    dot.position.y = -5 + waveHeight; // åŸºæº–ãƒ¬ãƒ™ãƒ« + æ³¢ã®é«˜ã•
                    
                    // æ³¢ã®é«˜ã•ã«å¿œã˜ã¦é€æ˜åº¦ã‚’å‹•çš„ã«èª¿æ•´
                    const heightOpacity = 0.4 + (waveHeight + 1) * 0.1; // 0.4ã€œ0.6ã®ç¯„å›²
                    dot.material.opacity = Math.min(heightOpacity, 0.7);
                    
                    // ãƒ‰ãƒƒãƒˆãŒç¯„å›²å¤–ã«å‡ºãŸã‚‰åå¯¾å´ã«æˆ»ã™ï¼ˆç„¡é™ãƒ«ãƒ¼ãƒ—åŠ¹æœï¼‰
                    const extraMargin = 20;
                    if (dot.position.z > 50) {
                        dot.position.z = -this.depth;
                    }
                    if (dot.position.z < -this.depth) {
                        dot.position.z = 50;
                    }
                    // Xæ–¹å‘ã®ãƒ«ãƒ¼ãƒ—ã¯ç¶­æŒï¼ˆåˆæœŸé…ç½®ã®ãŸã‚ï¼‰
                    if (dot.position.x > this.gridSize + extraMargin) {
                        dot.position.x = -this.gridSize - extraMargin;
                    }
                    if (dot.position.x < -this.gridSize - extraMargin) {
                        dot.position.x = this.gridSize + extraMargin;
                    }
                });
            }
            
            // æ®µéšå›ºæœ‰ã®è¡Œå‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ›´æ–°
            updateStageSpecificBehaviors(currentTime) {
                if (!this.behaviorState || !this.stageConfig) return;
                
                const timeSinceLastBehavior = currentTime - this.behaviorState.behaviorStartTime;
                
                // æ¬¡ã®è¡Œå‹•åˆ‡ã‚Šæ›¿ãˆã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‹ãƒã‚§ãƒƒã‚¯
                if (currentTime >= this.behaviorState.nextBehaviorTime) {
                    this.selectNextBehavior(currentTime);
                }
                
                // ç¾åœ¨ã®è¡Œå‹•ã‚’å®Ÿè¡Œ
                this.executeBehavior(timeSinceLastBehavior);
            }
            
            // æ¬¡ã®è¡Œå‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é¸æŠ
            selectNextBehavior(currentTime) {
                const config = this.stageConfig;
                const random = Math.random();
                
                let selectedBehavior = 'normal';
                
                // ç¢ºç‡ã«åŸºã¥ã„ã¦è¡Œå‹•ã‚’é¸æŠï¼ˆreflectingã¯é™¤å¤–ã—ã€pausingã«çµ±åˆï¼‰
                if (random < config.pauseFrequency) {
                    selectedBehavior = 'pausing';
                    this.behaviorState.behaviorDuration = this.randomBetween(
                        config.pauseDuration[0], 
                        config.pauseDuration[1]
                    );
                    // ç«‹ã¡æ­¢ã¾ã‚Šä¸­ã«æŒ¯ã‚Šè¿”ã‚ŠãŒç™ºç”Ÿã™ã‚‹ã‹ã‚’æ±ºå®š
                    this.behaviorState.shouldReflect = Math.random() < config.reflectionFrequency;
                    if (this.behaviorState.shouldReflect) {
                        this.behaviorState.reflectionAngle = config.reflectionAngle;
                        this.behaviorState.reflectionStartTime = null; // å¾Œã§è¨­å®š
                        console.log(`[GroundSystem] Pausing with reflection (angle: ${config.reflectionAngle})`);
                    }
                } else if (random < config.pauseFrequency + config.wanderFrequency) {
                    selectedBehavior = 'wandering';
                    this.behaviorState.behaviorDuration = this.randomBetween(1000, 3000);
                    // è¿·ã„æ–¹å‘ã‚’å‰å¾Œã®ã¿ã«åˆ¶é™ï¼ˆå·¦å³ã®è¿·ã„ã¯é™¤å¤–ï¼‰
                    const wanderIntensity = (Math.random() - 0.5) * config.wanderIntensity; // -0.5ã€œ0.5ã®ç¯„å›²
                    this.behaviorState.wanderDirection = {
                        x: 0, // å·¦å³ã®è¿·ã„ã‚’ç„¡åŠ¹åŒ–
                        z: 1 + wanderIntensity // å‰å¾Œã®ã¿ã®å¤‰å‹•
                    };
                } else {
                    selectedBehavior = 'normal';
                    this.behaviorState.behaviorDuration = this.randomBetween(2000, 5000);
                }
                
                // è¡Œå‹•çŠ¶æ…‹ã‚’æ›´æ–°
                this.behaviorState.currentBehavior = selectedBehavior;
                this.behaviorState.behaviorStartTime = currentTime;
                this.behaviorState.nextBehaviorTime = currentTime + 
                    this.behaviorState.behaviorDuration + 
                    this.calculateNextBehaviorDelay();
                
                console.log(`[GroundSystem] Behavior changed to: ${selectedBehavior} for ${this.behaviorState.behaviorDuration}ms`);
            }
            
            // ç¾åœ¨ã®è¡Œå‹•ã‚’å®Ÿè¡Œ
            executeBehavior(timeSinceStart) {
                const behavior = this.behaviorState.currentBehavior;
                const progress = Math.min(timeSinceStart / this.behaviorState.behaviorDuration, 1.0);
                
                switch (behavior) {
                    case 'pausing':
                        this.executePausingBehavior(progress);
                        break;
                    case 'wandering':
                        this.executeWanderingBehavior(progress);
                        break;
                    case 'normal':
                    default:
                        this.executeNormalBehavior();
                        break;
                }
            }
            
            // ç«‹ã¡æ­¢ã¾ã‚Šè¡Œå‹•ï¼šè‡ªç„¶ãªæ¸›é€Ÿãƒ»åŠ é€Ÿã¨å¾®ç´°ãªæºã‚‰ãã‚’å«ã‚€
            executePausingBehavior(progress) {
                // å…ƒã®é€Ÿåº¦ã‚’ä¿å­˜
                if (!this.originalSpeed) {
                    this.originalSpeed = this.movementPatterns[this.currentStage]?.speed || 0.1;
                }
                
                // ç«‹ã¡æ­¢ã¾ã‚Šãƒ•ã‚§ãƒ¼ã‚ºã®æ™‚é–“é…åˆ†ï¼ˆã‚ˆã‚Šãªã‚ã‚‰ã‹ã«ï¼‰
                const decelPhase = 0.35;      // æ¸›é€Ÿãƒ•ã‚§ãƒ¼ã‚º
                const pausedPhase = 0.3;      // åœæ­¢ãƒ•ã‚§ãƒ¼ã‚ºï¼ˆæºã‚‰ãã‚ã‚Šï¼‰
                const accelPhase = 0.35;      // åŠ é€Ÿãƒ•ã‚§ãƒ¼ã‚º
                
                let speedMultiplier = 0;
                let reflectionAngle = 0;
                let microMovement = { x: 0, z: 0 };
                
                // ç¾åœ¨æ™‚åˆ»ï¼ˆæºã‚‰ãè¨ˆç®—ç”¨ï¼‰
                const currentTime = Date.now();
                const timeOffset = this.behaviorState.behaviorStartTime || currentTime;
                
                if (progress <= decelPhase) {
                    // ãƒ•ã‚§ãƒ¼ã‚º1: è‡ªç„¶ãªæ¸›é€Ÿï¼ˆã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã‚¢ã‚¦ãƒˆï¼‰
                    const decelProgress = progress / decelPhase;
                    // ã‚¹ãƒ ãƒ¼ã‚ºãªæ¸›é€Ÿã‚«ãƒ¼ãƒ– (ease-out)
                    speedMultiplier = 1 - Math.pow(decelProgress, 2.5);
                    
                } else if (progress <= decelPhase + pausedPhase) {
                    // ãƒ•ã‚§ãƒ¼ã‚º2: å¾®ç´°ãªæºã‚‰ãã®ã‚ã‚‹åœæ­¢çŠ¶æ…‹
                    const pausedProgress = (progress - decelPhase) / pausedPhase;
                    
                    // åŸºæœ¬é€Ÿåº¦ã¯éå¸¸ã«ä½é€Ÿï¼ˆå®Œå…¨åœæ­¢ã§ã¯ãªã„ï¼‰
                    speedMultiplier = 0.05;
                    
                    // å¾®ç´°ãªæºã‚‰ãï¼ˆå‘¼å¸ã®ã‚ˆã†ãªå‹•ãï¼‰
                    const breathingCycle = (currentTime - timeOffset) * 0.002; // ã‚†ã£ãã‚Šã¨ã—ãŸå‘¼å¸
                    const nervousTremor = (currentTime - timeOffset) * 0.008;   // ç´°ã‹ã„éœ‡ãˆ
                    
                    microMovement.x = Math.sin(breathingCycle) * 0.01 + Math.sin(nervousTremor) * 0.005;
                    microMovement.z = Math.cos(breathingCycle * 0.7) * 0.008 + Math.cos(nervousTremor * 1.3) * 0.003;
                    
                    // æŒ¯ã‚Šè¿”ã‚ŠãŒäºˆå®šã•ã‚Œã¦ã„ã‚‹å ´åˆ
                    if (this.behaviorState.shouldReflect) {
                        if (!this.behaviorState.reflectionStartTime) {
                            this.behaviorState.reflectionStartTime = currentTime;
                        }
                        
                        // Ebæ®µéšã®ç‰¹åˆ¥ãªè¤‡æ•°æ¨©å¨ã‚¹ã‚­ãƒ£ãƒ‹ãƒ³ã‚°å‹•ä½œ
                        if (this.currentStage === 'Eb' && this.stageConfig.isMultiAuthorityScanning) {
                            reflectionAngle = this.executeMultiAuthorityScanning(pausedProgress);
                        } else {
                            // ä»–ã®æ®µéšï¼šé€šå¸¸ã®æŒ¯ã‚Šè¿”ã‚Šå‹•ä½œ
                            const reflectionCycle = pausedProgress * Math.PI * 1.5; // 1.5å¾€å¾©
                            const reflectionIntensity = Math.sin(pausedProgress * Math.PI); // ä¸­å¤®ã§æœ€å¤§
                            reflectionAngle = this.behaviorState.reflectionAngle * 
                                            Math.sin(reflectionCycle) * 
                                            reflectionIntensity * 0.6;
                        }
                    }
                    
                } else {
                    // ãƒ•ã‚§ãƒ¼ã‚º3: è‡ªç„¶ãªåŠ é€Ÿï¼ˆã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã‚¤ãƒ³ï¼‰
                    const accelProgress = (progress - decelPhase - pausedPhase) / accelPhase;
                    // ã‚¹ãƒ ãƒ¼ã‚ºãªåŠ é€Ÿã‚«ãƒ¼ãƒ– (ease-in)
                    speedMultiplier = Math.pow(accelProgress, 1.8);
                    
                    // æŒ¯ã‚Šè¿”ã‚Šå‹•ä½œã‚’å¾ã€…ã«åœæ­¢
                    const fadeOutReflection = 1 - accelProgress;
                    reflectionAngle *= fadeOutReflection;
                }
                
                // æ–¹å‘ã®èª¿æ•´ï¼ˆæŒ¯ã‚Šè¿”ã‚Šè§’åº¦ + å¾®ç´°ãªæºã‚‰ãã‚’é©ç”¨ï¼‰
                const originalDirection = this.movementPatterns[this.currentStage]?.direction || { x: 0, z: 1 };
                
                if (Math.abs(reflectionAngle) > 0.001) {
                    // æŒ¯ã‚Šè¿”ã‚Šä¸­: å…ƒã®æ–¹å‘ã‚’å›è»¢
                    const cos = Math.cos(reflectionAngle);
                    const sin = Math.sin(reflectionAngle);
                    
                    // ã‚¹ã‚­ãƒ£ãƒ‹ãƒ³ã‚°å‹•ä½œã®å ´åˆã¯ã€é€Ÿåº¦ã‚’ç¶­æŒã—ã¦æ–¹å‘ã®ã¿å¤‰æ›´
                    const isScanning = this.currentStage === 'Eb' && 
                                     this.stageConfig.isMultiAuthorityScanning && 
                                     this.behaviorState.shouldReflect;
                    
                    if (isScanning && speedMultiplier < 0.1) {
                        // ã‚¹ã‚­ãƒ£ãƒ‹ãƒ³ã‚°æ™‚ã¯æœ€ä½é™ã®å‹•ãã‚’ä¿è¨¼
                        const scanningSpeed = 0.08; // è¦–èªå¯èƒ½ãªé€Ÿåº¦
                        this.currentDirection.x = (originalDirection.x * cos - originalDirection.z * sin) * scanningSpeed + microMovement.x;
                        this.currentDirection.z = (originalDirection.x * sin + originalDirection.z * cos) * scanningSpeed + microMovement.z;
                    } else {
                        // é€šå¸¸ã®æŒ¯ã‚Šè¿”ã‚Š
                        this.currentDirection.x = (originalDirection.x * cos - originalDirection.z * sin) * speedMultiplier + microMovement.x;
                        this.currentDirection.z = (originalDirection.x * sin + originalDirection.z * cos) * speedMultiplier + microMovement.z;
                    }
                } else {
                    // é€šå¸¸æ™‚: å…ƒã®æ–¹å‘ + å¾®ç´°ãªæºã‚‰ã
                    this.currentDirection.x = originalDirection.x * speedMultiplier + microMovement.x;
                    this.currentDirection.z = originalDirection.z * speedMultiplier + microMovement.z;
                }
                
                // é€Ÿåº¦ã®è¨­å®šï¼ˆæœ€å°å€¤ã‚’ä¿è¨¼ã—ã¦å®Œå…¨åœæ­¢ã‚’é¿ã‘ã‚‹ï¼‰
                this.speed = Math.max(this.originalSpeed * speedMultiplier, 0.002);
            }
            
            // è¿·ã„è¡Œå‹•ï¼šã‚ˆã‚Šè‡ªç„¶ãªæ–¹å‘è»¢æ›ã¨é€Ÿåº¦å¤‰åŒ–
            executeWanderingBehavior(progress) {
                // å…ƒã®é€Ÿåº¦ã‚’ä¿å­˜
                if (!this.originalSpeed) {
                    this.originalSpeed = this.movementPatterns[this.currentStage]?.speed || 0.1;
                }
                
                // è¿·ã„è¡Œå‹•ã‚’3ã¤ã®ãƒ•ã‚§ãƒ¼ã‚ºã«åˆ†å‰²
                const transitionIn = 0.2;    // è¿·ã„å§‹ã‚
                const wanderCore = 0.6;      // è¿·ã„ã®ãƒ¡ã‚¤ãƒ³
                const transitionOut = 0.2;   // è¿·ã„ã‹ã‚‰ã®å¾©å¸°
                
                let directionBlend = 0;
                let speedMultiplier = 1;
                
                if (progress <= transitionIn) {
                    // ãƒ•ã‚§ãƒ¼ã‚º1: é€šå¸¸æ–¹å‘ã‹ã‚‰è¿·ã„æ–¹å‘ã¸ã®æ¼¸é€²çš„å¤‰åŒ–
                    const easeIn = progress / transitionIn;
                    directionBlend = Math.pow(easeIn, 2); // ease-in
                    speedMultiplier = 1 - easeIn * 0.4; // å¾ã€…ã«æ¸›é€Ÿ
                    
                } else if (progress <= transitionIn + wanderCore) {
                    // ãƒ•ã‚§ãƒ¼ã‚º2: ãƒ¡ã‚¤ãƒ³ã®è¿·ã„å‹•ä½œï¼ˆè¤‡é›‘ãªæ³¢çŠ¶å‹•ãï¼‰
                    const coreProgress = (progress - transitionIn) / wanderCore;
                    directionBlend = 1;
                    
                    // è¤‡æ•°ã®æ³¢ã‚’é‡ã­ãŸã‚ˆã‚Šè¤‡é›‘ãªè¿·ã„
                    const wave1 = Math.sin(coreProgress * Math.PI * 3) * 0.6;
                    const wave2 = Math.sin(coreProgress * Math.PI * 5 + Math.PI/3) * 0.3;
                    const wave3 = Math.sin(coreProgress * Math.PI * 2 + Math.PI/6) * 0.1;
                    const combinedWave = (wave1 + wave2 + wave3) * 0.5 + 0.5;
                    
                    speedMultiplier = 0.4 + combinedWave * 0.4; // 0.4-0.8ã®ç¯„å›²ã§å¤‰å‹•
                    
                } else {
                    // ãƒ•ã‚§ãƒ¼ã‚º3: è¿·ã„ã‹ã‚‰é€šå¸¸æ–¹å‘ã¸ã®å¾©å¸°
                    const easeOut = (progress - transitionIn - wanderCore) / transitionOut;
                    directionBlend = 1 - Math.pow(easeOut, 1.5); // ease-out
                    speedMultiplier = 0.6 + easeOut * 0.4; // é€šå¸¸é€Ÿåº¦ã«å¾©å¸°
                }
                
                // åŸºæœ¬æ–¹å‘ã¨è¿·ã„æ–¹å‘ã‚’ãƒ–ãƒ¬ãƒ³ãƒ‰
                const originalDirection = this.movementPatterns[this.currentStage]?.direction || { x: 0, z: 1 };
                this.currentDirection.x = originalDirection.x * (1 - directionBlend) + 
                    this.behaviorState.wanderDirection.x * directionBlend;
                this.currentDirection.z = originalDirection.z * (1 - directionBlend) + 
                    this.behaviorState.wanderDirection.z * directionBlend;
                
                // ã‚¹ãƒ ãƒ¼ã‚ºãªé€Ÿåº¦å¤‰åŒ–
                this.speed = this.originalSpeed * speedMultiplier;
            }
            
            // é€šå¸¸è¡Œå‹•ï¼šåŸºæœ¬çš„ãªå‰é€²ï¼ˆå¾®ç´°ãªæºã‚‰ãä»˜ãï¼‰
            executeNormalBehavior() {
                // å…ƒã®æ–¹å‘æ€§ã¨é€Ÿåº¦ã‚’å¾©å…ƒ
                if (this.movementPatterns[this.currentStage]) {
                    const original = this.movementPatterns[this.currentStage];
                    
                    // åŸºæœ¬æ–¹å‘ã‚’è¨­å®š
                    let baseX = original.direction.x;
                    let baseZ = original.direction.z;
                    
                    // æ­©è¡Œã®è‡ªç„¶ãªæºã‚‰ãã‚’è¿½åŠ 
                    const currentTime = Date.now();
                    const walkingRhythm = currentTime * 0.006; // æ­©è¡Œãƒªã‚ºãƒ 
                    const breathingRhythm = currentTime * 0.001; // å‘¼å¸ãƒªã‚ºãƒ 
                    
                    // å·¦å³ã®å¾®ç´°ãªæºã‚Œï¼ˆæ­©è¡Œã«ã‚ˆã‚‹è‡ªç„¶ãªå‹•ãï¼‰
                    const lateralSway = Math.sin(walkingRhythm) * 0.015;
                    const forwardVariation = Math.sin(breathingRhythm) * 0.008;
                    
                    // æ®µéšåˆ¥ã®æºã‚‰ãå¼·åº¦èª¿æ•´
                    const stageMultiplier = this.getStageAgitationLevel();
                    
                    this.currentDirection.x = baseX + lateralSway * stageMultiplier;
                    this.currentDirection.z = baseZ + forwardVariation * stageMultiplier;
                    
                    // é€Ÿåº¦ã«ã‚‚å¾®ç´°ãªå¤‰å‹•ã‚’è¿½åŠ 
                    const speedVariation = 1 + Math.sin(walkingRhythm * 0.7) * 0.05 * stageMultiplier;
                    this.speed = original.speed * speedVariation;
                    this.originalSpeed = original.speed;
                }
            }
            
            // æ®µéšåˆ¥ã®å‹•æºãƒ¬ãƒ™ãƒ«ã‚’å–å¾—
            getStageAgitationLevel() {
                const agitationLevels = {
                    'Ea': 0.8,   // å¤–éƒ¨æ¨©å¨æœŸï¼šã‚„ã‚„ç·Šå¼µ
                    'Eb': 0.9,   
                    'Ec': 1.0,   
                    'EI': 1.5,   // å²è·¯æœŸï¼šé«˜ã„å‹•æº
                    'E-I': 1.8,  // æœ€é«˜ã®è¿·ã„
                    'I-E': 1.6,  
                    'IE': 1.2,   // çµ±åˆæœŸï¼šæ¸›å°‘
                    'Ia': 0.7,   // å†…çš„æ¨©å¨æœŸï¼šå®‰å®š
                    'Ib': 0.5,   
                    'Ic': 0.3    // æœ€ã‚‚å®‰å®š
                };
                return agitationLevels[this.currentStage] || 1.0;
            }
            
            // Ebæ®µéšå°‚ç”¨: è¤‡æ•°æ¨©å¨ã‚’ã‚¹ã‚­ãƒ£ãƒ‹ãƒ³ã‚°ã™ã‚‹å‹•ä½œï¼ˆéå¸¸ã«ã‚†ã£ãã‚Šã—ãŸäººé–“çš„ãªå‹•ãï¼‰
            executeMultiAuthorityScanning(pausedProgress) {
                const config = this.stageConfig;
                const directions = config.authorityDirections;
                
                if (!directions || directions.length === 0) {
                    return 0; // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                }
                
                // ã‚ˆã‚Šäººé–“çš„ãªã‚¹ã‚­ãƒ£ãƒ‹ãƒ³ã‚°è¨­å®š
                const totalScans = Math.min(directions.length, 6); // ã‚ˆã‚Šå¤šãã®æ–¹å‘ã‚¹ã‚­ãƒ£ãƒ³
                const scanningCycles = 0.3; // ã•ã‚‰ã«å°‘ãªã„ã‚µã‚¤ã‚¯ãƒ«ï¼ˆã‚ˆã‚Šã‚†ã£ãã‚Šï¼‰
                const totalProgress = pausedProgress * scanningCycles;
                
                // ç¾åœ¨ã®ã‚¹ã‚­ãƒ£ãƒ³å¯¾è±¡ã‚’æ±ºå®š
                const currentScanIndex = Math.floor(totalProgress * totalScans) % totalScans;
                const scanPhaseProgress = (totalProgress * totalScans) % 1;
                
                // ãƒ©ãƒ³ãƒ€ãƒ ãªè§’åº¦è¨­å®šï¼ˆå·¦å³å‡ç­‰ã«åˆ†æ•£ï¼‰
                const randomSeed = Math.floor(Date.now() / 8000); // 8ç§’ã”ã¨ã«æ–°ã—ã„ãƒ©ãƒ³ãƒ€ãƒ è¨­å®š
                const rng = this.createSeededRandom(randomSeed + currentScanIndex);
                
                // ã‚ˆã‚Šè‡ªç„¶ãªãƒ©ãƒ³ãƒ€ãƒ å·¦å³é¸æŠï¼ˆã‚·ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ï¼‰
                const directionSeed = this.createSeededRandom(randomSeed * 7 + currentScanIndex * 3);
                const isLeft = directionSeed() < 0.5; // çœŸã®ãƒ©ãƒ³ãƒ€ãƒ å·¦å³é¸æŠ
                const baseAngle = isLeft ? -1 : 1; // å·¦ã¯è² ã€å³ã¯æ­£
                
                // E-Iã‚¹ãƒ†ãƒ¼ã‚¸ã¯ã‚ˆã‚Šå¤§ããªå›è»¢è§’åº¦ç¯„å›²ã‚’ä½¿ç”¨
                let randomAngleRange;
                if (this.currentStage === 'E-I') {
                    randomAngleRange = (Math.PI / 4) + (rng() * Math.PI / 2.5); // 45åº¦ã€œ117åº¦ã®ç¯„å›²ï¼ˆã‚ˆã‚Šå¤§ããï¼‰
                } else {
                    randomAngleRange = (Math.PI / 8) + (rng() * Math.PI / 6); // 22.5åº¦ã€œ52.5åº¦ã®ç¯„å›²ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
                }
                
                const targetAngle = baseAngle * randomAngleRange;
                
                // éå¸¸ã«ã‚†ã£ãã‚Šã¨ã—ãŸã‚¹ãƒ ãƒ¼ã‚ºãªç§»è¡Œ
                let easedProgress;
                if (scanPhaseProgress < 0.9) {
                    // å‰ã®è§’åº¦ã‹ã‚‰ç›®æ¨™è§’åº¦ã¸ã®ç§»è¡Œï¼ˆéå¸¸ã«ã‚†ã£ãã‚Šï¼‰
                    const transitionProgress = scanPhaseProgress / 0.9;
                    easedProgress = Math.pow(transitionProgress, 6); // éå¸¸ã«ç·©ã‚„ã‹ãªease-in
                } else {
                    // ç›®æ¨™è§’åº¦ã§ã®æ»åœ¨
                    easedProgress = 1;
                }
                
                // å‰å›ã®è§’åº¦ã‹ã‚‰ç¾åœ¨ã®è§’åº¦ã¸ã®éå¸¸ã«æ»‘ã‚‰ã‹ãªè£œé–“
                const prevAngle = currentScanIndex > 0 ? 
                    this.getPreviousRandomAngle(randomSeed + currentScanIndex - 1) : 0;
                
                const interpolatedAngle = prevAngle + (targetAngle - prevAngle) * easedProgress;
                
                // éå¸¸ã«æ§ãˆã‚ãªä¸å®‰å®šã•
                const nervousness = Math.sin(Date.now() * 0.002) * 0.005; // ã•ã‚‰ã«ç©ã‚„ã‹ãªå‹•ã
                
                return interpolatedAngle + nervousness;
            }
            
            // ã‚·ãƒ¼ãƒ‰ä»˜ããƒ©ãƒ³ãƒ€ãƒ é–¢æ•°ï¼ˆä¸€è²«ã—ãŸç–‘ä¼¼ãƒ©ãƒ³ãƒ€ãƒ ï¼‰
            createSeededRandom(seed) {
                let x = Math.sin(seed) * 10000;
                return function() {
                    x = Math.sin(x) * 10000;
                    return x - Math.floor(x);
                };
            }
            
            // å‰ã®è§’åº¦ã‚’å†è¨ˆç®—ï¼ˆä¸€è²«æ€§ã®ãŸã‚ï¼‰
            getPreviousRandomAngle(seed) {
                const rng = this.createSeededRandom(seed);
                // ã‚ˆã‚Šè‡ªç„¶ãªãƒ©ãƒ³ãƒ€ãƒ å·¦å³é¸æŠï¼ˆã‚·ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ï¼‰
                const directionSeed = this.createSeededRandom(seed * 7);
                const isLeft = directionSeed() < 0.5; // çœŸã®ãƒ©ãƒ³ãƒ€ãƒ å·¦å³é¸æŠ
                const baseAngle = isLeft ? -1 : 1;
                
                // E-Iã‚¹ãƒ†ãƒ¼ã‚¸ã¯ã‚ˆã‚Šå¤§ããªå›è»¢è§’åº¦ç¯„å›²ã‚’ä½¿ç”¨
                let randomAngleRange;
                if (this.currentStage === 'E-I') {
                    randomAngleRange = (Math.PI / 4) + (rng() * Math.PI / 2.5); // 45åº¦ã€œ117åº¦ã®ç¯„å›²ï¼ˆã‚ˆã‚Šå¤§ããï¼‰
                } else {
                    randomAngleRange = (Math.PI / 8) + (rng() * Math.PI / 6); // 22.5åº¦ã€œ52.5åº¦ã®ç¯„å›²ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
                }
                
                return baseAngle * randomAngleRange;
            }
            
            // èª¿æ•´ã•ã‚ŒãŸç§»å‹•ã‚’è¨ˆç®—
            calculateAdjustedMovement() {
                return {
                    direction: { ...this.currentDirection },
                    speed: this.speed
                };
            }
            
            // æ¬¡ã®è¡Œå‹•ã¾ã§ã®é…å»¶æ™‚é–“ã‚’è¨ˆç®—
            calculateNextBehaviorDelay() {
                if (!this.stageConfig) {
                    return 3000; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
                }
                const baseDelay = this.stageConfig.behaviorTransition || 3000;
                const variation = baseDelay * 0.3; // 30%ã®å¤‰å‹•
                return baseDelay + (Math.random() - 0.5) * variation;
            }
            
            // ç¯„å›²å†…ã®ãƒ©ãƒ³ãƒ€ãƒ æ•°å€¤ã‚’ç”Ÿæˆ
            randomBetween(min, max) {
                return min + Math.random() * (max - min);
            }
            
            // åœ°é¢ã‚·ã‚¹ãƒ†ãƒ ã®æœ‰åŠ¹åŒ–/ç„¡åŠ¹åŒ–
            setActive(active) {
                this.isActive = active;
                this.groundDots.forEach(dot => {
                    dot.visible = active;
                });
                console.log(`[GroundSystem] ${active ? 'Activated' : 'Deactivated'}`);
            }
            
            // åœ°é¢ãƒ‰ãƒƒãƒˆã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            clearGroundDots() {
                this.groundDots.forEach(dot => {
                    this.scene.remove(dot);
                    if (dot.geometry) dot.geometry.dispose();
                    if (dot.material) dot.material.dispose();
                });
                this.groundDots = [];
            }
            
            // ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            cleanup() {
                this.clearGroundDots();
                this.isActive = false;
                console.log('[GroundSystem] Cleanup completed');
            }
        }
        
        // èª¬æ˜è¡¨ç¤ºã‚·ã‚¹ãƒ†ãƒ  - å„è¦ç´ ã®æ„å‘³ã‚’ç°¡æ½”ã«è¡¨ç¤º
        class ExplanationDisplaySystem {
            constructor(container) {
                this.container = container;
                this.explanationPanel = null;
                this.isVisible = false;
                this.currentExplanations = new Map();
            }
            
            createExplanationPanel() {
                // èª¬æ˜ãƒ‘ãƒãƒ«ã®HTMLè¦ç´ ã‚’ä½œæˆ
                this.explanationPanel = document.createElement('div');
                this.explanationPanel.id = 'explanation-panel';
                this.explanationPanel.style.cssText = `
                    position: absolute;
                    top: 20px;
                    right: 20px;
                    width: 280px;
                    background: rgba(0, 0, 0, 0.85);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 12px;
                    padding: 16px;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                    font-size: 13px;
                    line-height: 1.4;
                    color: rgba(255, 255, 255, 0.9);
                    backdrop-filter: blur(10px);
                    -webkit-backdrop-filter: blur(10px);
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                    opacity: 0;
                    transform: translateY(-10px);
                    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                    pointer-events: none;
                    z-index: 1000;
                `;
                
                // ãƒ˜ãƒƒãƒ€ãƒ¼éƒ¨åˆ†ï¼ˆã‚¿ã‚¤ãƒˆãƒ« + é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ï¼‰
                const headerDiv = document.createElement('div');
                headerDiv.style.cssText = `
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 12px;
                    padding-bottom: 8px;
                    border-bottom: 1px solid rgba(135, 206, 235, 0.3);
                `;
                
                // ã‚¿ã‚¤ãƒˆãƒ«éƒ¨åˆ†
                const titleDiv = document.createElement('div');
                titleDiv.style.cssText = `
                    font-size: 14px;
                    font-weight: 600;
                    color: #87ceeb;
                `;
                titleDiv.textContent = 'è¦–è¦šè¦ç´ ã®èª¬æ˜';
                
                // é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³
                const closeButton = document.createElement('button');
                closeButton.style.cssText = `
                    background: none;
                    border: none;
                    color: rgba(255, 255, 255, 0.7);
                    font-size: 16px;
                    cursor: pointer;
                    padding: 2px 6px;
                    border-radius: 4px;
                    transition: all 0.2s ease;
                    line-height: 1;
                `;
                closeButton.innerHTML = 'Ã—';
                closeButton.title = 'èª¬æ˜ã‚’é–‰ã˜ã‚‹';
                
                // é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã®ãƒ›ãƒãƒ¼åŠ¹æœ
                closeButton.addEventListener('mouseenter', () => {
                    closeButton.style.background = 'rgba(255, 255, 255, 0.1)';
                    closeButton.style.color = 'rgba(255, 255, 255, 1)';
                });
                closeButton.addEventListener('mouseleave', () => {
                    closeButton.style.background = 'none';
                    closeButton.style.color = 'rgba(255, 255, 255, 0.7)';
                });
                
                // é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
                closeButton.addEventListener('click', () => {
                    this.hidePanel();
                });
                
                headerDiv.appendChild(titleDiv);
                headerDiv.appendChild(closeButton);
                
                // èª¬æ˜ãƒªã‚¹ãƒˆéƒ¨åˆ†
                const explanationList = document.createElement('div');
                explanationList.id = 'explanation-list';
                explanationList.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                `;
                
                this.explanationPanel.appendChild(headerDiv);
                this.explanationPanel.appendChild(explanationList);
                this.container.appendChild(this.explanationPanel);
            }
            
            // ã‚¹ãƒ†ãƒ¼ã‚¸ã«å¿œã˜ãŸèª¬æ˜ã‚’æ›´æ–°ï¼ˆæ‰‹å‹•åˆ¶å¾¡ã®ã¿ï¼‰
            updateStageExplanations(stage) {
                if (!this.explanationPanel) {
                    this.createExplanationPanel();
                }
                
                this.clearExplanations();
                
                // ã‚¹ãƒ†ãƒ¼ã‚¸ã«å¿œã˜ãŸèª¬æ˜ã‚’å–å¾—
                const explanations = this.getStageExplanations(stage);
                
                // èª¬æ˜ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¿½åŠ 
                const explanationList = this.explanationPanel.querySelector('#explanation-list');
                explanations.forEach(item => {
                    const explanationItem = this.createExplanationItem(item);
                    explanationList.appendChild(explanationItem);
                    this.currentExplanations.set(item.id, explanationItem);
                });
                
                // ãƒ‘ãƒãƒ«ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿æ›´æ–°ï¼ˆè‡ªå‹•è¡¨ç¤ºã¯ã—ãªã„ï¼‰
            }
            
            // ã‚¹ãƒ†ãƒ¼ã‚¸åˆ¥ã®èª¬æ˜å†…å®¹ã‚’å®šç¾©
            getStageExplanations(stage) {
                const stageNum = this.getStageNumber(stage);
                const baseExplanations = [
                    { id: 'core', icon: 'â—', text: 'ä¸­å¿ƒã‚³ã‚¢: ã‚»ãƒ«ãƒ•', color: '#87ceeb' }
                ];
                
                if (stageNum <= 3) {
                    // EAæ®µéš: åŸºæœ¬çš„ãªè¦ç´ ã®ã¿
                    return [
                        ...baseExplanations,
                        { id: 'particles', icon: 'âœ¦', text: 'ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«: å†…é¢ã®çµŒé¨“ãƒ»æ°—ã¥ã', color: '#98fb98' },
                        { id: 'lightning', icon: 'âš¡', text: 'å…‰ã®ç·š: è‡ªå·±ã®å†…é¢ã‚’è¦‹ã¤ã‚ã‚‹å‹•ã', color: '#ffd700' },
                        { id: 'radar', icon: 'ğŸ“¡', text: 'ãƒ¬ãƒ¼ãƒ€ãƒ¼: æ–°ã—ã„è¦–ç‚¹ãƒ»çŸ¥è­˜ã®æ¢ç´¢', color: '#ff69b4' },
                        { id: 'connections', icon: 'ğŸ’¬', text: 'ä¼é”ä¿¡å·: ä»–è€…ã¨ã®é–¢ä¿‚ãƒ»å¯¾è©±', color: '#40e0d0' }
                    ];
                } else if (stageNum <= 7) {
                    // å²è·¯æ®µéš: æ¢ç´¢è¦ç´ ã‚’è¿½åŠ 
                    return [
                        ...baseExplanations,
                        { id: 'particles', icon: 'âœ¦', text: 'ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«: å†…é¢ã®çµŒé¨“ãƒ»æ°—ã¥ã', color: '#98fb98' },
                        { id: 'lightning', icon: 'âš¡', text: 'å…‰ã®ç·š: è‡ªå·±ã®å†…é¢ã‚’è¦‹ã¤ã‚ã‚‹å‹•ã', color: '#ffd700' },
                        { id: 'radar', icon: 'ğŸ“¡', text: 'ãƒ¬ãƒ¼ãƒ€ãƒ¼: æ–°ã—ã„è¦–ç‚¹ãƒ»çŸ¥è­˜ã®æ¢ç´¢', color: '#ff69b4' },
                        { id: 'connections', icon: 'ğŸ’¬', text: 'ä¼é”ä¿¡å·: ä»–è€…ã¨ã®é–¢ä¿‚ãƒ»å¯¾è©±', color: '#40e0d0' }
                    ];
                } else {
                    // IAæ®µéš: é–¢ä¿‚æ€§è¦ç´ ã‚‚å«ã‚€
                    return [
                        ...baseExplanations,
                        { id: 'particles', icon: 'âœ¦', text: 'ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«: å†…é¢ã®çµŒé¨“ãƒ»æ°—ã¥ã', color: '#98fb98' },
                        { id: 'lightning', icon: 'âš¡', text: 'å…‰ã®ç·š: è‡ªå·±ã®å†…é¢ã‚’è¦‹ã¤ã‚ã‚‹å‹•ã', color: '#ffd700' },
                        { id: 'radar', icon: 'ğŸ“¡', text: 'ãƒ¬ãƒ¼ãƒ€ãƒ¼: æ–°ã—ã„è¦–ç‚¹ãƒ»çŸ¥è­˜ã®æ¢ç´¢', color: '#ff69b4' },
                        { id: 'connections', icon: 'ğŸ’¬', text: 'ä¼é”ä¿¡å·: ä»–è€…ã¨ã®é–¢ä¿‚ãƒ»å¯¾è©±', color: '#40e0d0' }
                    ];
                }
            }
            
            // èª¬æ˜ã‚¢ã‚¤ãƒ†ãƒ ã®HTMLè¦ç´ ã‚’ä½œæˆ
            createExplanationItem(item) {
                const itemDiv = document.createElement('div');
                itemDiv.style.cssText = `
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    padding: 6px 0;
                    border-radius: 6px;
                    transition: all 0.2s ease;
                `;
                
                const iconSpan = document.createElement('span');
                iconSpan.style.cssText = `
                    font-size: 14px;
                    width: 16px;
                    text-align: center;
                    color: ${item.color};
                `;
                iconSpan.textContent = item.icon;
                
                const textSpan = document.createElement('span');
                textSpan.style.cssText = `
                    flex: 1;
                    font-size: 13px;
                    color: rgba(255, 255, 255, 0.85);
                `;
                textSpan.textContent = item.text;
                
                itemDiv.appendChild(iconSpan);
                itemDiv.appendChild(textSpan);
                
                return itemDiv;
            }
            
            // ãƒ‘ãƒãƒ«ã‚’è¡¨ç¤º
            showPanel() {
                if (!this.explanationPanel) return;
                
                this.isVisible = true;
                this.explanationPanel.style.opacity = '1';
                this.explanationPanel.style.transform = 'translateY(0)';
                this.explanationPanel.style.pointerEvents = 'auto';
            }
            
            // ãƒ‘ãƒãƒ«ã‚’éè¡¨ç¤º
            hidePanel() {
                if (!this.explanationPanel) return;
                
                this.isVisible = false;
                this.explanationPanel.style.opacity = '0';
                this.explanationPanel.style.transform = 'translateY(-10px)';
                this.explanationPanel.style.pointerEvents = 'none';
            }
            
            // èª¬æ˜ã‚’ã‚¯ãƒªã‚¢
            clearExplanations() {
                this.currentExplanations.clear();
                if (this.explanationPanel) {
                    const explanationList = this.explanationPanel.querySelector('#explanation-list');
                    if (explanationList) {
                        explanationList.innerHTML = '';
                    }
                }
            }
            
            // ã‚¹ãƒ†ãƒ¼ã‚¸æ–‡å­—åˆ—ã‚’æ•°å€¤ã«å¤‰æ›
            getStageNumber(stage) {
                const stageMap = {
                    'Ea': 1, 'Eb': 2, 'Ec': 3,
                    'EI': 4, 'E-I': 5,
                    'I-E': 6, 'IE': 7,
                    'Ia': 8, 'Ib': 9, 'Ic': 10
                };
                return stageMap[stage] || 1;
            }
            
            // ãƒ‘ãƒãƒ«ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆï¼ˆæ‰‹å‹•åˆ¶å¾¡ã®ã¿ï¼‰
            toggle(currentStage = null) {
                if (this.isVisible) {
                    this.hidePanel();
                } else {
                    // ãƒ‘ãƒãƒ«ã‚’è¡¨ç¤ºå‰ã«ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã®èª¬æ˜ã‚’æ›´æ–°
                    if (currentStage) {
                        this.updateStageExplanations(currentStage);
                    }
                    this.showPanel();
                }
            }
            
            // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            cleanup() {
                if (this.explanationPanel && this.explanationPanel.parentNode) {
                    this.explanationPanel.parentNode.removeChild(this.explanationPanel);
                }
                this.explanationPanel = null;
                this.currentExplanations.clear();
            }
        }
        
        // æ¬¡å…ƒ1: å¯¾è‡ªé–¢ä¿‚æ¬¡å…ƒ - æµã‚Œæ˜Ÿã‚¤ãƒ¡ãƒ¼ã‚¸å…‰ç·šã‚·ã‚¹ãƒ†ãƒ 
        class LightningDimensionSystem {
            constructor(particles, scene) {
                this.particles = particles;
                this.scene = scene;
                this.activeShootingStars = []; // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªæµã‚Œæ˜Ÿ
                this.trailSegments = []; // æ®‹åƒã‚»ã‚°ãƒ¡ãƒ³ãƒˆ
                this.lastUpdate = 0;
                this.maxConcurrentStars = 2; // åŒæ™‚æµã‚Œæ˜Ÿæ•°
                this.tailLength = 0.8; // æµã‚Œæ˜Ÿã®å°»å°¾ã®é•·ã•
                this.trailFadeTime = 1500; // æ®‹åƒã®ãƒ•ã‚§ãƒ¼ãƒ‰æ™‚é–“ï¼ˆmsï¼‰
                this.maxTrailLifetime = 2500; // æ®‹åƒã®æœ€å¤§å¯¿å‘½ï¼ˆå¼·åˆ¶å‰Šé™¤ç”¨ï¼‰
            }
            
            // ç›´ç·šãƒ‘ã‚¹ç”Ÿæˆï¼ˆã‚®ã‚¶ã‚®ã‚¶ãªã—ï¼‰
            createStraightPath(startParticle, endParticle) {
                const start = startParticle.position.clone();
                const end = endParticle.position.clone();
                return [start, end];
            }
            
            // waypointsï¼ˆçµŒç”±ç‚¹ï¼‰ã®æœ‰åŠ¹æ€§ã‚’æ¤œè¨¼
            validateWaypoints(star) {
                try {
                    if (!star.waypoints || star.waypoints.length < 2) {
                        console.warn('[LightningSystem] Invalid waypoints: insufficient points');
                        return false;
                    }
                    
                    return star.waypoints.every((particle, index) => {
                        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åŸºæœ¬çš„ãªå­˜åœ¨ãƒã‚§ãƒƒã‚¯
                        if (!particle || !particle.position) {
                            console.warn(`[LightningSystem] Invalid particle at waypoint ${index}: missing position`);
                            return false;
                        }
                        
                        // å¯è¦–æ€§ãƒã‚§ãƒƒã‚¯
                        if (!particle.visible) {
                            console.warn(`[LightningSystem] Particle at waypoint ${index} became invisible`);
                            return false;
                        }
                        
                        // ã‚·ãƒ¼ãƒ³ã‹ã‚‰é™¤å»ã•ã‚Œã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
                        if (!particle.parent) {
                            console.warn(`[LightningSystem] Particle at waypoint ${index} was removed from scene`);
                            return false;
                        }
                        
                        // ç•°å¸¸ãªä½ç½®å¤‰æ›´ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆåŸç‚¹ä»˜è¿‘ã¸ã®å¼·åˆ¶ç§»å‹•ï¼‰
                        const distanceFromOrigin = particle.position.length();
                        if (distanceFromOrigin < 0.1) {
                            console.warn(`[LightningSystem] Particle at waypoint ${index} moved to origin (distance: ${distanceFromOrigin})`);
                            return false;
                        }
                        
                        return true;
                    });
                } catch (error) {
                    console.error('[LightningSystem] Error validating waypoints:', error);
                    return false;
                }
            }
            
            // æµã‚Œæ˜Ÿã‚¯ãƒ©ã‚¹ï¼ˆã‚¤ãƒ¼ã‚ºã‚¤ãƒ³/ã‚¢ã‚¦ãƒˆã¨æ®‹åƒåŠ¹æœä»˜ãï¼‰
            createShootingStar(waypoints, stageIntensity) {
                const star = {
                    waypoints: waypoints,
                    currentSegment: 0, // ç¾åœ¨ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆï¼ˆAâ†’B, Bâ†’C, etc.ï¼‰
                    progress: 0, // ç¾åœ¨ã‚»ã‚°ãƒ¡ãƒ³ãƒˆå†…ã®é€²è¡Œåº¦ (0-1)
                    globalProgress: 0, // å…¨ä½“ã®é€²è¡Œåº¦ (0-1)
                    baseSpeed: stageIntensity.speed, // åŸºæœ¬ç§»å‹•é€Ÿåº¦
                    currentSpeed: 0, // ç¾åœ¨ã®é€Ÿåº¦ï¼ˆã‚¤ãƒ¼ã‚ºç”¨ï¼‰
                    tailLength: this.tailLength, // æµã‚Œæ˜Ÿã®å°»å°¾ã®é•·ã•
                    color: stageIntensity.colors[Math.floor(Math.random() * stageIntensity.colors.length)],
                    opacity: stageIntensity.opacity,
                    creationTime: Date.now(),
                    duration: stageIntensity.duration,
                    mainLine: null, // ãƒ¡ã‚¤ãƒ³ã®æµã‚Œæ˜Ÿãƒ©ã‚¤ãƒ³
                    totalDistance: 0, // ç·è·é›¢
                    easingType: stageIntensity.easingType || 'easeInOut' // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã‚¿ã‚¤ãƒ—
                };
                
                // ç·è·é›¢ã‚’è¨ˆç®—
                star.totalDistance = this.getTotalRouteLength(waypoints);
                
                return star;
            }
            
            // çµŒç”±ç‚¹ã‚’é¸æŠï¼ˆTSPæœ€é©åŒ–ç‰ˆï¼‰
            selectWaypoints(availableParticles, count) {
                const waypoints = [];
                const usedIndices = new Set();
                
                // ãƒ©ãƒ³ãƒ€ãƒ ã«çµŒç”±ç‚¹ã‚’é¸æŠ
                while (waypoints.length < count && waypoints.length < availableParticles.length) {
                    const randomIndex = Math.floor(Math.random() * availableParticles.length);
                    if (!usedIndices.has(randomIndex)) {
                        waypoints.push(availableParticles[randomIndex]);
                        usedIndices.add(randomIndex);
                    }
                }
                
                // è·é›¢æœ€é©åŒ–
                if (waypoints.length > 1) {
                    const optimized = [waypoints[0]];
                    const remaining = waypoints.slice(1);
                    
                    while (remaining.length > 0) {
                        const current = optimized[optimized.length - 1];
                        let nearestIndex = 0;
                        let nearestDistance = current.position.distanceTo(remaining[0].position);
                        
                        for (let i = 1; i < remaining.length; i++) {
                            const distance = current.position.distanceTo(remaining[i].position);
                            if (distance < nearestDistance) {
                                nearestDistance = distance;
                                nearestIndex = i;
                            }
                        }
                        
                        optimized.push(remaining[nearestIndex]);
                        remaining.splice(nearestIndex, 1);
                    }
                    
                    return optimized;
                }
                
                return waypoints;
            }
            
            createShootingStars(stage) {
                const stageIntensity = this.getLightningIntensity(stage);
                const availableParticles = this.particles.filter(p => p.visible);
                
                // ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›
                console.log(`[ShootingStar] Stage: ${stage}, Particles: ${availableParticles.length}, Frequency: ${stageIntensity.frequency}ms`);
                
                if (availableParticles.length < 2) {
                    console.log('[ShootingStar] Not enough visible particles for shooting stars');
                    return;
                }
                
                // æ–°ã—ã„æµã‚Œæ˜Ÿã‚’ç”Ÿæˆ
                const starCount = Math.min(stageIntensity.maxCount, this.maxConcurrentStars);
                
                for (let i = 0; i < starCount; i++) {
                    const waypoints = this.selectWaypoints(availableParticles, stageIntensity.waypointCount);
                    if (waypoints.length >= 2) {
                        const star = this.createShootingStar(waypoints, stageIntensity);
                        this.activeShootingStars.push(star);
                    }
                }
            }
            
            getLightningIntensity(stageNumber) {
                if (stageNumber <= 3) {
                    // EAæ®µéš: ç©ã‚„ã‹ãªæµã‚Œæ˜Ÿï¼ˆãƒ‘ã‚¹ãƒ†ãƒ«èª¿ã®å˜è‰²ï¼‰
                    return {
                        maxCount: 1,
                        colors: [0x87ceeb, 0x98fb98, 0xffd1dc], // ã‚¹ã‚«ã‚¤ãƒ–ãƒ«ãƒ¼ã€ãƒšãƒ¼ãƒ«ã‚°ãƒªãƒ¼ãƒ³ã€ãƒ”ãƒ³ã‚¯
                        opacity: 0.8,
                        duration: 3000, // æµã‚Œæ˜Ÿã®å¯¿å‘½
                        frequency: 2000, // ç”Ÿæˆé »åº¦
                        waypointCount: 2, // 2ç‚¹é–“ç§»å‹•ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãªæµã‚Œæ˜Ÿï¼‰
                        speed: 0.6, // åŸºæœ¬ç§»å‹•é€Ÿåº¦ï¼ˆç·©ã‚„ã‹ã«å¤‰æ›´ï¼‰
                        easingType: 'easeInOut' // ã‚¹ãƒ ãƒ¼ã‚ºãªã‚¤ãƒ¼ã‚¸ãƒ³ã‚°
                    };
                } else if (stageNumber <= 7) {
                    // å²è·¯æ®µéš: æ´»ç™ºãªæµã‚Œæ˜Ÿï¼ˆæ˜ã‚‹ã„å¤šè‰²ï¼‰
                    return {
                        maxCount: 2,
                        colors: [0x87ceeb, 0x98fb98, 0xffd700, 0xff69b4, 0x40e0d0], // ã‚¹ã‚«ã‚¤ãƒ–ãƒ«ãƒ¼ã€ãƒ©ã‚¤ãƒˆã‚°ãƒªãƒ¼ãƒ³ã€ã‚´ãƒ¼ãƒ«ãƒ‰ã€ãƒ›ãƒƒãƒˆãƒ”ãƒ³ã‚¯ã€ã‚¿ãƒ¼ã‚³ã‚¤ã‚º
                        opacity: 0.85,
                        duration: 2500,
                        frequency: 1200,
                        waypointCount: 3, // 3ç‚¹çµŒç”±
                        speed: 0.6, // ã‚„ã‚„é«˜é€Ÿï¼ˆç·©ã‚„ã‹ã«å¤‰æ›´ï¼‰
                        easingType: 'easeInOut'
                    };
                } else {
                    // IAæ®µéš: çµ±åˆçš„ãªæµã‚Œæ˜Ÿï¼ˆè™¹è‰²ã‚¹ãƒšã‚¯ãƒˆãƒ©ãƒ ï¼‰
                    return {
                        maxCount: 2,
                        colors: [0xff69b4, 0x40e0d0, 0x98fb98, 0xffd700, 0xff7f50, 0xda70d6, 0x87ceeb], // è™¹è‰²ãƒ‘ãƒ¬ãƒƒãƒˆ
                        opacity: 0.9,
                        duration: 2000,
                        frequency: 800,
                        waypointCount: 4, // 4ç‚¹çµŒç”±
                        speed: 0.6, // é«˜é€Ÿï¼ˆç·©ã‚„ã‹ã«å¤‰æ›´ï¼‰
                        easingType: 'easeInOut'
                    };
                }
            }
            
            // æµã‚Œæ˜Ÿã®ç§»å‹•ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
            updateShootingStars(deltaTime) {
                this.activeShootingStars = this.activeShootingStars.filter(star => {
                    // Phase 2: waypointæ¤œè¨¼ã«ã‚ˆã‚‹æ—©æœŸçµ‚äº†
                    if (!this.validateWaypoints(star)) {
                        console.log('[LightningSystem] Terminating shooting star due to invalid waypoints');
                        this.cleanupShootingStar(star);
                        return false;
                    }
                    
                    const age = Date.now() - star.creationTime;
                    const normalizedAge = age / star.duration;
                    
                    // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã‚’é©ç”¨
                    const easedProgress = this.applyEasing(normalizedAge, star.easingType);
                    star.globalProgress = Math.min(easedProgress, 1.0);
                    
                    // ç¾åœ¨ã®é€Ÿåº¦ã‚’ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã«åŸºã¥ã„ã¦è¨ˆç®—
                    star.currentSpeed = this.calculateSpeedFromEasing(normalizedAge, star.easingType, star.baseSpeed);
                    
                    // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã¨ãƒ­ãƒ¼ã‚«ãƒ«é€²è¡Œåº¦ã®æ›´æ–°
                    this.updateSegmentProgress(star);
                    
                    // å¯¿å‘½ãƒã‚§ãƒƒã‚¯
                    if (normalizedAge >= 1.0) {
                        // æ®‹åƒã‚’ä½œæˆã—ã¦ã‹ã‚‰æµã‚Œæ˜Ÿã‚’é™¤å»
                        this.createTrailSegment(star);
                        this.cleanupShootingStar(star);
                        return false;
                    }
                    
                    // æµã‚Œæ˜Ÿã‚’æç”»
                    this.renderShootingStar(star);
                    
                    return true;
                });
                
                // æ®‹åƒã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®æ›´æ–°
                this.updateTrailSegments();
            }
            
            // æµã‚Œæ˜Ÿã®å…‰ç·šæç”»ï¼ˆã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã¨æ®‹åƒåŠ¹æœä»˜ãï¼‰
            renderShootingStar(star) {
                // æ—¢å­˜ã®ãƒ©ã‚¤ãƒ³ã‚’ç¢ºå®Ÿã«å‰Šé™¤
                if (star.mainLine) {
                    if (star.mainLine.parent) {
                        star.mainLine.parent.remove(star.mainLine);
                    } else {
                        this.scene.remove(star.mainLine);
                    }
                    
                    // ãƒªã‚½ãƒ¼ã‚¹ã‚’ç ´æ£„
                    if (star.mainLine.geometry) {
                        star.mainLine.geometry.dispose();
                    }
                    if (star.mainLine.material) {
                        if (star.mainLine.material.uniforms) {
                            Object.values(star.mainLine.material.uniforms).forEach(uniform => {
                                if (uniform.value && uniform.value.dispose) {
                                    uniform.value.dispose();
                                }
                            });
                        }
                        star.mainLine.material.dispose();
                    }
                    star.mainLine = null;
                }
                
                const currentWaypoint = star.waypoints[star.currentSegment];
                const nextWaypoint = star.waypoints[star.currentSegment + 1];
                
                if (!currentWaypoint || !nextWaypoint) return;
                
                // ç¾åœ¨ä½ç½®ã®è¨ˆç®—
                const currentPos = currentWaypoint.position.clone().lerp(
                    nextWaypoint.position, 
                    star.progress
                );
                
                // æµã‚Œæ˜Ÿã®å°»å°¾ä½ç½®ã®è¨ˆç®—ï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«é€²è¡Œåº¦ãƒ™ãƒ¼ã‚¹ï¼‰
                const tailGlobalProgress = Math.max(0, star.globalProgress - (star.tailLength / star.totalDistance));
                const tailPos = this.getPositionAtGlobalProgress(star.waypoints, tailGlobalProgress);
                
                if (!tailPos) return;
                
                // æµã‚Œæ˜Ÿã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æè³ªã‚’ä½œæˆ
                const points = [tailPos, currentPos];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                
                // ã‚¢ãƒ«ãƒ•ã‚¡å±æ€§ã‚’è¿½åŠ ï¼ˆå°»å°¾=0.0, å…ˆé ­=1.0ï¼‰
                const alphas = new Float32Array([0.0, 1.0]);
                geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
                
                // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ã§ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœ
                const material = this.createShootingStarMaterial(star);
                
                star.mainLine = new THREE.Line(geometry, material);
                this.scene.add(star.mainLine);
            }
            
            // é€²è¡Œåº¦ã‹ã‚‰åº§æ¨™ã‚’å–å¾—
            getPositionAtProgress(waypoints, totalProgress) {
                if (totalProgress <= 0) return waypoints[0].position.clone();
                
                const segmentIndex = Math.floor(totalProgress);
                const segmentProgress = totalProgress - segmentIndex;
                
                if (segmentIndex >= waypoints.length - 1) {
                    return waypoints[waypoints.length - 1].position.clone();
                }
                
                return waypoints[segmentIndex].position.clone().lerp(
                    waypoints[segmentIndex + 1].position,
                    segmentProgress
                );
            }
            
            // ãƒ«ãƒ¼ãƒˆã®ç·é•·ã‚’è¨ˆç®—
            getTotalRouteLength(waypoints) {
                let totalLength = 0;
                for (let i = 0; i < waypoints.length - 1; i++) {
                    totalLength += waypoints[i].position.distanceTo(waypoints[i + 1].position);
                }
                return totalLength;
            }
            
            // æµã‚Œæ˜Ÿç”¨ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ†ãƒªã‚¢ãƒ«ä½œæˆ
            createShootingStarMaterial(star) {
                const vertexShader = `
                    attribute float alpha;
                    varying float vAlpha;
                    varying vec3 vPosition;
                    
                    void main() {
                        vAlpha = alpha;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;
                
                const fragmentShader = `
                    uniform vec3 color;
                    uniform float opacity;
                    uniform float time;
                    varying float vAlpha;
                    varying vec3 vPosition;
                    
                    void main() {
                        // å…ˆé ­ã‹ã‚‰å°»å°¾ã¸ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                        float gradient = 1.0 - vAlpha; // 0=å°»å°¾, 1=å…ˆé ­
                        
                        // è¼ãåŠ¹æœ
                        float glow = pow(gradient, 0.5) * (0.8 + 0.2 * sin(time * 0.01));
                        
                        gl_FragColor = vec4(color, opacity * glow);
                    }
                `;
                
                const material = new THREE.ShaderMaterial({
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    uniforms: {
                        color: { value: new THREE.Color(star.color) },
                        opacity: { value: star.opacity },
                        time: { value: Date.now() }
                    },
                    transparent: true,
                    blending: THREE.AdditiveBlending // ç¾ã—ã„ç™ºå…‰åŠ¹æœ
                });
                
                return material;
            }
            
            // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°
            applyEasing(t, type) {
                switch (type) {
                    case 'easeIn':
                        return t * t * t; // ã‚¹ãƒ­ãƒ¼ã‚¹ã‚¿ãƒ¼ãƒˆ
                    case 'easeOut':
                        return 1 - Math.pow(1 - t, 3); // ã‚¹ãƒ­ãƒ¼ã‚¨ãƒ³ãƒ‰
                    case 'easeInOut':
                    default:
                        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; // æµã‚Œæ˜Ÿã‚‰ã—ã„å‹•ã
                }
            }
            
            // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã‹ã‚‰ç¾åœ¨ã®é€Ÿåº¦ã‚’è¨ˆç®—
            calculateSpeedFromEasing(t, type, baseSpeed) {
                const dt = 0.001; // å¾®å°å¤‰åŒ–
                const current = this.applyEasing(t, type);
                const next = this.applyEasing(Math.min(t + dt, 1.0), type);
                return (next - current) / dt * baseSpeed;
            }
            
            // ã‚°ãƒ­ãƒ¼ãƒãƒ«é€²è¡Œåº¦ã‹ã‚‰ã‚»ã‚°ãƒ¡ãƒ³ãƒˆé€²è¡Œåº¦ã‚’æ›´æ–°
            updateSegmentProgress(star) {
                const totalSegments = star.waypoints.length - 1;
                const globalSegmentProgress = star.globalProgress * totalSegments;
                
                star.currentSegment = Math.min(Math.floor(globalSegmentProgress), totalSegments - 1);
                star.progress = globalSegmentProgress - star.currentSegment;
                
                // æœ€çµ‚ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã§ã®èª¿æ•´
                if (star.currentSegment >= totalSegments - 1) {
                    star.currentSegment = totalSegments - 1;
                    star.progress = Math.min(star.progress, 1.0);
                }
            }
            
            // ã‚°ãƒ­ãƒ¼ãƒãƒ«é€²è¡Œåº¦ã‹ã‚‰ä½ç½®ã‚’å–å¾—
            getPositionAtGlobalProgress(waypoints, globalProgress) {
                if (globalProgress <= 0) return waypoints[0].position.clone();
                if (globalProgress >= 1) return waypoints[waypoints.length - 1].position.clone();
                
                const totalSegments = waypoints.length - 1;
                const segmentProgress = globalProgress * totalSegments;
                const segmentIndex = Math.floor(segmentProgress);
                const localProgress = segmentProgress - segmentIndex;
                
                if (segmentIndex >= totalSegments - 1) {
                    return waypoints[waypoints.length - 1].position.clone();
                }
                
                return waypoints[segmentIndex].position.clone().lerp(
                    waypoints[segmentIndex + 1].position,
                    localProgress
                );
            }
            
            // æ®‹åƒã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’ä½œæˆ
            createTrailSegment(star) {
                if (!star.mainLine) return;
                
                const trailSegment = {
                    line: star.mainLine.clone(),
                    creationTime: Date.now(),
                    originalOpacity: star.opacity,
                    color: star.color
                };
                
                // ã‚¯ãƒ­ãƒ¼ãƒ³ã—ãŸãƒ©ã‚¤ãƒ³ã®ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’æ·±ãã‚³ãƒ”ãƒ¼
                const originalMaterial = star.mainLine.material;
                if (originalMaterial.isShaderMaterial) {
                    // ShaderMaterialã®å ´åˆã¯å®Œå…¨ã«ã‚¯ãƒ­ãƒ¼ãƒ³
                    trailSegment.line.material = originalMaterial.clone();
                    // uniformsã‚‚å€‹åˆ¥ã«ã‚³ãƒ”ãƒ¼
                    if (originalMaterial.uniforms) {
                        Object.keys(originalMaterial.uniforms).forEach(key => {
                            if (originalMaterial.uniforms[key].value !== undefined) {
                                trailSegment.line.material.uniforms[key] = {
                                    value: originalMaterial.uniforms[key].value
                                };
                            }
                        });
                    }
                } else {
                    // é€šå¸¸ã®ãƒãƒ†ãƒªã‚¢ãƒ«ã®å ´åˆ
                    trailSegment.line.material = originalMaterial.clone();
                }
                
                this.scene.add(trailSegment.line);
                this.trailSegments.push(trailSegment);
                
                // å…ƒã®ãƒ©ã‚¤ãƒ³ã¯ã‚·ãƒ¼ãƒ³ã‹ã‚‰é™¤å»ã—ãªã„ï¼ˆã‚¯ãƒ­ãƒ¼ãƒ³ã—ãŸã®ã§åˆ¥ç‰©ï¼‰
                star.mainLine = null;
            }
            
            // æ®‹åƒã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®æ›´æ–°ï¼ˆãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆï¼‰
            updateTrailSegments() {
                const currentTime = Date.now();
                
                this.trailSegments = this.trailSegments.filter(segment => {
                    try {
                        const age = currentTime - segment.creationTime;
                        const fadeProgress = age / this.trailFadeTime;
                        
                        // Phase 3: æœ€å¤§å¯¿å‘½ã«ã‚ˆã‚‹å¼·åˆ¶å‰Šé™¤
                        if (age >= this.maxTrailLifetime) {
                            console.log('[LightningSystem] Force removing trail segment due to max lifetime exceeded');
                            this.forceRemoveTrailSegment(segment);
                            return false;
                        }
                        
                        if (fadeProgress >= 1.0) {
                            // ãƒ•ã‚§ãƒ¼ãƒ‰å®Œäº†ã€ç¢ºå®Ÿã«é™¤å»
                            this.forceRemoveTrailSegment(segment);
                            return false;
                        }
                        
                        // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆåŠ¹æœï¼ˆä¸¡æ–¹ã®ãƒãƒ†ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ—ã«å¯¾å¿œï¼‰
                        const fadedOpacity = segment.originalOpacity * (1 - fadeProgress);
                        const material = segment.line.material;
                        
                        if (material && material.uniforms && material.uniforms.opacity) {
                            // ShaderMaterialã®å ´åˆ
                            material.uniforms.opacity.value = fadedOpacity;
                        } else if (material && material.opacity !== undefined) {
                            // BasicMaterialãªã©ã®å ´åˆ
                            material.opacity = fadedOpacity;
                        }
                        
                        return true;
                    } catch (error) {
                        console.error('[LightningSystem] Error updating trail segment:', error);
                        this.forceRemoveTrailSegment(segment);
                        return false;
                    }
                });
            }
            
            // Phase 3: æ®‹åƒã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®å¼·åˆ¶å‰Šé™¤ï¼ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä»˜ãï¼‰
            forceRemoveTrailSegment(segment) {
                try {
                    if (segment.line) {
                        // ã‚·ãƒ¼ãƒ³ã‹ã‚‰ç¢ºå®Ÿã«é™¤å»
                        if (segment.line.parent) {
                            segment.line.parent.remove(segment.line);
                        } else {
                            this.scene.remove(segment.line);
                        }
                        
                        // ã‚¸ã‚ªãƒ¡ãƒˆãƒªã¨ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ç¢ºå®Ÿã«ç ´æ£„
                        if (segment.line.geometry) {
                            segment.line.geometry.dispose();
                        }
                        if (segment.line.material) {
                            // ShaderMaterialã®å ´åˆã€uniformsã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚‚ç ´æ£„
                            if (segment.line.material.uniforms) {
                                Object.values(segment.line.material.uniforms).forEach(uniform => {
                                    if (uniform.value && uniform.value.dispose) {
                                        uniform.value.dispose();
                                    }
                                });
                            }
                            segment.line.material.dispose();
                        }
                        segment.line = null;
                    }
                } catch (error) {
                    console.error('[LightningSystem] Error in forceRemoveTrailSegment:', error);
                    // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚nullã«è¨­å®šã—ã¦å‚ç…§ã‚’åˆ‡ã‚‹
                    segment.line = null;
                }
            }
            
            // æµã‚Œæ˜Ÿã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            cleanupShootingStar(star) {
                if (star.mainLine) {
                    // ã‚·ãƒ¼ãƒ³ã‹ã‚‰ç¢ºå®Ÿã«é™¤å»
                    if (star.mainLine.parent) {
                        star.mainLine.parent.remove(star.mainLine);
                    } else {
                        this.scene.remove(star.mainLine);
                    }
                    
                    // ã‚¸ã‚ªãƒ¡ãƒˆãƒªã¨ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ç ´æ£„
                    if (star.mainLine.geometry) {
                        star.mainLine.geometry.dispose();
                    }
                    if (star.mainLine.material) {
                        // ShaderMaterialã®å ´åˆã€uniformsã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚‚ç ´æ£„
                        if (star.mainLine.material.uniforms) {
                            Object.values(star.mainLine.material.uniforms).forEach(uniform => {
                                if (uniform.value && uniform.value.dispose) {
                                    uniform.value.dispose();
                                }
                            });
                        }
                        star.mainLine.material.dispose();
                    }
                    star.mainLine = null;
                }
            }
            
            // å…¨ä½“ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            clearActiveLightning() {
                // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªæµã‚Œæ˜Ÿã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                this.activeShootingStars.forEach(star => {
                    if (star.mainLine) {
                        // ã‚·ãƒ¼ãƒ³ã‹ã‚‰ç¢ºå®Ÿã«é™¤å»
                        if (star.mainLine.parent) {
                            star.mainLine.parent.remove(star.mainLine);
                        } else {
                            this.scene.remove(star.mainLine);
                        }
                        
                        // ãƒªã‚½ãƒ¼ã‚¹ã‚’ç ´æ£„
                        if (star.mainLine.geometry) {
                            star.mainLine.geometry.dispose();
                        }
                        if (star.mainLine.material) {
                            if (star.mainLine.material.uniforms) {
                                Object.values(star.mainLine.material.uniforms).forEach(uniform => {
                                    if (uniform.value && uniform.value.dispose) {
                                        uniform.value.dispose();
                                    }
                                });
                            }
                            star.mainLine.material.dispose();
                        }
                        star.mainLine = null;
                    }
                });
                this.activeShootingStars = [];
                
                // æ®‹åƒã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚‚ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                this.trailSegments.forEach(segment => {
                    if (segment.line) {
                        // ã‚·ãƒ¼ãƒ³ã‹ã‚‰ç¢ºå®Ÿã«é™¤å»
                        if (segment.line.parent) {
                            segment.line.parent.remove(segment.line);
                        } else {
                            this.scene.remove(segment.line);
                        }
                        
                        // ãƒªã‚½ãƒ¼ã‚¹ã‚’ç ´æ£„
                        if (segment.line.geometry) {
                            segment.line.geometry.dispose();
                        }
                        if (segment.line.material) {
                            if (segment.line.material.uniforms) {
                                Object.values(segment.line.material.uniforms).forEach(uniform => {
                                    if (uniform.value && uniform.value.dispose) {
                                        uniform.value.dispose();
                                    }
                                });
                            }
                            segment.line.material.dispose();
                        }
                        segment.line = null;
                    }
                });
                this.trailSegments = [];
            }
            
            update(stageNumber) {
                try {
                    const now = Date.now();
                    const intensity = this.getLightningIntensity(stageNumber);
                    
                    // Phase 4: çŠ¶æ…‹ã®å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯
                    if (this.activeShootingStars.length > this.maxConcurrentStars * 2) {
                        console.warn(`[LightningSystem] Too many active shooting stars (${this.activeShootingStars.length}), clearing excess`);
                        // å¤ã„æµã‚Œæ˜Ÿã‹ã‚‰å„ªå…ˆçš„ã«å‰Šé™¤
                        this.activeShootingStars.sort((a, b) => a.creationTime - b.creationTime);
                        const excess = this.activeShootingStars.splice(this.maxConcurrentStars);
                        excess.forEach(star => this.cleanupShootingStar(star));
                    }
                    
                    if (this.trailSegments.length > 20) {
                        console.warn(`[LightningSystem] Too many trail segments (${this.trailSegments.length}), forcing cleanup`);
                        // å¤ã„æ®‹åƒã‹ã‚‰å„ªå…ˆçš„ã«å‰Šé™¤
                        this.trailSegments.sort((a, b) => a.creationTime - b.creationTime);
                        const excess = this.trailSegments.splice(10);
                        excess.forEach(segment => this.forceRemoveTrailSegment(segment));
                    }
                    
                    // æ–°ã—ã„æµã‚Œæ˜Ÿã®ç”Ÿæˆã‚¿ã‚¤ãƒŸãƒ³ã‚°åˆ¶å¾¡
                    if (now - this.lastUpdate > intensity.frequency) {
                        this.createShootingStars(stageNumber);
                        this.lastUpdate = now;
                    }
                    
                    // æµã‚Œæ˜Ÿã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
                    const deltaTime = 0.016; // ç´„60FPSæƒ³å®š
                    this.updateShootingStars(deltaTime);
                    
                } catch (error) {
                    console.error('[LightningSystem] Critical error in update:', error);
                    // ç·Šæ€¥æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                    try {
                        this.clearActiveLightning();
                    } catch (cleanupError) {
                        console.error('[LightningSystem] Error during emergency cleanup:', cleanupError);
                    }
                }
            }
            
            cleanup() {
                this.clearActiveLightning();
            }
        }
        
        // æ¬¡å…ƒ2: èªè­˜è«–çš„æ¬¡å…ƒ - ãƒ¬ãƒ¼ãƒ€ãƒ¼æ¢çŸ¥ã‚·ã‚¹ãƒ†ãƒ 
        class RadarDimensionSystem {
            constructor(scene) {
                this.scene = scene;
                this.radarBeam = null;
                this.detectionRings = [];
                this.rotationSpeed = 0.005; // ã‚ˆã‚Šç©ã‚„ã‹ãªåŸºæœ¬é€Ÿåº¦ã«å¤‰æ›´
                this.sweepAngle = Math.PI / 3; // 60åº¦ã®æ‰‡å½¢
                this.maxRange = 4.0;
                this.currentAngle = 0;
                this.axisVariation = 0; // å›è»¢è»¸ã®å¤‰åŒ–ç”¨
            }
            
            createRadarBeam(stageNumber) {
                this.cleanup();
                const intensity = this.getRadarIntensity(stageNumber);
                
                // ãƒ¡ã‚¤ãƒ³ãƒ¬ãƒ¼ãƒ€ãƒ¼ãƒ“ãƒ¼ãƒ ï¼ˆæ‰‡å½¢ï¼‰- ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®è¤‡æ•°ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã§æ§‹æˆ
                const beamGeometry = new THREE.ConeGeometry(
                    intensity.range, 
                    0.05, 
                    32, // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°ã‚’å¢—ã‚„ã—ã¦ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœå‘ä¸Š
                    1, 
                    true, 
                    0, 
                    this.sweepAngle
                );
                
                // ã‚«ãƒ©ãƒ•ãƒ«ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ†ãƒªã‚¢ãƒ«ä½œæˆ
                const gradientMaterial = this.createGradientMaterial(intensity.colors, intensity.opacity);
                
                this.radarBeam = new THREE.Mesh(beamGeometry, gradientMaterial);
                this.radarBeam.rotation.x = -Math.PI / 2; // æ°´å¹³ã«é…ç½®
                this.radarBeam.position.y = 0.05; // ã‚ãšã‹ã«ä¸Šã«é…ç½®
                
                // æ¢çŸ¥ãƒªãƒ³ã‚°åŠ¹æœ
                this.createDetectionRings(intensity);
                
                this.scene.add(this.radarBeam);
                this.rotationSpeed = intensity.rotationSpeed;
            }
            
            createGradientMaterial(colors, opacity) {
                // ã‚«ãƒ©ãƒ•ãƒ«ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«
                const vertexShader = `
                    varying vec2 vUv;
                    varying float vDistance;
                    void main() {
                        vUv = uv;
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vDistance = length(worldPosition.xz);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;
                
                const fragmentShader = `
                    uniform vec3 colors[${colors.length}];
                    uniform float opacity;
                    uniform float time;
                    varying vec2 vUv;
                    varying float vDistance;
                    
                    void main() {
                        // è·é›¢ã¨UVã«åŸºã¥ãã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                        float t = vDistance * 0.3 + sin(time * 2.0) * 0.1;
                        t = fract(t); // 0-1ã®ç¯„å›²ã«ãƒ«ãƒ¼ãƒ—
                        
                        // è¤‡æ•°è‰²ã®è£œé–“
                        float colorIndex = t * float(${colors.length - 1});
                        int index1 = int(floor(colorIndex));
                        int index2 = min(index1 + 1, ${colors.length - 1});
                        float mix_factor = fract(colorIndex);
                        
                        vec3 color1 = colors[index1];
                        vec3 color2 = colors[index2];
                        vec3 finalColor = mix(color1, color2, mix_factor);
                        
                        // UVåº§æ¨™ã«åŸºã¥ãé€æ˜åº¦ã®å¤‰åŒ–ã§ã‚ˆã‚Šãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯ã«
                        float alpha = opacity * (0.8 + 0.2 * sin(vUv.x * 3.14159));
                        
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `;
                
                return new THREE.ShaderMaterial({
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    uniforms: {
                        colors: { value: colors.map(c => new THREE.Color(c)) },
                        opacity: { value: opacity },
                        time: { value: 0.0 }
                    },
                    transparent: true,
                    side: THREE.DoubleSide
                });
            }
            
            createDetectionRings(intensity) {
                const ringCount = intensity.ringCount;
                
                for (let i = 0; i < ringCount; i++) {
                    const ringRadius = (i + 1) * (intensity.range / ringCount);
                    const ringGeometry = new THREE.RingGeometry(
                        ringRadius - 0.02, 
                        ringRadius, 
                        64 // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°ã‚’å¢—ã‚„ã—ã¦ã‚ˆã‚Šæ»‘ã‚‰ã‹ã«
                    );
                    
                    // å„ãƒªãƒ³ã‚°ã‚‚ç•°ãªã‚‹è‰²ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é©ç”¨
                    const colorIndex = i % intensity.colors.length;
                    const ringGradientMaterial = this.createRingGradientMaterial(
                        intensity.colors[colorIndex],
                        intensity.ringOpacity,
                        i
                    );
                    
                    const ring = new THREE.Mesh(ringGeometry, ringGradientMaterial);
                    ring.rotation.x = -Math.PI / 2;
                    ring.position.y = 0.01;
                    
                    ring.userData = {
                        baseOpacity: intensity.ringOpacity,
                        pulsePhase: i * Math.PI / 2, // ä½ç›¸ã‚’ãšã‚‰ã—ã¦ãƒªãƒƒãƒ—ãƒ«åŠ¹æœ
                        pulseSpeed: 0.05,
                        material: ringGradientMaterial // ãƒãƒ†ãƒªã‚¢ãƒ«å‚ç…§ã‚’ä¿å­˜
                    };
                    
                    this.detectionRings.push(ring);
                    this.scene.add(ring);
                }
            }
            
            createRingGradientMaterial(baseColor, opacity, ringIndex) {
                const vertexShader = `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;
                
                const fragmentShader = `
                    uniform vec3 baseColor;
                    uniform float opacity;
                    uniform float time;
                    uniform float ringIndex;
                    varying vec2 vUv;
                    
                    void main() {
                        // å††å½¢ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœ
                        float angle = atan(vUv.y - 0.5, vUv.x - 0.5);
                        float normalizedAngle = (angle + 3.14159) / (2.0 * 3.14159);
                        
                        // æ™‚é–“ã¨ãƒªãƒ³ã‚°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«åŸºã¥ãè‰²ã®å¤‰åŒ–
                        float hueShift = normalizedAngle + time * 0.5 + ringIndex * 0.2;
                        
                        // HSVãƒ©ã‚¤ã‚¯ãªè‰²å¤‰æ›ã§è™¹è‰²åŠ¹æœ
                        vec3 color = baseColor;
                        color.r = baseColor.r + sin(hueShift * 2.0) * 0.3;
                        color.g = baseColor.g + sin(hueShift * 2.0 + 2.0) * 0.3;
                        color.b = baseColor.b + sin(hueShift * 2.0 + 4.0) * 0.3;
                        color = clamp(color, 0.0, 1.0);
                        
                        gl_FragColor = vec4(color, opacity);
                    }
                `;
                
                return new THREE.ShaderMaterial({
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    uniforms: {
                        baseColor: { value: new THREE.Color(baseColor) },
                        opacity: { value: opacity },
                        time: { value: 0.0 },
                        ringIndex: { value: ringIndex }
                    },
                    transparent: true,
                    side: THREE.DoubleSide
                });
            }
            
            getRadarIntensity(stageNumber) {
                if (stageNumber <= 3) {
                    // EAæ®µéš: é…ã„å›è»¢ã€ç‹­ã„ç¯„å›² - ãƒ‘ã‚¹ãƒ†ãƒ«ãƒ–ãƒ«ãƒ¼ç³»ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                    return {
                        range: 2.0,
                        colors: [0x87ceeb, 0xb0e0e6, 0xe0f6ff], // ã‚¹ã‚«ã‚¤ãƒ–ãƒ«ãƒ¼ â†’ ãƒ‘ã‚¦ãƒ€ãƒ¼ãƒ–ãƒ«ãƒ¼ â†’ ã‚¢ãƒªã‚¹ãƒ–ãƒ«ãƒ¼
                        opacity: 0.15,
                        rotationSpeed: 0.008, // ã•ã‚‰ã«é…ã
                        ringCount: 2,
                        ringOpacity: 0.1,
                        detectionSensitivity: 0.3
                    };
                } else if (stageNumber <= 7) {
                    // å²è·¯æ®µéš: å¤šå½©ãªè‰²åˆã„ - ã‚°ãƒªãƒ¼ãƒ³ãƒ»ã‚¤ã‚¨ãƒ­ãƒ¼ãƒ»ãƒ”ãƒ³ã‚¯ç³»ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                    return {
                        range: 3.0,
                        colors: [0x98fb98, 0xffffe0, 0xffc0cb, 0x87ceeb, 0xdda0dd], // ãƒšãƒ¼ãƒ«ã‚°ãƒªãƒ¼ãƒ³ â†’ ãƒ©ã‚¤ãƒˆã‚¤ã‚¨ãƒ­ãƒ¼ â†’ ãƒ”ãƒ³ã‚¯ â†’ ã‚¹ã‚«ã‚¤ãƒ–ãƒ«ãƒ¼ â†’ ãƒ—ãƒ©ãƒ 
                        opacity: 0.25,
                        rotationSpeed: 0.015, // é…ã‚ã«èª¿æ•´
                        ringCount: 3,
                        ringOpacity: 0.15,
                        detectionSensitivity: 0.5
                    };
                } else {
                    // IAæ®µéš: ã‚«ãƒ©ãƒ•ãƒ«ãªè™¹è‰² - è±Šå¯Œãªè‰²å½©ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                    return {
                        range: 4.0,
                        colors: [0xffa07a, 0xffb6c1, 0x98fb98, 0x87ceeb, 0xdda0dd, 0xf0e68c, 0xffa500], // ãƒ©ã‚¤ãƒˆã‚µãƒ¼ãƒ¢ãƒ³ â†’ ãƒ©ã‚¤ãƒˆãƒ”ãƒ³ã‚¯ â†’ ãƒšãƒ¼ãƒ«ã‚°ãƒªãƒ¼ãƒ³ â†’ ã‚¹ã‚«ã‚¤ãƒ–ãƒ«ãƒ¼ â†’ ãƒ—ãƒ©ãƒ  â†’ ã‚«ãƒ¼ã‚­ â†’ ã‚ªãƒ¬ãƒ³ã‚¸
                        opacity: 0.35,
                        rotationSpeed: 0.02, // é«˜é€Ÿã‹ã‚‰ä¸­é€Ÿã«å¤‰æ›´
                        ringCount: 4,
                        ringOpacity: 0.2,
                        detectionSensitivity: 0.8
                    };
                }
            }
            
            update(time, particles) {
                if (!this.radarBeam) return;
                
                // ãƒ¬ãƒ¼ãƒ€ãƒ¼ãƒ“ãƒ¼ãƒ ã®å‹•çš„è»¸å¤‰åŒ–å›è»¢ã‚·ã‚¹ãƒ†ãƒ 
                this.currentAngle += this.rotationSpeed;
                this.axisVariation += 0.003; // è»¸å¤‰åŒ–ã®é€Ÿåº¦ã‚’å°‘ã—ä¸Šã’ã‚‹
                
                // å›è»¢è»¸è‡ªä½“ã‚’å‹•çš„ã«å¤‰åŒ–ã•ã›ã‚‹
                const axisX = Math.sin(this.axisVariation * 0.7) * 0.3; // Xè»¸æ–¹å‘ã®è»¸å¤‰åŒ–
                const axisY = 1.0; // Yè»¸ã®åŸºæœ¬æˆåˆ†
                const axisZ = Math.cos(this.axisVariation * 0.5) * 0.3; // Zè»¸æ–¹å‘ã®è»¸å¤‰åŒ–
                
                // æ­£è¦åŒ–ã—ã¦å›è»¢è»¸ãƒ™ã‚¯ãƒˆãƒ«ã‚’ä½œæˆ
                const axisLength = Math.sqrt(axisX * axisX + axisY * axisY + axisZ * axisZ);
                const normalizedAxisX = axisX / axisLength;
                const normalizedAxisY = axisY / axisLength;
                const normalizedAxisZ = axisZ / axisLength;
                
                // å‹•çš„å›è»¢è»¸ã§ã®å›è»¢ã‚’é©ç”¨
                const quaternion = new THREE.Quaternion();
                quaternion.setFromAxisAngle(
                    new THREE.Vector3(normalizedAxisX, normalizedAxisY, normalizedAxisZ), 
                    this.currentAngle
                );
                
                // åŸºæœ¬å§¿å‹¢ï¼ˆæ°´å¹³é…ç½®ï¼‰ã‹ã‚‰ã®å›è»¢ã‚’é©ç”¨
                const baseQuaternion = new THREE.Quaternion();
                baseQuaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2);
                
                // æœ€çµ‚çš„ãªå›è»¢ã‚’è¨­å®š
                this.radarBeam.quaternion.copy(baseQuaternion.multiply(quaternion));
                
                // æ¢çŸ¥ãƒªãƒ³ã‚°ã®ãƒ‘ãƒ«ã‚¹åŠ¹æœã¨ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
                this.detectionRings.forEach(ring => {
                    if (ring.userData) {
                        const pulseValue = Math.sin(time * ring.userData.pulseSpeed + ring.userData.pulsePhase);
                        
                        // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ã®æ™‚é–“æ›´æ–°
                        if (ring.userData.material && ring.userData.material.uniforms) {
                            ring.userData.material.uniforms.time.value = time * 0.001;
                            ring.userData.material.uniforms.opacity.value = ring.userData.baseOpacity + pulseValue * 0.1;
                        }
                    }
                });
                
                // ãƒ¡ã‚¤ãƒ³ãƒ¬ãƒ¼ãƒ€ãƒ¼ãƒ“ãƒ¼ãƒ ã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼æ™‚é–“æ›´æ–°
                if (this.radarBeam && this.radarBeam.material && this.radarBeam.material.uniforms) {
                    this.radarBeam.material.uniforms.time.value = time * 0.001;
                }
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ¢çŸ¥åŠ¹æœï¼ˆæœªæ¥ã®æ‹¡å¼µãƒã‚¤ãƒ³ãƒˆï¼‰
                this.detectParticles(particles);
            }
            
            detectParticles(particles) {
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãŒãƒ¬ãƒ¼ãƒ€ãƒ¼ç¯„å›²å†…ã«ã‚ã‚‹å ´åˆã®è¦–è¦šåŠ¹æœ
                // ï¼ˆç¾åœ¨ã¯åŸºæœ¬å®Ÿè£…ã€å°†æ¥çš„ã«ã¯ã‚ˆã‚Šé«˜åº¦ãªæ¢çŸ¥åŠ¹æœã‚’è¿½åŠ å¯èƒ½ï¼‰
                if (!particles || !this.radarBeam) return;
                
                particles.forEach(particle => {
                    if (!particle.position) return;
                    
                    const distance = particle.position.length();
                    const intensity = this.getRadarIntensity(this.getCurrentStage());
                    
                    if (distance <= intensity.range) {
                        // æ¢çŸ¥ã•ã‚ŒãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å¾®ç´°ãªåŠ¹æœ
                        // ï¼ˆç¾åœ¨ã¯æ§ãˆã‚ãªå®Ÿè£…ï¼‰
                    }
                });
            }
            
            getCurrentStage() {
                // ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’å–å¾—ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼ˆãƒ¡ã‚¤ãƒ³ã‚¯ãƒ©ã‚¹ã‹ã‚‰å‚ç…§ï¼‰
                return 5; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
            }
            
            cleanup() {
                if (this.radarBeam) {
                    this.scene.remove(this.radarBeam);
                    this.radarBeam.geometry.dispose();
                    this.radarBeam.material.dispose();
                    this.radarBeam = null;
                }
                
                this.detectionRings.forEach(ring => {
                    this.scene.remove(ring);
                    ring.geometry.dispose();
                    ring.material.dispose();
                });
                this.detectionRings = [];
            }
        }
        
        // TargetCoreç”¨ãƒŸãƒ‹ãƒ¬ãƒ¼ãƒ€ãƒ¼ã‚·ã‚¹ãƒ†ãƒ  - ä»–è€…ã®èªè­˜è«–çš„æ¢çŸ¥ã‚’è¡¨ç¾
        class MiniRadarSystem {
            constructor(scene, parentCore) {
                this.scene = scene;
                this.parentCore = parentCore;
                this.radarBeam = null;
                this.detectionRings = [];
                this.rotationSpeed = 0.003 + Math.random() * 0.002; // å„ä»–è€…å›ºæœ‰ã®é€Ÿåº¦
                this.sweepAngle = Math.PI / 6; // 30åº¦ã®å°ã•ãªæ‰‡å½¢
                this.maxRange = 0.8; // å°ã•ãªæ¢çŸ¥ç¯„å›²
                this.currentAngle = Math.random() * Math.PI * 2; // ãƒ©ãƒ³ãƒ€ãƒ é–‹å§‹è§’åº¦
                this.axisVariation = Math.random() * Math.PI * 2; // å„ä»–è€…å›ºæœ‰ã®è»¸å¤‰åŒ–
                this.colorPhase = Math.random() * Math.PI * 2; // ã‚«ãƒ©ãƒ¼ä½ç›¸
            }
            
            createMiniRadarBeam(coreColor) {
                this.cleanup();
                
                // ãƒ¡ã‚¤ãƒ³ãƒ¬ãƒ¼ãƒ€ãƒ¼ãƒ“ãƒ¼ãƒ ï¼ˆå°ã•ãªæ‰‡å½¢ï¼‰
                const beamGeometry = new THREE.ConeGeometry(
                    this.maxRange, 
                    0.02, // éå¸¸ã«è–„ã
                    16, 
                    1, 
                    true, 
                    0, 
                    this.sweepAngle
                );
                
                // ã‚³ã‚¢ã¨èª¿å’Œã™ã‚‹ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ†ãƒªã‚¢ãƒ«
                const gradientMaterial = this.createMiniGradientMaterial(coreColor);
                
                this.radarBeam = new THREE.Mesh(beamGeometry, gradientMaterial);
                this.radarBeam.rotation.x = -Math.PI / 2; // æ°´å¹³ã«é…ç½®
                this.radarBeam.position.copy(this.parentCore.position);
                this.radarBeam.position.y += 0.02; // ã‚ãšã‹ã«ä¸Šã«é…ç½®
                
                // å°ã•ãªæ¢çŸ¥ãƒªãƒ³ã‚°åŠ¹æœ
                this.createMiniDetectionRings(coreColor);
                
                this.scene.add(this.radarBeam);
            }
            
            createMiniGradientMaterial(coreColor) {
                const baseColor = new THREE.Color(coreColor);
                
                const vertexShader = `
                    varying vec2 vUv;
                    varying float vDistance;
                    void main() {
                        vUv = uv;
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vDistance = length(worldPosition.xz);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;
                
                const fragmentShader = `
                    uniform vec3 baseColor;
                    uniform float opacity;
                    uniform float time;
                    uniform float colorPhase;
                    varying vec2 vUv;
                    varying float vDistance;
                    
                    void main() {
                        // è·é›¢ã¨UVã«åŸºã¥ãã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                        float t = vDistance * 0.5 + sin(time * 3.0 + colorPhase) * 0.2;
                        t = fract(t);
                        
                        // ãƒ™ãƒ¼ã‚¹ã‚«ãƒ©ãƒ¼ã‹ã‚‰æ´¾ç”Ÿã—ãŸç¾ã—ã„ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                        vec3 color1 = baseColor;
                        vec3 color2 = baseColor * 1.3; // æ˜ã‚‹ã
                        vec3 color3 = baseColor * 0.7; // æš—ã
                        
                        vec3 finalColor;
                        if (t < 0.5) {
                            finalColor = mix(color1, color2, t * 2.0);
                        } else {
                            finalColor = mix(color2, color3, (t - 0.5) * 2.0);
                        }
                        
                        float alpha = opacity * (0.6 + 0.4 * sin(vUv.x * 3.14159));
                        
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `;
                
                return new THREE.ShaderMaterial({
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    uniforms: {
                        baseColor: { value: baseColor },
                        opacity: { value: 0.15 }, // æ§ãˆã‚ãªé€æ˜åº¦
                        time: { value: 0.0 },
                        colorPhase: { value: this.colorPhase }
                    },
                    transparent: true,
                    side: THREE.DoubleSide
                });
            }
            
            createMiniDetectionRings(coreColor) {
                const ringCount = 2; // å°ã•ãªãƒªãƒ³ã‚°2ã¤
                const baseColor = new THREE.Color(coreColor);
                
                for (let i = 0; i < ringCount; i++) {
                    const ringRadius = (i + 1) * (this.maxRange / ringCount);
                    const ringGeometry = new THREE.RingGeometry(
                        ringRadius - 0.01, 
                        ringRadius, 
                        32 
                    );
                    
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: baseColor,
                        transparent: true,
                        opacity: 0.1,
                        side: THREE.DoubleSide
                    });
                    
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = -Math.PI / 2;
                    ring.position.copy(this.parentCore.position);
                    ring.position.y += 0.01;
                    
                    ring.userData = {
                        baseOpacity: 0.1,
                        pulsePhase: i * Math.PI / 2 + this.colorPhase,
                        pulseSpeed: 0.03,
                        baseColor: baseColor.clone()
                    };
                    
                    this.detectionRings.push(ring);
                    this.scene.add(ring);
                }
            }
            
            update(time) {
                if (!this.radarBeam) return;
                
                // ãƒŸãƒ‹ãƒ¬ãƒ¼ãƒ€ãƒ¼ãƒ“ãƒ¼ãƒ ã®å›è»¢
                this.currentAngle += this.rotationSpeed;
                this.axisVariation += 0.001;
                
                // è¦ªã‚³ã‚¢ã®ä½ç½®ã«è¿½å¾“
                this.radarBeam.position.copy(this.parentCore.position);
                this.radarBeam.position.y += 0.02;
                
                // å‹•çš„å›è»¢è»¸ã§ã®å›è»¢
                const axisX = Math.sin(this.axisVariation * 0.5) * 0.2;
                const axisY = 1.0;
                const axisZ = Math.cos(this.axisVariation * 0.3) * 0.2;
                
                const axisLength = Math.sqrt(axisX * axisX + axisY * axisY + axisZ * axisZ);
                const normalizedAxisX = axisX / axisLength;
                const normalizedAxisY = axisY / axisLength;
                const normalizedAxisZ = axisZ / axisLength;
                
                const quaternion = new THREE.Quaternion();
                quaternion.setFromAxisAngle(
                    new THREE.Vector3(normalizedAxisX, normalizedAxisY, normalizedAxisZ), 
                    this.currentAngle
                );
                
                const baseQuaternion = new THREE.Quaternion();
                baseQuaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2);
                
                this.radarBeam.quaternion.copy(baseQuaternion.multiply(quaternion));
                
                // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ã®æ™‚é–“æ›´æ–°
                if (this.radarBeam && this.radarBeam.material && this.radarBeam.material.uniforms) {
                    this.radarBeam.material.uniforms.time.value = time * 0.001;
                }
                
                // æ¢çŸ¥ãƒªãƒ³ã‚°ã®æ›´æ–°
                this.detectionRings.forEach(ring => {
                    // è¦ªã‚³ã‚¢ã®ä½ç½®ã«è¿½å¾“
                    ring.position.copy(this.parentCore.position);
                    ring.position.y += 0.01;
                    
                    if (ring.userData) {
                        const pulseValue = Math.sin(time * ring.userData.pulseSpeed + ring.userData.pulsePhase);
                        ring.material.opacity = ring.userData.baseOpacity + pulseValue * 0.05;
                    }
                });
            }
            
            cleanup() {
                if (this.radarBeam) {
                    this.scene.remove(this.radarBeam);
                    this.radarBeam.geometry.dispose();
                    this.radarBeam.material.dispose();
                    this.radarBeam = null;
                }
                
                this.detectionRings.forEach(ring => {
                    this.scene.remove(ring);
                    ring.geometry.dispose();
                    ring.material.dispose();
                });
                this.detectionRings = [];
            }
        }
        
        // æ¬¡å…ƒ3: å¯¾äººé–¢ä¿‚æ¬¡å…ƒ - ãƒ‹ãƒ¥ãƒ¼ãƒ­ãƒ³ã‚·ãƒŠãƒ—ã‚¹ä¼é”ã‚·ã‚¹ãƒ†ãƒ 
        class BeamDimensionSystem {
            constructor(scene) {
                this.scene = scene;
                this.particleStreams = []; // ä¼é”ç‰©è³ªã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ 
                this.targetCores = []; // ä»–ã®ã‚³ã‚¢ï¼ˆç›®æ¨™åœ°ç‚¹ï¼‰
                this.connectionPaths = []; // æ¥ç¶šãƒ‘ã‚¹
                this.transmissionActive = {}; // ä¼é”çŠ¶æ…‹ç®¡ç†
                this.maxConnections = 8;
                this.particleCount = 15; // å„ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°
                this.miniRadars = []; // å„TargetCoreç”¨ã®ãƒŸãƒ‹ãƒ¬ãƒ¼ãƒ€ãƒ¼ã‚·ã‚¹ãƒ†ãƒ 
            }
            
            createNeuralConnections(stageNumber) {
                this.cleanup();
                const intensity = this.getSynapseIntensity(stageNumber);
                
                // æ®µéšã«å¿œã˜ãŸæ¥ç¶šæ•°ã¨ç›®æ¨™ã‚³ã‚¢ã®é…ç½®
                const connectionCount = intensity.connectionCount;
                this.createTargetCores(connectionCount, intensity);
                
                // å„æ¥ç¶šã«å¯¾ã—ã¦ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œæˆ
                for (let i = 0; i < connectionCount; i++) {
                    const targetCore = this.targetCores[i];
                    const particleStream = this.createParticleStream(targetCore, intensity, i);
                    this.particleStreams.push(particleStream);
                    this.scene.add(particleStream.group);
                    
                    // ä¼é”çŠ¶æ…‹ã‚’åˆæœŸåŒ–
                    this.transmissionActive[i] = {
                        active: true,
                        lastTransmission: Math.random() * 3000, // ã‚ˆã‚Šåºƒã„ãƒ©ãƒ³ãƒ€ãƒ é–‹å§‹æ™‚åˆ»ï¼ˆ0-3ç§’ï¼‰
                        interval: 600 + Math.random() * 2400, // 0.6-3ç§’ã®å¤šæ§˜ãªé–“éš”
                        baseInterval: 1200 + Math.random() * 1800, // åŸºæº–é–“éš”ï¼ˆå€‹ä½“å·®ï¼‰
                        intervalVariation: 0.3 + Math.random() * 0.7, // é–“éš”å¤‰å‹•ä¿‚æ•°
                        particles: []
                    };
                }
            }
            
            createTargetCores(count, intensity) {
                this.targetCores = [];
                const radius = intensity.connectionDistance;
                
                // 7ç¨®é¡ã®3Då½¢çŠ¶å®šç¾©ï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚ˆã‚Šå¤§ããï¼‰
                const geometryTypes = [
                    { name: 'sphere', create: () => new THREE.SphereGeometry(0.15, 8, 6) },
                    { name: 'box', create: () => new THREE.BoxGeometry(0.24, 0.24, 0.24) },
                    { name: 'cone', create: () => new THREE.ConeGeometry(0.15, 0.30, 6) },
                    { name: 'cylinder', create: () => new THREE.CylinderGeometry(0.12, 0.12, 0.24, 6) },
                    { name: 'octahedron', create: () => new THREE.OctahedronGeometry(0.15) },
                    { name: 'icosahedron', create: () => new THREE.IcosahedronGeometry(0.15) },
                    { name: 'tetrahedron', create: () => new THREE.TetrahedronGeometry(0.18) }
                ];
                
                for (let i = 0; i < count; i++) {
                    // å‡ç­‰ãªè§’åº¦é…ç½®ã«å°‘ã—ã®ãƒ©ãƒ³ãƒ€ãƒ æ€§ã‚’åŠ ãˆã‚‹
                    const baseAngle = (i / count) * Math.PI * 2;
                    const angle = baseAngle + (Math.random() - 0.5) * 0.3;
                    const elevation = (Math.random() - 0.5) * 0.4; // Yè»¸ã®å¤‰åŒ–
                    
                    const position = new THREE.Vector3(
                        Math.cos(angle) * radius,
                        elevation,
                        Math.sin(angle) * radius
                    );
                    
                    // ãƒ©ãƒ³ãƒ€ãƒ ãªå½¢çŠ¶ã‚’é¸æŠ
                    const randomGeometryType = geometryTypes[Math.floor(Math.random() * geometryTypes.length)];
                    const coreGeometry = randomGeometryType.create();
                    
                    // æ§˜ã€…ãªä»–è€…ã‚’è¡¨ç¾ã™ã‚‹å¤šå½©ãªè‰²å½©ãƒ‘ãƒ¬ãƒƒãƒˆ
                    const diverseColors = [
                        0x87ceeb, // ã‚¹ã‚«ã‚¤ãƒ–ãƒ«ãƒ¼ - ç†æ€§çš„ãªä»–è€…
                        0xffa07a, // ãƒ©ã‚¤ãƒˆã‚µãƒ¼ãƒ¢ãƒ³ - æ¸©ã‹ã„ä»–è€…
                        0x98fb98, // ãƒšãƒ¼ãƒ«ã‚°ãƒªãƒ¼ãƒ³ - è‡ªç„¶ä½“ãªä»–è€…
                        0xdda0dd, // ãƒ—ãƒ©ãƒ  - ç¥ç§˜çš„ãªä»–è€…
                        0xf0e68c, // ã‚«ãƒ¼ã‚­ - åœ°ã«è¶³ã¤ã„ãŸä»–è€…
                        0xffb6c1, // ãƒ©ã‚¤ãƒˆãƒ”ãƒ³ã‚¯ - æ„Ÿæƒ…è±Šã‹ãªä»–è€…
                        0xffd700, // ã‚´ãƒ¼ãƒ«ãƒ‰ - è¼ãä»–è€…
                        0xff6347, // ãƒˆãƒãƒˆ - æƒ…ç†±çš„ãªä»–è€…
                        0x40e0d0, // ã‚¿ãƒ¼ã‚³ã‚¤ã‚º - æ¸…ã‚‰ã‹ãªä»–è€…
                        0xda70d6, // ã‚ªãƒ¼ã‚­ãƒƒãƒ‰ - å€‹æ€§çš„ãªä»–è€…
                        0x32cd32, // ãƒ©ã‚¤ãƒ ã‚°ãƒªãƒ¼ãƒ³ - ç”Ÿå‘½åŠ›ã‚ã‚‹ä»–è€…
                        0xff69b4, // ãƒ›ãƒƒãƒˆãƒ”ãƒ³ã‚¯ - æ´»ç™ºãªä»–è€…
                        0x00ced1, // ãƒ€ãƒ¼ã‚¯ã‚¿ãƒ¼ã‚³ã‚¤ã‚º - æ·±ã„ä»–è€…
                        0xffa500, // ã‚ªãƒ¬ãƒ³ã‚¸ - ã‚¨ãƒãƒ«ã‚®ãƒƒã‚·ãƒ¥ãªä»–è€…
                        0x9370db  // ãƒŸãƒ‡ã‚£ã‚¢ãƒ ãƒ‘ãƒ¼ãƒ—ãƒ« - å‰µé€ çš„ãªä»–è€…
                    ];
                    
                    const randomColor = diverseColors[Math.floor(Math.random() * diverseColors.length)];
                    const coreMaterial = new THREE.MeshBasicMaterial({
                        color: randomColor,
                        transparent: true,
                        opacity: 0.4 // å­˜åœ¨æ„Ÿã‚’æŠ‘ãˆã‚‹ãŸã‚åŠé€æ˜ã«å¤‰æ›´
                    });
                    
                    const core = new THREE.Mesh(coreGeometry, coreMaterial);
                    core.position.copy(position);
                    
                    // ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ åŠ¹æœï¼ˆã‚¨ãƒƒã‚¸å¼·èª¿ï¼‰- ä¸­å¤®ã‚³ã‚¢ã¨åŒæ§˜
                    const wireframeGeometry = new THREE.EdgesGeometry(coreGeometry);
                    const wireframeMaterial = new THREE.LineBasicMaterial({ 
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.6,
                        linewidth: 1
                    });
                    
                    const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
                    core.add(wireframe); // ã‚³ã‚¢ã®å­ã¨ã—ã¦è¿½åŠ 
                    
                    // ã‚°ãƒ­ãƒ¼åŠ¹æœã‚‚åŒã˜å½¢çŠ¶ã§å°‘ã—å¤§ããã€åŒã˜è‰²èª¿ã§
                    const glowScale = 1.5;
                    const glowGeometry = randomGeometryType.create();
                    glowGeometry.scale(glowScale, glowScale, glowScale);
                    
                    // ã‚°ãƒ­ãƒ¼ã¯åŒã˜è‰²ã®æ·¡ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä½¿ç”¨
                    const glowColor = new THREE.Color(randomColor);
                    glowColor.multiplyScalar(0.8); // å°‘ã—æš—ãã—ã¦çµ±ä¸€æ„Ÿã‚’ä¿ã¤
                    
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: glowColor,
                        transparent: true,
                        opacity: 0.15 // ã‚°ãƒ­ãƒ¼ã‚‚æ§ãˆã‚ã«å¤‰æ›´
                    });
                    
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    glow.position.copy(position);
                    
                    this.scene.add(core);
                    this.scene.add(glow);
                    
                    // å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¿½åŠ 
                    core.userData = {
                        rotationSpeed: {
                            x: (Math.random() - 0.5) * 0.02,
                            y: (Math.random() - 0.5) * 0.02,
                            z: (Math.random() - 0.5) * 0.02
                        },
                        baseScale: 1.0,
                        pulseSpeed: 0.5 + Math.random() * 1.0,
                        pulsePhase: Math.random() * Math.PI * 2,
                        // ä½ç½®ç§»å‹•ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆã‚ˆã‚Šæ´»ç™ºãªå‹•ãï¼‰
                        basePosition: position.clone(),
                        movementSpeed: {
                            x: (Math.random() - 0.5) * 0.003, // 3å€ã«å¢—åŠ 
                            y: (Math.random() - 0.5) * 0.002, // 2.5å€ã«å¢—åŠ 
                            z: (Math.random() - 0.5) * 0.003  // 3å€ã«å¢—åŠ 
                        },
                        movementPhase: {
                            x: Math.random() * Math.PI * 2,
                            y: Math.random() * Math.PI * 2,
                            z: Math.random() * Math.PI * 2
                        },
                        movementRadius: {
                            x: 0.5 + Math.random() * 0.6, // Xè»¸ã®ç§»å‹•ç¯„å›²æ‹¡å¤§
                            y: 0.3 + Math.random() * 0.5, // Yè»¸ã®ç§»å‹•ç¯„å›²æ‹¡å¤§
                            z: 0.5 + Math.random() * 0.6  // Zè»¸ã®ç§»å‹•ç¯„å›²æ‹¡å¤§
                        },
                        distanceVariation: 0.7 + Math.random() * 0.6 // 0.7-1.3å€ã®è·é›¢å¤‰å‹•æ‹¡å¤§
                    };
                    
                    glow.userData = {
                        rotationSpeed: core.userData.rotationSpeed,
                        baseScale: glowScale,
                        pulseSpeed: core.userData.pulseSpeed,
                        pulsePhase: core.userData.pulsePhase,
                        // ä½ç½®ç§»å‹•ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ã‚°ãƒ­ãƒ¼ã‚‚å…±æœ‰
                        basePosition: position.clone(),
                        movementSpeed: core.userData.movementSpeed,
                        movementPhase: core.userData.movementPhase,
                        movementRadius: core.userData.movementRadius,
                        distanceVariation: core.userData.distanceVariation
                    };
                    
                    this.targetCores.push({
                        position: position.clone(),
                        core: core,
                        glow: glow,
                        index: i,
                        geometryType: randomGeometryType.name
                    });
                    
                    // å„TargetCoreã«ãƒŸãƒ‹ãƒ¬ãƒ¼ãƒ€ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ã‚’è¿½åŠ 
                    const miniRadar = new MiniRadarSystem(this.scene, core);
                    miniRadar.createMiniRadarBeam(randomColor);
                    this.miniRadars.push(miniRadar);
                }
            }
            
            createParticleStream(targetCore, intensity, streamIndex) {
                const group = new THREE.Group();
                const particles = [];
                
                // ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
                const direction = targetCore.position.clone().normalize();
                
                for (let i = 0; i < this.particleCount; i++) {
                    // å„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã¯æœ€åˆéè¡¨ç¤º
                    const particleGeometry = new THREE.SphereGeometry(0.02, 6, 4);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: intensity.particleColors[Math.floor(Math.random() * intensity.particleColors.length)],
                        transparent: true,
                        opacity: 0
                    });
                    
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    
                    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
                    particle.userData = {
                        originalOpacity: 0.8,
                        progress: 0, // 0-1ã®é€²è¡Œåº¦
                        speed: 0.4 + Math.random() * 0.4, // 0.4-0.8 ã®é€Ÿåº¦ï¼ˆç·©ã‚„ã‹ã«å¤‰æ›´ï¼‰
                        startDelay: i * 100, // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é–“ã®é…å»¶
                        targetPosition: targetCore.position.clone(),
                        direction: direction.clone(),
                        active: false,
                        pulsePhase: Math.random() * Math.PI * 2
                    };
                    
                    group.add(particle);
                    particles.push(particle);
                }
                
                return {
                    group: group,
                    particles: particles,
                    targetCore: targetCore,
                    direction: direction.clone(),
                    streamIndex: streamIndex
                };
            }
            
            getSynapseIntensity(stageNumber) {
                if (stageNumber <= 3) {
                    // EAæ®µéš: å°‘ãªã„æ¥ç¶šã€çŸ­è·é›¢ã€ç©ã‚„ã‹ãªè‰²å½©
                    return {
                        connectionCount: Math.max(1, Math.min(2, stageNumber)),
                        connectionDistance: 8.0,
                        particleColors: [0x87ceeb, 0xb0e0e6, 0xe6f3ff], // ãƒ‘ã‚¹ãƒ†ãƒ«ãƒ–ãƒ«ãƒ¼ç³»
                        coreColor: 0xb0e0e6,
                        glowColor: 0x87ceeb,
                        transmissionFrequency: 0.3, // ä½é »åº¦
                        particleSpeed: 0.6,
                        connectionOpacity: 0.4
                    };
                } else if (stageNumber <= 7) {
                    // å²è·¯æ®µéš: ä¸­ç¨‹åº¦ã®æ¥ç¶šã€å¤šå½©ãªè‰²å½©
                    const progressInPhase = (stageNumber - 3) / 4;
                    return {
                        connectionCount: Math.floor(3 + progressInPhase * 3), // 3-6æ¥ç¶š
                        connectionDistance: 7.5,
                        particleColors: [
                            0x98fb98, 0xffffe0, 0xffc0cb, // ãƒšãƒ¼ãƒ«ã‚°ãƒªãƒ¼ãƒ³ã€ãƒ©ã‚¤ãƒˆã‚¤ã‚¨ãƒ­ãƒ¼ã€ãƒ”ãƒ³ã‚¯
                            0x87ceeb, 0xdda0dd, 0xf0e68c  // ã‚¹ã‚«ã‚¤ãƒ–ãƒ«ãƒ¼ã€ãƒ—ãƒ©ãƒ ã€ã‚«ãƒ¼ã‚­
                        ],
                        coreColor: 0xffc0cb,
                        glowColor: 0x98fb98,
                        transmissionFrequency: 0.6, // ä¸­é »åº¦
                        particleSpeed: 0.8,
                        connectionOpacity: 0.6
                    };
                } else {
                    // IAæ®µéš: è±Šå¯Œãªæ¥ç¶šã€è™¹è‰²ã®ç¾ã—ã„è‰²å½©
                    const progressInPhase = (stageNumber - 7) / 3;
                    return {
                        connectionCount: Math.floor(6 + progressInPhase * 2), // 6-8æ¥ç¶š
                        connectionDistance: 7.5,
                        particleColors: [
                            0xffa07a, 0xffb6c1, 0x98fb98, 0x87ceeb, // ãƒ©ã‚¤ãƒˆã‚µãƒ¼ãƒ¢ãƒ³ã€ãƒ©ã‚¤ãƒˆãƒ”ãƒ³ã‚¯ã€ãƒšãƒ¼ãƒ«ã‚°ãƒªãƒ¼ãƒ³ã€ã‚¹ã‚«ã‚¤ãƒ–ãƒ«ãƒ¼
                            0xdda0dd, 0xf0e68c, 0xffa500, 0xff6347  // ãƒ—ãƒ©ãƒ ã€ã‚«ãƒ¼ã‚­ã€ã‚ªãƒ¬ãƒ³ã‚¸ã€ãƒˆãƒãƒˆ
                        ],
                        coreColor: 0xffa07a,
                        glowColor: 0xffb6c1,
                        transmissionFrequency: 1.0, // é«˜é »åº¦
                        particleSpeed: 1.0,
                        connectionOpacity: 0.8
                    };
                }
            }
            
            update(time, stageNumber) {
                const intensity = this.getSynapseIntensity(stageNumber);
                const currentTime = Date.now();
                
                this.particleStreams.forEach((stream, streamIndex) => {
                    if (!this.transmissionActive[streamIndex]) return;
                    
                    const transmissionState = this.transmissionActive[streamIndex];
                    
                    // ä¼é”é–‹å§‹ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’ãƒã‚§ãƒƒã‚¯
                    if (currentTime - transmissionState.lastTransmission > transmissionState.interval) {
                        this.startTransmission(stream, intensity);
                        transmissionState.lastTransmission = currentTime;
                        // ã‚ˆã‚Šè‡ªç„¶ãªãƒ©ãƒ³ãƒ€ãƒ é–“éš”ï¼ˆå€‹ä½“å·®ã¨å¤‰å‹•ã‚’è€ƒæ…®ï¼‰
                        const baseInterval = transmissionState.baseInterval;
                        const variation = transmissionState.intervalVariation;
                        transmissionState.interval = baseInterval * (1 - variation + Math.random() * variation * 2);
                    }
                    
                    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ›´æ–°
                    stream.particles.forEach(particle => {
                        if (!particle.userData.active) return;
                        
                        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®é€²è¡Œ
                        particle.userData.progress += particle.userData.speed * 0.008;
                        
                        if (particle.userData.progress <= 1.0) {
                            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ä½ç½®æ›´æ–°ï¼ˆãƒ™ã‚¸ã‚§æ›²ç·šã§è‡ªç„¶ãªè»Œé“ï¼‰
                            const startPos = new THREE.Vector3(0, 0, 0);
                            // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåº§æ¨™ã‚’ä½¿ç”¨ï¼ˆå‹•çš„è¿½è·¡ï¼‰
                            const endPos = stream.targetCore.position.clone();
                            const t = particle.userData.progress;
                            
                            // ãƒ™ã‚¸ã‚§æ›²ç·šã®ä¸­é–“åˆ¶å¾¡ç‚¹ã‚’ä½œæˆï¼ˆå¼§ã‚’æãï¼‰
                            const midPoint = startPos.clone().lerp(endPos, 0.5);
                            midPoint.y += 0.3 * Math.sin(Math.PI * t); // ä¸Šå‘ãã®å¼§
                            
                            // äºŒæ¬¡ãƒ™ã‚¸ã‚§æ›²ç·š
                            const pos1 = startPos.clone().lerp(midPoint, t);
                            const pos2 = midPoint.clone().lerp(endPos, t);
                            const finalPos = pos1.lerp(pos2, t);
                            
                            particle.position.copy(finalPos);
                            
                            // é€æ˜åº¦ã¨ã‚µã‚¤ã‚ºã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                            const fadeIn = Math.min(1.0, t * 4); // é–‹å§‹æ™‚ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
                            const fadeOut = Math.max(0, 1 - (t - 0.8) * 5); // çµ‚äº†æ™‚ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
                            const opacity = fadeIn * fadeOut * particle.userData.originalOpacity;
                            
                            // ãƒ‘ãƒ«ã‚¹åŠ¹æœ
                            const pulse = Math.sin(time * 0.01 + particle.userData.pulsePhase) * 0.2 + 0.8;
                            particle.material.opacity = opacity * pulse;
                            
                            // ã‚µã‚¤ã‚ºå¤‰åŒ–ï¼ˆç¾ã—ã„è¼ãï¼‰
                            const scale = 1 + Math.sin(time * 0.02 + particle.userData.pulsePhase) * 0.3;
                            particle.scale.setScalar(scale);
                            
                        } else {
                            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãŒç›®æ¨™ã«åˆ°é”ã€æ¥ç¶šåŠ¹æœã‚’è¡¨ç¤º
                            this.showConnectionEffect(stream.targetCore, intensity);
                            this.resetParticle(particle);
                        }
                    });
                    
                    // ç›®æ¨™ã‚³ã‚¢ã®å›è»¢ãƒ»å‘¼å¸ãƒ»ä½ç½®ç§»å‹•ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
                    const targetCore = stream.targetCore;
                    if (targetCore && targetCore.core && targetCore.glow) {
                        // å„ã‚³ã‚¢ã®ç‹¬ç«‹ã—ãŸå›è»¢
                        targetCore.core.rotation.x += targetCore.core.userData.rotationSpeed.x;
                        targetCore.core.rotation.y += targetCore.core.userData.rotationSpeed.y;
                        targetCore.core.rotation.z += targetCore.core.userData.rotationSpeed.z;
                        
                        targetCore.glow.rotation.x += targetCore.glow.userData.rotationSpeed.x;
                        targetCore.glow.rotation.y += targetCore.glow.userData.rotationSpeed.y;
                        targetCore.glow.rotation.z += targetCore.glow.userData.rotationSpeed.z;
                        
                        // è‡ªå¾‹çš„ä½ç½®ç§»å‹•ï¼ˆä»–è€…ã®å‹•ãï¼‰
                        const movementTime = time * 0.001;
                        const coreData = targetCore.core.userData;
                        
                        // å„è»¸ã§ç‹¬ç«‹ã—ãŸä¸‰è§’é–¢æ•°ã«ã‚ˆã‚‹æ»‘ã‚‰ã‹ãªç§»å‹•
                        const offsetX = Math.sin(movementTime * coreData.movementSpeed.x * 10 + coreData.movementPhase.x) * coreData.movementRadius.x;
                        const offsetY = Math.sin(movementTime * coreData.movementSpeed.y * 10 + coreData.movementPhase.y) * coreData.movementRadius.y;
                        const offsetZ = Math.cos(movementTime * coreData.movementSpeed.z * 10 + coreData.movementPhase.z) * coreData.movementRadius.z;
                        
                        // è·é›¢å¤‰å‹•ï¼ˆè¿‘ããªã£ãŸã‚Šé ããªã£ãŸã‚Šï¼‰- ã‚ˆã‚Šé¡•è‘—ãªå¤‰åŒ–
                        const distanceModulation = Math.sin(movementTime * 0.5 + coreData.pulsePhase) * 0.3 + 1;
                        const finalDistanceMultiplier = coreData.distanceVariation * distanceModulation;
                        
                        // æ–°ã—ã„ä½ç½®ã‚’è¨ˆç®—
                        const newPosition = coreData.basePosition.clone();
                        newPosition.multiplyScalar(finalDistanceMultiplier);
                        newPosition.add(new THREE.Vector3(offsetX, offsetY, offsetZ));
                        
                        // ã‚³ã‚¢ã¨ã‚°ãƒ­ãƒ¼ã®ä½ç½®ã‚’æ›´æ–°
                        targetCore.core.position.copy(newPosition);
                        targetCore.glow.position.copy(newPosition);
                        
                        // targetCoreã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½ç½®æƒ…å ±ã‚‚æ›´æ–°ï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«è»Œé“è¨ˆç®—ç”¨ï¼‰
                        targetCore.position.copy(newPosition);
                        
                        // å‘¼å¸ã®ã‚ˆã†ãªè„ˆå‹•åŠ¹æœï¼ˆè‡ªå¾‹çš„ç”Ÿå‘½æ„Ÿï¼‰
                        const pulse = Math.sin(time * 0.001 * targetCore.core.userData.pulseSpeed + targetCore.core.userData.pulsePhase);
                        const breathingScale = targetCore.core.userData.baseScale + pulse * 0.15;
                        const breathingGlowScale = targetCore.glow.userData.baseScale + pulse * 0.2;
                        
                        targetCore.core.scale.setScalar(breathingScale);
                        targetCore.glow.scale.setScalar(breathingGlowScale);
                        
                        // è‰²ã®å¾®å¦™ãªå¤‰åŒ–ï¼ˆæ´»å‹•æ„Ÿã‚’è¡¨ç¾ï¼‰- å„ã‚³ã‚¢ã®å€‹åˆ¥è‰²ã‚’ç¶­æŒ
                        const colorVariation = (Math.sin(time * 0.002 + targetCore.core.userData.pulsePhase) + 1) * 0.1;
                        const originalColor = targetCore.core.userData.originalColor || targetCore.core.material.color.clone();
                        
                        // åˆå›æ™‚ã«å…ƒã®è‰²ã‚’ä¿å­˜
                        if (!targetCore.core.userData.originalColor) {
                            targetCore.core.userData.originalColor = targetCore.core.material.color.clone();
                        }
                        
                        const enhancedColor = originalColor.clone();
                        enhancedColor.multiplyScalar(1 + colorVariation);
                        targetCore.core.material.color.copy(enhancedColor);
                    }
                    
                    // ç›®æ¨™ã‚³ã‚¢ã®ã‚°ãƒ­ãƒ¼åŠ¹æœæ›´æ–°
                    if (stream.targetCore && stream.targetCore.glow) {
                        const glowPulse = Math.sin(time * 0.005 + streamIndex) * 0.3 + 0.7;
                        stream.targetCore.glow.material.opacity = 0.2 * glowPulse;
                        stream.targetCore.glow.scale.setScalar(1 + glowPulse * 0.2);
                    }
                });
                
                // ãƒŸãƒ‹ãƒ¬ãƒ¼ãƒ€ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ã®æ›´æ–°
                this.miniRadars.forEach(miniRadar => {
                    miniRadar.update(time);
                });
            }
            
            startTransmission(stream, intensity) {
                // éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’é¸ã‚“ã§ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
                const inactiveParticles = stream.particles.filter(p => !p.userData.active);
                if (inactiveParticles.length === 0) return;
                
                // åŒæ™‚ã«ç™ºå°„ã™ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°ï¼ˆ3-7å€‹ï¼‰
                const burstCount = Math.floor(3 + Math.random() * 5);
                
                for (let i = 0; i < Math.min(burstCount, inactiveParticles.length); i++) {
                    const particle = inactiveParticles[i];
                    particle.userData.active = true;
                    particle.userData.progress = 0;
                    particle.position.set(0, 0, 0); // ã‚³ã‚¢ã®ä¸­å¤®ã‹ã‚‰é–‹å§‹
                    
                    // ãƒ©ãƒ³ãƒ€ãƒ ãªè‰²ã‚’å‰²ã‚Šå½“ã¦
                    const randomColor = intensity.particleColors[Math.floor(Math.random() * intensity.particleColors.length)];
                    particle.material.color.setHex(randomColor);
                }
            }
            
            showConnectionEffect(targetCore, intensity) {
                if (!targetCore || !targetCore.core) return;
                
                // æ¥ç¶šæˆåŠŸã®ç¬é–“çš„ãƒ•ãƒ©ãƒƒã‚·ãƒ¥åŠ¹æœ
                const originalOpacity = targetCore.core.material.opacity;
                targetCore.core.material.opacity = 1.0;
                
                setTimeout(() => {
                    if (targetCore.core && targetCore.core.material) {
                        targetCore.core.material.opacity = originalOpacity;
                    }
                }, 200);
                
                // ã‚°ãƒ­ãƒ¼ã®ä¸€æ™‚çš„å¼·åŒ–
                if (targetCore.glow) {
                    const originalGlowOpacity = targetCore.glow.material.opacity;
                    targetCore.glow.material.opacity = 0.8;
                    targetCore.glow.scale.setScalar(1.5);
                    
                    setTimeout(() => {
                        if (targetCore.glow && targetCore.glow.material) {
                            targetCore.glow.material.opacity = originalGlowOpacity;
                            targetCore.glow.scale.setScalar(1.0);
                        }
                    }, 400);
                }
            }
            
            resetParticle(particle) {
                particle.userData.active = false;
                particle.userData.progress = 0;
                particle.material.opacity = 0;
                particle.scale.setScalar(1);
                particle.position.set(0, 0, 0);
            }
            
            cleanup() {
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                this.particleStreams.forEach(stream => {
                    if (stream.group) {
                        stream.particles.forEach(particle => {
                            particle.geometry.dispose();
                            particle.material.dispose();
                        });
                        this.scene.remove(stream.group);
                    }
                });
                
                // ç›®æ¨™ã‚³ã‚¢ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                this.targetCores.forEach(targetCore => {
                    if (targetCore.core) {
                        this.scene.remove(targetCore.core);
                        targetCore.core.geometry.dispose();
                        targetCore.core.material.dispose();
                    }
                    if (targetCore.glow) {
                        this.scene.remove(targetCore.glow);
                        targetCore.glow.geometry.dispose();
                        targetCore.glow.material.dispose();
                    }
                });
                
                this.particleStreams = [];
                this.targetCores = [];
                this.connectionPaths = [];
                this.transmissionActive = {};
                
                // ãƒŸãƒ‹ãƒ¬ãƒ¼ãƒ€ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                this.miniRadars.forEach(miniRadar => {
                    miniRadar.cleanup();
                });
                this.miniRadars = [];
            }
        }
        
        class CoreGeometryManager {
            constructor() {
                this.currentGeometry = null;
                this.transitionDuration = 2000; // 2ç§’ã®ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³
            }

            createPolyhedronGeometry(stage) {
                // æ®µéšã«å¿œã˜ãŸã‚µã‚¤ã‚ºã®æ±ºå®š
                const baseSize = this.getStageSize(stage);
                
                switch(stage) {
                    case 'Ea':
                    case 'Eb': 
                    case 'Ec':
                        // æ­£å››é¢ä½“ (Tetrahedron) - External AuthorityæœŸ
                        return new THREE.TetrahedronGeometry(baseSize);
                        
                    case 'EI':
                    case 'E-I':
                    case 'I-E':
                        // æ­£å…«é¢ä½“ (Octahedron) - TransitionæœŸ
                        return new THREE.OctahedronGeometry(baseSize);
                        
                    case 'IE':
                    case 'Ia':
                        // æ­£åäºŒé¢ä½“ (Dodecahedron) - Internal FoundationæœŸ
                        return new THREE.DodecahedronGeometry(baseSize);
                        
                    case 'Ib':
                    case 'Ic':
                        // æ­£äºŒåé¢ä½“ (Icosahedron) - Self-AuthorshipæœŸ
                        return new THREE.IcosahedronGeometry(baseSize);
                        
                    default:
                        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æ­£å››é¢ä½“
                        return new THREE.TetrahedronGeometry(baseSize);
                }
            }

            getStageSize(stage) {
                // æˆé•·ã«å¿œã˜ãŸã‚µã‚¤ã‚ºãƒãƒƒãƒ”ãƒ³ã‚°
                const sizeMap = {
                    // External AuthorityæœŸ - å°ã•ãã€æœªç™ºé”
                    'Ea': 0.35,  // æœ€å°ã‚µã‚¤ã‚º
                    'Eb': 0.4,   // å°‘ã—æˆé•·
                    'Ec': 0.45,  // ç–‘å•ã®å…†ã—
                    
                    // TransitionæœŸ - ä¸­ç¨‹åº¦ã€æ¢æ±‚æœŸ
                    'EI': 0.5,   // å†…çš„æ¢æ±‚ã®å§‹ã¾ã‚Š
                    'E-I': 0.55, // å†…ãªã‚‹å£°ã®æ§‹ç¯‰
                    'I-E': 0.6,  // å†…ãªã‚‹å£°ã‚’è´ã
                    
                    // Internal FoundationæœŸ - å¤§ããã€ç¢ºç«‹æœŸ
                    'IE': 0.65,  // å†…ãªã‚‹å£°ã‚’è‚²ã‚€
                    'Ia': 0.7,   // å†…ãªã‚‹å£°ã‚’ä¿¡é ¼
                    
                    // Self-AuthorshipæœŸ - æœ€å¤§ã€çµ±åˆæœŸ
                    'Ib': 0.75,  // å†…ãªã‚‹åŸºç›¤ç¢ºç«‹
                    'Ic': 0.8    // æœ€å¤§ã‚µã‚¤ã‚ºã€å®Œå…¨ãªçµ±åˆ
                };
                
                return sizeMap[stage] || 0.35; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æœ€å°ã‚µã‚¤ã‚º
            }

            getSizeDescription(stage) {
                const size = this.getStageSize(stage);
                const percentage = Math.round((size / 0.8) * 100); // æœ€å¤§ã‚µã‚¤ã‚ºã‚’100%ã¨ã—ã¦
                return `ã‚µã‚¤ã‚º: ${percentage}% (${size.toFixed(2)})`;
            }

            getPolyhedronName(stage) {
                const shapeName = this.getShapeName(stage);
                const sizeInfo = this.getSizeDescription(stage);
                return `${shapeName} - ${sizeInfo}`;
            }

            getShapeName(stage) {
                switch(stage) {
                    case 'Ea': case 'Eb': case 'Ec':
                        return 'Tetrahedron (æ­£å››é¢ä½“)';
                    case 'EI': case 'E-I': case 'I-E':
                        return 'Octahedron (æ­£å…«é¢ä½“)';
                    case 'IE': case 'Ia':
                        return 'Dodecahedron (æ­£åäºŒé¢ä½“)';
                    case 'Ib': case 'Ic':
                        return 'Icosahedron (æ­£äºŒåé¢ä½“)';
                    default:
                        return 'Tetrahedron (æ­£å››é¢ä½“)';
                }
            }

            createWireframeGeometry(geometry) {
                // ã‚¨ãƒƒã‚¸ã®ã¿ã‚’è¡¨ç¤ºï¼ˆé¢ã®å†…éƒ¨ã®å¯¾è§’ç·šã‚’é™¤å»ï¼‰
                // thresholdAngleã‚’è¨­å®šã—ã¦ã€éš£æ¥ã™ã‚‹é¢ã®è§’åº¦ãŒä¸€å®šä»¥ä¸Šã®å ´åˆã®ã¿ã‚¨ãƒƒã‚¸ã¨ã—ã¦èªè­˜
                const edges = new THREE.EdgesGeometry(geometry, 40); // 40åº¦ã®è§’åº¦é–¾å€¤
                return edges;
            }
        }

        class RefinedSelfAuthorshipVisualization {
            constructor() {
                this.container = null;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.currentStage = 'Ea';
                this.isInitialized = false;
                this.isInitializing = false;
                this.animationFrameId = null;
                this.particles = [];
                this.core = null;
                this.coreLight = null;                // ã‚³ã‚¢ç™ºå…‰ãƒ©ã‚¤ãƒˆ
                this.baseCoreIntensity = 0.3;         // ã‚³ã‚¢ã®åŸºæœ¬å…‰é‡
                this.currentCoreIntensity = 0.3;      // ç¾åœ¨ã®ã‚³ã‚¢å…‰é‡
                this.maxCoreIntensity = 1.5;          // æœ€å¤§ã‚³ã‚¢å…‰é‡
                this.absorptionCount = 0;             // å¸åã•ã‚ŒãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°
                // æ–°ã—ã„æ¬¡å…ƒåŠ¹æœã‚·ã‚¹ãƒ†ãƒ 
                this.lightningDimension = null;      // æ¬¡å…ƒ1: ç¨²å…‰ã‚·ã‚¹ãƒ†ãƒ 
                this.radarDimension = null;          // æ¬¡å…ƒ2: ãƒ¬ãƒ¼ãƒ€ãƒ¼ã‚·ã‚¹ãƒ†ãƒ   
                this.beamDimension = null;           // æ¬¡å…ƒ3: å…‰ç·šã‚·ã‚¹ãƒ†ãƒ 
                this.controls = null;
                
                // èª¬æ˜è¡¨ç¤ºã‚·ã‚¹ãƒ†ãƒ 
                this.explanationSystem = null;      // èª¬æ˜è¡¨ç¤ºã‚·ã‚¹ãƒ†ãƒ 
                
                // å¤šé¢ä½“ã‚·ã‚¹ãƒ†ãƒ 
                this.coreGeometryManager = new CoreGeometryManager();
                this.isTransitioning = false;        // å½¢çŠ¶å¤‰æ›´ä¸­ãƒ•ãƒ©ã‚°
                
                // æ®µéšçš„å…‰å¼·åŒ–ã‚·ã‚¹ãƒ†ãƒ  - ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã«å¿œã˜ãŸã‚³ã‚¢å…‰ã®ç™ºé”
                this.lightVeils = [];                 // å…‰ã®ãƒ™ãƒ¼ãƒ«é…åˆ—
                this.stageProgressionOrder = ['I-E', 'IE', 'Ia', 'Ib', 'Ic']; // å…‰ã®ãƒ™ãƒ¼ãƒ«ãŒå‡ºç¾ã™ã‚‹ã‚¹ãƒ†ãƒ¼ã‚¸é †
                this.currentStageIndex = 0;           // ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
                
                // å…‰ã®ãƒ™ãƒ¼ãƒ«ãŒè¡¨ç¤ºã•ã‚Œãªã„ã‚¹ãƒ†ãƒ¼ã‚¸ã®ãƒªã‚¹ãƒˆ
                this.noLightVeilStages = ['Ea', 'Eb', 'Ec', 'EI', 'E-I'];
                
                // I(E)ã‚¹ãƒ†ãƒ¼ã‚¸ä»¥é™ã®å…‰ç·šæ¥ç¶šã‚·ã‚¹ãƒ†ãƒ 
                this.connectionLines = [];            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é–“ã®æ¥ç¶šç·š
                this.connectionPairs = new Map();     // æ¥ç¶šãƒšã‚¢ã®ç®¡ç†
                this.maxConnections = 45;             // æœ€å¤§æ¥ç¶šæ•°ï¼ˆIcã‚¹ãƒ†ãƒ¼ã‚¸ã®æ¥µã‚ã¦è±Šå¯Œãªæ¥ç¶šã«å¯¾å¿œï¼‰
                this.connectionUpdateInterval = 10000; // æ¥ç¶šæ›´æ–°é–“éš”ï¼ˆãƒŸãƒªç§’ï¼‰- çµŒé¨“ã®çµã³ã¤ãã‚’é•·æ™‚é–“ç¶­æŒ
                this.lastConnectionUpdate = 0;        // æœ€å¾Œã®æ¥ç¶šæ›´æ–°æ™‚åˆ»
                
                // æ¥ç¶šç·šã®ãƒ•ã‚§ãƒ¼ãƒ‰åŠ¹æœã‚·ã‚¹ãƒ†ãƒ 
                this.isConnectionTransitioning = false; // æ¥ç¶šç·šé·ç§»ä¸­ãƒ•ãƒ©ã‚°
                this.fadeOutDuration = 1500;           // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆæœŸé–“ï¼ˆãƒŸãƒªç§’ï¼‰
                this.fadeInDuration = 1500;            // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³æœŸé–“ï¼ˆãƒŸãƒªç§’ï¼‰
                this.transitionStartTime = 0;          // é·ç§»é–‹å§‹æ™‚åˆ»
                this.pendingConnections = [];          // æ¬¡ã®æ¥ç¶šãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå¾…æ©Ÿä¸­ï¼‰
                this.transitionPhase = 'none';         // é·ç§»ãƒ•ã‚§ãƒ¼ã‚º: 'none', 'fadeOut', 'fadeIn'
                
                // ã‚¹ãƒ†ãƒ¼ã‚¸åˆ¥æ¥ç¶šåˆ¶é™ - ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã«å¿œã˜ãŸçµŒé¨“çµ±åˆèƒ½åŠ›ã®ç™ºé”
                this.stageConnectionLimits = {
                    'IE': 3,      // IEã‚¹ãƒ†ãƒ¼ã‚¸ï¼šå†…ãªã‚‹å£°ã‚’è‚²ã‚€æ®µéš - å°‘ãªã„æ¥ç¶š
                    'Ia': 8,      // Iaã‚¹ãƒ†ãƒ¼ã‚¸ï¼šéå»ã®æ„å‘³ã¥ã‘æ®µéš - åŸºç¤çš„ãªæ¥ç¶š
                    'Ib': 18,      // Ibã‚¹ãƒ†ãƒ¼ã‚¸ï¼šçµ±åˆã®åŸºç›¤æ®µéš - ä¸­ç¨‹åº¦ã®æ¥ç¶š
                    'Ic': 32      // Icã‚¹ãƒ†ãƒ¼ã‚¸ï¼šç™ºè¦‹ã¨æ°—ã¥ãæ®µéš - æ¥µã‚ã¦è±Šå¯Œãªæ¥ç¶šï¼ˆåºƒç¯„å›²ãªçµŒé¨“çµ±åˆãƒ»å®Œå…¨ãªã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒ³ãƒˆï¼‰
                };
                
                // Zoom controls
                this.defaultCameraZ = 10;
                this.minZoom = 3;
                this.maxZoom = 20;
                this.zoomSpeed = 0.1;
                
                // ã‚«ãƒ¡ãƒ©å›è»¢åˆ¶å¾¡ï¼ˆè¦‹å›ã—åŠ¹æœç”¨ï¼‰
                this.cameraRotationAngle = 0; // ç¾åœ¨ã®ã‚«ãƒ¡ãƒ©å›è»¢è§’åº¦
                this.baseLookAtTarget = { x: 0, y: 0, z: 0 }; // åŸºæº–ã¨ãªã‚‹æ³¨è¦–ç‚¹
                this.lookAroundRadius = 8; // è¦‹å›ã—æ™‚ã®è¦–ç·šåŠå¾„ï¼ˆæ§ãˆã‚ã«ï¼‰
                this.lastCameraRotationAngle = 0; // å‰å›ã®è§’åº¦ï¼ˆã‚¹ãƒ ãƒ¼ã‚ºè£œé–“ç”¨ï¼‰
                
                // Dynamic particle management for questioning stage
                this.dynamicParticles = [];
                this.lastParticleSpawn = 0;
                this.persistentParticleIndices = new Set();
                
                // Colorful particle system for I(E) stages and beyond
                this.colorfulParticlePalette = [
                    0xff6b6b, 0x4ecdc4, 0x45b7d1, 0x96c93d, 0xffeaa7,
                    0xdda0dd, 0x98d8c8, 0xf7dc6f, 0xbb8fce, 0x85c1e9,
                    0xf8c471, 0x82e0aa, 0xf1948a, 0x85c1e9, 0xc39bd3,
                    0x7fb3d3, 0xaed6f1, 0xf9e79f, 0xa3e4d7, 0xd7bde2
                ];
                this.colorTransitionSpeed = 0.05;
                
                // I-E Stage Particle Emergence System
                this.isEmergingIE = false;           // I-Eå‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ãƒ•ãƒ©ã‚°
                this.emergenceStartTime = 0;         // å‡ºç¾é–‹å§‹æ™‚åˆ»
                this.emergenceDelay = 500;           // åˆ‡ã‚Šæ›¿ãˆå¾Œã®é…å»¶ï¼ˆmsï¼‰
                this.emergenceDuration = 2500;       // å…¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å‡ºç¾æœŸé–“ï¼ˆmsï¼‰
                this.particleEmergenceInterval = 100; // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é–“å‡ºç¾é–“éš”ï¼ˆmsï¼‰
                this.emergingParticles = [];         // å‡ºç¾ä¸­ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒªã‚¹ãƒˆ
                this.emergenceTransitionStarted = false; // å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é·ç§»é–‹å§‹ãƒ•ãƒ©ã‚°
                this.emergenceTransitionTime = 0;    // é·ç§»é–‹å§‹æ™‚åˆ»
                
                // åœ°é¢ç§»å‹•ã‚·ã‚¹ãƒ†ãƒ  - ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®äººç”Ÿã®æ—…è·¯è¡¨ç¾
                this.groundMovementSystem = null;   // åœ°é¢ç§»å‹•ã‚·ã‚¹ãƒ†ãƒ 
                this.isGroundActive = false;        // åœ°é¢ã‚·ã‚¹ãƒ†ãƒ ã®æœ‰åŠ¹çŠ¶æ…‹
            }
            
            async init(containerId) {
                if (this.isInitialized || this.isInitializing) return;
                this.isInitializing = true;
                
                console.log('ğŸš€ 3Dç’°å¢ƒåˆæœŸåŒ–é–‹å§‹');
                console.log('ğŸ“‹ ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±:', {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    hardwareConcurrency: navigator.hardwareConcurrency,
                    language: navigator.language
                });
                
                this.container = document.getElementById(containerId);
                if (!this.container) {
                    console.error('âŒ ã‚³ãƒ³ãƒ†ãƒŠãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:', containerId);
                    this.showError();
                    this.isInitializing = false;
                    return;
                }
                
                console.log('âœ… ã‚³ãƒ³ãƒ†ãƒŠãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ:', {
                    id: containerId,
                    width: this.container.offsetWidth,
                    height: this.container.offsetHeight
                });
                
                // WebGLã‚µãƒãƒ¼ãƒˆã®ç¢ºèª
                console.log('ğŸ” WebGLå¯¾å¿œã‚’ãƒã‚§ãƒƒã‚¯ä¸­...');
                if (!this.checkWebGLSupport()) {
                    console.error('âŒ WebGLãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“');
                    this.showError();
                    this.isInitializing = false;
                    return;
                }
                console.log('âœ… WebGLå¯¾å¿œã‚’ç¢ºèªã—ã¾ã—ãŸ');
                
                this.showLoading();
                
                try {
                    console.log('ğŸ¬ 3Dã‚·ãƒ¼ãƒ³ä½œæˆä¸­...');
                    await this.createScene();
                    console.log('âœ… 3Dã‚·ãƒ¼ãƒ³ä½œæˆå®Œäº†');
                    
                    console.log('ğŸ® ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ä½œæˆä¸­...');
                    this.createControls();
                    console.log('âœ… ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ä½œæˆå®Œäº†');
                    
                    console.log('ğŸ”— ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒ‰ä¸­...');
                    this.bindEvents();
                    console.log('âœ… ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒ‰å®Œäº†');
                    
                    console.log('â–¶ï¸ ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹...');
                    this.startAnimation();
                    console.log('âœ… ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹å®Œäº†');
                    
                    this.hideLoading();
                    this.isInitialized = true;
                    console.log('ğŸ‰ 3Dç’°å¢ƒã®åˆæœŸåŒ–ãŒå®Œäº†ã—ã¾ã—ãŸ');
                } catch (error) {
                    console.error('3DåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
                    console.error('ã‚¨ãƒ©ãƒ¼è©³ç´°:', error.message);
                    console.error('ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹:', error.stack);
                    this.showError();
                } finally {
                    this.isInitializing = false;
                }
            }
            
            // WebGLã‚µãƒãƒ¼ãƒˆã®ç¢ºèªï¼ˆæ”¹è‰¯ç‰ˆï¼‰
            isWebGLSupported() {
                try {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('webgl2') || 
                                   canvas.getContext('webgl') || 
                                   canvas.getContext('experimental-webgl');
                    
                    if (!context) {
                        console.warn('WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ä½œæˆã«å¤±æ•—');
                        return false;
                    }
                    
                    // åŸºæœ¬çš„ãªWebGLæ©Ÿèƒ½ã‚’ãƒ†ã‚¹ãƒˆ
                    const renderer = context.getParameter(context.RENDERER);
                    const vendor = context.getParameter(context.VENDOR);
                    
                    console.log('WebGLæƒ…å ±:', { renderer, vendor });
                    
                    // ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®æ¤œå‡º
                    if (renderer && (
                        renderer.toLowerCase().includes('software') ||
                        renderer.toLowerCase().includes('llvmpipe') ||
                        renderer.toLowerCase().includes('mesa')
                    )) {
                        console.warn('ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ');
                    }
                    
                    return true;
                } catch (e) {
                    console.error('WebGLå¯¾å¿œãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼:', e);
                    return false;
                }
            }
            
            // WebGLãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ä½œæˆï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¯¾å¿œï¼‰
            createWebGLRenderer() {
                const rendererOptions = [
                    // æœ€é«˜å“è³ªè¨­å®š
                    { 
                        antialias: true, 
                        alpha: false, 
                        powerPreference: 'high-performance',
                        precision: 'highp'
                    },
                    // ä¸­å“è³ªè¨­å®š
                    { 
                        antialias: true, 
                        alpha: false, 
                        powerPreference: 'default'
                    },
                    // ä½å“è³ªè¨­å®š
                    { 
                        antialias: false, 
                        alpha: false, 
                        powerPreference: 'low-power'
                    },
                    // æœ€å°è¨­å®š
                    { 
                        antialias: false
                    }
                ];
                
                for (let i = 0; i < rendererOptions.length; i++) {
                    try {
                        console.log(`WebGLãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ä½œæˆè©¦è¡Œ ${i + 1}/${rendererOptions.length}`, rendererOptions[i]);
                        const renderer = new THREE.WebGLRenderer(rendererOptions[i]);
                        
                        // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ãƒ†ã‚¹ãƒˆ
                        const context = renderer.getContext();
                        if (context) {
                            console.log('WebGLãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ãŒæ­£å¸¸ã«ä½œæˆã•ã‚Œã¾ã—ãŸ');
                            return renderer;
                        }
                    } catch (e) {
                        console.warn(`ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ä½œæˆå¤±æ•— (è©¦è¡Œ ${i + 1}):`, e);
                        continue;
                    }
                }
                
                console.error('ã™ã¹ã¦ã®WebGLãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ä½œæˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒå¤±æ•—ã—ã¾ã—ãŸ');
                return null;
            }

            // WebGLã‚µãƒãƒ¼ãƒˆã®ç¢ºèªï¼ˆæ—§ç‰ˆ - äº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
            checkWebGLSupport() {
                return this.isWebGLSupported();
            }

            showLoading() {
                const loading = document.getElementById('refined-3d-loading');
                if (loading) loading.style.display = 'flex';
            }
            
            hideLoading() {
                const loading = document.getElementById('refined-3d-loading');
                const controls = document.getElementById('refined-3d-controls');
                if (loading) loading.style.display = 'none';
                if (controls) controls.style.display = 'block';
            }
            
            showError() {
                const loading = document.getElementById('refined-3d-loading');
                if (loading) {
                    // WebGLè¨ºæ–­æƒ…å ±ã‚’å–å¾—
                    const diagnostics = this.getWebGLDiagnostics();
                    
                    loading.innerHTML = `
                        <div style="text-align: center; color: #ff6b6b; max-width: 700px; margin: 0 auto;">
                            <h4>ğŸš« 3Dè¡¨ç¤ºã‚¨ãƒ©ãƒ¼</h4>
                            <p>3Dè¡¨ç¤ºã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</p>
                            
                            <div style="background: #1a1a1a; padding: 15px; border-radius: 8px; margin: 15px 0; text-align: left;">
                                <h5 style="color: #ffd700; margin-top: 0;">ğŸ” è¨ºæ–­æƒ…å ±</h5>
                                <ul style="color: #ccc; line-height: 1.6; font-size: 13px;">
                                    <li><strong>WebGLå¯¾å¿œ:</strong> ${diagnostics.webglSupported ? 'âœ… å¯¾å¿œ' : 'âŒ éå¯¾å¿œ'}</li>
                                    ${diagnostics.webglVersion ? `<li><strong>WebGLãƒãƒ¼ã‚¸ãƒ§ãƒ³:</strong> ${diagnostics.webglVersion}</li>` : ''}
                                    <li><strong>ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã‚¢ã‚¯ã‚»ãƒ©ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³:</strong> ${diagnostics.hardwareAccelerated ? 'âœ… æœ‰åŠ¹' : 'âš ï¸ ç„¡åŠ¹ã®å¯èƒ½æ€§'}</li>
                                    <li><strong>ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼:</strong> ${diagnostics.renderer || 'ä¸æ˜'}</li>
                                    <li><strong>ãƒ™ãƒ³ãƒ€ãƒ¼:</strong> ${diagnostics.vendor || 'ä¸æ˜'}</li>
                                    ${diagnostics.maxTextureSize ? `<li><strong>æœ€å¤§ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚º:</strong> ${diagnostics.maxTextureSize}px</li>` : ''}
                                    <li><strong>å¯¾å¿œæ‹¡å¼µæ©Ÿèƒ½:</strong> ${diagnostics.extensions.length}å€‹</li>
                                    <li><strong>ãƒ–ãƒ©ã‚¦ã‚¶:</strong> ${this.getBrowserInfo()}</li>
                                    ${diagnostics.errors.length > 0 ? `<li style="color: #ff6b6b;"><strong>ã‚¨ãƒ©ãƒ¼:</strong><br>${diagnostics.errors.join('<br>')}</li>` : ''}
                                </ul>
                            </div>
                            
                            <div style="background: #2a1a1a; padding: 15px; border-radius: 8px; margin: 15px 0; text-align: left;">
                                <h5 style="color: #ffd700; margin-top: 0;">ğŸ’¡ ã‚ˆãã‚ã‚‹åŸå› ã¨è§£æ±ºæ–¹æ³•</h5>
                                <div style="color: #ccc; line-height: 1.6; font-size: 13px;">
                                    <h6 style="color: #4ecdc4; margin: 10px 0 5px 0;">ğŸ”„ ã™ãã«è©¦ã›ã‚‹æ–¹æ³•:</h6>
                                    <ol>
                                        <li><strong>ãƒ–ãƒ©ã‚¦ã‚¶ã®å®Œå…¨å†èµ·å‹•</strong> (å…¨ã¦ã®ã‚¿ãƒ–ã‚’é–‰ã˜ã¦å†èµ·å‹•)</li>
                                        <li><strong>ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆ/ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¢ãƒ¼ãƒ‰</strong>ã§è©¦è¡Œ</li>
                                        <li><strong>ä»–ã®GPUé›†ç´„çš„ã‚¢ãƒ—ãƒª</strong>ã‚’çµ‚äº†</li>
                                        <li><strong>ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢</strong></li>
                                    </ol>
                                    
                                    <h6 style="color: #4ecdc4; margin: 15px 0 5px 0;">âš™ï¸ è¨­å®šã®ç¢ºèª:</h6>
                                    <ol start="5">
                                        <li><strong>Chrome:</strong> chrome://settings/system â†’ ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã‚¢ã‚¯ã‚»ãƒ©ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æœ‰åŠ¹</li>
                                        <li><strong>Firefox:</strong> about:config â†’ webgl.disabled = false</li>
                                        <li><strong>Safari:</strong> é–‹ç™ºãƒ¡ãƒ‹ãƒ¥ãƒ¼ â†’ WebGLã‚’æœ‰åŠ¹ã«ã™ã‚‹</li>
                                    </ol>
                                    
                                    <h6 style="color: #4ecdc4; margin: 15px 0 5px 0;">ğŸ› ï¸ ã‚·ã‚¹ãƒ†ãƒ é–¢é€£:</h6>
                                    <ol start="8">
                                        <li><strong>ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ãƒ‰ãƒ©ã‚¤ãƒãƒ¼</strong>ã‚’æœ€æ–°ç‰ˆã«æ›´æ–°</li>
                                        <li><strong>OS ã®æ›´æ–°</strong>ã‚’ç¢ºèª</li>
                                        <li><strong>åˆ¥ã®ãƒ–ãƒ©ã‚¦ã‚¶</strong>ã§è©¦è¡Œ (Chromeæ¨å¥¨)</li>
                                    </ol>
                                </div>
                            </div>
                            
                            <div style="margin-top: 20px;">
                                <button onclick="location.reload()" style="padding: 12px 24px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; margin-right: 10px; font-size: 14px;">
                                    ğŸ”„ å†èª­ã¿è¾¼ã¿
                                </button>
                                <button onclick="window.open('https://get.webgl.org/', '_blank')" style="padding: 12px 24px; background: #6b7280; color: white; border: none; border-radius: 6px; cursor: pointer; margin-right: 10px; font-size: 14px;">
                                    ğŸ”— WebGLãƒ†ã‚¹ãƒˆ
                                </button>
                                <button onclick="navigator.clipboard?.writeText(JSON.stringify(${JSON.stringify(diagnostics)}, null, 2))" style="padding: 12px 24px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px;">
                                    ğŸ“‹ è¨ºæ–­æƒ…å ±ã‚³ãƒ”ãƒ¼
                                </button>
                            </div>
                            
                            <div style="margin-top: 15px; font-size: 12px; color: #888;">
                                ğŸ’¡ å•é¡ŒãŒè§£æ±ºã—ãªã„å ´åˆã¯ã€è¨ºæ–­æƒ…å ±ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦æŠ€è¡“ã‚µãƒãƒ¼ãƒˆã«ãŠå•ã„åˆã‚ã›ãã ã•ã„
                            </div>
                        </div>
                    `;
                }
            }
            
            // ãƒ–ãƒ©ã‚¦ã‚¶æƒ…å ±ã‚’å–å¾—
            getBrowserInfo() {
                const ua = navigator.userAgent;
                if (ua.includes('Chrome') && !ua.includes('Edg')) {
                    return 'Chrome';
                } else if (ua.includes('Firefox')) {
                    return 'Firefox';
                } else if (ua.includes('Safari') && !ua.includes('Chrome')) {
                    return 'Safari';
                } else if (ua.includes('Edg')) {
                    return 'Edge';
                } else {
                    return 'ãã®ä»–';
                }
            }
            
            // WebGLè¨ºæ–­æƒ…å ±ã‚’å–å¾—ï¼ˆæ‹¡å¼µç‰ˆï¼‰
            getWebGLDiagnostics() {
                const diagnostics = {
                    webglSupported: false,
                    hardwareAccelerated: false,
                    renderer: null,
                    vendor: null,
                    userAgent: navigator.userAgent,
                    webglVersion: null,
                    maxTextureSize: null,
                    maxRenderBufferSize: null,
                    extensions: [],
                    errors: []
                };
                
                try {
                    const canvas = document.createElement('canvas');
                    let gl = null;
                    
                    // WebGL2ã‚’è©¦è¡Œ
                    try {
                        gl = canvas.getContext('webgl2');
                        if (gl) {
                            diagnostics.webglVersion = 'WebGL 2.0';
                            diagnostics.webglSupported = true;
                        }
                    } catch (e) {
                        diagnostics.errors.push('WebGL2ä½œæˆã‚¨ãƒ©ãƒ¼: ' + e.message);
                    }
                    
                    // WebGL2ãŒå¤±æ•—ã—ãŸå ´åˆã€WebGL1ã‚’è©¦è¡Œ
                    if (!gl) {
                        try {
                            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                            if (gl) {
                                diagnostics.webglVersion = 'WebGL 1.0';
                                diagnostics.webglSupported = true;
                            }
                        } catch (e) {
                            diagnostics.errors.push('WebGL1ä½œæˆã‚¨ãƒ©ãƒ¼: ' + e.message);
                        }
                    }
                    
                    if (gl) {
                        try {
                            // åŸºæœ¬æƒ…å ±ã‚’å–å¾—
                            diagnostics.renderer = gl.getParameter(gl.RENDERER);
                            diagnostics.vendor = gl.getParameter(gl.VENDOR);
                            diagnostics.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                            diagnostics.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
                            
                            // æ‹¡å¼µæ©Ÿèƒ½ä¸€è¦§ã‚’å–å¾—
                            const extensions = gl.getSupportedExtensions();
                            diagnostics.extensions = extensions || [];
                            
                            // ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã‚¢ã‚¯ã‚»ãƒ©ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®æ¨å®š
                            const renderer = diagnostics.renderer?.toLowerCase() || '';
                            diagnostics.hardwareAccelerated = !(
                                renderer.includes('software') ||
                                renderer.includes('llvmpipe') ||
                                renderer.includes('mesa') ||
                                renderer.includes('swiftshader') ||
                                renderer.includes('microsoft basic render driver')
                            );
                            
                            // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›
                            console.log('ğŸ” è©³ç´°WebGLè¨ºæ–­æƒ…å ±:', {
                                version: diagnostics.webglVersion,
                                renderer: diagnostics.renderer,
                                vendor: diagnostics.vendor,
                                maxTextureSize: diagnostics.maxTextureSize,
                                maxRenderBufferSize: diagnostics.maxRenderBufferSize,
                                extensionsCount: diagnostics.extensions.length,
                                hardwareAccelerated: diagnostics.hardwareAccelerated
                            });
                            
                        } catch (e) {
                            diagnostics.errors.push('WebGLæƒ…å ±å–å¾—ã‚¨ãƒ©ãƒ¼: ' + e.message);
                        }
                    } else {
                        diagnostics.errors.push('WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ä½œæˆã«å¤±æ•—');
                    }
                    
                } catch (e) {
                    diagnostics.errors.push('WebGLè¨ºæ–­ã‚¨ãƒ©ãƒ¼: ' + e.message);
                    console.error('WebGLè¨ºæ–­ã‚¨ãƒ©ãƒ¼:', e);
                }
                
                return diagnostics;
            }
            
            async createScene() {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        try {
                            // WebGLå¯¾å¿œãƒã‚§ãƒƒã‚¯
                            if (!this.isWebGLSupported()) {
                                throw new Error('WebGL is not supported');
                            }
                            
                            // Create Three.js scene
                            this.scene = new THREE.Scene();
                            this.scene.background = new THREE.Color(0x0a0a0a);
                            
                            // Create camera
                            const aspect = this.container.offsetWidth / this.container.offsetHeight;
                            this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
                            this.camera.position.set(0, 0, this.defaultCameraZ);
                            
                            // Create renderer with fallback options
                            this.renderer = this.createWebGLRenderer();
                            if (!this.renderer) {
                                throw new Error('Failed to create WebGL renderer');
                            }
                            
                            this.renderer.setSize(this.container.offsetWidth, this.container.offsetHeight);
                            this.renderer.setClearColor(0x0a0a0a);
                            
                            // Add renderer to container
                            const sceneElement = document.getElementById('refined-3d-scene');
                            if (sceneElement) {
                                sceneElement.appendChild(this.renderer.domElement);
                            } else {
                                throw new Error('Scene container not found');
                            }
                            
                            // Create basic 3D content
                            this.createInitialContent();
                        
                        // Add lighting
                        const ambientLight = new THREE.AmbientLight(0x606060, 0.5); // ã‚ˆã‚Šæ˜ã‚‹ã„ç’°å¢ƒå…‰
                        this.scene.add(ambientLight);
                        
                        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // ã‚ˆã‚Šå¼·ã„æŒ‡å‘æ€§ãƒ©ã‚¤ãƒˆ
                        directionalLight.position.set(10, 10, 5);
                        this.scene.add(directionalLight);
                        
                        // è¿½åŠ ã®ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆã§ç«‹ä½“æ„Ÿã‚’å¼·åŒ–
                        const pointLight1 = new THREE.PointLight(0xffffff, 0.5, 100);
                        pointLight1.position.set(-10, -10, 10);
                        this.scene.add(pointLight1);
                            
                            const pointLight2 = new THREE.PointLight(0xffffff, 0.3, 100);
                            pointLight2.position.set(5, -5, -10);
                            this.scene.add(pointLight2);
                            
                            resolve();
                        } catch (error) {
                            console.error('createSceneå†…ã§ã‚¨ãƒ©ãƒ¼:', error);
                            reject(error);
                        }
                    }, 2000); // 2ç§’ã®åˆæœŸåŒ–æ™‚é–“
                });
            }
            
            createInitialContent() {
                // Create core (self) with polyhedron geometry
                this.createPolyhedronCore(this.currentStage);
                
                // Create core light for enhanced introspection effect
                this.coreLight = new THREE.PointLight(0xffffcc, this.baseCoreIntensity, 10);
                this.coreLight.position.set(0, 0, 0);
                this.scene.add(this.coreLight);
                
                // Initialize progressive light enhancement system
                this.initializeLightVeils();
                
                // Initialize new dimension effect systems
                this.initializeDimensionEffects();
                
                // Initialize ground movement system
                this.initializeGroundSystem();
                
                // èª¬æ˜è¡¨ç¤ºã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
                this.initializeExplanationSystem();
                
                // Create stage-specific particles
                this.createStageParticles();
            }
            
            // èª¬æ˜è¡¨ç¤ºã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
            initializeExplanationSystem() {
                if (!this.explanationSystem) {
                    this.explanationSystem = new ExplanationDisplaySystem(this.container);
                }
            }
            
            // æ–°ã—ã„æ¬¡å…ƒåŠ¹æœã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
            initializeDimensionEffects() {
                // æ—¢å­˜ã®ã‚·ã‚¹ãƒ†ãƒ ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                this.cleanupDimensionEffects();
                
                // 3ã¤ã®æ¬¡å…ƒã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–ï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å‚ç…§ã¯å‹•çš„ã«æ¸¡ã™ï¼‰
                this.lightningDimension = new LightningDimensionSystem([], this.scene);
                this.radarDimension = new RadarDimensionSystem(this.scene);
                this.beamDimension = new BeamDimensionSystem(this.scene);
                
                // ç¾åœ¨ã®æ®µéšã«å¿œã˜ã¦ã‚·ã‚¹ãƒ†ãƒ ã‚’æ›´æ–°
                const stageNumber = this.getStageNumber(this.currentStage);
                this.updateDimensionEffects(stageNumber);
            }
            
            // æ¬¡å…ƒåŠ¹æœã®æ®µéšåˆ¥æ›´æ–°
            updateDimensionEffects(stageNumber) {
                if (!this.lightningDimension || !this.radarDimension || !this.beamDimension) return;
                
                // ãƒ¬ãƒ¼ãƒ€ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ã®æ›´æ–°
                this.radarDimension.createRadarBeam(stageNumber);
                
                // å…‰ç·šã‚·ã‚¹ãƒ†ãƒ ã®æ›´æ–°
                this.beamDimension.createNeuralConnections(stageNumber);
                
                // ç¨²å…‰ã‚·ã‚¹ãƒ†ãƒ ã¯å‹•çš„ã«æ›´æ–°ã•ã‚Œã‚‹ãŸã‚ã€ã“ã“ã§ã¯è¨­å®šã®ã¿
            }
            
            // æ¬¡å…ƒåŠ¹æœã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            cleanupDimensionEffects() {
                if (this.lightningDimension) {
                    this.lightningDimension.cleanup();
                    this.lightningDimension = null;
                }
                if (this.radarDimension) {
                    this.radarDimension.cleanup();
                    this.radarDimension = null;
                }
                if (this.beamDimension) {
                    this.beamDimension.cleanup();
                    this.beamDimension = null;
                }
            }
            
            // åœ°é¢ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
            initializeGroundSystem() {
                if (this.groundMovementSystem) {
                    this.groundMovementSystem.cleanup();
                }
                
                // åœ°é¢ç§»å‹•ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½œæˆ
                this.groundMovementSystem = new GroundMovementSystem(this.scene, this.camera);
                
                // åœ°é¢ãƒ‰ãƒƒãƒˆã‚’åˆæœŸåŒ–
                this.groundMovementSystem.initializeGroundDots();
                
                // ç¾åœ¨ã®æ®µéšã«å¿œã˜ãŸå‹•ä½œãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¨­å®š
                this.groundMovementSystem.setMovementPattern(this.currentStage);
                
                // åœ°é¢ã‚·ã‚¹ãƒ†ãƒ ã‚’æœ‰åŠ¹åŒ–ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§è¡¨ç¤ºï¼‰
                this.groundMovementSystem.setActive(true);
                this.isGroundActive = true;
                
                console.log('[3D] Ground movement system initialized for stage:', this.currentStage);
            }
            
            // æ¬¡å…ƒåŠ¹æœã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®æ›´æ–°
            updateDimensionAnimations(time) {
                const stageNumber = this.getStageNumber(this.currentStage);
                
                // æ¬¡å…ƒ1: ç¨²å…‰ã‚·ã‚¹ãƒ†ãƒ ã®æ›´æ–°ï¼ˆå‹•çš„ã«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é…åˆ—ã‚’æ›´æ–°ï¼‰
                if (this.lightningDimension) {
                    this.lightningDimension.particles = this.particles; // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é…åˆ—ã‚’å‹•çš„ã«æ›´æ–°
                    this.lightningDimension.update(stageNumber);
                }
                
                // æ¬¡å…ƒ2: ãƒ¬ãƒ¼ãƒ€ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ã®æ›´æ–°
                if (this.radarDimension) {
                    this.radarDimension.update(time, this.particles);
                }
                
                // æ¬¡å…ƒ3: å…‰ç·šã‚·ã‚¹ãƒ†ãƒ ã®æ›´æ–°
                if (this.beamDimension) {
                    this.beamDimension.update(time, stageNumber);
                }
                
                // åœ°é¢ç§»å‹•ã‚·ã‚¹ãƒ†ãƒ ã®æ›´æ–°
                if (this.groundMovementSystem && this.isGroundActive) {
                    this.groundMovementSystem.updateGroundMovement();
                }
                
                // ã‚«ãƒ¡ãƒ©ã®è¦‹å›ã—åŠ¹æœã‚’æ›´æ–°
                this.updateCameraLookAround();
            }
            
            createDimensionRings() {
                // æ—¢å­˜ã®ãƒªãƒ³ã‚°ã‚’ã‚¯ãƒªã‚¢
                this.dimensionRings.forEach(ring => this.scene.remove(ring));
                this.dimensionRings = [];
                
                // ç¾åœ¨ã®æ®µéšç•ªå·ã‚’å–å¾—ï¼ˆåˆæœŸåŒ–æ™‚ã¯Ea=1ï¼‰
                const currentStageNumber = this.getStageNumber(this.currentStage || 'Ea');
                
                for (let i = 0; i < 3; i++) {
                    // æ®µéšã«å¿œã˜ãŸåŠå¾„ã‚’å–å¾—
                    const radius = this.getDimensionRingRadius(i, currentStageNumber);
                    const geometry = new THREE.TorusGeometry(radius, 0.05, 8, 32);
                    
                    // å¤šé¢ä½“ã‚³ã‚¢ã¨çµ±ä¸€ã—ãŸæè³ªã‚·ã‚¹ãƒ†ãƒ 
                    const material = new THREE.MeshPhongMaterial({ 
                        color: this.getDimensionRingColor(i, currentStageNumber),
                        transparent: true,
                        opacity: this.getDimensionRingOpacity(currentStageNumber),
                        shininess: this.getDimensionRingShininess(currentStageNumber),
                        emissive: this.getDimensionRingEmissive(i, currentStageNumber),
                        emissiveIntensity: this.getDimensionRingEmissiveIntensity(currentStageNumber),
                        specular: 0x888888 // çµ±ä¸€ã•ã‚ŒãŸåå°„å…‰
                    });
                    
                    const ring = new THREE.Mesh(geometry, material);
                    ring.rotation.x = Math.PI / 2 + (i * Math.PI / 6);
                    
                    // æ®µéšçš„é€²åŒ–ã®ãŸã‚ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¿½åŠ 
                    ring.userData = {
                        ringIndex: i,
                        baseRotationX: Math.PI / 2 + (i * Math.PI / 6),
                        baseRotationSpeed: 0.1 + i * 0.05, // åŸºæœ¬å›è»¢é€Ÿåº¦
                        rotationDirection: i % 2 === 0 ? 1 : -1,
                        interactionPhase: 0, // ç›¸äº’ä½œç”¨ã®ä½ç›¸
                        synchronizationFactor: 0, // åŒæœŸåº¦åˆã„
                        materialEvolution: 0 // æè³ªé€²åŒ–åº¦
                    };
                    
                    this.scene.add(ring);
                    this.dimensionRings.push(ring);
                }
            }
            
            // æ®µéšã«å¿œã˜ãŸæ¬¡å…ƒãƒªãƒ³ã‚°ã®åŠå¾„ã‚’æ±ºå®š
            getDimensionRingRadius(ringIndex, stage) {
                // åŸºæœ¬åŠå¾„ï¼ˆåˆæœŸã‚µã‚¤ã‚ºï¼‰
                const baseRadii = [1.8, 2.5, 3.2]; // å†…å´ã€ä¸­é–“ã€å¤–å´ãƒªãƒ³ã‚°
                const baseRadius = baseRadii[ringIndex];
                
                // æ®µéšã«å¿œã˜ãŸã‚µã‚¤ã‚ºå€ç‡
                let sizeMultiplier;
                
                if (stage <= 3) {
                    // Ea, Eb, Ec: å°ã•ã‚ã‹ã‚‰é–‹å§‹
                    sizeMultiplier = 0.7 + stage * 0.1; // 0.8-1.0å€
                } else if (stage <= 7) {
                    // EI, E-I, I-E, IE: å¾ã€…ã«æ‹¡å¤§
                    sizeMultiplier = 1.0 + (stage - 3) * 0.12; // 1.0-1.48å€
                } else {
                    // Ia, Ib, Ic: æœ€ã‚‚å¤§ãã
                    sizeMultiplier = 1.48 + (stage - 7) * 0.08; // 1.48-1.72å€
                }
                
                return baseRadius * sizeMultiplier;
            }

            // æ®µéšã«å¿œã˜ãŸæ¬¡å…ƒãƒªãƒ³ã‚°ã®è‰²ã‚’æ±ºå®šï¼ˆå¤šé¢ä½“ã‚³ã‚¢ã¨çµ±ä¸€åŒ–ï¼‰
            getDimensionRingColor(ringIndex, stage) {
                // å¤šé¢ä½“ã‚³ã‚¢ã®è‰²ã‚·ã‚¹ãƒ†ãƒ ã¨çµ±ä¸€ã—ãŸè‰²ç›¸é…ç½®
                const baseHues = [240, 300, 60]; // é’ç´«ç³», ç´«ç³», é»„ç·‘ç³»
                const hue = baseHues[ringIndex];
                
                // å¤šé¢ä½“ã‚³ã‚¢ã®ã‚µã‚¤ã‚ºé€²åŒ–ã«åˆã‚ã›ãŸè‰²å½©ç™ºå±•
                const coreProgress = this.getCoreProgress(stage);
                
                // æ®µéšã«å¿œã˜ãŸè‰²å½©ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ ã¨çµ±ä¸€ï¼‰
                let saturation, lightness;
                
                if (stage <= 3) {
                    // EAæ®µéš: è½ã¡ç€ã„ãŸåŸºèª¿è‰²
                    saturation = 45 + coreProgress * 15;     // 45-60%
                    lightness = 25 + coreProgress * 15;      // 25-40%
                } else if (stage <= 7) {
                    // å²è·¯æ®µéš: æ´»ç™ºãªå¤‰åŒ–ã‚’è¡¨ç¾
                    const transitionFactor = (stage - 3) / 4;
                    saturation = 60 + transitionFactor * 20; // 60-80%
                    lightness = 40 + transitionFactor * 25;  // 40-65%
                } else {
                    // IAæ®µéš: è¼ãå®Œæˆå½¢
                    const masterFactor = (stage - 7) / 3;
                    saturation = 80 + masterFactor * 15;     // 80-95%
                    lightness = 65 + masterFactor * 20;      // 65-85%
                }
                
                // ãƒªãƒ³ã‚°é–“ã®å¾®å¦™ãªè‰²å½©å¤‰åŒ–ï¼ˆçµ±ä¸€æ„Ÿã‚’ä¿ã¡ãªãŒã‚‰åŒºåˆ¥ï¼‰
                const ringVariation = ringIndex * 0.05;
                saturation = Math.min(95, saturation + ringVariation * 10);
                lightness = Math.max(15, lightness - ringVariation * 5);
                
                return new THREE.Color().setHSL(hue / 360, saturation / 100, lightness / 100).getHex();
            }
            
            // æ®µéšã«å¿œã˜ãŸé€æ˜åº¦ã‚’æ±ºå®š
            getDimensionRingOpacity(stage) {
                if (stage <= 3) {
                    // EAæ®µéš: 0.35-0.50
                    return 0.35 + stage * 0.05;
                } else if (stage <= 7) {
                    // å²è·¯æ®µéš: 0.50-0.82
                    return 0.50 + (stage - 3) * 0.08;
                } else {
                    // IAæ®µéš: 0.82-0.94 (æœ€ã‚‚æ˜ã‚‹ã)
                    return 0.82 + (stage - 7) * 0.04;
                }
            }
            
            // æ®µéšã«å¿œã˜ãŸå…‰æ²¢åº¦ã‚’æ±ºå®šï¼ˆå¤šé¢ä½“ã‚³ã‚¢ã¨çµ±ä¸€åŒ–ï¼‰
            getDimensionRingShininess(stage) {
                // å¤šé¢ä½“ã‚³ã‚¢ã®å…‰æ²¢é€²åŒ–ã‚·ã‚¹ãƒ†ãƒ ã¨çµ±ä¸€
                const coreProgress = this.getCoreProgress(stage);
                
                if (stage <= 3) {
                    // EAæ®µéš: ä½å…‰æ²¢ã‹ã‚‰å§‹ã¾ã‚‹ï¼ˆã‚³ã‚¢ã®æ§ãˆã‚ãªè¼ãï¼‰
                    return 10 + coreProgress * 20; // 10-30
                } else if (stage <= 7) {
                    // å²è·¯æ®µéš: å¤‰åŒ–çš„ãªå…‰æ²¢ï¼ˆã‚³ã‚¢ã®å¤‰å®¹ã¨åŒæœŸï¼‰
                    const transitionIntensity = (stage - 3) / 4;
                    return 30 + transitionIntensity * 50; // 30-80
                } else {
                    // IAæ®µéš: é«˜å…‰æ²¢ãƒ»è¼ãå®Œæˆå½¢ï¼ˆã‚³ã‚¢ã®æ´—ç·´ã•ã‚ŒãŸè¼ãï¼‰
                    const masterIntensity = (stage - 7) / 3;
                    return 80 + masterIntensity * 60; // 80-140
                }
            }

            // æ¬¡å…ƒãƒªãƒ³ã‚°ã®ã‚¨ãƒŸãƒƒã‚·ãƒ–ï¼ˆç™ºå…‰ï¼‰è‰²ã‚’æ±ºå®š
            getDimensionRingEmissive(ringIndex, stage) {
                // ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ ã¨çµ±ä¸€ã—ãŸã‚¨ãƒŸãƒƒã‚·ãƒ–åŠ¹æœ
                const baseHues = [240, 300, 60]; // å„ãƒªãƒ³ã‚°ã®åŸºæœ¬è‰²ç›¸
                const hue = baseHues[ringIndex];
                const coreProgress = this.getCoreProgress(stage);
                
                // æ®µéšã«å¿œã˜ãŸã‚¨ãƒŸãƒƒã‚·ãƒ–å¼·åº¦
                let emissiveSaturation, emissiveLightness;
                
                if (stage <= 3) {
                    // EAæ®µéš: å¾®ç´°ãªå†…éƒ¨å…‰
                    emissiveSaturation = 20 + coreProgress * 10; // 20-30%
                    emissiveLightness = 5 + coreProgress * 5;    // 5-10%
                } else if (stage <= 7) {
                    // å²è·¯æ®µéš: å‹•çš„ãªç™ºå…‰
                    const transitionFactor = (stage - 3) / 4;
                    emissiveSaturation = 30 + transitionFactor * 25; // 30-55%
                    emissiveLightness = 10 + transitionFactor * 10;  // 10-20%
                } else {
                    // IAæ®µéš: å¼·ã„å†…éƒ¨å…‰
                    const masterFactor = (stage - 7) / 3;
                    emissiveSaturation = 55 + masterFactor * 20; // 55-75%
                    emissiveLightness = 20 + masterFactor * 15;  // 20-35%
                }
                
                return new THREE.Color().setHSL(hue / 360, emissiveSaturation / 100, emissiveLightness / 100).getHex();
            }

            // æ¬¡å…ƒãƒªãƒ³ã‚°ã®ã‚¨ãƒŸãƒƒã‚·ãƒ–å¼·åº¦ã‚’æ±ºå®š
            getDimensionRingEmissiveIntensity(stage) {
                const coreProgress = this.getCoreProgress(stage);
                
                if (stage <= 3) {
                    // EAæ®µéš: å¼±ã„ç™ºå…‰
                    return 0.1 + coreProgress * 0.1; // 0.1-0.2
                } else if (stage <= 7) {
                    // å²è·¯æ®µéš: ä¸­ç¨‹åº¦ã®ç™ºå…‰
                    const transitionFactor = (stage - 3) / 4;
                    return 0.2 + transitionFactor * 0.3; // 0.2-0.5
                } else {
                    // IAæ®µéš: å¼·ã„ç™ºå…‰
                    const masterFactor = (stage - 7) / 3;
                    return 0.5 + masterFactor * 0.3; // 0.5-0.8
                }
            }

            // å¤šé¢ä½“ã‚³ã‚¢ã®é€²åŒ–åº¦åˆã„ã‚’è¨ˆç®—ï¼ˆçµ±ä¸€åŒ–ã®ãŸã‚ã®ãƒ™ãƒ¼ã‚¹ãƒ¡ãƒˆãƒªãƒƒã‚¯ï¼‰
            getCoreProgress(stage) {
                // 10æ®µéšã®é€²åŒ–ã‚’0.0-1.0ã®ç¯„å›²ã§æ­£è¦åŒ–
                if (stage <= 1) return 0.0;
                if (stage >= 10) return 1.0;
                
                // å„æ®µéšã‚°ãƒ«ãƒ¼ãƒ—å†…ã§ã®é€²è¡Œåº¦ã‚’è¨ˆç®—
                if (stage <= 3) {
                    // EAæ®µéš (1-3): åŸºç¤å½¢æˆæœŸ
                    return (stage - 1) / 9; // 0.0-0.22
                } else if (stage <= 7) {
                    // å²è·¯æ®µéš (4-7): å¤‰å®¹æœŸ
                    return (stage - 1) / 9; // 0.33-0.67
                } else {
                    // IAæ®µéš (8-10): å®ŒæˆæœŸ
                    return (stage - 1) / 9; // 0.78-1.0
                }
            }

            createPolyhedronCore(stage) {
                // æ—¢å­˜ã®ã‚³ã‚¢ã‚’å‰Šé™¤
                if (this.core) {
                    this.scene.remove(this.core);
                    if (this.core.geometry) this.core.geometry.dispose();
                    if (this.core.material) this.core.material.dispose();
                }

                // æ®µéšã«å¿œã˜ãŸå¤šé¢ä½“ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’ä½œæˆ
                const coreGeometry = this.coreGeometryManager.createPolyhedronGeometry(stage);
                
                // æ®µéšãƒ‡ãƒ¼ã‚¿ã‹ã‚‰è‰²å½©ã‚’å–å¾—
                const stageData = this.getStageData(stage);
                const stageColor = stageData.color;
                
                // diverseColorsé…åˆ—ã‚’å®šç¾©
                const diverseColors = [
                    0x87ceeb, // ã‚¹ã‚«ã‚¤ãƒ–ãƒ«ãƒ¼ - ç†æ€§çš„ãªä»–è€…
                    0xffa07a, // ãƒ©ã‚¤ãƒˆã‚µãƒ¼ãƒ¢ãƒ³ - æ¸©ã‹ã„ä»–è€…
                    0x98fb98, // ãƒšãƒ¼ãƒ«ã‚°ãƒªãƒ¼ãƒ³ - è‡ªç„¶ä½“ãªä»–è€…
                    0xdda0dd, // ãƒ—ãƒ©ãƒ  - ç¥ç§˜çš„ãªä»–è€…
                    0xf0e68c, // ã‚«ãƒ¼ã‚­ - åœ°ã«è¶³ã¤ã„ãŸä»–è€…
                    0xffb6c1, // ãƒ©ã‚¤ãƒˆãƒ”ãƒ³ã‚¯ - æ„Ÿæƒ…è±Šã‹ãªä»–è€…
                    0xffd700, // ã‚´ãƒ¼ãƒ«ãƒ‰ - è¼ãä»–è€…
                    0xff6347, // ãƒˆãƒãƒˆ - æƒ…ç†±çš„ãªä»–è€…
                    0x40e0d0, // ã‚¿ãƒ¼ã‚³ã‚¤ã‚º - æ¸…ã‚‰ã‹ãªä»–è€…
                    0xda70d6, // ã‚ªãƒ¼ã‚­ãƒƒãƒ‰ - å€‹æ€§çš„ãªä»–è€…
                    0x32cd32, // ãƒ©ã‚¤ãƒ ã‚°ãƒªãƒ¼ãƒ³ - ç”Ÿå‘½åŠ›ã‚ã‚‹ä»–è€…
                    0xff69b4, // ãƒ›ãƒƒãƒˆãƒ”ãƒ³ã‚¯ - æ´»ç™ºãªä»–è€…
                    0x00ced1, // ãƒ€ãƒ¼ã‚¯ã‚¿ãƒ¼ã‚³ã‚¤ã‚º - æ·±ã„ä»–è€…
                    0xffa500, // ã‚ªãƒ¬ãƒ³ã‚¸ - ã‚¨ãƒãƒ«ã‚®ãƒƒã‚·ãƒ¥ãªä»–è€…
                    0x9370db  // ãƒŸãƒ‡ã‚£ã‚¢ãƒ ãƒ‘ãƒ¼ãƒ—ãƒ« - å‰µé€ çš„ãªä»–è€…
                ];
                
                // æ®µéšã«å¿œã˜ãŸè‰²æ•°ã‚’æ±ºå®š
                const colorCount = this.getColorCountForStage(stage);
                const selectedColors = this.selectColorsForStage(diverseColors, colorCount);
                
                // å¤šé¢ä½“ç”¨ãƒãƒ†ãƒªã‚¢ãƒ«ï¼ˆé¢ã”ã¨ã«è‰²åˆ†ã‘ï¼‰
                let coreMaterial;
                if (selectedColors.length > 1) {
                    // è¤‡æ•°è‰²ã®å ´åˆã€é¢ã”ã¨ã«ç•°ãªã‚‹è‰²ã‚’é©ç”¨
                    coreMaterial = this.createMultiColorMaterial(coreGeometry, selectedColors);
                } else {
                    // å˜è‰²ã®å ´åˆã€å¾“æ¥é€šã‚Š
                    coreMaterial = new THREE.MeshPhongMaterial({ 
                        color: selectedColors[0],
                        emissive: 0x333333,
                        transparent: true,
                        opacity: 0.85,
                        shininess: 100,
                        wireframe: false
                    });
                }
                
                // ãƒ¡ã‚¤ãƒ³ã®å¤šé¢ä½“ãƒ¡ãƒƒã‚·ãƒ¥
                this.core = new THREE.Mesh(coreGeometry, coreMaterial);
                this.scene.add(this.core);
                
                // ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ åŠ¹æœï¼ˆã‚¨ãƒƒã‚¸å¼·èª¿ï¼‰
                const wireframeGeometry = this.coreGeometryManager.createWireframeGeometry(coreGeometry);
                const wireframeMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.6,
                    linewidth: 2
                });
                
                const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
                this.core.add(wireframe); // ã‚³ã‚¢ã®å­ã¨ã—ã¦è¿½åŠ 
                
                // é ‚ç‚¹å…‰ç‚¹åŠ¹æœ
                this.createVertexLights(coreGeometry, stageColor);
                
                console.log(`ã‚³ã‚¢å½¢çŠ¶æ›´æ–°: ${this.coreGeometryManager.getPolyhedronName(stage)}`);
            }

            createVertexLights(geometry, baseColor) {
                // é ‚ç‚¹ä½ç½®ã‚’å–å¾—
                const vertices = geometry.attributes.position.array;
                const vertexCount = vertices.length / 3;
                
                // æ—¢å­˜ã®é ‚ç‚¹ãƒ©ã‚¤ãƒˆã‚’å‰Šé™¤
                if (this.vertexLights) {
                    this.vertexLights.forEach(light => {
                        this.scene.remove(light);
                    });
                }
                this.vertexLights = [];
                
                // å„é ‚ç‚¹ã«å°ã•ãªå…‰ç‚¹ã‚’é…ç½®
                for (let i = 0; i < vertexCount; i += 3) { // é–“å¼•ã„ã¦é…ç½®
                    const x = vertices[i * 3];
                    const y = vertices[i * 3 + 1];
                    const z = vertices[i * 3 + 2];
                    
                    // å°ã•ãªçƒä½“å…‰ç‚¹
                    const lightGeometry = new THREE.SphereGeometry(0.02, 8, 8);
                    const lightMaterial = new THREE.MeshBasicMaterial({ 
                        color: baseColor,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const lightSphere = new THREE.Mesh(lightGeometry, lightMaterial);
                    lightSphere.position.set(x, y, z);
                    
                    this.core.add(lightSphere); // ã‚³ã‚¢ã®å­ã¨ã—ã¦è¿½åŠ 
                }
            }

            // æ®µéšã«å¿œã˜ãŸè‰²æ•°ã‚’æ±ºå®š
            getColorCountForStage(stage) {
                switch(stage) {
                    case 'Ea':
                    case 'Eb': 
                    case 'Ec':
                        // Tetrahedron: 1è‰²
                        return 1;
                        
                    case 'EI':
                    case 'E-I':
                    case 'I-E':
                        // Octahedron: 3è‰²
                        return 3;
                        
                    case 'IE':
                    case 'Ia':
                        // Dodecahedron: 5è‰²
                        return 5;
                        
                    case 'Ib':
                    case 'Ic':
                        // Icosahedron: 8è‰²
                        return 8;
                        
                    default:
                        return 1;
                }
            }

            // æ®µéšã«å¿œã˜ãŸè‰²ã‚’é¸æŠ
            selectColorsForStage(diverseColors, colorCount) {
                const shuffled = [...diverseColors].sort(() => 0.5 - Math.random());
                return shuffled.slice(0, colorCount);
            }

            // è¤‡æ•°è‰²ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆï¼ˆé¢å˜ä½ã§ã®è‰²ä»˜ã‘å¯¾å¿œï¼‰
            createMultiColorMaterial(geometry, colors) {
                // é¢ã®æ•°ã‚’å–å¾—ï¼ˆä¸‰è§’å½¢é¢ã®æ•°ï¼‰
                const faceCount = geometry.attributes.position.count / 3;
                const faceColors = [];
                
                // ç™½è‰²ï¼ˆæœªçŸ¥ãªã‚‹å¯èƒ½æ€§ï¼‰ã®å®šç¾©
                const whiteColor = new THREE.Color(0xffffff);
                
                // å¤šé¢ä½“ã®ç¨®é¡ã«å¿œã˜ãŸé¢ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã‚’åˆ¤å®š
                const actualFaceCount = this.getActualFaceCount(geometry);
                const trianglesPerFace = Math.round(faceCount / actualFaceCount);
                
                console.log(`[è‰²ä»˜ã‘] ä¸‰è§’å½¢é¢æ•°: ${faceCount}, å®Ÿéš›ã®é¢æ•°: ${actualFaceCount}, é¢ã‚ãŸã‚Šä¸‰è§’å½¢æ•°: ${trianglesPerFace}`);
                
                // å„ä¸‰è§’å½¢ã«è‰²ã‚’å‰²ã‚Šå½“ã¦ï¼ˆé¢å˜ä½ã§ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ï¼‰
                for (let i = 0; i < faceCount; i++) {
                    // ã©ã®å®Ÿéš›ã®é¢ã«å±ã™ã‚‹ã‹ã‚’è¨ˆç®—
                    const actualFaceIndex = Math.floor(i / trianglesPerFace);
                    let color;
                    
                    // æŒ‡å®šã•ã‚ŒãŸè‰²æ•°ã¾ã§ã¯å¤šæ§˜ãªè‰²ã€æ®‹ã‚Šã¯ç™½ï¼ˆæœªçŸ¥ãªã‚‹å¯èƒ½æ€§ï¼‰
                    if (actualFaceIndex < colors.length) {
                        color = new THREE.Color(colors[actualFaceIndex]);
                    } else {
                        color = whiteColor; // æœªçŸ¥ãªã‚‹å¯èƒ½æ€§ã‚’è¡¨ç¾ã™ã‚‹ç™½ã„é¢
                    }
                    
                    // å„é ‚ç‚¹ï¼ˆ3ã¤ï¼‰ã«åŒã˜è‰²ã‚’å‰²ã‚Šå½“ã¦
                    faceColors.push(color.r, color.g, color.b);
                    faceColors.push(color.r, color.g, color.b);
                    faceColors.push(color.r, color.g, color.b);
                }
                
                // è‰²å±æ€§ã‚’è¿½åŠ 
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(faceColors, 3));
                
                // é ‚ç‚¹ã‚«ãƒ©ãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹ãƒãƒ†ãƒªã‚¢ãƒ«
                return new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    emissive: 0x222222,
                    transparent: true,
                    opacity: 0.85,
                    shininess: 100,
                    wireframe: false
                });
            }

            // å¤šé¢ä½“ã®å®Ÿéš›ã®é¢æ•°ã‚’å–å¾—ï¼ˆä¸‰è§’åˆ†å‰²å‰ã®é¢æ•°ï¼‰
            getActualFaceCount(geometry) {
                // ã‚¸ã‚ªãƒ¡ãƒˆãƒªã®é ‚ç‚¹æ•°ã‹ã‚‰å¤šé¢ä½“ã®ç¨®é¡ã‚’æ¨å®š
                const vertexCount = geometry.attributes.position.count;
                const triangleCount = vertexCount / 3;
                
                // å„å¤šé¢ä½“ã®ç†è«–çš„ãªé¢æ•°ï¼ˆEulerã®å¤šé¢ä½“å…¬å¼ã‚’å‚è€ƒï¼‰
                if (triangleCount <= 8) {
                    return 4;  // æ­£å››é¢ä½“: 4é¢
                } else if (triangleCount <= 16) {
                    return 8;  // æ­£å…«é¢ä½“: 8é¢
                } else if (triangleCount <= 40) {
                    return 12; // æ­£åäºŒé¢ä½“: 12é¢ï¼ˆå„äº”è§’å½¢é¢ãŒ3-4å€‹ã®ä¸‰è§’å½¢ã«åˆ†å‰²ï¼‰
                } else {
                    return 20; // æ­£äºŒåé¢ä½“: 20é¢
                }
            }

            initializeLightVeils() {
                // æ®µéšçš„å…‰å¼·åŒ–ã‚·ã‚¹ãƒ†ãƒ  - ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã«å¿œã˜ãŸå…‰ã®ãƒ™ãƒ¼ãƒ«
                // å„ã‚¹ãƒ†ãƒ¼ã‚¸ã§å¤§å¹…ã«ã‚µã‚¤ã‚ºãŒå¢—åŠ ã™ã‚‹é€æ˜ãªå…‰ã®ãƒ™ãƒ¼ãƒ«ã‚’ä½œæˆ
                
                // æ—¢å­˜ã®ãƒ™ãƒ¼ãƒ«ã‚’ã‚¯ãƒªã‚¢
                this.lightVeils.forEach(veil => this.scene.remove(veil));
                this.lightVeils = [];
                
                // 5æ®µéšã®å…‰ã®ãƒ™ãƒ¼ãƒ«ã‚’ä½œæˆï¼ˆI-E, IE, Ia, Ib, Icï¼‰
                // ã‚ˆã‚Šå¤§ããªã‚µã‚¤ã‚ºå·®ã§è¦–è¦šçš„ãªå±¤ã®é‡ãªã‚Šã‚’æ˜ç¢ºã«è¡¨ç¾
                const baseRadii = [0.4, 0.6, 0.9, 1.3, 1.8]; // æ®µéšçš„ã«å¤§å¹…å¢—åŠ 
                
                for (let i = 0; i < 5; i++) {
                    const radius = baseRadii[i];
                    const geometry = new THREE.SphereGeometry(radius, 32, 32);
                    
                    // ã‚·ãƒ³ãƒ—ãƒ«ã§ç¢ºå®Ÿãªå…‰ã®ãƒ™ãƒ¼ãƒ« - MeshBasicMaterialã§è‡ªå·±ç™ºå…‰
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xffffee,              // æš–ã‹ã¿ã®ã‚ã‚‹æŸ”ã‚‰ã‹ãªç™½
                        transparent: true,
                        opacity: 0.005 + i * 0.002,  // æ¥µã‚ã¦é€æ˜åº¦ã‚’é«˜ãã—ã¦èƒŒæ™¯ãŒã¯ã£ãã‚Šè¦‹ãˆã‚‹ã‚ˆã†ã«
                        fog: false,                   // ãƒ•ã‚©ã‚°ã®å½±éŸ¿ã‚’å—ã‘ãªã„
                        side: THREE.DoubleSide,       // ä¸¡é¢æç”»ã§å…‰ã‚‰ã—ã•ã‚’å¼·åŒ–
                        blending: THREE.AdditiveBlending,  // åŠ ç®—ãƒ–ãƒ¬ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã§å…‰ã‚‰ã—ã•ã‚’å¼·åŒ–
                        depthWrite: false             // æ·±åº¦æ›¸ãè¾¼ã¿ã‚’ç„¡åŠ¹åŒ–ã—ã¦é€æ˜æ„Ÿå‘ä¸Š
                    });
                    
                    const veil = new THREE.Mesh(geometry, material);
                    veil.position.set(0, 0, 0);
                    
                    // æ”¾å°„çŠ¶ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœã‚’ãƒãƒ†ãƒªã‚¢ãƒ«è‡ªä½“ã§å®Ÿç¾
                    veil.material.userData = {
                        baseOpacity: 0.005 + i * 0.002,    // åŸºæº–é€æ˜åº¦ã‚’æ¥µã‚ã¦é€æ˜ã«
                        emissiveStrength: 0.15 + i * 0.03,
                        layerIndex: i
                    };
                    
                    // å‘¼å¸ã®ã‚ˆã†ãªå‹•ãã®ãŸã‚ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
                    veil.userData = {
                        baseRadius: radius,
                        breatheSpeed: 0.8 + i * 0.1,
                        breathePhase: i * Math.PI / 3,
                        stageIndex: i,
                        visible: false  // åˆæœŸçŠ¶æ…‹ã§ã¯éè¡¨ç¤º
                    };
                    
                    veil.visible = false; // åˆæœŸçŠ¶æ…‹ã§ã¯éè¡¨ç¤º
                    this.scene.add(veil);
                    this.lightVeils.push(veil);
                }
            }
            
            createStageParticles() {
                // Clear existing particles
                this.particles.forEach(particle => this.scene.remove(particle));
                this.particles = [];
                
                // Create particles based on current stage
                const stageData = this.getStageData(this.currentStage);
                const particleCount = stageData.particleCount;
                const color = stageData.color;
                
                for (let i = 0; i < particleCount; i++) {
                    // çµŒé¨“ã®ãƒ¡ã‚¿ãƒ•ã‚¡ãƒ¼ã¨ã—ã¦ãƒ©ãƒ³ãƒ€ãƒ ãªã‚µã‚¤ã‚ºã‚’ç”Ÿæˆ
                    // åŸºæœ¬ã‚µã‚¤ã‚º0.04ã«å¯¾ã—ã¦ã€0.5å€ã€œ1.8å€ã®ç¯„å›²ã§ãƒ©ãƒ³ãƒ€ãƒ åŒ–
                    const baseSize = 0.04;
                    const sizeVariation = 0.5 + Math.random() * 1.3; // 0.5 - 1.8å€
                    const particleSize = baseSize * sizeVariation;
                    
                    // æ®µéšã«å¿œã˜ãŸã‚µã‚¤ã‚ºèª¿æ•´ï¼šå¾ŒæœŸæ®µéšã»ã©å¤§ããã€å¤šæ§˜ã«ãªã‚‹
                    const stageNumber = this.getStageNumber(this.currentStage);
                    let stageSizeMultiplier = 1.0;
                    
                    if (stageNumber >= 8) { // Ia, Ib, Icæ®µéš
                        stageSizeMultiplier = 1.0 + (stageNumber - 7) * 0.15; // æœ€å¤§1.45å€
                    } else if (stageNumber >= 5) { // E-I, I-E, IEæ®µéš
                        stageSizeMultiplier = 1.0 + (stageNumber - 4) * 0.08; // æœ€å¤§1.24å€
                    }
                    
                    const finalSize = particleSize * stageSizeMultiplier;
                    const geometry = new THREE.SphereGeometry(finalSize, 12, 12); // ãƒ©ãƒ³ãƒ€ãƒ ã‚µã‚¤ã‚ºé©ç”¨ã€å“è³ªã‚‚å‘ä¸Š
                    
                    // ã‚µã‚¤ã‚ºã«å¿œã˜ãŸè¦–è¦šçš„åŠ¹æœã®èª¿æ•´
                    const sizeRatio = finalSize / baseSize; // ã‚µã‚¤ã‚ºæ¯”ã‚’è¨ˆç®—
                    const baseOpacity = 0.9;
                    const sizeAdjustedOpacity = Math.min(baseOpacity * (0.7 + sizeRatio * 0.3), 1.0); // å¤§ãã„ã»ã©å°‘ã—é€æ˜ã«
                    const sizeAdjustedEmissive = Math.floor(0x111111 * (0.8 + sizeRatio * 0.4)); // å¤§ãã„ã»ã©å°‘ã—æ˜ã‚‹ãç™ºå…‰
                    const sizeAdjustedShininess = 80 + (sizeRatio - 1) * 40; // ã‚µã‚¤ã‚ºã«å¿œã˜ã¦å…‰æ²¢åº¦èª¿æ•´
                    
                    const material = new THREE.MeshPhongMaterial({ 
                        color: color,
                        transparent: true,
                        opacity: sizeAdjustedOpacity,  // ã‚µã‚¤ã‚ºèª¿æ•´ã•ã‚ŒãŸé€æ˜åº¦
                        emissive: sizeAdjustedEmissive,  // ã‚µã‚¤ã‚ºèª¿æ•´ã•ã‚ŒãŸç™ºå…‰
                        shininess: Math.max(50, Math.min(150, sizeAdjustedShininess))  // å…‰æ²¢ç¯„å›²åˆ¶é™ï¼ˆ50-150ï¼‰
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    
                    // Position particles based on stage characteristics
                    const radius = 1 + Math.random() * 5;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    particle.position.x = radius * Math.sin(phi) * Math.cos(theta);
                    particle.position.y = radius * Math.sin(phi) * Math.sin(theta);
                    particle.position.z = radius * Math.cos(phi);
                    
                    // Add dynamic properties based on stage behavior
                    particle.userData = {
                        originalPosition: particle.position.clone(),
                        baseRadius: radius,
                        baseTheta: theta,
                        basePhi: phi,
                        personalityFactor: Math.random(),
                        phaseOffset: Math.random() * Math.PI * 2,
                        speed: stageData.speed * (0.8 + Math.random() * 0.4),
                        cohesion: stageData.cohesion,
                        behavior: stageData.behavior,
                        pattern: stageData.pattern,
                        age: 0,
                        targetPosition: new THREE.Vector3(),
                        // ã‚µã‚¤ã‚ºé–¢é€£æƒ…å ±ã‚’è¿½åŠ 
                        originalSize: finalSize,
                        sizeRatio: sizeRatio,
                        baseSize: baseSize,
                        sizeVariation: sizeVariation
                    };
                    
                    this.scene.add(particle);
                    this.particles.push(particle);
                }
                
                // I(E)ã‚¹ãƒ†ãƒ¼ã‚¸ä»¥é™ã®å ´åˆã€åˆæœŸæ¥ç¶šã‚’å³åº§ã«ç”Ÿæˆ
                if (this.shouldShowConnections(this.currentStage)) {
                    setTimeout(() => {
                        this.updateConnections(true); // å¼·åˆ¶æ›´æ–°ã§å³åº§ã«æ¥ç¶šè¡¨ç¤º
                    }, 200); // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é…ç½®å®Œäº†ã‚’å¾…ã¤
                }
            }
            
            // I(E)ã‚¹ãƒ†ãƒ¼ã‚¸ä»¥é™ã‹ã©ã†ã‹ã‚’åˆ¤å®š
            isColorfulStage(stageId) {
                const colorfulStages = ['IE', 'Ia', 'Ib', 'Ic'];
                return colorfulStages.includes(stageId);
            }
            
            // I(E)ã‚¹ãƒ†ãƒ¼ã‚¸ä»¥é™ã§æ¥ç¶šç·šã‚’è¡¨ç¤ºã™ã‚‹ã‹ã‚’åˆ¤å®š
            shouldShowConnections(stageId) {
                const connectionStages = ['IE', 'Ia', 'Ib', 'Ic'];
                return connectionStages.includes(stageId);
            }
            
            // ã‚¹ãƒ†ãƒ¼ã‚¸ã«å¿œã˜ãŸæœ€å¤§æ¥ç¶šæ•°ã‚’å–å¾—
            getMaxConnectionsForStage(stageId) {
                return this.stageConnectionLimits[stageId] || this.maxConnections;
            }
            
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é–“ã®è·é›¢ã‚’è¨ˆç®—
            calculateParticleDistance(particle1, particle2) {
                return particle1.position.distanceTo(particle2.position);
            }
            
            // é©åˆ‡ãªæ¥ç¶šãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é¸æŠï¼ˆãƒãƒ–å‹ãƒ»é€£é–å‹ãƒ»ç›¸äº’é€£çµå‹ãªã©ï¼‰
            selectConnectionPairs() {
                if (!this.shouldShowConnections(this.currentStage) || this.particles.length < 2) {
                    return [];
                }
                
                const connections = [];
                const usedParticles = new Set();
                const maxDistance = 4.5; // æœ€å¤§æ¥ç¶šè·é›¢
                const minDistance = 0.5; // æœ€å°æ¥ç¶šè·é›¢
                
                // ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã«å¿œã˜ãŸæœ€å¤§æ¥ç¶šæ•°ã‚’å–å¾—
                const stageMaxConnections = this.getMaxConnectionsForStage(this.currentStage);
                
                // ã‚¹ãƒ†ãƒ¼ã‚¸åˆ¥ã®æ¥ç¶šãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¨­å®š
                let patterns;
                if (this.currentStage === 'I-E') {
                    // I-Eã‚¹ãƒ†ãƒ¼ã‚¸ï¼šå†…ãªã‚‹å£°ã‚’è´ã - æ§ãˆã‚ã§æ€æ…®æ·±ã„æ¥ç¶š
                    patterns = [
                        { type: 'contemplative_pairs', weight: 0.4 },  // æ€ç´¢çš„ãªãƒšã‚¢æ¥ç¶š
                        { type: 'chain', weight: 0.3 },                // é€£é–å‹ï¼ˆæ€è€ƒã®æµã‚Œï¼‰
                        { type: 'triangle', weight: 0.2 },             // å°ã•ãªä¸‰è§’å½¢ï¼ˆå†…çš„å¯¾è©±ï¼‰
                        { type: 'introspective_hub', weight: 0.1 }     // å†…çœçš„ãƒãƒ–
                    ];
                } else if (this.currentStage === 'IE') {
                    // IEã‚¹ãƒ†ãƒ¼ã‚¸ï¼šã‚·ãƒ³ãƒ—ãƒ«ãªæ¥ç¶šãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã¿
                    patterns = [
                        { type: 'chain', weight: 0.5 },     // é€£é–å‹ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãªç¹‹ãŒã‚Šï¼‰
                        { type: 'triangle', weight: 0.3 },  // ä¸‰è§’å½¢ï¼ˆåŸºæœ¬çš„ãªç›¸äº’é€£çµï¼‰
                        { type: 'hub', weight: 0.2 }        // ãƒãƒ–å‹ï¼ˆå°‘æ•°ï¼‰
                    ];
                } else if (this.currentStage === 'Ic') {
                    // Icã‚¹ãƒ†ãƒ¼ã‚¸ï¼šæ¥µã‚ã¦è±Šå¯Œã§è¤‡é›‘ãªæ¥ç¶šãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå®Œå…¨ãªã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒ³ãƒˆæ®µéšï¼‰
                    patterns = [
                        { type: 'dense_network', weight: 0.25 },  // å¯†ãªå…¨ä½“ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯
                        { type: 'multi_hub', weight: 0.2 },       // è¤‡æ•°ãƒãƒ–å‹
                        { type: 'triangle', weight: 0.15 },       // ä¸‰è§’å½¢ï¼ˆç›¸äº’é€£çµï¼‰
                        { type: 'star', weight: 0.15 },           // æ˜Ÿå‹ï¼ˆä¸­å¿ƒã‹ã‚‰æ”¾å°„ï¼‰
                        { type: 'chain', weight: 0.1 },           // é€£é–å‹
                        { type: 'hub', weight: 0.1 },             // å˜ä¸€ãƒãƒ–å‹
                        { type: 'cycle', weight: 0.05 }           // å¾ªç’°å‹
                    ];
                } else {
                    // ãã®ä»–ã®ã‚¹ãƒ†ãƒ¼ã‚¸ï¼šæ¨™æº–çš„ãªãƒ‘ã‚¿ãƒ¼ãƒ³
                    patterns = [
                        { type: 'hub', weight: 0.3 },        // ãƒãƒ–å‹ï¼ˆ1ã¤ã®ä¸­å¿ƒã«è¤‡æ•°æ¥ç¶šï¼‰
                        { type: 'chain', weight: 0.25 },     // é€£é–å‹ï¼ˆAâ†’Bâ†’Câ†’Dï¼‰
                        { type: 'triangle', weight: 0.2 },   // ä¸‰è§’å½¢ï¼ˆç›¸äº’é€£çµï¼‰
                        { type: 'star', weight: 0.15 },      // æ˜Ÿå‹ï¼ˆä¸­å¿ƒã‹ã‚‰æ”¾å°„ï¼‰
                        { type: 'cycle', weight: 0.1 }       // å¾ªç’°å‹ï¼ˆAâ†’Bâ†’Câ†’Aï¼‰
                    ];
                }
                
                // è·é›¢ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
                const distanceMatrix = this.calculateDistanceMatrix();
                
                // ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é †æ¬¡ç”Ÿæˆï¼ˆã‚¹ãƒ†ãƒ¼ã‚¸åˆ¥ã®åˆ¶é™ã¾ã§ï¼‰
                let maxAttempts;
                if (this.currentStage === 'IE') {
                    maxAttempts = 3; // IEã‚¹ãƒ†ãƒ¼ã‚¸ã¯å°‘ãªã‚
                } else if (this.currentStage === 'Ic') {
                    maxAttempts = 15; // Icã‚¹ãƒ†ãƒ¼ã‚¸ã¯å¤§å¹…ã«å¢—åŠ ï¼ˆè¤‡é›‘ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç”Ÿæˆï¼‰
                } else {
                    maxAttempts = 6; // ãã®ä»–ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¯æ¨™æº–
                }
                
                for (let attempt = 0; attempt < maxAttempts && connections.length < stageMaxConnections; attempt++) {
                    const pattern = this.selectRandomPattern(patterns);
                    const patternConnections = this.generateConnectionPattern(
                        pattern.type, distanceMatrix, usedParticles, maxDistance, minDistance
                    );
                    
                    if (patternConnections.length > 0) {
                        connections.push(...patternConnections);
                    }
                }
                
                return connections;
            }
            
            // è·é›¢ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
            calculateDistanceMatrix() {
                const matrix = [];
                for (let i = 0; i < this.particles.length; i++) {
                    matrix[i] = [];
                    for (let j = 0; j < this.particles.length; j++) {
                        if (i === j) {
                            matrix[i][j] = 0;
                        } else {
                            matrix[i][j] = this.calculateParticleDistance(this.particles[i], this.particles[j]);
                        }
                    }
                }
                return matrix;
            }
            
            // ãƒ©ãƒ³ãƒ€ãƒ ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é¸æŠ
            selectRandomPattern(patterns) {
                const random = Math.random();
                let cumulative = 0;
                
                for (const pattern of patterns) {
                    cumulative += pattern.weight;
                    if (random <= cumulative) {
                        return pattern;
                    }
                }
                return patterns[patterns.length - 1];
            }
            
            // æŒ‡å®šã•ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã§æ¥ç¶šã‚’ç”Ÿæˆ
            generateConnectionPattern(patternType, distanceMatrix, usedParticles, maxDistance, minDistance) {
                switch (patternType) {
                    case 'hub':
                        return this.generateHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'chain':
                        return this.generateChainPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'triangle':
                        return this.generateTrianglePattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'star':
                        return this.generateStarPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'cycle':
                        return this.generateCyclePattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'dense_network':
                        return this.generateDenseNetworkPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'multi_hub':
                        return this.generateMultiHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'contemplative_pairs':
                        return this.generateContemplativePairsPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'introspective_hub':
                        return this.generateIntrospectiveHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    default:
                        return [];
                }
            }
            
            // ãƒãƒ–å‹ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼š1ã¤ã®ä¸­å¿ƒãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã«3-5å€‹ãŒæ¥ç¶š
            generateHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 4) return [];
                
                // ä¸­å¿ƒã¨ãªã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’é¸æŠ
                const hubIndex = availableParticles[Math.floor(Math.random() * availableParticles.length)];
                usedParticles.add(hubIndex);
                
                // ãƒãƒ–ã‹ã‚‰ã®æ¥ç¶šæ•°ã‚’æ±ºå®šï¼ˆIEã‚¹ãƒ†ãƒ¼ã‚¸ã¯æ§ãˆã‚ã«ï¼‰
                let connectionCount;
                if (this.currentStage === 'IE') {
                    connectionCount = 2 + Math.floor(Math.random() * 2); // 2-3å€‹ï¼ˆæ§ãˆã‚ï¼‰
                } else {
                    connectionCount = 3 + Math.floor(Math.random() * 3); // 3-5å€‹ï¼ˆé€šå¸¸ï¼‰
                }
                const connections = [];
                
                // ãƒãƒ–ã«æ¥ç¶šã™ã‚‹å€™è£œã‚’è·é›¢é †ã«ã‚½ãƒ¼ãƒˆ
                const candidates = availableParticles
                    .filter(i => i !== hubIndex && !usedParticles.has(i))
                    .map(i => ({ index: i, distance: distanceMatrix[hubIndex][i] }))
                    .filter(c => c.distance >= minDistance && c.distance <= maxDistance)
                    .sort((a, b) => a.distance - b.distance);
                
                // ä¸Šä½å€™è£œã‹ã‚‰æ¥ç¶š
                for (let i = 0; i < Math.min(connectionCount, candidates.length); i++) {
                    const targetIndex = candidates[i].index;
                    connections.push({ pair: [hubIndex, targetIndex], type: 'hub' });
                    usedParticles.add(targetIndex);
                }
                
                return connections;
            }
            
            // é€£é–å‹ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼šAâ†’Bâ†’Câ†’D ã®ç·šå½¢æ¥ç¶š
            generateChainPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 3) return [];
                
                // é€£é–ã®é•·ã•ã‚’æ±ºå®šï¼ˆIEã‚¹ãƒ†ãƒ¼ã‚¸ã¯çŸ­ã‚ã«ï¼‰
                let chainLength;
                if (this.currentStage === 'IE') {
                    chainLength = 2 + Math.floor(Math.random() * 2); // 2-3å€‹ï¼ˆçŸ­ã„é€£é–ï¼‰
                } else {
                    chainLength = 3 + Math.floor(Math.random() * 3); // 3-5å€‹ï¼ˆé€šå¸¸ï¼‰
                }
                
                const chain = [availableParticles[Math.floor(Math.random() * availableParticles.length)]];
                usedParticles.add(chain[0]);
                
                // é€£é–ã‚’æ§‹ç¯‰
                for (let i = 1; i < chainLength; i++) {
                    const lastIndex = chain[i - 1];
                    const candidates = availableParticles
                        .filter(j => !usedParticles.has(j))
                        .map(j => ({ index: j, distance: distanceMatrix[lastIndex][j] }))
                        .filter(c => c.distance >= minDistance && c.distance <= maxDistance)
                        .sort((a, b) => a.distance - b.distance);
                    
                    if (candidates.length === 0) break;
                    
                    const nextIndex = candidates[0].index;
                    chain.push(nextIndex);
                    usedParticles.add(nextIndex);
                }
                
                // é€£é–ã®æ¥ç¶šã‚’ä½œæˆ
                const connections = [];
                for (let i = 0; i < chain.length - 1; i++) {
                    connections.push({ pair: [chain[i], chain[i + 1]], type: 'chain' });
                }
                
                return connections;
            }
            
            // ä¸‰è§’å½¢ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼š3ã¤ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãŒç›¸äº’ã«æ¥ç¶š
            generateTrianglePattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 3) return [];
                
                // æœ€åˆã®2ã¤ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’é¸æŠ
                const first = availableParticles[Math.floor(Math.random() * availableParticles.length)];
                const secondCandidates = availableParticles
                    .filter(i => i !== first)
                    .map(i => ({ index: i, distance: distanceMatrix[first][i] }))
                    .filter(c => c.distance >= minDistance && c.distance <= maxDistance);
                
                if (secondCandidates.length === 0) return [];
                
                const second = secondCandidates[Math.floor(Math.random() * secondCandidates.length)].index;
                
                // 3ã¤ç›®ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’é¸æŠï¼ˆä¸¡æ–¹ã«é©åˆ‡ãªè·é›¢ï¼‰
                const thirdCandidates = availableParticles
                    .filter(i => i !== first && i !== second)
                    .filter(i => {
                        const d1 = distanceMatrix[first][i];
                        const d2 = distanceMatrix[second][i];
                        return d1 >= minDistance && d1 <= maxDistance && 
                               d2 >= minDistance && d2 <= maxDistance;
                    });
                
                if (thirdCandidates.length === 0) return [];
                
                const third = thirdCandidates[Math.floor(Math.random() * thirdCandidates.length)];
                
                // ä½¿ç”¨æ¸ˆã¿ã¨ã—ã¦ãƒãƒ¼ã‚¯
                usedParticles.add(first);
                usedParticles.add(second);
                usedParticles.add(third);
                
                return [
                    { pair: [first, second], type: 'triangle' },
                    { pair: [second, third], type: 'triangle' },
                    { pair: [third, first], type: 'triangle' }
                ];
            }
            
            // æ˜Ÿå‹ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼šä¸­å¿ƒã‹ã‚‰æ”¾å°„çŠ¶ã«æ¥ç¶š
            generateStarPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                return this.generateHubPattern(distanceMatrix, usedParticles, maxDistance * 1.2, minDistance);
            }
            
            // å¾ªç’°å‹ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼šAâ†’Bâ†’Câ†’Dâ†’A ã®å¾ªç’°æ¥ç¶š
            generateCyclePattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const chainConnections = this.generateChainPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                if (chainConnections.length < 2) return chainConnections;
                
                // ã™ã¹ã¦ã‚’å¾ªç’°ã‚¿ã‚¤ãƒ—ã«å¤‰æ›´
                chainConnections.forEach(connection => connection.type = 'cycle');
                
                // æœ€å¾Œã¨æœ€åˆã‚’æ¥ç¶šã—ã¦å¾ªç’°ã«ã™ã‚‹
                const firstParticle = chainConnections[0].pair[0];
                const lastParticle = chainConnections[chainConnections.length - 1].pair[1];
                const distance = distanceMatrix[lastParticle][firstParticle];
                
                if (distance >= minDistance && distance <= maxDistance) {
                    chainConnections.push({ pair: [lastParticle, firstParticle], type: 'cycle' });
                }
                
                return chainConnections;
            }
            
            // å¯†ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼šIcã‚¹ãƒ†ãƒ¼ã‚¸ç”¨ã®è±Šå¯Œãªç›¸äº’æ¥ç¶š
            generateDenseNetworkPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 6) return [];
                
                const connections = [];
                const selectedParticles = [];
                
                // 6-8å€‹ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’é¸æŠ
                const networkSize = Math.min(6 + Math.floor(Math.random() * 3), availableParticles.length);
                
                for (let i = 0; i < networkSize; i++) {
                    const index = availableParticles[Math.floor(Math.random() * availableParticles.length)];
                    if (!selectedParticles.includes(index)) {
                        selectedParticles.push(index);
                        usedParticles.add(index);
                    }
                }
                
                // é¸æŠã•ã‚ŒãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é–“ã§å¯†ãªæ¥ç¶šã‚’ä½œæˆ
                for (let i = 0; i < selectedParticles.length; i++) {
                    for (let j = i + 1; j < selectedParticles.length; j++) {
                        const particle1 = selectedParticles[i];
                        const particle2 = selectedParticles[j];
                        const distance = distanceMatrix[particle1][particle2];
                        
                        if (distance >= minDistance && distance <= maxDistance) {
                            // 60%ã®ç¢ºç‡ã§æ¥ç¶šï¼ˆå¯†ã ãŒå…¨ã¦ã§ã¯ãªã„ï¼‰
                            if (Math.random() < 0.6) {
                                connections.push({ pair: [particle1, particle2], type: 'dense_network' });
                            }
                        }
                    }
                }
                
                return connections;
            }
            
            // è¤‡æ•°ãƒãƒ–ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼šIcã‚¹ãƒ†ãƒ¼ã‚¸ç”¨ã®è¤‡æ•°ã®ä¸­å¿ƒç‚¹ã‚’æŒã¤ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯
            generateMultiHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 8) return [];
                
                const connections = [];
                const hubCount = 2 + Math.floor(Math.random() * 2); // 2-3å€‹ã®ãƒãƒ–
                const hubs = [];
                
                // ãƒãƒ–ã‚’é¸æŠ
                for (let h = 0; h < hubCount && availableParticles.length > 0; h++) {
                    const hubIndex = availableParticles.splice(Math.floor(Math.random() * availableParticles.length), 1)[0];
                    hubs.push(hubIndex);
                    usedParticles.add(hubIndex);
                }
                
                // å„ãƒãƒ–ã‹ã‚‰æ¥ç¶šã‚’ä½œæˆ
                hubs.forEach(hubIndex => {
                    const remainingParticles = availableParticles.filter(i => !usedParticles.has(i));
                    const connectionsPerHub = 2 + Math.floor(Math.random() * 3); // 2-4å€‹ã®æ¥ç¶š
                    
                    const candidates = remainingParticles
                        .map(i => ({ index: i, distance: distanceMatrix[hubIndex][i] }))
                        .filter(c => c.distance >= minDistance && c.distance <= maxDistance)
                        .sort((a, b) => a.distance - b.distance);
                    
                    for (let i = 0; i < Math.min(connectionsPerHub, candidates.length); i++) {
                        const targetIndex = candidates[i].index;
                        connections.push({ pair: [hubIndex, targetIndex], type: 'multi_hub' });
                        usedParticles.add(targetIndex);
                    }
                });
                
                // ãƒãƒ–åŒå£«ã‚‚æ¥ç¶šã™ã‚‹å¯èƒ½æ€§
                for (let i = 0; i < hubs.length; i++) {
                    for (let j = i + 1; j < hubs.length; j++) {
                        const distance = distanceMatrix[hubs[i]][hubs[j]];
                        if (distance >= minDistance && distance <= maxDistance && Math.random() < 0.4) {
                            connections.push({ pair: [hubs[i], hubs[j]], type: 'multi_hub' });
                        }
                    }
                }
                
                return connections;
            }

            // æ€ç´¢çš„ãƒšã‚¢ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼šI-Eã‚¹ãƒ†ãƒ¼ã‚¸ç”¨ - å†…ãªã‚‹å£°ã‚’è´ãéç¨‹ã§ã®æ…é‡ãªå¯¾è©±
            generateContemplativePairsPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 2) return [];
                
                const connections = [];
                const maxPairs = Math.min(3, Math.floor(availableParticles.length / 2)); // æœ€å¤§3ãƒšã‚¢
                
                // é©åº¦ãªè·é›¢ã®ãƒšã‚¢ã‚’é¸æŠï¼ˆè¿‘ã™ããšé ã™ããšï¼‰
                for (let pairCount = 0; pairCount < maxPairs && availableParticles.length >= 2; pairCount++) {
                    const candidates = [];
                    
                    // åˆ©ç”¨å¯èƒ½ãªãƒšã‚¢ã®çµ„ã¿åˆã‚ã›ã‚’è©•ä¾¡
                    for (let i = 0; i < availableParticles.length; i++) {
                        for (let j = i + 1; j < availableParticles.length; j++) {
                            const idx1 = availableParticles[i];
                            const idx2 = availableParticles[j];
                            const distance = distanceMatrix[idx1][idx2];
                            
                            // æ€ç´¢ã«é©ã—ãŸè·é›¢ï¼ˆä¸­ç¨‹åº¦ã®è·é›¢ã‚’å¥½ã‚€ï¼‰
                            if (distance >= minDistance * 1.5 && distance <= maxDistance * 0.8) {
                                candidates.push({ 
                                    pair: [idx1, idx2], 
                                    distance: distance,
                                    suitability: 1.0 - Math.abs(distance - (maxDistance * 0.5)) / (maxDistance * 0.5)
                                });
                            }
                        }
                    }
                    
                    if (candidates.length === 0) break;
                    
                    // æœ€é©ãªè·é›¢ã®ãƒšã‚¢ã‚’é¸æŠ
                    candidates.sort((a, b) => b.suitability - a.suitability);
                    const selectedPair = candidates[0];
                    
                    connections.push({ pair: selectedPair.pair, type: 'contemplative' });
                    
                    // ä½¿ç”¨æ¸ˆã¿ã«è¿½åŠ 
                    usedParticles.add(selectedPair.pair[0]);
                    usedParticles.add(selectedPair.pair[1]);
                    
                    // availableParticlesã‹ã‚‰ã‚‚å‰Šé™¤
                    const removeIndices = [
                        availableParticles.indexOf(selectedPair.pair[0]),
                        availableParticles.indexOf(selectedPair.pair[1])
                    ].sort((a, b) => b - a); // é™é †ã§ã‚½ãƒ¼ãƒˆã—ã¦å¾Œã‚ã‹ã‚‰å‰Šé™¤
                    
                    removeIndices.forEach(idx => availableParticles.splice(idx, 1));
                }
                
                return connections;
            }

            // å†…çœçš„ãƒãƒ–ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼šI-Eã‚¹ãƒ†ãƒ¼ã‚¸ç”¨ - æ§ãˆã‚ãªä¸­å¿ƒçš„æ€è€ƒ
            generateIntrospectiveHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 3) return [];
                
                const connections = [];
                
                // ä¸­å¿ƒã¨ãªã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’é¸æŠï¼ˆä¸­å¤®ã«è¿‘ã„ä½ç½®ã‚’å¥½ã‚€ï¼‰
                let hubIndex = availableParticles[0];
                let minCenterDistance = Number.MAX_VALUE;
                
                for (const idx of availableParticles) {
                    const particle = this.particles[idx];
                    const centerDistance = particle.position.length(); // åŸç‚¹ã‹ã‚‰ã®è·é›¢
                    if (centerDistance < minCenterDistance) {
                        minCenterDistance = centerDistance;
                        hubIndex = idx;
                    }
                }
                
                usedParticles.add(hubIndex);
                
                // æ§ãˆã‚ãªæ¥ç¶šï¼ˆ2-3å€‹ã®ã¿ï¼‰
                const connectionCount = 2 + Math.floor(Math.random() * 2);
                const candidates = availableParticles
                    .filter(i => i !== hubIndex)
                    .map(i => ({ index: i, distance: distanceMatrix[hubIndex][i] }))
                    .filter(c => c.distance >= minDistance && c.distance <= maxDistance * 0.7) // è¿‘ã‚ã®è·é›¢ã‚’å¥½ã‚€
                    .sort((a, b) => a.distance - b.distance);
                
                for (let i = 0; i < Math.min(connectionCount, candidates.length); i++) {
                    const targetIndex = candidates[i].index;
                    connections.push({ pair: [hubIndex, targetIndex], type: 'introspective' });
                    usedParticles.add(targetIndex);
                }
                
                return connections;
            }

            // ä½¿ç”¨å¯èƒ½ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒªã‚¹ãƒˆã‚’å–å¾—
            getAvailableParticles(usedParticles) {
                const available = [];
                for (let i = 0; i < this.particles.length; i++) {
                    if (!usedParticles.has(i)) {
                        available.push(i);
                    }
                }
                return available;
            }
            
            // æ¥ç¶šç·šã‚’ä½œæˆï¼ˆå¼·åŒ–ç‰ˆï¼‰
            createConnectionLine(particle1, particle2, opacity = 0.4, lineType = 'normal') {
                const points = [particle1.position.clone(), particle2.position.clone()];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                
                // ç·šã®ç¨®é¡ã«å¿œã˜ãŸé€æ˜åº¦ã¨å¤ªã•ã‚’èª¿æ•´
                let actualOpacity = opacity;
                let lineWidth = 1;
                
                switch (lineType) {
                    case 'hub':        // ãƒãƒ–æ¥ç¶šã¯å°‘ã—å¤ªãæ˜ã‚‹ã
                        actualOpacity = opacity * 1.3;
                        lineWidth = 2;
                        break;
                    case 'chain':      // é€£é–æ¥ç¶šã¯ä¸­ç¨‹åº¦
                        actualOpacity = opacity * 1.1;
                        lineWidth = 1.5;
                        break;
                    case 'cycle':      // å¾ªç’°æ¥ç¶šã¯è„ˆå‹•åŠ¹æœ
                        actualOpacity = opacity * (0.8 + Math.sin(Date.now() * 0.003) * 0.3);
                        lineWidth = 1.8;
                        break;
                    case 'triangle':   // ç›¸äº’æ¥ç¶šã¯å®‰å®šçš„ã«æ˜ã‚‹ã
                        actualOpacity = opacity * 1.2;
                        lineWidth = 1.5;
                        break;
                    case 'contemplative': // æ€ç´¢çš„æ¥ç¶šã¯æ§ãˆã‚ã§æºã‚‰ãã‚ã‚Š
                        actualOpacity = opacity * (0.6 + Math.sin(Date.now() * 0.002) * 0.2);
                        lineWidth = 1.2;
                        break;
                    case 'introspective': // å†…çœçš„æ¥ç¶šã¯ã‚ˆã‚Šç¹Šç´°
                        actualOpacity = opacity * 0.8;
                        lineWidth = 1.0;
                        break;
                        lineWidth = 1.3;
                        break;
                    default:
                        break;
                }
                
                // ã‚«ãƒ©ãƒ•ãƒ«ã‚¹ãƒ†ãƒ¼ã‚¸ã§ã¯å¤šæ§˜ãªè‰²ã€ãã‚Œä»¥å¤–ã¯ç™½ã€œé’ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                let color;
                if (this.isColorfulStage(this.currentStage)) {
                    color = this.colorfulParticlePalette[Math.floor(Math.random() * this.colorfulParticlePalette.length)];
                } else {
                    // æ¥ç¶šã®ç¨®é¡ã«å¿œã˜ãŸè‰²åˆ†ã‘
                    const colors = {
                        'hub': 0xffdd44,         // ãƒãƒ–ï¼šé‡‘è‰²
                        'chain': 0x44ddff,       // é€£é–ï¼šé’è‰²
                        'cycle': 0xff44dd,       // å¾ªç’°ï¼šç´«è‰²
                        'triangle': 0x44ff88,    // ç›¸äº’ï¼šç·‘è‰²
                        'dense_network': 0xff8844, // å¯†ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼šã‚ªãƒ¬ãƒ³ã‚¸è‰²
                        'multi_hub': 0x88ff44,   // è¤‡æ•°ãƒãƒ–ï¼šæ˜ã‚‹ã„ç·‘è‰²
                        'normal': 0xcccccc       // é€šå¸¸ï¼šç™½è‰²
                    };
                    color = colors[lineType] || colors.normal;
                }
                
                const material = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: Math.min(actualOpacity, 0.8),
                    blending: THREE.AdditiveBlending,
                    linewidth: lineWidth  // Note: linewidth ã¯ WebGL ã§ã¯åˆ¶é™ãŒã‚ã‚‹
                });
                
                const line = new THREE.Line(geometry, material);
                line.userData = { lineType: lineType }; // ç¨®é¡ã‚’ä¿å­˜
                return line;
            }
            
            // æ¥ç¶šç·šã‚’æ›´æ–°ï¼ˆå¼·åˆ¶æ›´æ–°ã‚ªãƒ—ã‚·ãƒ§ãƒ³ä»˜ãï¼‰
            updateConnections(forceUpdate = false) {
                const currentTime = Date.now();
                
                // ã‚¹ãƒ†ãƒ¼ã‚¸åˆ¥ã®æ›´æ–°é–“éš”ã‚’è¨­å®š
                let updateInterval;
                if (this.currentStage === 'Ic') {
                    updateInterval = 10000; // Icã‚¹ãƒ†ãƒ¼ã‚¸ï¼š10ç§’é–“éš”ï¼ˆæ¨™æº–çš„ãªæ›´æ–°é »åº¦ï¼‰
                } else if (this.currentStage === 'Ib') {
                    updateInterval = 10000; // Ibã‚¹ãƒ†ãƒ¼ã‚¸ï¼š10ç§’é–“éš”
                } else {
                    updateInterval = this.connectionUpdateInterval; // ãã®ä»–ï¼šæ¨™æº–é–“éš”
                }
                
                // é·ç§»ä¸­ã®å ´åˆã¯æ›´æ–°ã‚’ã‚¹ã‚­ãƒƒãƒ—
                if (this.isConnectionTransitioning && !forceUpdate) {
                    return;
                }
                
                // å®šæœŸçš„ãªæ›´æ–°ãƒã‚§ãƒƒã‚¯ï¼ˆå¼·åˆ¶æ›´æ–°ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—ï¼‰
                if (!forceUpdate && currentTime - this.lastConnectionUpdate < updateInterval) {
                    return;
                }
                
                this.lastConnectionUpdate = currentTime;
                
                // æ–°ã—ã„æ¥ç¶šãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é¸æŠ
                const newConnectionPairs = this.selectConnectionPairs();
                
                // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ãƒ»ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆåŠ¹æœã§åˆ‡ã‚Šæ›¿ãˆ
                if (this.connectionLines.length > 0 && !forceUpdate) {
                    // æ—¢å­˜ã®æ¥ç¶šãŒã‚ã‚‹å ´åˆã¯ãƒ•ã‚§ãƒ¼ãƒ‰é·ç§»ã‚’é–‹å§‹
                    this.startConnectionTransition(newConnectionPairs);
                } else {
                    // åˆå›ã¾ãŸã¯å¼·åˆ¶æ›´æ–°ã®å ´åˆã¯ç›´æ¥ä½œæˆ
                    this.clearConnections();
                    this.createConnectionsFromPairs(newConnectionPairs);
                }
            }
            
            // æ¥ç¶šç·šã‚’ã‚¯ãƒªã‚¢
            clearConnections() {
                this.connectionLines.forEach(connection => {
                    this.scene.remove(connection.line);
                    connection.line.geometry.dispose();
                    connection.line.material.dispose();
                });
                this.connectionLines = [];
            }
            
            // ãƒ•ã‚§ãƒ¼ãƒ‰é·ç§»ã‚’é–‹å§‹
            startConnectionTransition(newConnectionPairs) {
                this.isConnectionTransitioning = true;
                this.transitionStartTime = Date.now();
                this.pendingConnections = newConnectionPairs;
                this.transitionPhase = 'fadeOut';
                
                console.log('æ¥ç¶šç·šãƒ•ã‚§ãƒ¼ãƒ‰é·ç§»é–‹å§‹');
            }
            
            // ãƒ•ã‚§ãƒ¼ãƒ‰é·ç§»ã‚’æ›´æ–°
            updateConnectionTransition() {
                if (!this.isConnectionTransitioning) return;
                
                const currentTime = Date.now();
                const elapsedTime = currentTime - this.transitionStartTime;
                
                if (this.transitionPhase === 'fadeOut') {
                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆæ®µéš
                    const fadeProgress = Math.min(elapsedTime / this.fadeOutDuration, 1.0);
                    const targetOpacity = 1.0 - fadeProgress;
                    
                    // æ—¢å­˜ã®æ¥ç¶šç·šã®é€æ˜åº¦ã‚’ä¸‹ã’ã‚‹
                    this.connectionLines.forEach(connection => {
                        if (connection.line.material) {
                            connection.line.material.opacity = Math.max(0, targetOpacity * 0.4); // åŸºæœ¬é€æ˜åº¦0.4ã‹ã‚‰ãƒ•ã‚§ãƒ¼ãƒ‰
                        }
                    });
                    
                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆå®Œäº†ãƒã‚§ãƒƒã‚¯
                    if (fadeProgress >= 1.0) {
                        this.clearConnections();
                        this.createConnectionsFromPairs(this.pendingConnections);
                        this.transitionPhase = 'fadeIn';
                        this.transitionStartTime = currentTime;
                        console.log('ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆå®Œäº†ã€ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é–‹å§‹');
                    }
                } else if (this.transitionPhase === 'fadeIn') {
                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³æ®µéš
                    const fadeProgress = Math.min(elapsedTime / this.fadeInDuration, 1.0);
                    const targetOpacity = fadeProgress;
                    
                    // æ–°ã—ã„æ¥ç¶šç·šã®é€æ˜åº¦ã‚’ä¸Šã’ã‚‹
                    this.connectionLines.forEach(connection => {
                        if (connection.line.material) {
                            const baseOpacity = this.getBaseOpacityForLineType(connection.lineType);
                            connection.line.material.opacity = targetOpacity * baseOpacity;
                        }
                    });
                    
                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³å®Œäº†ãƒã‚§ãƒƒã‚¯
                    if (fadeProgress >= 1.0) {
                        this.isConnectionTransitioning = false;
                        this.transitionPhase = 'none';
                        this.pendingConnections = [];
                        console.log('ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³å®Œäº†ã€é·ç§»çµ‚äº†');
                    }
                }
            }
            
            // æ¥ç¶šç·šã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸåŸºæœ¬é€æ˜åº¦ã‚’å–å¾—
            getBaseOpacityForLineType(lineType) {
                switch (lineType) {
                    case 'hub':
                        return 0.52; // 0.4 * 1.3
                    case 'chain':
                        return 0.44; // 0.4 * 1.1
                    case 'triangle':
                        return 0.48; // 0.4 * 1.2
                    case 'contemplative':
                    case 'introspective':
                        return 0.32; // 0.4 * 0.8
                    default:
                        return 0.4;  // åŸºæœ¬é€æ˜åº¦
                }
            }
            
            // æ¥ç¶šç·šã‚’ãƒšã‚¢ã‹ã‚‰ä½œæˆ
            createConnectionsFromPairs(connectionPairs) {
                connectionPairs.forEach(connection => {
                    const [index1, index2] = connection.pair;
                    const lineType = connection.type;
                    const particle1 = this.particles[index1];
                    const particle2 = this.particles[index2];
                    
                    if (particle1 && particle2) {
                        const line = this.createConnectionLine(particle1, particle2, 0.4, lineType);
                        
                        // é·ç§»ä¸­ã®å ´åˆã¯åˆæœŸé€æ˜åº¦ã‚’0ã«è¨­å®š
                        if (this.isConnectionTransitioning && this.transitionPhase === 'fadeIn') {
                            line.material.opacity = 0;
                        }
                        
                        this.scene.add(line);
                        this.connectionLines.push({
                            line: line,
                            particle1Index: index1,
                            particle2Index: index2,
                            lineType: lineType
                        });
                    }
                });
            }
            
            // æ—¢å­˜ã®æ¥ç¶šç·šã®ä½ç½®ã‚’æ›´æ–°ï¼ˆå‹•çš„åŠ¹æœä»˜ãï¼‰
            updateConnectionPositions() {
                const time = Date.now() * 0.001;
                
                this.connectionLines.forEach(connection => {
                    const particle1 = this.particles[connection.particle1Index];
                    const particle2 = this.particles[connection.particle2Index];
                    
                    if (particle1 && particle2) {
                        const points = [particle1.position.clone(), particle2.position.clone()];
                        connection.line.geometry.setFromPoints(points);
                        connection.line.geometry.attributes.position.needsUpdate = true;
                        
                        // ãƒ•ã‚§ãƒ¼ãƒ‰é·ç§»ä¸­ã§ãªã„å ´åˆã®ã¿å‹•çš„åŠ¹æœã‚’é©ç”¨
                        if (!this.isConnectionTransitioning) {
                            // æ¥ç¶šã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸå‹•çš„åŠ¹æœ
                            if (connection.lineType === 'cycle') {
                                // å¾ªç’°æ¥ç¶šã¯è„ˆå‹•åŠ¹æœ
                                const pulse = 0.3 + 0.4 * (0.5 + 0.5 * Math.sin(time * 3));
                                connection.line.material.opacity = pulse;
                            } else if (connection.lineType === 'hub') {
                                // ãƒãƒ–æ¥ç¶šã¯å¾ã€…ã«æ˜ã‚‹ããªã‚‹åŠ¹æœ
                                const glow = 0.4 + 0.3 * (0.5 + 0.5 * Math.sin(time * 1.5));
                                connection.line.material.opacity = glow;
                            } else if (connection.lineType === 'chain') {
                                // é€£é–æ¥ç¶šã¯æµã‚Œã‚‹ã‚ˆã†ãªåŠ¹æœ
                                const flow = 0.3 + 0.3 * (0.5 + 0.5 * Math.sin(time * 2 + connection.particle1Index));
                                connection.line.material.opacity = flow;
                            }
                        }
                    }
                });
            }
            
            // ã‚«ãƒ©ãƒ•ãƒ«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”¨ã®è‰²ã‚’å–å¾—
            getColorfulParticleColor(index, time) {
                const paletteIndex = (index + Math.floor(time * 2)) % this.colorfulParticlePalette.length;
                return this.colorfulParticlePalette[paletteIndex];
            }
            
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®è‰²ã‚’å‹•çš„ã«æ›´æ–°
            updateParticleColorDynamic(particle, index, time) {
                if (this.isColorfulStage(this.currentStage)) {
                    const targetColor = this.getColorfulParticleColor(index, time);
                    const currentColor = particle.material.color;
                    const targetColorObj = new THREE.Color(targetColor);
                    
                    // æ»‘ã‚‰ã‹ãªè‰²å¤‰æ›´
                    currentColor.lerp(targetColorObj, this.colorTransitionSpeed);
                }
            }
            
            getStageData(stage) {
                const stageMap = {
                    'Ea': { 
                        particleCount: 20, 
                        color: 0xff6b6b, 
                        description: 'å¤–çš„æ¨©å¨ã‚’ä¿¡é ¼',
                        behavior: 'chaotic',           // æ··æ²Œã¨ã—ãŸå‹•ã
                        cohesion: 0.1,                // çµæŸåº¦ï¼šéå¸¸ã«ä½ã„
                        speed: 0.8,                   // é€Ÿåº¦ï¼šæ¯”è¼ƒçš„ä½ã„
                        pattern: 'random'             // ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼šãƒ©ãƒ³ãƒ€ãƒ 
                    },
                    'Eb': { 
                        particleCount: 25, 
                        color: 0xff8e53, 
                        description: 'å¤–çš„æ¨©å¨ã¨ã®ç·Šå¼µ',
                        behavior: 'conflicted',       // å¯¾ç«‹ã™ã‚‹å‹•ã
                        cohesion: 0.2,
                        speed: 1.2,                   // ç·Šå¼µã§é€Ÿåº¦ä¸Šæ˜‡
                        pattern: 'opposing'           // å¯¾ç«‹ãƒ‘ã‚¿ãƒ¼ãƒ³
                    },
                    'Ec': { 
                        particleCount: 30, 
                        color: 0xffa726, 
                        description: 'æ¬ ç‚¹ã®èªè­˜',
                        behavior: 'questioning',      // ç–‘å•ã‚’ç¤ºã™å‹•ã
                        cohesion: 0.3,
                        speed: 0.9,
                        pattern: 'hesitant'           // ãŸã‚ã‚‰ã„ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
                    },
                    'EI': { 
                        particleCount: 20,  // 35ã‹ã‚‰20ã«æ¸›å°‘
                        color: 0xffeb3b, 
                        description: 'ç–‘å•ã‚’æŒã¤',
                        behavior: 'questioning_emergence',  // ç–‘å•ã«ã‚ˆã‚‹å‡ºç¾ãƒ»æ¶ˆå¤±
                        cohesion: 0.4,
                        speed: 1.0,
                        pattern: 'dynamic_emergence'       // å‹•çš„å‡ºç¾ãƒ‘ã‚¿ãƒ¼ãƒ³
                    },
                    'E-I': { 
                        particleCount: 40, 
                        color: 0xcddc39, 
                        description: 'å†…ãªã‚‹å£°ã‚’æ§‹ç¯‰',
                        behavior: 'building',         // æ§‹ç¯‰ã™ã‚‹å‹•ã
                        cohesion: 0.5,
                        speed: 1.1,
                        pattern: 'convergent'         // åæŸãƒ‘ã‚¿ãƒ¼ãƒ³
                    },
                    'I-E': { 
                        particleCount: 45, 
                        color: 0x8bc34a, 
                        description: 'å†…ãªã‚‹å£°ã‚’è´ã',
                        behavior: 'listening',        // è´ãå‹•ã
                        cohesion: 0.1,                // ä½ã„å‡é›†åŠ›ï¼ˆè‡ªç”±ãªæµ®éŠã‚’ç¶­æŒï¼‰
                        speed: 0.5,                   // ã‚ˆã‚Šé™ã‹ã«è´ã
                        pattern: 'pulse'              // è„ˆå‹•ãƒ‘ã‚¿ãƒ¼ãƒ³
                    },
                    'IE': { 
                        particleCount: 50, 
                        color: 0x4caf50, 
                        description: 'å†…ãªã‚‹å£°ã‚’è‚²ã‚€',
                        behavior: 'nurturing',        // è‚²ã‚€å‹•ã
                        cohesion: 0.7,
                        speed: 0.9,
                        pattern: 'growth'             // æˆé•·ãƒ‘ã‚¿ãƒ¼ãƒ³
                    },
                    'Ia': { 
                        particleCount: 55, 
                        color: 0x26a69a, 
                        description: 'å†…ãªã‚‹å£°ã‚’ä¿¡é ¼',
                        behavior: 'trusting',         // ä¿¡é ¼ã™ã‚‹å‹•ã
                        cohesion: 0.8,
                        speed: 1.0,
                        pattern: 'stable_orbit'       // å®‰å®šè»Œé“
                    },
                    'Ib': { 
                        particleCount: 60, 
                        color: 0x29b6f6, 
                        description: 'å†…ãªã‚‹åŸºç›¤',
                        behavior: 'foundation',       // åŸºç›¤å½¢æˆ
                        cohesion: 0.9,
                        speed: 0.8,
                        pattern: 'structured'         // æ§‹é€ åŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³
                    },
                    'Ic': { 
                        particleCount: 65, 
                        color: 0x42a5f5,              // Ibã®é’ã‚’ãƒ™ãƒ¼ã‚¹ã«ã—ãŸæ˜ã‚‹ã„è‰²
                        description: 'ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒ³ãƒˆç¢ºä¿',
                        behavior: 'committed',        // ã‚³ãƒŸãƒƒãƒˆçŠ¶æ…‹
                        cohesion: 1.0,                // æœ€é«˜ã®çµæŸ
                        speed: 1.0,
                        pattern: 'wave_rotation'      // æ³¢å‹•å›è»¢ãƒ‘ã‚¿ãƒ¼ãƒ³
                    }
                };
                return stageMap[stage] || stageMap['Ea'];
            }
            
            createControls() {
                // Add mouse controls for camera
                let mouseDown = false;
                let mouseX = 0;
                let mouseY = 0;
                
                const canvas = this.renderer.domElement;
                
                canvas.addEventListener('mousedown', (e) => {
                    mouseDown = true;
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!mouseDown) return;
                    
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    
                    this.camera.position.x += deltaX * 0.01;
                    this.camera.position.y -= deltaY * 0.01;
                    this.camera.lookAt(0, 0, 0);
                    
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                canvas.addEventListener('mouseup', () => {
                    mouseDown = false;
                });
                
                // Touch controls for mobile
                let touchStartX = 0;
                let touchStartY = 0;
                
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                });
                
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - touchStartX;
                    const deltaY = touch.clientY - touchStartY;
                    
                    this.camera.position.x += deltaX * 0.01;
                    this.camera.position.y -= deltaY * 0.01;
                    this.camera.lookAt(0, 0, 0);
                    
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                });
            }
            
            bindEvents() {
                // Stage button clicks
                const stageButtons = document.querySelectorAll('.stage-btn');
                stageButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const stage = btn.dataset.stage;
                        this.switchToStage(stage);
                    });
                });
                
                // View control buttons
                const resetBtn = document.getElementById('reset-view-btn');
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => {
                        this.resetView();
                    });
                }
                
                const reinitBtn = document.getElementById('reinit-3d-btn');
                if (reinitBtn) {
                    reinitBtn.addEventListener('click', () => {
                        this.reinitialize3D();
                    });
                }
                
                // èª¬æ˜è¡¨ç¤ºãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
                const explanationBtn = document.getElementById('explanation-toggle-btn');
                if (explanationBtn) {
                    explanationBtn.addEventListener('click', () => {
                        if (this.explanationSystem) {
                            // ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’æ¸¡ã—ã¦è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ
                            this.explanationSystem.toggle(this.currentStage);
                        }
                    });
                }
                
                // Zoom controls via mouse wheel
                if (this.renderer && this.renderer.domElement) {
                    this.renderer.domElement.addEventListener('wheel', (e) => {
                        e.preventDefault();
                        this.handleZoom(e.deltaY);
                    }, { passive: false });
                }
                
                // Window resize
                window.addEventListener('resize', () => {
                    if (this.isInitialized) {
                        this.handleResize();
                    }
                });
            }
            
            switchToStage(stageId) {
                if (!this.isInitialized || this.isTransitioning) return;
                
                // Reset questioning stage specific data when switching stages
                this.persistentParticleIndices.clear();
                
                this.currentStage = stageId;
                
                // å¤šé¢ä½“å½¢çŠ¶ã®æ›´æ–°
                this.updatePolyhedronShape(stageId);
                
                this.updateStageVisualization(stageId);
                this.updateActiveButton(stageId);
                console.log('Switched to stage:', stageId);
            }

            updatePolyhedronShape(stageId) {
                if (this.isTransitioning) return;
                
                this.isTransitioning = true;
                
                // ç¾åœ¨ã®å½¢çŠ¶ã‹ã‚‰æ–°ã—ã„å½¢çŠ¶ã¸ã®ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³
                const currentGeometry = this.core?.geometry;
                const newGeometry = this.coreGeometryManager.createPolyhedronGeometry(stageId);
                
                if (currentGeometry && newGeometry) {
                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ â†’ å½¢çŠ¶å¤‰æ›´ â†’ ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
                    this.animatePolyhedronTransition(currentGeometry, newGeometry, stageId);
                } else {
                    // åˆå›ã¾ãŸã¯ç·Šæ€¥æ™‚ã¯ç›´æ¥ä½œæˆ
                    this.createPolyhedronCore(stageId);
                    this.isTransitioning = false;
                }
            }

            animatePolyhedronTransition(oldGeometry, newGeometry, stageId) {
                const transitionDuration = 1500; // 1.5ç§’ã®ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³
                const fadeOutDuration = 500;
                const scaleTransitionDuration = 700; // ã‚¹ã‚±ãƒ¼ãƒ«å¤‰æ›´æœŸé–“
                const fadeInDuration = 500;
                
                // ç¾åœ¨ã®ã‚µã‚¤ã‚ºã¨æ–°ã—ã„ã‚µã‚¤ã‚ºã‚’å–å¾—
                const oldSize = this.coreGeometryManager.getStageSize(this.currentStage);
                const newSize = this.coreGeometryManager.getStageSize(stageId);
                
                // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
                const startOpacity = this.core.material.opacity;
                const startScale = this.core.scale.x;
                const fadeOutStart = Date.now();
                
                const fadeOut = () => {
                    const elapsed = Date.now() - fadeOutStart;
                    const progress = Math.min(elapsed / fadeOutDuration, 1);
                    
                    this.core.material.opacity = startOpacity * (1 - progress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(fadeOut);
                    } else {
                        // å½¢çŠ¶å¤‰æ›´
                        this.createPolyhedronCore(stageId);
                        
                        // ã‚¹ã‚±ãƒ¼ãƒ«ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ä»˜ããƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
                        const targetOpacity = 0.85;
                        this.core.material.opacity = 0;
                        this.core.scale.set(oldSize / newSize, oldSize / newSize, oldSize / newSize); // å¤ã„ã‚µã‚¤ã‚ºã‹ã‚‰é–‹å§‹
                        
                        const fadeInStart = Date.now();
                        
                        const fadeIn = () => {
                            const elapsed = Date.now() - fadeInStart;
                            const progress = Math.min(elapsed / fadeInDuration, 1);
                            
                            // ã‚ªãƒ‘ã‚·ãƒ†ã‚£ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
                            this.core.material.opacity = targetOpacity * progress;
                            
                            // ã‚¹ã‚±ãƒ¼ãƒ«ã®æ»‘ã‚‰ã‹ãªå¤‰åŒ–
                            const scaleProgress = Math.min(elapsed / scaleTransitionDuration, 1);
                            const easeOut = 1 - Math.pow(1 - scaleProgress, 3); // ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆ
                            const currentScale = (oldSize / newSize) + (1 - oldSize / newSize) * easeOut;
                            this.core.scale.set(currentScale, currentScale, currentScale);
                            
                            if (progress < 1 || scaleProgress < 1) {
                                requestAnimationFrame(fadeIn);
                            } else {
                                // æœ€çµ‚çš„ã«æ­£ç¢ºãªã‚¹ã‚±ãƒ¼ãƒ«ã«è¨­å®š
                                this.core.scale.set(1, 1, 1);
                                this.isTransitioning = false;
                                console.log(`ã‚µã‚¤ã‚ºå¤‰æ›´å®Œäº†: ${oldSize.toFixed(2)} â†’ ${newSize.toFixed(2)}`);
                            }
                        };
                        
                        fadeIn();
                    }
                };
                
                fadeOut();
            }
            
            updateStageVisualization(stageId) {
                // ã‚¹ãƒ ãƒ¼ã‚ºãªãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³åŠ¹æœ
                this.transitionToStage(stageId);
                
                // Update core appearance based on stage
                const stageData = this.getStageData(stageId);
                if (this.core) {
                    // Coreè‰²ã‚’ã‚¹ãƒ ãƒ¼ã‚ºã«å¤‰æ›´
                    this.animateCoreColor(stageData.color);
                }
                
                // æ–°ã—ã„æ¬¡å…ƒåŠ¹æœã‚·ã‚¹ãƒ†ãƒ ã‚’æ›´æ–°
                const stageNumber = this.getStageNumber(stageId);
                this.updateDimensionEffects(stageNumber);
            }
            
            // æ®µéšã«å¿œã˜ã¦æ¬¡å…ƒãƒªãƒ³ã‚°ã‚’æ›´æ–°ï¼ˆçµ±ä¸€åŒ–ã•ã‚ŒãŸãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ã‚·ã‚¹ãƒ†ãƒ ï¼‰
            updateDimensionRings(stageId) {
                const stageNumber = this.getStageNumber(stageId);
                
                this.dimensionRings.forEach((ring, index) => {
                    if (!ring.userData) return;
                    
                    // çµ±ä¸€åŒ–ã•ã‚ŒãŸè‰²èª¿ã¨è³ªæ„Ÿã‚’æ®µéšã«å¿œã˜ã¦æ›´æ–°
                    const newColor = this.getDimensionRingColor(index, stageNumber);
                    const newOpacity = this.getDimensionRingOpacity(stageNumber);
                    const newShininess = this.getDimensionRingShininess(stageNumber);
                    const newEmissive = this.getDimensionRingEmissive(index, stageNumber);
                    const newEmissiveIntensity = this.getDimensionRingEmissiveIntensity(stageNumber);
                    
                    // ã‚µã‚¤ã‚ºã‚’æ®µéšã«å¿œã˜ã¦æ›´æ–°
                    const newRadius = this.getDimensionRingRadius(index, stageNumber);
                    this.updateRingGeometry(ring, newRadius);
                    
                    // çµ±ä¸€åŒ–ã•ã‚ŒãŸãƒãƒ†ãƒªã‚¢ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã§ã‚¹ãƒ ãƒ¼ã‚ºãªãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³
                    this.animateRingProperties(ring, newColor, newOpacity, newShininess, newEmissive, newEmissiveIntensity);
                    
                    // ç›¸äº’ä½œç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ®µéšã«å¿œã˜ã¦è¨­å®š
                    ring.userData.interactionStrength = this.getInteractionStrength(stageNumber);
                    ring.userData.synchronizationFactor = this.getSynchronizationFactor(stageNumber);
                    ring.userData.materialEvolution = this.getCoreProgress(stageNumber); // æè³ªé€²åŒ–åº¦ã‚’åŒæœŸ
                });
            }
            
            // ãƒªãƒ³ã‚°ã®ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’æ–°ã—ã„åŠå¾„ã§æ›´æ–°
            updateRingGeometry(ring, newRadius) {
                // ç¾åœ¨ã®åŠå¾„ã¨æ–°ã—ã„åŠå¾„ã‚’æ¯”è¼ƒã—ã¦ãƒ­ã‚°å‡ºåŠ›
                const currentRadius = ring.geometry.parameters.radius;
                if (Math.abs(currentRadius - newRadius) > 0.1) {
                    console.log(`ãƒªãƒ³ã‚°${ring.userData.ringIndex}ã®ã‚µã‚¤ã‚ºå¤‰æ›´: ${currentRadius.toFixed(2)} â†’ ${newRadius.toFixed(2)}`);
                }
                
                // æ–°ã—ã„ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’ä½œæˆ
                const newGeometry = new THREE.TorusGeometry(newRadius, 0.05, 8, 32);
                
                // å¤ã„ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’ç ´æ£„
                ring.geometry.dispose();
                
                // æ–°ã—ã„ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’é©ç”¨
                ring.geometry = newGeometry;
            }

            // æ®µéšç•ªå·ã‚’å–å¾—
            getStageNumber(stageId) {
                const stageMap = {
                    'Ea': 1, 'Eb': 2, 'Ec': 3,    // External Authority 1-3
                    'EI': 4,                          // External-Internal (å²è·¯æ®µéšã®å§‹ã¾ã‚Š)
                    'E-I': 5,                         // External to Internal
                    'I-E': 6,                         // Internal to External  
                    'IE': 7,                          // Internal-External
                    'Ia': 8, 'Ib': 9, 'Ic': 10    // Internal Authority 8-10
                };
                return stageMap[stageId] || 1;
            }
            
            // çµ±ä¸€åŒ–ã•ã‚ŒãŸãƒªãƒ³ã‚°ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            animateRingProperties(ring, newColor, newOpacity, newShininess, newEmissive, newEmissiveIntensity) {
                // è‰²ã®ã‚¹ãƒ ãƒ¼ã‚ºãªå¤‰æ›´
                const currentColor = new THREE.Color(ring.material.color);
                const targetColor = new THREE.Color(newColor);
                const currentEmissive = new THREE.Color(ring.material.emissive);
                const targetEmissive = new THREE.Color(newEmissive);
                
                // çµ±ä¸€åŒ–ã•ã‚ŒãŸãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ï¼ˆå¤šé¢ä½“ã‚³ã‚¢ã¨åŒæœŸï¼‰
                ring.material.color.lerp(targetColor, 0.1);
                ring.material.opacity = THREE.MathUtils.lerp(ring.material.opacity, newOpacity, 0.1);
                ring.material.shininess = THREE.MathUtils.lerp(ring.material.shininess, newShininess, 0.1);
                ring.material.emissive.lerp(targetEmissive, 0.1);
                ring.material.emissiveIntensity = THREE.MathUtils.lerp(ring.material.emissiveIntensity, newEmissiveIntensity, 0.1);
                
                // ãƒãƒ†ãƒªã‚¢ãƒ«ã®æ›´æ–°ãŒå¿…è¦ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™
                ring.material.needsUpdate = true;
            }
            
            // æ®µéšã«å¿œã˜ãŸç›¸äº’ä½œç”¨ã®å¼·åº¦
            getInteractionStrength(stage) {
                if (stage <= 3) {
                    // EAæ®µéš: 0.05-0.20 (ç‹¬ç«‹å›è»¢)
                    return 0.05 + stage * 0.05;
                } else if (stage <= 7) {
                    // å²è·¯æ®µéš: 0.20-0.80 (åŒæœŸã®å§‹ã¾ã‚Šã€œç™ºå±•)
                    return 0.20 + (stage - 3) * 0.15;
                } else {
                    // IAæ®µéš: 0.80-0.98 (å¼·ã„ç›¸äº’ä½œç”¨)
                    return 0.80 + (stage - 7) * 0.06;
                }
            }
            
            // æ®µéšã«å¿œã˜ãŸåŒæœŸåº¦åˆã„
            getSynchronizationFactor(stage) {
                if (stage <= 3) {
                    // EAæ®µéš: 0 (å®Œå…¨ã«ç‹¬ç«‹)
                    return 0;
                } else if (stage <= 7) {
                    // å²è·¯æ®µéš: 0-0.80 (å¾ã€…ã«åŒæœŸ)
                    return (stage - 3) * 0.20;
                } else {
                    // IAæ®µéš: 0.80-0.98 (é«˜åº¦ãªçµ±åˆ)
                    return 0.80 + (stage - 7) * 0.06;
                }
            }
            
            // æ®µéšçš„é€²åŒ–ã™ã‚‹æ¬¡å…ƒãƒªãƒ³ã‚°ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            animateDimensionRingsEvolution(time) {
                const stageNumber = this.getStageNumber(this.currentStage);
                
                this.dimensionRings.forEach((ring, index) => {
                    if (!ring.userData) return;
                    
                    const userData = ring.userData;
                    const interactionStrength = userData.interactionStrength || 0;
                    const syncFactor = userData.synchronizationFactor || 0;
                    
                    // åŸºæœ¬å›è»¢é€Ÿåº¦ã®è¨ˆç®—
                    let currentSpeed = userData.baseRotationSpeed;
                    
                    // æ®µéšã«å¿œã˜ãŸå›è»¢ãƒ‘ã‚¿ãƒ¼ãƒ³
                    if (stageNumber <= 3) {
                        // æ®µéš1-3: ç‹¬ç«‹å›è»¢ï¼ˆãã‚Œãã‚Œç‹¬ç«‹ï¼‰
                        ring.rotation.y += currentSpeed * userData.rotationDirection * 0.01;
                        ring.rotation.x = userData.baseRotationX + Math.sin(time * 0.3 + index) * 0.05;
                        
                    } else if (stageNumber <= 6) {
                        // æ®µéš4-6: å¼±ã„ç›¸äº’ä½œç”¨ï¼ˆåŒæœŸã®å§‹ã¾ã‚Šï¼‰
                        const otherRingsInfluence = this.calculateRingInfluence(index, time);
                        const influenceStrength = interactionStrength * 0.5;
                        
                        ring.rotation.y += (currentSpeed + otherRingsInfluence * influenceStrength) * userData.rotationDirection * 0.01;
                        ring.rotation.x = userData.baseRotationX + 
                                         Math.sin(time * 0.4 + index) * 0.08 + 
                                         Math.sin(time * 0.2 + index * 2) * influenceStrength * 0.03;
                        
                    } else {
                        // æ®µéš7-10: è¤‡é›‘ãªç›¸äº’ä½œç”¨ï¼ˆçµ±åˆã•ã‚ŒãŸå‹•ãï¼‰
                        const complexInteraction = this.calculateComplexInteraction(index, time, syncFactor);
                        
                        ring.rotation.y += (currentSpeed + complexInteraction.yInfluence) * userData.rotationDirection * 0.01;
                        ring.rotation.x = userData.baseRotationX + complexInteraction.xInfluence;
                        
                        // é«˜æ¬¡æ®µéšã§ã¯è»Œé“ã‚‚å¤‰åŒ–
                        const orbitalMotion = this.calculateOrbitalMotion(index, time, syncFactor);
                        ring.position.x = orbitalMotion.x;
                        ring.position.z = orbitalMotion.z;
                    }
                    
                    // ã™ã¹ã¦ã®æ®µéšã§è‰²ã¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®ç¶™ç¶šçš„æ›´æ–°
                    this.updateRingAppearanceContinuous(ring, index, stageNumber, time);
                });
            }
            
            // ä»–ã®ãƒªãƒ³ã‚°ã‹ã‚‰ã®å½±éŸ¿ã‚’è¨ˆç®—
            calculateRingInfluence(currentIndex, time) {
                let totalInfluence = 0;
                
                this.dimensionRings.forEach((otherRing, otherIndex) => {
                    if (otherIndex !== currentIndex && otherRing.userData) {
                        const distance = Math.abs(currentIndex - otherIndex);
                        const influence = Math.sin(time * 0.3 + otherIndex) / (distance + 1);
                        totalInfluence += influence;
                    }
                });
                
                return totalInfluence * 0.1;
            }
            
            // è¤‡é›‘ãªç›¸äº’ä½œç”¨ã®è¨ˆç®—ï¼ˆé«˜æ¬¡æ®µéšç”¨ï¼‰
            calculateComplexInteraction(index, time, syncFactor) {
                const phase1 = time * 0.2 + index * Math.PI * 2 / 3;
                const phase2 = time * 0.15 + (index + 1) * Math.PI * 2 / 3;
                const phase3 = time * 0.25 + (index + 2) * Math.PI * 2 / 3;
                
                const yInfluence = (Math.sin(phase1) + Math.sin(phase2) * syncFactor) * 0.3;
                const xInfluence = (Math.sin(phase1) * 0.1 + 
                                  Math.cos(phase2) * syncFactor * 0.08 + 
                                  Math.sin(phase3) * syncFactor * 0.05);
                
                return { yInfluence, xInfluence };
            }
            
            // è»Œé“é‹å‹•ã®è¨ˆç®—ï¼ˆæœ€é«˜æ¬¡æ®µéšç”¨ï¼‰
            calculateOrbitalMotion(index, time, syncFactor) {
                if (syncFactor < 0.5) {
                    return { x: 0, z: 0 }; // è»Œé“é‹å‹•ãªã—
                }
                
                const radius = 0.2 * syncFactor;
                const frequency = 0.1 + index * 0.05;
                const phase = index * Math.PI * 2 / 3;
                
                return {
                    x: Math.cos(time * frequency + phase) * radius,
                    z: Math.sin(time * frequency + phase) * radius
                };
            }
            
            // ãƒªãƒ³ã‚°ã®å¤–è¦³ã®ç¶™ç¶šçš„æ›´æ–°
            updateRingAppearanceContinuous(ring, index, stageNumber, time) {
                // å‘¼å¸ã®ã‚ˆã†ãªå…‰ã®å¤‰å‹•
                const breathe = Math.sin(time * 0.5 + index) * 0.1 + 1;
                
                // æ®µéšã«å¿œã˜ãŸç™ºå…‰åŠ¹æœ
                if (stageNumber >= 7) {
                    // è¼ãè³ªæ„Ÿã®æ®µéšã§ã¯ç™ºå…‰åŠ¹æœã‚’è¿½åŠ 
                    const glow = Math.sin(time * 0.8 + index * 2) * 0.3 + 0.7;
                    ring.material.emissive = ring.material.color.clone().multiplyScalar(0.1 * glow);
                }
                
                // é€æ˜åº¦ã®å¾®èª¿æ•´
                const baseOpacity = this.getDimensionRingOpacity(stageNumber);
                ring.material.opacity = baseOpacity * breathe;
            }

            transitionToStage(newStageId) {
                const oldStageData = this.getStageData(this.currentStage);
                const newStageData = this.getStageData(newStageId);
                
                // æ¥ç¶šç·šã‚’ã‚¯ãƒªã‚¢ï¼ˆå…¨ã‚¹ãƒ†ãƒ¼ã‚¸åˆ‡ã‚Šæ›¿ãˆæ™‚ï¼‰
                this.clearConnections();
                
                // ã‚¹ãƒ†ãƒ¼ã‚¸åˆ‡ã‚Šæ›¿ãˆæ™‚ã®ã‚³ã‚¢å…‰é‡ãƒªã‚»ãƒƒãƒˆ
                if (this.currentStage === 'EI' || newStageId !== 'EI') {
                    this.resetCoreIntensity();
                }
                
                // EIã‚¹ãƒ†ãƒ¼ã‚¸å›ºæœ‰ã®åˆæœŸåŒ–
                if (newStageId === 'EI') {
                    // æ—¢å­˜ã®ç–‘å•ãƒ•ã‚§ãƒ¼ã‚ºã‚’ãƒªã‚»ãƒƒãƒˆ
                    this.particles.forEach(particle => {
                        if (particle.userData) {
                            particle.userData.questioningPhase = null;
                        }
                    });
                    this.persistentParticleIndices.clear();
                    
                    // å³åº§ã«è¡¨ç¤ºã™ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è¨­å®šï¼ˆæœ€åˆã®5å€‹ï¼‰
                    const currentTime = Date.now() * 0.001;
                    this.particles.slice(0, 5).forEach((particle, index) => {
                        if (particle.userData) {
                            // å³åº§ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åˆæœŸè¨­å®š
                            const angle = Math.random() * Math.PI * 2;
                            const radius = 1 + Math.random() * 2.5;
                            const height = (Math.random() - 0.5) * 3;
                            
                            const fixedPosition = {
                                x: radius * Math.cos(angle),
                                y: height,
                                z: radius * Math.sin(angle)
                            };
                            
                            particle.position.set(fixedPosition.x, fixedPosition.y, fixedPosition.z);
                            
                            // ãƒ•ã‚§ãƒ¼ã‚ºã‚’åˆæœŸåŒ–ã—ã¦å³åº§ã«è¡¨ç¤º
                            particle.userData.questioningPhase = {
                                spawnTime: currentTime - 1, // 1ç§’å‰ã«ç”Ÿæˆã•ã‚ŒãŸã“ã¨ã«ã—ã¦å³åº§ã«è¡¨ç¤º
                                lifespan: 2 + Math.random() * 4,
                                isPersistent: Math.random() < 0.3,
                                fadeInDuration: 0.8,
                                fadeOutDuration: 1.2,
                                hasBeenPersistent: false,
                                fixedPosition: fixedPosition
                            };
                            
                            // é€æ˜åº¦ã‚’å³åº§ã«è¨­å®š
                            particle.material.opacity = 0.9;
                        }
                    });
                }
                
                // I(E)ã‚¹ãƒ†ãƒ¼ã‚¸ä»¥é™ï¼ˆIaã€Ibã€Icç­‰ï¼‰ã®æ¥ç¶šç·šå³åº§è¡¨ç¤º
                if (this.shouldShowConnections(newStageId)) {
                    // æ¥ç¶šæ›´æ–°ã‚¿ã‚¤ãƒãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦å³åº§ã«æ¥ç¶šã‚’ç”Ÿæˆ
                    this.lastConnectionUpdate = 0;
                    
                    // å°‘ã—é…å»¶ã—ã¦æ¥ç¶šã‚’å¼·åˆ¶ç”Ÿæˆï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åˆæœŸåŒ–å®Œäº†å¾Œï¼‰
                    setTimeout(() => {
                        this.updateConnections(true); // å¼·åˆ¶æ›´æ–°
                    }, 100);
                }
                
                // I-E ã‚¹ãƒ†ãƒ¼ã‚¸å°‚ç”¨: ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
                if (newStageId === 'I-E') {
                    // ã¾ãšå…¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å®Œå…¨ã«ã‚³ã‚¢ä¸­å¿ƒã«ç§»å‹•ãƒ»éè¡¨ç¤ºåŒ–
                    this.particles.forEach((particle, index) => {
                        if (particle.userData) {
                            // ã‚³ã‚¢ä¸­å¿ƒã«ç§»å‹•
                            particle.position.set(0, 0, 0);
                            // å®Œå…¨ã«éè¡¨ç¤º
                            particle.visible = false;
                            particle.material.opacity = 0;
                            particle.scale.setScalar(0.1);
                            
                            // I-Eã‚¹ãƒ†ãƒ¼ã‚¸ã®å‹•ä½œãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¨­å®šï¼ˆé‡è¦ï¼ï¼‰
                            particle.userData.behavior = newStageData.behavior;
                            particle.userData.pattern = newStageData.pattern; // 'pulse'ã«è¨­å®š
                            particle.userData.cohesion = newStageData.cohesion;
                            particle.userData.speed = newStageData.speed * (0.8 + Math.random() * 0.4);
                            
                            // å‡ºç¾å…ˆã®ç›®æ¨™ä½ç½®ã‚’è¨ˆç®—ï¼ˆæ”¾å°„çŠ¶é…ç½®ï¼‰
                            const radius = 1 + Math.random() * 4; // 1-5ã®ç¯„å›²
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.random() * Math.PI;
                            
                            const targetX = radius * Math.sin(phi) * Math.cos(theta);
                            const targetY = radius * Math.sin(phi) * Math.sin(theta);
                            const targetZ = radius * Math.cos(phi);
                            
                            // å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ãƒ‡ãƒ¼ã‚¿ã‚’è¨­å®š
                            particle.userData.emergenceStartPosition = new THREE.Vector3(0, 0, 0);
                            particle.userData.emergenceTargetPosition = new THREE.Vector3(targetX, targetY, targetZ);
                            
                            // originalPositionã‚’æœ€çµ‚ç›®æ¨™ä½ç½®ã«è¨­å®šï¼ˆãƒ‘ãƒ«ã‚¹å‹•ä½œã®åŸºæº–ç‚¹ï¼‰
                            particle.userData.originalPosition = new THREE.Vector3(targetX, targetY, targetZ);
                        }
                    });
                    
                    // å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
                    this.initializeIEEmergence();
                }
                
                // æ—¢å­˜ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’æ–°ã—ã„å‹•ä½œãƒ‘ã‚¿ãƒ¼ãƒ³ã«æ®µéšçš„ã«ç§»è¡Œ
                this.particles.forEach((particle, index) => {
                    if (particle.userData) {
                        // I-Eã‚¹ãƒ†ãƒ¼ã‚¸ã®å ´åˆã¯æ—¢ã«ä¸Šã§å‡¦ç†æ¸ˆã¿
                        if (newStageId === 'I-E') {
                            // I-Eã‚¹ãƒ†ãƒ¼ã‚¸ã§ã¯è‰²ã ã‘æ›´æ–°ï¼ˆãƒ‘ã‚¿ãƒ¼ãƒ³ã¯æ—¢ã«è¨­å®šæ¸ˆã¿ï¼‰
                            if (!this.isColorfulStage(newStageId)) {
                                particle.material.color.setHex(newStageData.color);
                            }
                            return;
                        }
                        
                        // æ–°ã—ã„å‹•ä½œãƒ‘ã‚¿ãƒ¼ãƒ³ã«æ›´æ–°
                        particle.userData.behavior = newStageData.behavior;
                        particle.userData.pattern = newStageData.pattern;
                        particle.userData.cohesion = newStageData.cohesion;
                        particle.userData.speed = newStageData.speed * (0.8 + Math.random() * 0.4);
                        
                        // ã‚«ãƒ©ãƒ•ãƒ«ã‚¹ãƒ†ãƒ¼ã‚¸ã§ãªã„å ´åˆã¯å˜è‰²ã«æˆ»ã™
                        if (!this.isColorfulStage(newStageId)) {
                            this.animateParticleColor(particle, newStageData.color, index * 50);
                        }
                        // ã‚«ãƒ©ãƒ•ãƒ«ã‚¹ãƒ†ãƒ¼ã‚¸ã®å ´åˆã¯è‰²ã®ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆå‹•çš„ã«å¤‰åŒ–ã™ã‚‹ãŸã‚ï¼‰
                    }
                });
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°ã®èª¿æ•´
                this.adjustParticleCount(newStageData.particleCount, newStageData.color);
                
                // æ®µéšçš„å…‰å¼·åŒ–ã‚·ã‚¹ãƒ†ãƒ  - ã‚¹ãƒ†ãƒ¼ã‚¸é€²è¡Œã«å¿œã˜ã¦å…‰ã®ãƒ™ãƒ¼ãƒ«ã‚’æ›´æ–°
                this.updateLightVeils(newStageId);
                
                // åœ°é¢ç§»å‹•ã‚·ã‚¹ãƒ†ãƒ  - ã‚¹ãƒ†ãƒ¼ã‚¸å¤‰æ›´æ™‚ã®å‹•ä½œãƒ‘ã‚¿ãƒ¼ãƒ³æ›´æ–°
                if (this.groundMovementSystem) {
                    this.groundMovementSystem.setMovementPattern(newStageId);
                    console.log('[Ground] Movement pattern updated for stage:', newStageId);
                }
                
                // èª¬æ˜è¡¨ç¤ºã‚·ã‚¹ãƒ†ãƒ  - ã‚¹ãƒ†ãƒ¼ã‚¸å¤‰æ›´æ™‚ã¯èª¬æ˜å†…å®¹ã®ã¿æ›´æ–°ï¼ˆè‡ªå‹•è¡¨ç¤ºã¯ã—ãªã„ï¼‰
                if (this.explanationSystem) {
                    this.explanationSystem.updateStageExplanations(newStageId);
                }
            }
            
            animateCoreColor(targetColor) {
                if (!this.core) return;
                
                const currentColor = this.core.material.emissive.getHex();
                const targetColorObj = new THREE.Color(targetColor);
                
                // ã‚¹ãƒ ãƒ¼ã‚ºãªè‰²å¤‰æ›´ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                let progress = 0;
                const animateColor = () => {
                    progress += 0.05;
                    if (progress >= 1) {
                        this.core.material.emissive.setHex(targetColor);
                        return;
                    }
                    
                    const currentColorObj = new THREE.Color(currentColor);
                    currentColorObj.lerp(targetColorObj, progress);
                    this.core.material.emissive.copy(currentColorObj);
                    
                    requestAnimationFrame(animateColor);
                };
                animateColor();
            }
            
            animateParticleColor(particle, targetColor, delay = 0) {
                setTimeout(() => {
                    const currentColor = particle.material.color.getHex();
                    const targetColorObj = new THREE.Color(targetColor);
                    
                    let progress = 0;
                    const animateColor = () => {
                        progress += 0.03;
                        if (progress >= 1) {
                            particle.material.color.setHex(targetColor);
                            return;
                        }
                        
                        const currentColorObj = new THREE.Color(currentColor);
                        currentColorObj.lerp(targetColorObj, progress);
                        particle.material.color.copy(currentColorObj);
                        
                        requestAnimationFrame(animateColor);
                    };
                    animateColor();
                }, delay);
            }
            
            // I-E ã‚¹ãƒ†ãƒ¼ã‚¸å°‚ç”¨: ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
            initializeIEEmergence() {
                this.isEmergingIE = true;
                this.emergenceStartTime = Date.now() + this.emergenceDelay;
                this.emergingParticles = [];
                this.emergenceTransitionStarted = false; // é·ç§»ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.emergenceTransitionTime = 0;        // é·ç§»æ™‚åˆ»ã‚’ãƒªã‚»ãƒƒãƒˆ
                
                // å…¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å‡ºç¾å¾…ã¡ãƒªã‚¹ãƒˆã«è¿½åŠ ï¼ˆã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ã¦è‡ªç„¶ãªé †åºã«ï¼‰
                const particleIndices = this.particles.map((_, index) => index);
                this.shuffleArray(particleIndices);
                
                particleIndices.forEach((index, order) => {
                    this.emergingParticles.push({
                        particleIndex: index,
                        emergenceTime: this.emergenceStartTime + (order * this.particleEmergenceInterval),
                        hasEmerged: false,
                        emergenceProgress: 0
                    });
                });
                
                console.log(`I-E Emergence initialized: ${this.emergingParticles.length} particles scheduled`);
            }
            
            // é…åˆ—ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }
            
            adjustParticleCount(targetCount, color) {
                const currentCount = this.particles.length;
                
                if (currentCount < targetCount) {
                    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è¿½åŠ 
                    const toAdd = targetCount - currentCount;
                    for (let i = 0; i < toAdd; i++) {
                        setTimeout(() => {
                            this.addSingleParticle(color);
                        }, i * 100); // æ®µéšçš„ã«è¿½åŠ 
                    }
                } else if (currentCount > targetCount) {
                    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å‰Šé™¤
                    const toRemove = currentCount - targetCount;
                    for (let i = 0; i < toRemove; i++) {
                        setTimeout(() => {
                            this.removeSingleParticle();
                        }, i * 50); // æ®µéšçš„ã«å‰Šé™¤
                    }
                }
            }
            
            updateLightVeils(currentStageId) {
                // å…‰ã®ãƒ™ãƒ¼ãƒ«ãŒè¡¨ç¤ºã•ã‚Œãªã„ã‚¹ãƒ†ãƒ¼ã‚¸ã®å ´åˆã¯å…¨ãƒ™ãƒ¼ãƒ«ã‚’éè¡¨ç¤º
                if (this.noLightVeilStages.includes(currentStageId)) {
                    this.hideAllLightVeils();
                    return;
                }
                
                // ã‚¹ãƒ†ãƒ¼ã‚¸é€²è¡Œé †åºã«åŸºã¥ã„ã¦ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¾ã§ã®å…‰ã®ãƒ™ãƒ¼ãƒ«ã‚’è¡¨ç¤º
                const currentIndex = this.stageProgressionOrder.indexOf(currentStageId);
                
                if (currentIndex === -1) {
                    // é€²è¡Œé †åºã«ãªã„ã‚¹ãƒ†ãƒ¼ã‚¸ã®å ´åˆã‚‚å…¨ãƒ™ãƒ¼ãƒ«ã‚’éè¡¨ç¤º
                    this.hideAllLightVeils();
                    return;
                }
                
                // ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¾ã§ã®å…‰ã®ãƒ™ãƒ¼ãƒ«ã‚’æ®µéšçš„ã«è¡¨ç¤º
                this.lightVeils.forEach((veil, index) => {
                    if (index <= currentIndex) {
                        // æ®µéšçš„ã«ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ - ã‚ˆã‚Šæ»‘ã‚‰ã‹ãªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                        setTimeout(() => {
                            veil.visible = true;
                            veil.userData.visible = true;
                            veil.userData.fadingIn = true; // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³çŠ¶æ…‹ãƒ•ãƒ©ã‚°
                            veil.userData.fadeStartTime = Date.now(); // ãƒ•ã‚§ãƒ¼ãƒ‰é–‹å§‹æ™‚åˆ»
                            veil.userData.fadeDuration = 2000; // 2ç§’é–“ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
                            
                            // åˆæœŸçŠ¶æ…‹ã‚’å®Œå…¨é€æ˜ã«è¨­å®š
                            if (veil.material.uniforms) {
                                veil.material.uniforms.opacity.value = 0;
                                veil.material.uniforms.emissiveIntensity.value = 0;
                            } else {
                                veil.material.opacity = 0;
                                if (veil.material.emissiveIntensity !== undefined) {
                                    veil.material.emissiveIntensity = 0;
                                }
                            }
                            
                        }, index * 500); // å„ãƒ™ãƒ¼ãƒ«ã‚’500msé–“éš”ã§æ®µéšçš„ã«è¡¨ç¤ºï¼ˆå°‘ã—é•·ã‚ã«ï¼‰
                    } else {
                        // ã¾ã åˆ°é”ã—ã¦ã„ãªã„ã‚¹ãƒ†ãƒ¼ã‚¸ã®ãƒ™ãƒ¼ãƒ«ã¯éè¡¨ç¤º
                        veil.visible = false;
                        veil.userData.visible = false;
                        veil.userData.fadingIn = false;
                    }
                });
                
                // ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ›´æ–°
                this.currentStageIndex = currentIndex;
            }
            
            hideAllLightVeils() {
                // å…¨ã¦ã®å…‰ã®ãƒ™ãƒ¼ãƒ«ã‚’éè¡¨ç¤ºã«ã™ã‚‹ï¼ˆãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆåŠ¹æœä»˜ãï¼‰
                this.lightVeils.forEach((veil, index) => {
                    if (veil.visible) {
                        // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                        veil.userData.fadingOut = true;
                        veil.userData.fadeOutStartTime = Date.now();
                        veil.userData.fadeOutDuration = 1000; // 1ç§’é–“ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
                        
                        // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«å¯¾å¿œã®åˆæœŸå€¤è¨˜éŒ²
                        if (veil.material.uniforms) {
                            veil.userData.fadeOutStartOpacity = veil.material.uniforms.opacity.value;
                            veil.userData.fadeOutStartEmissive = veil.material.uniforms.emissiveIntensity.value;
                        } else {
                            veil.userData.fadeOutStartOpacity = veil.material.opacity;
                            veil.userData.fadeOutStartEmissive = veil.material.emissiveIntensity || 0;
                        }
                        
                        veil.userData.fadingIn = false; // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚’åœæ­¢
                    }
                });
                this.currentStageIndex = -1; // ãƒ™ãƒ¼ãƒ«ãªã—çŠ¶æ…‹
            }
            
            addSingleParticle(color) {
                // çµŒé¨“ã®ãƒ¡ã‚¿ãƒ•ã‚¡ãƒ¼ã¨ã—ã¦ãƒ©ãƒ³ãƒ€ãƒ ãªã‚µã‚¤ã‚ºã‚’ç”Ÿæˆ
                const baseSize = 0.04;
                const sizeVariation = 0.5 + Math.random() * 1.3; // 0.5 - 1.8å€
                const particleSize = baseSize * sizeVariation;
                
                // æ®µéšã«å¿œã˜ãŸã‚µã‚¤ã‚ºèª¿æ•´
                const stageNumber = this.getStageNumber(this.currentStage);
                let stageSizeMultiplier = 1.0;
                
                if (stageNumber >= 8) { // Ia, Ib, Icæ®µéš
                    stageSizeMultiplier = 1.0 + (stageNumber - 7) * 0.15;
                } else if (stageNumber >= 5) { // E-I, I-E, IEæ®µéš
                    stageSizeMultiplier = 1.0 + (stageNumber - 4) * 0.08;
                }
                
                const finalSize = particleSize * stageSizeMultiplier;
                const geometry = new THREE.SphereGeometry(finalSize, 12, 12); // ãƒ©ãƒ³ãƒ€ãƒ ã‚µã‚¤ã‚ºé©ç”¨ã€å“è³ªã‚‚å‘ä¸Š
                
                // ã‚«ãƒ©ãƒ•ãƒ«ã‚¹ãƒ†ãƒ¼ã‚¸ã®å ´åˆã¯åˆæœŸè‰²ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«è¨­å®š
                const initialColor = this.isColorfulStage(this.currentStage) ? 
                    this.colorfulParticlePalette[Math.floor(Math.random() * this.colorfulParticlePalette.length)] : 
                    color;
                
                // ã‚µã‚¤ã‚ºã«å¿œã˜ãŸè¦–è¦šçš„åŠ¹æœã®èª¿æ•´
                const sizeRatio = finalSize / baseSize; // ã‚µã‚¤ã‚ºæ¯”ã‚’è¨ˆç®—
                const baseOpacity = 0.0; // addSingleParticleã¯0ã‹ã‚‰é–‹å§‹
                const sizeAdjustedEmissive = Math.floor(0x111111 * (0.8 + sizeRatio * 0.4)); // å¤§ãã„ã»ã©å°‘ã—æ˜ã‚‹ãç™ºå…‰
                const sizeAdjustedShininess = 80 + (sizeRatio - 1) * 40; // ã‚µã‚¤ã‚ºã«å¿œã˜ã¦å…‰æ²¢åº¦èª¿æ•´
                
                const material = new THREE.MeshPhongMaterial({ 
                    color: initialColor,
                    transparent: true,
                    opacity: baseOpacity,  // åˆæœŸã¯0
                    emissive: sizeAdjustedEmissive,  // ã‚µã‚¤ã‚ºèª¿æ•´ã•ã‚ŒãŸç™ºå…‰
                    shininess: Math.max(50, Math.min(150, sizeAdjustedShininess))  // å…‰æ²¢ç¯„å›²åˆ¶é™
                });
                const particle = new THREE.Mesh(geometry, material);
                
                // ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã«é…ç½®
                const radius = 1 + Math.random() * 5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                particle.position.x = radius * Math.sin(phi) * Math.cos(theta);
                particle.position.y = radius * Math.sin(phi) * Math.sin(theta);
                particle.position.z = radius * Math.cos(phi);
                
                // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’è¨­å®š
                const stageData = this.getStageData(this.currentStage);
                particle.userData = {
                    originalPosition: particle.position.clone(),
                    baseRadius: radius,
                    baseTheta: theta,
                    basePhi: phi,
                    personalityFactor: Math.random(),
                    phaseOffset: Math.random() * Math.PI * 2,
                    speed: stageData.speed * (0.8 + Math.random() * 0.4),
                    cohesion: stageData.cohesion,
                    behavior: stageData.behavior,
                    pattern: stageData.pattern,
                    age: 0,
                    targetPosition: new THREE.Vector3(),
                    // ã‚µã‚¤ã‚ºé–¢é€£æƒ…å ±ã‚’è¿½åŠ 
                    originalSize: finalSize,
                    sizeRatio: sizeRatio,
                    baseSize: baseSize,
                    sizeVariation: sizeVariation
                };
                
                // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³åŠ¹æœ
                let opacity = 0;
                const fadeIn = () => {
                    opacity += 0.02;
                    if (opacity >= 0.8) {
                        particle.material.opacity = 0.8;
                        return;
                    }
                    particle.material.opacity = opacity;
                    requestAnimationFrame(fadeIn);
                };
                fadeIn();
                
                this.scene.add(particle);
                this.particles.push(particle);
            }
            
            removeSingleParticle() {
                if (this.particles.length === 0) return;
                
                const particle = this.particles.pop();
                
                // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆåŠ¹æœ
                let opacity = particle.material.opacity;
                const fadeOut = () => {
                    opacity -= 0.05;
                    if (opacity <= 0) {
                        this.scene.remove(particle);
                        particle.geometry.dispose();
                        particle.material.dispose();
                        return;
                    }
                    particle.material.opacity = opacity;
                    requestAnimationFrame(fadeOut);
                };
                fadeOut();
            }
            
            updateActiveButton(stageId) {
                const buttons = document.querySelectorAll('.stage-btn');
                buttons.forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.stage === stageId) {
                        btn.classList.add('active');
                    }
                });
                
                // æ®µéšæƒ…å ±è¡¨ç¤ºã‚’æ›´æ–°
                this.updateStageInfo(stageId);
            }
            
            updateStageInfo(stageId) {
                const stageData = this.getStageData(stageId);
                const titleElement = document.getElementById('current-stage-title');
                const descElement = document.getElementById('current-stage-description');
                
                // titleElementãŒå­˜åœ¨ã—ãªã„å ´åˆã§ã‚‚ã€descElementãŒã‚ã‚Œã°å‡¦ç†ã‚’ç¶šè¡Œ
                if (descElement) {
                    // titleElement ã‚’ä¸€æ™‚çš„ã«éè¡¨ç¤ºåŒ–ï¼ˆé‡è¤‡è¡¨ç¤ºå›é¿ã®ãŸã‚ï¼‰
                    // if (titleElement) {
                    //     titleElement.textContent = `${stageId}: ${stageData.description}`;
                    // }
                    
                    // behaviorDescriptions ã‚’ä¸€æ™‚çš„ã«éè¡¨ç¤ºåŒ–ï¼ˆå°†æ¥çš„ã«æˆ»ã™å¯èƒ½æ€§ã®ãŸã‚ä¿æŒï¼‰
                    /*
                    // æ®µéšã«å¿œã˜ãŸè©³ç´°èª¬æ˜
                    const behaviorDescriptions = {
                        'chaotic': 'ã‚ã¾ã‚Šç–‘å•ã«æ„Ÿã˜ãŸã‚Šã™ã‚‹ã“ã¨ã¯å°‘ãªã„',
                        'conflicted': 'ä»Šã¾ã§ã®è€ƒãˆæ–¹ã‚„æ–¹æ³•ã§ã†ã¾ãã„ã‹ãªã„å‡ºæ¥äº‹ã«é­é‡',
                        'questioning': 'å½“ãŸã‚Šå‰ã¨æ€ã£ã¦ã„ãŸã“ã¨ã«å¯¾ã™ã‚‹ãµã¨ã—ãŸç–‘å•',
                        'questioning_emergence': 'ã“ã®ã¾ã¾ã§ã„ã„ã®ã‹ã€æœ¬å½“ã«å¤§ä¸ˆå¤«ã ã‚ã†ã‹',
                        'building': 'è‡ªåˆ†ã®å¥½ããªã“ã¨ã‚„å¿ƒã«æ®‹ã£ã¦ã„ã‚‹çµŒé¨“ã¯ä½•ã‹',
                        'listening': 'è‡ªåˆ†ã®å¿ƒã®å‹•ãã«è½ã¡ç€ã„ã¦è€³ã‚’å‚¾ã‘ã‚‹',
                        'nurturing': 'è‡ªåˆ†ã®æ°—æŒã¡ã‚„çµŒé¨“ã¨å‘¨å›²ã®çŠ¶æ³ã‚’æ„å‘³ã¥ã‘ã‚‹',
                        'trusting': 'è‡ªåˆ†ãŒæœ¬å½“ã«å¤§åˆ‡ã«ã—ãŸã„ã“ã¨ã®è¼ªéƒ­ã‚’æ´ã‚€',
                        'foundation': 'å‘¨ã‚Šã®äººã®å£°ã«è€³ã‚’å‚¾ã‘ã€è‡ªåˆ†ã®è€ƒãˆã‚’è‡ªåˆ†ã®è¨€è‘‰ã§è©±ã™',
                        'committed': 'é€²ã¿ãŸã„é“ã€è²¢çŒ®ã—ãŸã„ã‚‚ã®ã”ã¨ã«å‘ã‹ã†'
                    };
                    
                    descElement.textContent = behaviorDescriptions[stageData.behavior] || stageData.description;
                    */
                    
                    // stageData.description ã®ã¿ã‚’è¡¨ç¤ºï¼ˆé‡è¤‡å›é¿ï¼‰
                    descElement.textContent = stageData.description;
                }
            }
            
            resetView() {
                this.camera.position.set(0, 0, this.defaultCameraZ);
                this.camera.lookAt(0, 0, 0);
                // ã‚«ãƒ¡ãƒ©å›è»¢ã‚‚åˆæœŸåŒ–
                this.cameraRotationAngle = 0;
            }
            
            // ã‚«ãƒ¡ãƒ©ã®è¦‹å›ã—åŠ¹æœã‚’æ›´æ–°
            updateCameraLookAround() {
                // åœ°é¢ç§»å‹•ã‚·ã‚¹ãƒ†ãƒ ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã€è¦‹å›ã—å‹•ä½œãŒå¿…è¦ãªå ´åˆã®ã¿å®Ÿè¡Œ
                if (!this.groundMovementSystem || !this.isGroundActive) {
                    // ã‚¹ã‚­ãƒ£ãƒ‹ãƒ³ã‚°ä¸­ã§ãªã„å ´åˆã¯ä¸­å¤®ã‚’å‘ã
                    if (this.cameraRotationAngle !== 0) {
                        const resetSpeed = 0.001; // ã•ã‚‰ã«ã‚†ã£ãã‚Šã¨ä¸­å¤®ã«æˆ»ã‚‹
                        if (Math.abs(this.cameraRotationAngle) > resetSpeed) {
                            this.cameraRotationAngle -= Math.sign(this.cameraRotationAngle) * resetSpeed;
                        } else {
                            this.cameraRotationAngle = 0;
                        }
                        this.camera.lookAt(0, 0, 0); // ä¸­å¤®ã«æˆ»ã™
                    }
                    return;
                }
                
                // ç¾åœ¨ã®åœ°é¢ç§»å‹•ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰å›è»¢è§’åº¦ã‚’å–å¾—
                const targetRotationAngle = this.getCameraRotationFromGroundSystem();
                
                if (targetRotationAngle !== null) {
                    // ã‚ˆã‚Šé…ã„è§’åº¦å¤‰åŒ–ï¼ˆã•ã‚‰ã«ã‚†ã£ãã‚Šï¼‰
                    const maxAngleChangePerFrame = 0.001; // ç´„0.5åº¦/ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆã•ã‚‰ã«é…ãï¼‰
                    const angleDiff = targetRotationAngle - this.cameraRotationAngle;
                    
                    // è§’åº¦å·®ã‚’ -Ï€ ã‹ã‚‰ Ï€ ã®ç¯„å›²ã«æ­£è¦åŒ–
                    let normalizedAngleDiff = angleDiff;
                    while (normalizedAngleDiff > Math.PI) normalizedAngleDiff -= 2 * Math.PI;
                    while (normalizedAngleDiff < -Math.PI) normalizedAngleDiff += 2 * Math.PI;
                    
                    // éå¸¸ã«æ»‘ã‚‰ã‹ãªè§’åº¦æ›´æ–°
                    if (Math.abs(normalizedAngleDiff) > maxAngleChangePerFrame) {
                        this.cameraRotationAngle += Math.sign(normalizedAngleDiff) * maxAngleChangePerFrame;
                    } else {
                        this.cameraRotationAngle = targetRotationAngle;
                    }
                    
                    // ã‚ˆã‚Šæ§ãˆã‚ãªè¦–ç·šç§»å‹•ï¼ˆä¸­å¤®ã‹ã‚‰ã®å°ã•ãªã‚ªãƒ•ã‚»ãƒƒãƒˆï¼‰
                    const lookAtX = Math.sin(this.cameraRotationAngle) * this.lookAroundRadius;
                    const lookAtZ = Math.cos(this.cameraRotationAngle) * this.lookAroundRadius;
                    
                    // åŸºæº–æ³¨è¦–ç‚¹ã‹ã‚‰ã®å°ã•ãªã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’é©ç”¨
                    this.camera.lookAt(
                        this.baseLookAtTarget.x + lookAtX,
                        this.baseLookAtTarget.y,
                        this.baseLookAtTarget.z + lookAtZ
                    );
                } else {
                    // ã‚¹ã‚­ãƒ£ãƒ‹ãƒ³ã‚°ä¸­ã§ãªã„å ´åˆã¯ä¸­å¤®ã‚’å‘ã
                    if (this.cameraRotationAngle !== 0) {
                        const resetSpeed = 0.001; // ã•ã‚‰ã«é…ã„ãƒªã‚»ãƒƒãƒˆé€Ÿåº¦
                        if (Math.abs(this.cameraRotationAngle) > resetSpeed) {
                            this.cameraRotationAngle -= Math.sign(this.cameraRotationAngle) * resetSpeed;
                            const lookAtX = Math.sin(this.cameraRotationAngle) * this.lookAroundRadius;
                            const lookAtZ = Math.cos(this.cameraRotationAngle) * this.lookAroundRadius;
                            this.camera.lookAt(lookAtX, 0, lookAtZ);
                        } else {
                            this.cameraRotationAngle = 0;
                            this.camera.lookAt(0, 0, 0);
                        }
                    }
                }
            }
            
            // åœ°é¢ç§»å‹•ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰ç¾åœ¨ã®å›è»¢è§’åº¦ã‚’å–å¾—
            getCameraRotationFromGroundSystem() {
                if (!this.groundMovementSystem || !this.groundMovementSystem.behaviorState) {
                    return null;
                }
                
                const behaviorState = this.groundMovementSystem.behaviorState;
                const currentStage = this.groundMovementSystem.currentStage;
                
                // Ebã‚¹ãƒ†ãƒ¼ã‚¸ã¾ãŸã¯E-Iã‚¹ãƒ†ãƒ¼ã‚¸ã§è¤‡æ•°æ¨©å¨ã‚¹ã‚­ãƒ£ãƒ‹ãƒ³ã‚°ä¸­ã®å ´åˆ
                if ((currentStage === 'Eb' || currentStage === 'E-I') && 
                    behaviorState.currentBehavior === 'pausing' && 
                    behaviorState.shouldReflect &&
                    this.groundMovementSystem.stageConfig?.isMultiAuthorityScanning) {
                    
                    // ç¾åœ¨ã®ã‚¹ã‚­ãƒ£ãƒ‹ãƒ³ã‚°é€²è¡Œåº¦ã‚’è¨ˆç®—
                    const currentTime = Date.now();
                    const timeSinceStart = currentTime - behaviorState.behaviorStartTime;
                    const totalDuration = behaviorState.behaviorDuration;
                    const progress = Math.min(timeSinceStart / totalDuration, 1.0);
                    
                    // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šã‚«ãƒ¡ãƒ©å›è»¢ã®ãƒ­ã‚°
                    if (progress > 0.35 && progress <= 0.65) { // åœæ­¢ãƒ•ã‚§ãƒ¼ã‚ºä¸­ã®ã¿
                        const pausedProgress = (progress - 0.35) / 0.3;
                        
                        // è¤‡æ•°æ¨©å¨ã‚¹ã‚­ãƒ£ãƒ‹ãƒ³ã‚°ã®è§’åº¦ã‚’å–å¾—
                        const scanningAngle = this.groundMovementSystem.executeMultiAuthorityScanning(pausedProgress);
                        console.log(`[Camera Scanning - ${currentStage}] Progress: ${pausedProgress.toFixed(3)}, Camera Angle: ${(scanningAngle * 180 / Math.PI).toFixed(1)}Â°`);
                        return scanningAngle;
                    }
                }
                
                return null; // å›è»¢ä¸è¦
            }
            
            reinitialize3D() {
                // è»½ã„åˆæœŸåŒ–ï¼šç¾åœ¨ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦åˆæœŸçŠ¶æ…‹ã«æˆ»ã™
                
                // å…¨ã¦ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ã‚¯ãƒªã‚¢
                if (this.particles) {
                    this.particles.forEach(particle => {
                        if (particle && this.scene) {
                            this.scene.remove(particle);
                        }
                    });
                    this.particles = [];
                }
                
                // æ¥ç¶šã‚’ã‚¯ãƒªã‚¢
                this.clearConnections();
                
                // å…‰ã®ãƒ™ãƒ¼ãƒ«ã‚’éš ã™
                this.hideAllLightVeils();
                
                // èª¬æ˜è¡¨ç¤ºã‚·ã‚¹ãƒ†ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆ
                if (this.explanationSystem) {
                    this.explanationSystem.hidePanel();
                }
                
                // ã‚«ãƒ¡ãƒ©ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.resetView();
                
                // åˆæœŸçŠ¶æ…‹ï¼ˆEaï¼‰ã«æˆ»ã™
                this.switchToStage('Ea');
            }
            
            cleanup() {
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åœæ­¢
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                
                // èª¬æ˜è¡¨ç¤ºã‚·ã‚¹ãƒ†ãƒ ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                if (this.explanationSystem) {
                    this.explanationSystem.cleanup();
                    this.explanationSystem = null;
                }
                
                // ã‚·ãƒ¼ãƒ³ã®å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤
                if (this.scene) {
                    while(this.scene.children.length > 0) {
                        const child = this.scene.children[0];
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (child.material.map) child.material.map.dispose();
                            child.material.dispose();
                        }
                        this.scene.remove(child);
                    }
                }
                
                // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã‚’å‰Šé™¤
                if (this.renderer) {
                    this.renderer.dispose();
                    this.renderer = null;
                }
            }
            
            handleZoom(deltaY) {
                if (!this.camera) return;
                
                // Zoom direction: positive deltaY = zoom out, negative deltaY = zoom in
                const zoomDirection = deltaY > 0 ? 1 : -1;
                const zoomAmount = zoomDirection * this.zoomSpeed;
                
                // Calculate new camera position
                const currentZ = this.camera.position.z;
                const newZ = currentZ + zoomAmount;
                
                // Clamp zoom within bounds
                const clampedZ = Math.max(this.minZoom, Math.min(this.maxZoom, newZ));
                
                // Apply smooth zoom
                this.camera.position.z = clampedZ;
                
                // Optionally update field of view for more dramatic zoom effect
                // this.camera.fov = Math.max(30, Math.min(75, 75 - (clampedZ - this.defaultCameraZ) * 2));
                // this.camera.updateProjectionMatrix();
            }
            
            handleResize() {
                const width = this.container.offsetWidth;
                const height = this.container.offsetHeight;
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }
            
            startAnimation() {
                const animate = () => {
                    this.animationFrameId = requestAnimationFrame(animate);
                    
                    const time = Date.now() * 0.001;
                    
                    // Core rotation
                    if (this.core) {
                        this.core.rotation.y += 0.005; // ã‚†ã£ãã‚Šã¨ã—ãŸå›è»¢
                        this.core.rotation.x += 0.002;
                    }
                    
                    // æ–°ã—ã„æ¬¡å…ƒåŠ¹æœã‚·ã‚¹ãƒ†ãƒ ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
                    this.updateDimensionAnimations(time);
                    
                    // I-E ã‚¹ãƒ†ãƒ¼ã‚¸: ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†
                    if (this.isEmergingIE) {
                        this.updateIEEmergence();
                    }
                    
                    // Advanced particle animation based on stage behavior
                    this.particles.forEach((particle, index) => {
                        const userData = particle.userData;
                        if (!userData) return;
                        
                        userData.age += 0.016; // Approximate 60fps
                        
                        // Update colorful particles for I(E) stages and beyond
                        this.updateParticleColorDynamic(particle, index, time);
                        
                        this.updateParticleBehavior(particle, index, time);
                    });
                    
                    // Update particle connections for I(E) stages and beyond
                    if (this.shouldShowConnections(this.currentStage)) {
                        this.updateConnections();
                        this.updateConnectionTransition(); // ãƒ•ã‚§ãƒ¼ãƒ‰é·ç§»ã®æ›´æ–°
                        this.updateConnectionPositions();
                    }
                    
                    // å…‰ã®ãƒ™ãƒ¼ãƒ«ã®å‘¼å¸ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    this.animateLightVeils(time);
                    
                    // å¤šé¢ä½“ã‚³ã‚¢ã®å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    this.animatePolyhedronCore(time);
                    
                    this.renderer.render(this.scene, this.camera);
                };
                animate();
            }

            animatePolyhedronCore(time) {
                if (!this.core || this.isTransitioning) return;
                
                // æ®µéšã«å¿œã˜ãŸå›è»¢ãƒ‘ã‚¿ãƒ¼ãƒ³
                const stageData = this.getStageData(this.currentStage);
                
                switch(this.currentStage) {
                    case 'Ea': case 'Eb': case 'Ec':
                        // æ­£å››é¢ä½“: ä¸å®‰å®šãªæŒ¯å‹•çš„å›è»¢
                        this.core.rotation.x = Math.sin(time * 0.003) * 0.3;
                        this.core.rotation.y += 0.01 + Math.sin(time * 0.002) * 0.005;
                        this.core.rotation.z = Math.cos(time * 0.0025) * 0.2;
                        break;
                        
                    case 'EI': case 'E-I': case 'I-E':
                        // æ­£å…«é¢ä½“: äºŒé‡è»¸å›è»¢ï¼ˆè‘›è—¤è¡¨ç¾ï¼‰
                        this.core.rotation.x += 0.008;
                        this.core.rotation.y += 0.012;
                        this.core.rotation.z = Math.sin(time * 0.001) * 0.1;
                        break;
                        
                    case 'IE': case 'Ia':
                        // æ­£åäºŒé¢ä½“: èª¿å’Œçš„ãªå®‰å®šå›è»¢
                        this.core.rotation.x += 0.005;
                        this.core.rotation.y += 0.008;
                        this.core.rotation.z += 0.003;
                        break;
                        
                    case 'Ib': case 'Ic':
                        // æ­£äºŒåé¢ä½“: è¤‡é›‘ã§ç¾ã—ã„çµ±åˆå›è»¢ï¼ˆè½ã¡ç€ã„ãŸé€Ÿåº¦ï¼‰
                        this.core.rotation.x += 0.002;
                        this.core.rotation.y += 0.003;
                        this.core.rotation.z += 0.001;
                        // å¾®ç´°ãªå‘¨æœŸçš„å¤‰å‹•ï¼ˆã‚ˆã‚Šç©ã‚„ã‹ï¼‰
                        const fine = Math.sin(time * 0.001) * 0.02;
                        this.core.rotation.x += fine;
                        this.core.rotation.y += fine * 0.8;
                        this.core.rotation.z += fine * 0.6;
                        break;
                }
                
                // æ®µéšå…±é€š: ç™ºå…‰åŠ¹æœã®å‘¼å¸
                if (this.coreLight) {
                    const baseIntensity = this.baseCoreIntensity;
                    const breathe = Math.sin(time * 0.002) * 0.2 + 1;
                    this.coreLight.intensity = baseIntensity * breathe;
                }
            }
            
            animateLightVeils(time) {
                // å…‰ã®ãƒ™ãƒ¼ãƒ«ã®å‘¼å¸ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ - ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’è¡¨ç¾
                this.lightVeils.forEach((veil, index) => {
                    const userData = veil.userData;
                    const now = Date.now();
                    
                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆå‡¦ç†
                    if (userData.fadingOut) {
                        const elapsed = now - userData.fadeOutStartTime;
                        const progress = Math.min(elapsed / userData.fadeOutDuration, 1);
                        
                        // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ï¼ˆease-inï¼‰ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
                        const easedProgress = Math.pow(progress, 2);
                        
                        // MeshBasicMaterialç”¨ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
                        veil.material.opacity = userData.fadeOutStartOpacity * (1 - easedProgress);
                        const colorFade = 1.0 * (1 - easedProgress);
                        veil.material.color.setRGB(colorFade, colorFade * 0.98, colorFade * 0.95); // æš–ã‹ã¿ã‚’ä¿ã¤
                        
                        // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆå®Œäº†ãƒã‚§ãƒƒã‚¯
                        if (progress >= 1) {
                            veil.visible = false;
                            veil.userData.visible = false;
                            veil.userData.fadingOut = false;
                        }
                        return; // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆä¸­ã¯ä»–ã®å‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—
                    }
                    
                    if (!veil.visible || !veil.userData.visible) return;
                    
                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®å‡¦ç†
                    if (userData.fadingIn) {
                        const elapsed = now - userData.fadeStartTime;
                        const progress = Math.min(elapsed / userData.fadeDuration, 1);
                        
                        // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ï¼ˆease-outï¼‰ã§ã‚ˆã‚Šè‡ªç„¶ãªãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
                        const easedProgress = 1 - Math.pow(1 - progress, 3);
                        
                        // ç›®æ¨™å€¤ã®è¨ˆç®— - ã‚ˆã‚Šé€æ˜æ„Ÿã®ã‚ã‚‹è¨­å®š
                        const targetOpacity = 0.005 + userData.stageIndex * 0.002; // æ¥µã‚ã¦é€æ˜ã«è¨­å®š
                        const targetEmissive = 0.15 + userData.stageIndex * 0.03;
                        
                        // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ç”¨ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
                        if (veil.material.uniforms) {
                            veil.material.uniforms.opacity.value = targetOpacity * easedProgress;
                            veil.material.uniforms.emissiveIntensity.value = targetEmissive * easedProgress;
                            veil.material.uniforms.time.value = time; // æ™‚é–“æ›´æ–°
                        } else {
                            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šé€šå¸¸ã®ãƒãƒ†ãƒªã‚¢ãƒ«
                            veil.material.opacity = targetOpacity * easedProgress;
                            if (veil.material.emissiveIntensity !== undefined) {
                                veil.material.emissiveIntensity = targetEmissive * easedProgress;
                            }
                        }
                        
                        // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³å®Œäº†ãƒã‚§ãƒƒã‚¯
                        if (progress >= 1) {
                            userData.fadingIn = false;
                        }
                        
                        // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ä¸­ã¯ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ§ãˆã‚ã«
                        const breatheIntensity = easedProgress * 0.08; // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é€²è¡Œã«å¿œã˜ã¦å¼·åŒ–
                        const breathe = Math.sin(time * userData.breatheSpeed + userData.breathePhase) * breatheIntensity + 1;
                        veil.scale.setScalar(breathe);
                        
                    } else {
                        // é€šå¸¸ã®å‘¼å¸ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³å®Œäº†å¾Œï¼‰
                        const breathe = Math.sin(time * userData.breatheSpeed + userData.breathePhase) * 0.08 + 1;
                        veil.scale.setScalar(breathe);
                        
                        // ã‚³ã‚¢ã¨ã®åŒæœŸåŠ¹æœï¼ˆMeshBasicMaterialç”¨ï¼‰
                        const coreSync = Math.sin(time * 0.5) * 0.02 + 1; // ã‚³ã‚¢ã¨ã®åŒæœŸãƒ‘ãƒ«ã‚¹
                        const opacityVariation = Math.sin(time * userData.breatheSpeed * 0.7 + userData.breathePhase) * 0.03;
                        
                        // åŸºæº–å€¤ã«ã‚³ã‚¢åŒæœŸã¨å‘¼å¸ã‚’é©ç”¨
                        const materialData = veil.material.userData;
                        const baseOpacity = materialData.baseOpacity;
                        
                        // è‡ªç„¶ãªå…‰ã®å¤‰å‹• - ã‚³ã‚¢ã‹ã‚‰ã®æ”¾å°„å…‰ã¨ã—ã¦
                        veil.material.opacity = Math.max(0.002, (baseOpacity + opacityVariation) * breathe * coreSync);
                        
                        // å…‰ã®è‰²ã®å¼·åº¦ã‚‚å¤‰å‹•ã•ã›ã¦å…‰ã‚‰ã—ã•ã‚’æ¼”å‡º
                        const colorIntensity = 0.85 + (materialData.emissiveStrength * 0.15 * breathe * coreSync);
                        veil.material.color.setRGB(colorIntensity, colorIntensity * 0.98, colorIntensity * 0.95); // æš–ã‹ã¿ã®ã‚ã‚‹è‰²èª¿
                    }
                });
            }
            
            // I-E ã‚¹ãƒ†ãƒ¼ã‚¸: ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
            updateIEEmergence() {
                const currentTime = Date.now();
                let allEmerged = true;
                
                this.emergingParticles.forEach(emergenceData => {
                    if (emergenceData.hasEmerged) return;
                    
                    // ã¾ã å‡ºç¾æ™‚åˆ»ã«é”ã—ã¦ã„ãªã„
                    if (currentTime < emergenceData.emergenceTime) {
                        allEmerged = false;
                        return;
                    }
                    
                    const particle = this.particles[emergenceData.particleIndex];
                    if (!particle || !particle.userData) {
                        emergenceData.hasEmerged = true;
                        return;
                    }
                    
                    // å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
                    if (!emergenceData.hasEmerged) {
                        const elapsedTime = currentTime - emergenceData.emergenceTime;
                        const emergenceDuration = 1200; // å„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å‡ºç¾æœŸé–“ã‚’1.2ç§’ã«å»¶é•·
                        emergenceData.emergenceProgress = Math.min(elapsedTime / emergenceDuration, 1);
                        
                        // ã‚ˆã‚Šè‡ªç„¶ãªã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ï¼ˆease-out cubicï¼‰
                        const easedProgress = 1 - Math.pow(1 - emergenceData.emergenceProgress, 2.5);
                        
                        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è¡¨ç¤º
                        particle.visible = true;
                        
                        // ä½ç½®: ã‚ˆã‚Šæ»‘ã‚‰ã‹ãªæ”¾å°„çŠ¶ç§»å‹•
                        const startPos = particle.userData.emergenceStartPosition;
                        const targetPos = particle.userData.emergenceTargetPosition;
                        
                        // æ”¾å°„æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
                        const direction = targetPos.clone().normalize();
                        const maxDistance = targetPos.length();
                        
                        // åŠ é€Ÿåº¦çš„ãªç§»å‹•ï¼ˆæœ€åˆã¯ã‚†ã£ãã‚Šã€å¾Œã§åŠ é€Ÿï¼‰
                        const currentDistance = maxDistance * easedProgress;
                        particle.position.copy(direction.multiplyScalar(currentDistance));
                        
                        // é€æ˜åº¦: ã‚ˆã‚Šæ»‘ã‚‰ã‹ãªãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
                        const opacityProgress = Math.min(emergenceData.emergenceProgress * 1.5, 1);
                        particle.material.opacity = 0.9 * opacityProgress;
                        
                        // ã‚¹ã‚±ãƒ¼ãƒ«: ã‚ˆã‚Šæ»‘ã‚‰ã‹ãªã‚µã‚¤ã‚ºå¤‰åŒ–
                        const scaleProgress = Math.min(emergenceData.emergenceProgress * 1.2, 1);
                        const scale = 0.2 + (0.8 * scaleProgress);
                        particle.scale.setScalar(scale);
                        
                        // è»½å¾®ãªå›è»¢åŠ¹æœï¼ˆç”Ÿå‘½æ„Ÿã‚’è¡¨ç¾ï¼‰
                        particle.rotation.z = emergenceData.emergenceProgress * Math.PI * 0.5;
                        
                        // å‡ºç¾å®Œäº†ãƒã‚§ãƒƒã‚¯
                        if (emergenceData.emergenceProgress >= 1) {
                            emergenceData.hasEmerged = true;
                            
                            // ãƒ‘ãƒ«ã‚¹å‹•ä½œã®åˆæœŸçŠ¶æ…‹ã«åˆã‚ã›ã¦ä½ç½®ã‚’è¨­å®š
                            const basePos = particle.userData.originalPosition;
                            const distance = basePos.length();
                            
                            // ç¾åœ¨ã®ä½ç½®ã‹ã‚‰ã‚ˆã‚Šæ­£ç¢ºãªæ™‚é–“ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—
                            const currentDistance = particle.position.length();
                            const currentPulse = Math.max(0.85, Math.min(1.0, currentDistance / distance));
                            
                            // æ­£è¦åŒ–ï¼ˆ-1ã‹ã‚‰1ã®ç¯„å›²ï¼‰
                            const normalizedPulse = Math.max(-1, Math.min(1, (currentPulse - 0.925) / 0.075));
                            
                            // ã‚ˆã‚Šå®‰å…¨ãªä½ç›¸è¨ˆç®—ï¼ˆMath.asinã®ä»£ã‚ã‚Šã«Math.atan2ã‚’ä½¿ç”¨ï¼‰
                            const currentPhase = Math.atan2(normalizedPulse, Math.sqrt(Math.max(0, 1 - normalizedPulse * normalizedPulse)));
                            const currentTime = Date.now() * 0.001;
                            particle.userData.pulseTimeOffset = currentPhase - currentTime * 1.2;
                            
                            // ãƒ‘ãƒ«ã‚¹å‹•ä½œã¨åŒã˜è¨ˆç®—å¼ã‚’ä½¿ç”¨ã—ã¦ä½ç½®ã‚’å¾®èª¿æ•´ï¼ˆæ»‘ã‚‰ã‹ãªæ¥ç¶šï¼‰
                            const initialPulse = Math.sin(currentTime * 1.2 + particle.userData.pulseTimeOffset) * 0.075 + 0.925;
                            const direction = basePos.clone().normalize();
                            const pulsedDistance = distance * initialPulse;
                            
                            // ç¾åœ¨ä½ç½®ã‹ã‚‰ç›®æ¨™ä½ç½®ã¸ã®æ»‘ã‚‰ã‹ãªè£œé–“ï¼ˆæ€¥æ¿€ãªå¤‰åŒ–ã‚’é˜²ãï¼‰
                            const targetPosition = direction.multiplyScalar(pulsedDistance);
                            particle.position.lerp(targetPosition, 0.3); // 30%ã®é‡ã¿ã§è£œé–“
                            
                            // é€šå¸¸ã®å‹•ä½œã«ç§»è¡Œã™ã‚‹ãŸã‚ã€åˆæœŸè¨­å®šã‚’ãƒªã‚»ãƒƒãƒˆ
                            particle.material.opacity = Math.min(0.9, particle.material.opacity + 0.1);
                            particle.scale.setScalar(Math.min(1.0, particle.scale.x + 0.1));
                            particle.rotation.z *= 0.7; // å›è»¢ã‚’å¾ã€…ã«æ¸›è¡°
                        } else {
                            allEmerged = false;
                        }
                    }
                });
                
                // å…¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å‡ºç¾å®Œäº†
                if (allEmerged) {
                    // æ®µéšçš„ã«ãƒ•ãƒ©ã‚°ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹ï¼ˆå³åº§ã«åˆ‡ã‚Šæ›¿ãˆãªã„ï¼‰
                    if (!this.emergenceTransitionStarted) {
                        this.emergenceTransitionStarted = true;
                        this.emergenceTransitionTime = Date.now();
                        console.log('I-E Emergence animation nearing completion - starting transition phase');
                    }
                    
                    // é·ç§»æœŸé–“ï¼ˆ500msï¼‰çµŒéå¾Œã«ãƒ•ãƒ©ã‚°ã‚’åˆ‡ã‚Šæ›¿ãˆ
                    const transitionDuration = 500;
                    if (Date.now() - this.emergenceTransitionTime > transitionDuration) {
                        this.isEmergingIE = false;
                        this.emergenceTransitionStarted = false;
                        console.log('I-E Emergence animation completed - fully transitioned to pulse behavior');
                        
                        // å…¨ã¦ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç¢ºå®Ÿã«pulseã«è¨­å®š
                        this.particles.children.forEach(particle => {
                            if (particle.userData) {
                                particle.userData.pattern = 'pulse';
                                particle.userData.cohesion = 0.1;
                                particle.userData.behavior = 'listening';
                            }
                        });
                        
                        console.log('I-E particles reset to pulse pattern - total particles:', this.particles.children.length);
                        
                        // é€šå¸¸ã®pulseãƒ‘ã‚¿ãƒ¼ãƒ³ã«ç§»è¡Œã™ã‚‹ãŸã‚ã€å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ä¸€æ™‚çš„åŠ¹æœã®ã¿ãƒªã‚»ãƒƒãƒˆ
                        this.particles.forEach(particle => {
                            if (particle.userData) {
                                // æœ€çµ‚çš„ãªå±æ€§ã‚’ç¢ºå®Ÿã«è¨­å®š
                                particle.material.opacity = Math.min(0.9, particle.material.opacity);
                                particle.scale.setScalar(1.0);
                                particle.rotation.z = 0;
                            }
                        });
                    }
                }
            }
            
            updateParticleBehavior(particle, index, time) {
                try {
                    const userData = particle.userData;
                    const stageData = this.getStageData(this.currentStage);
                    
                    // ã‚µã‚¤ã‚ºã«åŸºã¥ãå‹•çš„åŠ¹æœã®é©ç”¨
                    if (userData.originalSize && userData.sizeRatio) {
                        // å¤§ããªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã¯å°‘ã—ã‚†ã£ãã‚Šå‹•ãï¼ˆé‡ã„çµŒé¨“ã®ãƒ¡ã‚¿ãƒ•ã‚¡ãƒ¼ï¼‰
                        const sizeSpeedModifier = 1.0 / (1.0 + (userData.sizeRatio - 1.0) * 0.3);
                        
                        // å°ã•ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã¯å°‘ã—æ´»ç™ºã«å‹•ãï¼ˆæ–°ã—ã„çµŒé¨“ã®ãƒ¡ã‚¿ãƒ•ã‚¡ãƒ¼ï¼‰
                        const sizePulseModifier = userData.sizeRatio < 1.0 ? 
                            1.0 + (1.0 - userData.sizeRatio) * 0.5 : 1.0;
                        
                        // å¾®ç´°ãªè„ˆå‹•åŠ¹æœï¼ˆçµŒé¨“ã® "ç”Ÿãã¦ã„ã‚‹" æ„Ÿè¦šã‚’è¡¨ç¾ï¼‰
                        const pulse = 1.0 + Math.sin(time * 2.0 + userData.phaseOffset) * 0.05 * sizePulseModifier;
                        particle.scale.setScalar(pulse);
                        
                        // ã‚µã‚¤ã‚ºæƒ…å ±ã‚’userDataã«ä¿å­˜ï¼ˆä»–ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§ä½¿ç”¨ï¼‰
                        userData.currentSpeedModifier = sizeSpeedModifier;
                        userData.currentPulseModifier = sizePulseModifier;
                    }
                    
                    switch (userData.pattern) {
                        case 'random':
                            this.animateRandomBehavior(particle, index, time);
                            break;
                        case 'opposing':
                            this.animateOpposingBehavior(particle, index, time);
                            break;
                        case 'hesitant':
                            this.animateHesitantBehavior(particle, index, time);
                            break;
                        case 'spiral_out':
                            this.animateSpiralOutBehavior(particle, index, time);
                            break;
                        case 'dynamic_emergence':
                            this.animateDynamicEmergenceBehavior(particle, index, time);
                            break;
                        case 'convergent':
                            this.animateConvergentBehavior(particle, index, time);
                            break;
                        case 'pulse':
                            this.animatePulseBehavior(particle, index, time);
                            break;
                        case 'growth':
                            this.animateGrowthBehavior(particle, index, time);
                            break;
                        case 'stable_orbit':
                            this.animateStableOrbitBehavior(particle, index, time);
                            break;
                        case 'structured':
                            this.animateStructuredBehavior(particle, index, time);
                            break;
                        case 'harmonious':
                            this.animateHarmoniousBehavior(particle, index, time);
                            break;
                        case 'wave_rotation':
                            this.animateHarmoniousBehavior(particle, index, time);
                            break;
                        default:
                            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: åŸºæœ¬çš„ãªå‹•ã
                            this.animateRandomBehavior(particle, index, time);
                            break;
                    }
                } catch (error) {
                    console.error('Particle animation error:', error, 'Pattern:', userData?.pattern);
                    // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã¯ãƒ©ãƒ³ãƒ€ãƒ å‹•ä½œã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                    this.animateRandomBehavior(particle, index, time);
                }
            }
            
            // æ®µéšåˆ¥ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°ç¾¤
            animateRandomBehavior(particle, index, time) {
                // Ea: æ··æ²Œã¨ã—ãŸä¸è¦å‰‡ãªå‹•ã
                const userData = particle.userData;
                const speedModifier = userData.currentSpeedModifier || 1.0;
                const baseSpeed = 0.02 * speedModifier; // ã‚µã‚¤ã‚ºã«å¿œã˜ãŸé€Ÿåº¦èª¿æ•´
                
                const noise = Math.sin(time * 2 + index) * 0.5;
                particle.position.x += (Math.random() - 0.5) * baseSpeed;
                particle.position.y += (Math.random() - 0.5) * baseSpeed;
                particle.position.z += (Math.random() - 0.5) * baseSpeed;
                
                // å¢ƒç•Œå†…ã«ä¿æŒ
                const distance = particle.position.length();
                if (distance > 6) {
                    particle.position.multiplyScalar(0.9);
                }
            }
            
            animateOpposingBehavior(particle, index, time) {
                // Eb: å¯¾ç«‹ã™ã‚‹åŠ›ã«ã‚ˆã‚‹ç·Šå¼µçŠ¶æ…‹
                const userData = particle.userData;
                const speedModifier = userData.currentSpeedModifier || 1.0;
                const baseIntensity = 0.03 * speedModifier; // ã‚µã‚¤ã‚ºã«å¿œã˜ãŸå‹•ãã®å¼·åº¦èª¿æ•´
                
                const conflictDirection = index % 2 === 0 ? 1 : -1;
                const intensity = Math.sin(time * 3 + index) * conflictDirection;
                
                particle.position.x += Math.cos(time + index) * intensity * baseIntensity;
                particle.position.y += Math.sin(time * 1.5 + index) * intensity * baseIntensity;
                particle.rotation.z += intensity * 0.1 * speedModifier;
            }
            
            animateHesitantBehavior(particle, index, time) {
                // Ec: ãŸã‚ã‚‰ã„ã¨æ°—ã¥ãã®å‹•ã
                const hesitation = Math.sin(time * 0.5 + index) * 0.5 + 0.5;
                const awareness = Math.cos(time * 0.3 + index * 0.1);
                
                particle.position.y += awareness * hesitation * 0.01;
                particle.material.opacity = 0.5 + hesitation * 0.3;
            }
            
            animateSpiralOutBehavior(particle, index, time) {
                // E(I): å¤–å‘ãã‚¹ãƒ‘ã‚¤ãƒ©ãƒ« - ç–‘å•ãŒå¤–ã«å‘ã‹ã†
                const userData = particle.userData;
                const spiralRadius = userData.baseRadius + time * 0.1;
                const spiralAngle = userData.baseTheta + time * userData.speed;
                
                particle.position.x = spiralRadius * Math.cos(spiralAngle);
                particle.position.z = spiralRadius * Math.sin(spiralAngle);
                particle.position.y += Math.sin(time + index) * 0.01;
            }
            
            animateConvergentBehavior(particle, index, time) {
                // E-I: åæŸ - å†…ãªã‚‹å£°ã®æ§‹ç¯‰
                const userData = particle.userData;
                
                // I-Eã‚¹ãƒ†ãƒ¼ã‚¸ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãŒã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«æ¥ã¦ã„ãªã„ã‹ç¢ºèª
                if (this.currentStage === 'I-E' && index === 0 && Math.random() < 0.05) {
                    console.warn('I-E stage particle in convergent behavior - pattern:', userData.pattern, 'should be pulse');
                }
                
                const centerPull = userData.cohesion * 0.03; // å°‘ã—å¼·åŒ–
                const direction = new THREE.Vector3().subVectors(new THREE.Vector3(0, 0, 0), particle.position).normalize();
                
                // ã‚ˆã‚Šå¼·ã„ä¸­å¿ƒã¸ã®å¸å¼•åŠ›
                particle.position.add(direction.multiplyScalar(centerPull));
                
                // å‚ç›´æ–¹å‘ã®å¾®ç´°ãªå‹•ãã‚’æŠ‘åˆ¶ï¼ˆã‚ˆã‚ŠåæŸã«é›†ä¸­ï¼‰
                particle.position.y += Math.sin(time * 2 + index) * 0.003;
                
                // ã‚³ã‚¢è¿‘ãã§ã¯é€æ˜åº¦ã‚’ä¸‹ã’ã‚‹ï¼ˆå¸ã„è¾¼ã¾ã‚Œã‚‹æ„Ÿè¦šï¼‰
                const distanceToCore = particle.position.length();
                if (distanceToCore < 0.5) {
                    particle.material.opacity = Math.max(0.3, 0.9 * (distanceToCore / 0.5));
                }
            }
            
            animateDynamicEmergenceBehavior(particle, index, time) {
                // E(I): å‹•çš„å‡ºç¾ãƒ»æ¶ˆå¤± - ç–‘å•ã«ã‚ˆã‚‹çµŒé¨“ã®å†è©•ä¾¡
                const userData = particle.userData;
                
                // ç–‘å•ãƒ•ã‚§ãƒ¼ã‚ºã®ç®¡ç†
                if (!userData.questioningPhase) {
                    // transitionToStageã§æ—¢ã«åˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿åˆæœŸè¨­å®š
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 1 + Math.random() * 2.5;
                    const height = (Math.random() - 0.5) * 3;
                    
                    const fixedPosition = {
                        x: radius * Math.cos(angle),
                        y: height,
                        z: radius * Math.sin(angle)
                    };
                    
                    particle.position.set(fixedPosition.x, fixedPosition.y, fixedPosition.z);
                    
                    userData.questioningPhase = {
                        spawnTime: time,
                        lifespan: 1.5 + Math.random() * 4, // 1.5-5.5ç§’ã®ãƒ©ã‚¤ãƒ•ã‚¹ãƒ‘ãƒ³
                        isPersistent: Math.random() < 0.25, // 25%ã®ç¢ºç‡ã§æ°¸ç¶šåŒ–
                        fadeInDuration: 0.8,
                        fadeOutDuration: 1.2,
                        hasBeenPersistent: false,
                        fixedPosition: fixedPosition
                    };
                }
                
                const phase = userData.questioningPhase;
                const age = time - phase.spawnTime;
                
                // æ°¸ç¶šåŒ–åˆ¤å®šï¼ˆãƒ©ã‚¤ãƒ•ã‚¹ãƒ‘ãƒ³ã®70%çµŒéæ™‚ç‚¹ã§åˆ¤å®šï¼‰
                if (!phase.hasBeenPersistent && age > phase.lifespan * 0.7 && phase.isPersistent) {
                    phase.hasBeenPersistent = true;
                    this.persistentParticleIndices.add(index);
                    phase.lifespan = Infinity; // æ°¸ç¶šåŒ–
                }
                
                // ãƒ•ã‚§ãƒ¼ãƒ‰å‡¦ç†
                let alpha = 1;
                if (age < phase.fadeInDuration) {
                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
                    alpha = age / phase.fadeInDuration;
                } else if (age > phase.lifespan - phase.fadeOutDuration && phase.lifespan !== Infinity) {
                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆï¼ˆæ°¸ç¶šãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ä»¥å¤–ï¼‰
                    alpha = Math.max(0, (phase.lifespan - age) / phase.fadeOutDuration);
                }
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å†ç”Ÿæˆåˆ¤å®š
                if (age > phase.lifespan && phase.lifespan !== Infinity) {
                    // æ–°ã—ã„ä½ç½®ã§å†å‡ºç¾
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 1 + Math.random() * 2.5;
                    const height = (Math.random() - 0.5) * 3;
                    
                    const newFixedPosition = {
                        x: radius * Math.cos(angle),
                        y: height,
                        z: radius * Math.sin(angle)
                    };
                    
                    particle.position.set(newFixedPosition.x, newFixedPosition.y, newFixedPosition.z);
                    
                    // æ–°ã—ã„ãƒ•ã‚§ãƒ¼ã‚ºã‚’é–‹å§‹
                    userData.questioningPhase = {
                        spawnTime: time,
                        lifespan: 1.5 + Math.random() * 4,
                        isPersistent: Math.random() < 0.25,
                        fadeInDuration: 0.8,
                        fadeOutDuration: 1.2,
                        hasBeenPersistent: false,
                        fixedPosition: newFixedPosition
                    };
                    alpha = 0;
                } else {
                    // å›ºå®šä½ç½®ã«ç•™ã¾ã‚‹ï¼ˆã‚ãšã‹ãªæµ®éŠæ„Ÿã®ã¿ï¼‰
                    const basePos = phase.fixedPosition;
                    const gentleFloat = Math.sin(time * 0.5 + index * 0.3) * 0.05; // éå¸¸ã«å¾®ç´°ãªæµ®éŠ
                    
                    particle.position.x = basePos.x;
                    particle.position.y = basePos.y + gentleFloat;
                    particle.position.z = basePos.z;
                }
                
                // é€æ˜åº¦ã¨ã‚¹ã‚±ãƒ¼ãƒ«ã®é©ç”¨
                particle.material.opacity = alpha * 0.95;
                const scale = 0.7 + alpha * 0.5;
                
                // ã‚¹ã‚±ãƒ¼ãƒ«è¨­å®šã®å®‰å…¨ãªå‡¦ç†
                if (particle.scale) {
                    particle.scale.setScalar(scale);
                } else {
                    particle.scale = new THREE.Vector3(scale, scale, scale);
                }
                
                // æ°¸ç¶šãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã¯å°‘ã—æ˜ã‚‹ãã€ã‚ˆã‚Šå¼·ã„ç™ºå…‰
                if (this.persistentParticleIndices.has(index)) {
                    if (particle.material.emissive) {
                        particle.material.emissive.setHex(0x666600); // ã‚ˆã‚Šå¼·ã„é»„è‰²ã®ç™ºå…‰
                    }
                } else {
                    if (particle.material.emissive) {
                        particle.material.emissive.setHex(0x111111);
                    }
                }
            }
            
            animatePulseBehavior(particle, index, time) {
                // I-E: è„ˆå‹• - å†…ãªã‚‹å£°ã‚’è´ãï¼ˆã¤ã‹ãšé›¢ã‚Œãšã®çŠ¶æ…‹ï¼‰
                
                const basePos = particle.userData.originalPosition;
                if (!basePos) return; // originalPositionãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                
                // å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã§ã‚‚ã€æ®µéšçš„ã«ãƒ‘ãƒ«ã‚¹å‹•ä½œã«ç§»è¡Œã™ã‚‹
                let transitionFactor = 1.0; // é€šå¸¸æ™‚ã¯å®Œå…¨ãªãƒ‘ãƒ«ã‚¹å‹•ä½œ
                let shouldBlendWithEmergence = false;
                
                if (this.isEmergingIE && this.emergingParticles) {
                    const emergenceData = this.emergingParticles.find(data => data.particleIndex === index);
                    if (emergenceData && emergenceData.emergenceProgress > 0.7) {
                        // å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒ70%å®Œäº†ã—ãŸã‚‰æ®µéšçš„ã«ãƒ‘ãƒ«ã‚¹å‹•ä½œã‚’é–‹å§‹
                        transitionFactor = (emergenceData.emergenceProgress - 0.7) / 0.3; // 0.7-1.0ã‚’0-1ã«ãƒãƒƒãƒ—
                        shouldBlendWithEmergence = true;
                    } else if (emergenceData && emergenceData.emergenceProgress <= 0.7) {
                        // ã¾ã å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸»å°æœŸé–“
                        return;
                    }
                }
                
                // ãƒ‡ãƒãƒƒã‚°ï¼šãƒ‘ã‚¿ãƒ¼ãƒ³ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªï¼ˆæœ€åˆã®æ•°å›ã®ã¿ï¼‰
                if (index === 0 && Math.random() < 0.01) {
                    console.log('I-E Pulse behavior - pattern:', particle.userData.pattern, 'cohesion:', particle.userData.cohesion, 'transition:', transitionFactor);
                }
                
                const distance = basePos.length();
                
                // æ™‚é–“ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’ä½¿ç”¨ã—ãŸæ»‘ã‚‰ã‹ãªãƒ‘ãƒ«ã‚¹ï¼ˆè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯indexåŸºæº–ï¼‰
                let timeOffset = particle.userData.pulseTimeOffset;
                if (timeOffset === undefined) {
                    // åˆå›ã®å ´åˆã€ç¾åœ¨ä½ç½®ã«åŸºã¥ã„ã¦è‡ªç„¶ãªæ™‚é–“ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—
                    const currentDistance = particle.position.length();
                    const currentPulseRatio = Math.max(0.85, Math.min(1.0, currentDistance / distance));
                    const normalizedPulse = Math.max(-1, Math.min(1, (currentPulseRatio - 0.925) / 0.075));
                    
                    // ã‚ˆã‚Šå®‰å…¨ãªä½ç›¸è¨ˆç®—ï¼ˆMath.asinã®ä»£ã‚ã‚Šã«Math.atan2ã‚’ä½¿ç”¨ï¼‰
                    const basePhase = Math.atan2(normalizedPulse, Math.sqrt(1 - normalizedPulse * normalizedPulse));
                    timeOffset = basePhase - time * 1.2;
                    particle.userData.pulseTimeOffset = timeOffset;
                }
                
                // ã‚ˆã‚ŠçŸ­ã„è·é›¢ã§ã®è„ˆå‹•ï¼ˆ0.85-1.0ã®ç¯„å›²ã«èª¿æ•´ï¼‰
                const pulse = Math.sin(time * 1.2 + timeOffset) * 0.075 + 0.925;
                
                // å€‹åˆ¥ã®æ€æ¡ˆãƒ—ãƒ­ã‚»ã‚¹ã‚’è¡¨ç¾ã™ã‚‹å¾®ç´°ãªæºã‚‰ã
                const contemplation = Math.sin(time * 2.3 + index * 0.3) * 0.03;
                const finalPulse = pulse + contemplation;
                
                // åŸºæº–ä½ç½®ã‹ã‚‰ã®è„ˆå‹•ï¼ˆã‚³ã‚¢ã«å‘ã‹ã‚ãšã€å…ƒã®ä½ç½®å‘¨è¾ºã§è„ˆå‹•ï¼‰
                const direction = basePos.clone().normalize();
                const pulsedDistance = distance * finalPulse;
                
                // ç›®æ¨™ä½ç½®ã‚’è¨ˆç®—
                const targetPosition = direction.clone().multiplyScalar(pulsedDistance);
                
                // è»½å¾®ãªå††è»Œé“é‹å‹•ã‚’è¿½åŠ ï¼ˆå†…ãªã‚‹å£°ã‚’ã€Œè´ãã€å‹•ãã‚’è¡¨ç¾ï¼‰
                const orbitAngle = time * 0.3 + index * 0.5;
                const orbitRadius = 0.1;
                const orbitX = Math.cos(orbitAngle) * orbitRadius;
                const orbitZ = Math.sin(orbitAngle) * orbitRadius;
                
                targetPosition.x += orbitX;
                targetPosition.z += orbitZ;
                
                if (shouldBlendWithEmergence) {
                    // å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã¨ãƒ‘ãƒ«ã‚¹å‹•ä½œã‚’ãƒ–ãƒ¬ãƒ³ãƒ‰
                    const currentPos = particle.position.clone();
                    particle.position.lerpVectors(currentPos, targetPosition, transitionFactor * 0.1);
                } else {
                    // é€šå¸¸ã®ãƒ‘ãƒ«ã‚¹å‹•ä½œ
                    particle.position.copy(targetPosition);
                }
                
                // é€æ˜åº¦ã‚‚å¾®ç´°ã«å¤‰å‹•ï¼ˆæ€è€ƒã®æ·±ã•ã‚’è¡¨ç¾ï¼‰
                const targetOpacity = 0.7 + finalPulse * 0.2;
                if (shouldBlendWithEmergence) {
                    particle.material.opacity = THREE.MathUtils.lerp(particle.material.opacity, targetOpacity, transitionFactor * 0.1);
                } else {
                    particle.material.opacity = targetOpacity;
                }
            }
            
            animateGrowthBehavior(particle, index, time) {
                // I(E): æˆé•·ãƒ‘ã‚¿ãƒ¼ãƒ³ - å†…ãªã‚‹å£°ã‚’è‚²ã‚€
                const growth = Math.min(1, particle.userData.age * 0.1);
                const organic = Math.sin(time + index * 0.5) * growth;
                
                particle.position.y += organic * 0.015;
                particle.scale.setScalar(0.8 + growth * 0.4);
            }
            
            animateStableOrbitBehavior(particle, index, time) {
                // Ia: å®‰å®šè»Œé“ - ä¿¡é ¼ã«åŸºã¥ãå®‰å®šã—ãŸå‹•ã
                const userData = particle.userData;
                const orbitRadius = userData.baseRadius;
                const orbitSpeed = userData.speed * 0.5;
                const angle = time * orbitSpeed + userData.phaseOffset;
                
                particle.position.x = orbitRadius * Math.cos(angle);
                particle.position.z = orbitRadius * Math.sin(angle);
                particle.position.y = userData.originalPosition.y + Math.sin(angle * 2) * 0.2;
            }
            
            animateStructuredBehavior(particle, index, time) {
                // Ib: æ§‹é€ åŒ– - åŸºç›¤å½¢æˆï¼ˆã‚ˆã‚Šã‚ªãƒ¼ã‚¬ãƒ‹ãƒƒã‚¯ãªé…ç½®ï¼‰
                const userData = particle.userData;
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å›ºæœ‰ã®ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ ã‚’åˆæœŸåŒ–ï¼ˆä¸€åº¦ã ã‘ï¼‰
                if (!userData.structuredParams) {
                    userData.structuredParams = {
                        layerGroup: Math.floor(index / 5) + Math.floor(index / 8), // ã‚ˆã‚Šå¤šæ§˜ãªå±¤åˆ†å¸ƒ
                        baseAngleOffset: Math.random() * Math.PI * 2, // å„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å›ºæœ‰ã®è§’åº¦ã‚ªãƒ•ã‚»ãƒƒãƒˆ
                        radiusVariation: 0.7 + Math.random() * 0.6, // åŠå¾„ã®ãƒ©ãƒ³ãƒ€ãƒ å¤‰å‹•
                        heightOffset: (Math.random() - 0.5) * 0.4, // é«˜ã•ã®ãƒ©ãƒ³ãƒ€ãƒ ã‚ªãƒ•ã‚»ãƒƒãƒˆ
                        rotationSpeed: 0.8 + Math.random() * 0.4, // å€‹åˆ¥ã®å›è»¢é€Ÿåº¦
                        phaseShift: Math.random() * Math.PI * 2, // æ³¢ã®ä½ç›¸ã‚·ãƒ•ãƒˆ
                        verticalCenter: (Math.random() - 0.5) * 0.8 // æ°´å¹³é¢ã‚’ä¸­å¿ƒã¨ã—ãŸä¸Šä¸‹åˆ†æ•£
                    };
                }
                
                const params = userData.structuredParams;
                const layer = Math.min(params.layerGroup, 4); // æœ€å¤§5å±¤ã«åˆ¶é™
                const layerRadius = (1 + layer * 0.7) * params.radiusVariation;
                
                // ã‚ˆã‚Šã‚ªãƒ¼ã‚¬ãƒ‹ãƒƒã‚¯ãªè§’åº¦è¨ˆç®—
                const baseAngle = params.baseAngleOffset + time * 0.2 * params.rotationSpeed;
                const angleNoise = Math.sin(time * 0.5 + params.phaseShift) * 0.3; // è§’åº¦ã®ã‚†ã‚‰ã
                const finalAngle = baseAngle + angleNoise;
                
                // åŠå¾„ã«ã‚‚å¾®ç´°ãªå¤‰å‹•ã‚’è¿½åŠ 
                const radiusNoise = Math.sin(time * 0.8 + index * 0.1) * 0.2;
                const finalRadius = layerRadius + radiusNoise;
                
                particle.position.x = finalRadius * Math.cos(finalAngle);
                particle.position.z = finalRadius * Math.sin(finalAngle);
                // æ°´å¹³é¢ï¼ˆy=0ï¼‰ã‚’ä¸­å¿ƒã«ä¸Šä¸‹å‡ç­‰ã«åˆ†æ•£
                particle.position.y = params.verticalCenter + params.heightOffset + Math.sin(time + params.phaseShift) * 0.15;
            }
            
            animateHarmoniousBehavior(particle, index, time) {
                // Ic: æ³¢å‹•å›è»¢ - Ibã®ã‚ªãƒ¼ã‚¬ãƒ‹ãƒƒã‚¯æ§‹é€ ã‚’ãƒ™ãƒ¼ã‚¹ã«æ³¢ã®ã†ã­ã‚Šã¨å›è»¢ã‚’è¿½åŠ 
                // åºƒç¯„å›²ãªçµŒé¨“ã®çµã³ã¤ãã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã€ã‚ˆã‚Šåºƒã„ç©ºé–“åˆ†æ•£ã‚’å®Ÿç¾
                const userData = particle.userData;
                
                // Ibã®ã‚ªãƒ¼ã‚¬ãƒ‹ãƒƒã‚¯æ§‹é€ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å–å¾—/åˆæœŸåŒ–
                if (!userData.structuredParams) {
                    userData.structuredParams = {
                        layerGroup: Math.floor(index / 5) + Math.floor(index / 8),
                        baseAngleOffset: Math.random() * Math.PI * 2,
                        radiusVariation: 0.7 + Math.random() * 0.6,
                        heightOffset: (Math.random() - 0.5) * 1.2, // é«˜ã•ã®åˆ†æ•£ã‚’3å€ã«æ‹¡å¤§
                        rotationSpeed: 0.8 + Math.random() * 0.4,
                        phaseShift: Math.random() * Math.PI * 2,
                        verticalCenter: (Math.random() - 0.5) * 1.0 // æ°´å¹³é¢ã‚’ä¸­å¿ƒã¨ã—ãŸä¸Šä¸‹åˆ†æ•£
                    };
                }
                
                const params = userData.structuredParams;
                const layer = Math.min(params.layerGroup, 4);
                const baseRadius = (1 + layer * 0.7) * params.radiusVariation;
                const baseAngle = params.baseAngleOffset + time * 0.2 * params.rotationSpeed;
                
                // æ³¢ã®ã†ã­ã‚Šæˆåˆ†ã‚’è¿½åŠ 
                const waveFrequency = 0.5;
                const waveAmplitude = 0.4;
                const wavePhase = time * 2 + params.phaseShift;
                const wave = Math.sin(wavePhase * waveFrequency) * waveAmplitude;
                
                // å‹•çš„ãªå›è»¢åŠå¾„ï¼ˆæ³¢ã®å½±éŸ¿ã‚’å—ã‘ã‚‹ï¼‰
                const dynamicRadius = baseRadius + wave;
                
                // åŸºæœ¬å›è»¢ã«å‚ç›´ãªæ³¢å‹•ã‚’è¿½åŠ ï¼ˆé«˜ã•æ–¹å‘ã®å‹•ãã‚’æ‹¡å¤§ï¼‰
                const verticalWave = Math.sin(time * 1.5 + params.phaseShift) * 0.5; // å‚ç›´æ³¢å‹•ã‚’æ‹¡å¤§
                const radialWave = Math.cos(time * 0.8 + index * 0.4) * 0.15;
                const angleNoise = Math.sin(time * 0.7 + params.phaseShift) * 0.2;
                
                particle.position.x = (dynamicRadius + radialWave) * Math.cos(baseAngle + angleNoise);
                particle.position.z = (dynamicRadius + radialWave) * Math.sin(baseAngle + angleNoise);
                // æ°´å¹³é¢ï¼ˆy=0ï¼‰ã‚’ä¸­å¿ƒã«ä¸Šä¸‹å‡ç­‰ã«åˆ†æ•£
                particle.position.y = params.verticalCenter + params.heightOffset + verticalWave + Math.sin(baseAngle * 3 + time) * 0.3;
                
                // ã‚ˆã‚Šæ˜ã‚‹ãæ´»ç™ºãªé€æ˜åº¦å¤‰åŒ–
                const brightness = 0.8 + Math.sin(time * 2 + index) * 0.2;
                particle.material.opacity = Math.max(0.6, brightness);
            }
            
            // EI stage: ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å¸åã¨ã‚³ã‚¢å…‰é‡å¢—åŠ 
            absorbParticleIntoCore(particle, index) {
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å‰Šé™¤
                this.scene.remove(particle);
                particle.geometry.dispose();
                particle.material.dispose();
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é…åˆ—ã‹ã‚‰å‰Šé™¤
                const particleIndex = this.particles.indexOf(particle);
                if (particleIndex > -1) {
                    this.particles.splice(particleIndex, 1);
                }
                
                // å¸åã‚«ã‚¦ãƒ³ãƒˆã‚’å¢—åŠ 
                this.absorptionCount++;
                
                // ã‚³ã‚¢å…‰é‡ã‚’å¢—åŠ ï¼ˆæ®µéšçš„ã«ä¸Šé™ã¾ã§ï¼‰
                const intensityIncrease = 0.05; // 1å›ã®å¸åã§ã®å¢—åŠ é‡
                this.currentCoreIntensity = Math.min(
                    this.maxCoreIntensity, 
                    this.currentCoreIntensity + intensityIncrease
                );
                
                // ã‚³ã‚¢ãƒ©ã‚¤ãƒˆã®å¼·åº¦ã‚’æ›´æ–°
                if (this.coreLight) {
                    this.coreLight.intensity = this.currentCoreIntensity;
                }
                
                // ã‚³ã‚¢è‡ªä½“ã®ç™ºå…‰ã‚‚å¼·åŒ–
                if (this.core && this.core.material) {
                    const emissiveIntensity = Math.min(0.8, 0.2 + (this.absorptionCount * 0.02));
                    this.core.material.emissive.setRGB(emissiveIntensity, emissiveIntensity, emissiveIntensity);
                }
                
                console.log(`ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å¸å: ${this.absorptionCount}å€‹, ã‚³ã‚¢å…‰é‡: ${this.currentCoreIntensity.toFixed(2)}`);
            }
            
            // ã‚³ã‚¢å…‰é‡ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆã‚¹ãƒ†ãƒ¼ã‚¸åˆ‡ã‚Šæ›¿ãˆæ™‚ãªã©ï¼‰
            resetCoreIntensity() {
                this.absorptionCount = 0;
                this.currentCoreIntensity = this.baseCoreIntensity;
                
                if (this.coreLight) {
                    this.coreLight.intensity = this.baseCoreIntensity;
                }
                
                if (this.core && this.core.material) {
                    this.core.material.emissive.setRGB(0.27, 0.27, 0.27); // 0x444444ç›¸å½“
                }
            }
            
            cleanup() {
                console.log('3Dãƒªã‚½ãƒ¼ã‚¹ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ä¸­...');
                
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                
                // Remove particles
                this.particles.forEach(particle => {
                    this.scene.remove(particle);
                    particle.geometry.dispose();
                    particle.material.dispose();
                });
                this.particles = [];
                
                // Clean up connection lines
                this.clearConnections();
                
                // Remove dimension rings
                this.dimensionRings.forEach(ring => {
                    this.scene.remove(ring);
                    ring.geometry.dispose();
                    ring.material.dispose();
                });
                this.dimensionRings = [];
                
                // Clean up renderer
                if (this.renderer) {
                    const sceneElement = document.getElementById('refined-3d-scene');
                    if (sceneElement && this.renderer.domElement.parentNode === sceneElement) {
                        sceneElement.removeChild(this.renderer.domElement);
                    }
                    this.renderer.dispose();
                    this.renderer = null;
                }
                
                // Clean up scene
                if (this.scene) {
                    while(this.scene.children.length > 0) {
                        const object = this.scene.children[0];
                        if (object.geometry) object.geometry.dispose();
                        if (object.material) object.material.dispose();
                        this.scene.remove(object);
                    }
                    this.scene = null;
                }
                
                this.isInitialized = false;
                console.log('3Dãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†');
            }
        }

        // Global instances
        let refinedVisualization = null;
        let journeyVisualization = null;

        // Enhanced toggleSection function with detailed debugging
        function toggleSection(sectionId) {
            console.log('toggleSection called with:', sectionId);
            const section = document.getElementById(sectionId);
            
            if (!section) {
                console.error('Section not found:', sectionId);
                alert('ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ' + sectionId);
                return;
            }
            
            console.log('Section element found:', section);
            section.classList.toggle('active');
            const isActive = section.classList.contains('active');
            console.log('Section', sectionId, 'is now', isActive ? 'active' : 'inactive');
            
            // Handle 3D initialization/cleanup for refined-phases section
            if (sectionId === 'refined-phases') {
                if (isActive) {
                    // Section opened - initialize 3D
                    console.log('ç²¾ç·»åŒ–ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒé–‹ã‹ã‚Œã¾ã—ãŸ - 3DåˆæœŸåŒ–é–‹å§‹');
                    try {
                        if (!refinedVisualization) {
                            console.log('Creating new RefinedSelfAuthorshipVisualization instance');
                            refinedVisualization = new RefinedSelfAuthorshipVisualization();
                            console.log('Initializing 3D visualization');
                            refinedVisualization.init('refined-3d-container');
                        } else {
                            // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒå†åº¦é–‹ã‹ã‚ŒãŸæ™‚ã¯3Dç’°å¢ƒã‚’åˆæœŸåŒ–
                            console.log('Re-initializing 3D environment');
                            refinedVisualization.reinitialize3D();
                        }
                    } catch (error) {
                        console.error('3DåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
                        alert('3DåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ' + error.message);
                    }
                } else {
                    // Section closed - è»½ã„ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã®ã¿ï¼ˆãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã¯ä¿æŒï¼‰
                    console.log('ç²¾ç·»åŒ–ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒé–‰ã˜ã‚‰ã‚Œã¾ã—ãŸ - è»½ã„ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–‹å§‹');
                    try {
                        if (refinedVisualization) {
                            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ã¿åœæ­¢ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã¯ä¿æŒ
                            if (refinedVisualization.animationId) {
                                cancelAnimationFrame(refinedVisualization.animationId);
                                refinedVisualization.animationId = null;
                            }
                            console.log('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åœæ­¢å®Œäº†ï¼ˆãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã¯ä¿æŒï¼‰');
                        }
                    } catch (error) {
                        console.error('è»½ã„ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼:', error);
                    }
                }
            }
            
            // Handle Canvas 2D initialization/cleanup for detailed-journey section
            if (sectionId === 'detailed-journey') {
                if (isActive) {
                    // Section opened - initialize Canvas 2D
                    console.log('è©³ç´°ãªæ—…ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒé–‹ã‹ã‚Œã¾ã—ãŸ - Canvas2DåˆæœŸåŒ–é–‹å§‹');
                    try {
                        console.log('Calling initJourneyVisualization');
                        initJourneyVisualization();
                    } catch (error) {
                        console.error('Canvas2DåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
                        alert('Canvas2DåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ' + error.message);
                    }
                } else {
                    // Section closed - cleanup Canvas 2D
                    console.log('è©³ç´°ãªæ—…ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒé–‰ã˜ã‚‰ã‚Œã¾ã—ãŸ - Canvas2Dã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–‹å§‹');
                    try {
                        cleanupJourneyVisualization();
                    } catch (error) {
                        console.error('Canvas2Dã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼:', error);
                    }
                }
            }
        }

        // Make toggleSection globally available
        window.toggleSection = toggleSection;

        // Stage click handling for dynamic linking
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—3Dçµ±åˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
            
            // Add click handlers to stage headings in text for dynamic linking
            setTimeout(() => {
                const stageHeadings = document.querySelectorAll('.sub-phase h4');
                stageHeadings.forEach(heading => {
                    const text = heading.textContent;
                    const stageMatch = text.match(/^(Ea|Eb|Ec|E\(I\)|E-I|I-E|I\(E\)|Ia|Ib|Ic):/);
                    if (stageMatch) {
                        let stageId = stageMatch[1];
                        // Convert special cases
                        if (stageId === 'E(I)') stageId = 'EI';
                        if (stageId === 'I(E)') stageId = 'IE';
                        
                        heading.style.cursor = 'pointer';
                        heading.style.transition = 'all 0.3s';
                        
                        heading.addEventListener('click', () => {
                            if (refinedVisualization && refinedVisualization.isInitialized) {
                                refinedVisualization.switchToStage(stageId);
                                
                                // Scroll to 3D area
                                const container = document.getElementById('refined-3d-container');
                                if (container) {
                                    container.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            }
                        });
                    }
                });
            }, 1000);
        });

        // ===== Canvas 2D ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³çµ±åˆã‚³ãƒ¼ãƒ‰ =====
        
        class EnhancedParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.2;
                this.vy = (Math.random() - 0.5) * 0.2;
                this.baseSize = Math.random() * 3 + 2;
                this.size = this.baseSize;
                this.autonomy = 0.0;
                this.personalDirection = Math.random() * Math.PI * 2;
                this.personalFrequency = 0.01 + Math.random() * 0.02;
                this.vibrationPhase = Math.random() * Math.PI * 2;
                this.shape = 'circle';
                this.connections = [];
                
                // æ¥ç¶šãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³åˆ¶å¾¡ç”¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
                this.connectionFadeOpacity = 0.0;
                this.connectionFadeStartTime = null;
                this.connectionFadeDuration = 1500; // 1.5ç§’ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³å®Œäº†
                this.connectionFadeDelay = 1500;    // 1.5ç§’ã®é…å»¶å¾Œã«ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é–‹å§‹
                
                // è‰²å½©ã‚·ã‚¹ãƒ†ãƒ 
                this.originalHue = Math.random() * 360;
                this.currentHue = this.originalHue;
                this.saturation = 30;
                this.lightness = 50;
                this.glow = 0;
                
                // è»Œè·¡ã‚·ã‚¹ãƒ†ãƒ 
                this.trail = [];
                this.maxTrailLength = 20;
            }

            update(stage, mouseX, mouseY, particles) {
                // è»Œè·¡ã®æ›´æ–°
                this.trail.push({x: this.x, y: this.y, life: 1.0});
                while (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                this.trail.forEach(point => point.life *= 0.95);

                // æ®µéšã«å¿œã˜ãŸæŒ™å‹•
                switch(stage) {
                    case 0: this.updateGravityDominance(mouseX, mouseY); break;
                    case 1: this.updateChaosEdge(mouseX, mouseY); break;
                    case 2: this.updateCreativeScattering(mouseX, mouseY); break;
                    case 3: this.updateCosmicDance(mouseX, mouseY, particles); break;
                }

                // å¢ƒç•Œå‡¦ç†
                this.handleBoundaries();
                
                // ä½ç½®æ›´æ–°
                this.x += this.vx;
                this.y += this.vy;

                // æ‘©æ“¦
                this.vx *= 0.99;
                this.vy *= 0.99;
            }

            updateGravityDominance(mouseX, mouseY) {
                // é‡åŠ›å ´ã®å½±éŸ¿
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    const force = 0.004;
                    this.vx += (dx / distance) * force;
                    this.vy += (dy / distance) * force;
                }

                // åŒèª¿è¡Œå‹•
                this.vibrationPhase += this.personalFrequency;
                this.size = this.baseSize + Math.sin(this.vibrationPhase) * 0.5;
                
                // è‰²å½©ã®çµ±ä¸€åŒ–
                this.currentHue = 240;
                this.saturation = 40;
                this.lightness = 60;
                this.glow = 0;
                this.autonomy = 0;
                this.shape = 'ellipse';
            }

            updateChaosEdge(mouseX, mouseY) {
                // å¤–éƒ¨ã¨å†…éƒ¨ã®åŠ›ã®æ··åœ¨
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    const force = 0.002 * (1 - this.autonomy);
                    this.vx += (dx / distance) * force;
                    this.vy += (dy / distance) * force;
                }

                // ä¸è¦å‰‡ãªæŒ¯å‹•
                this.vibrationPhase += this.personalFrequency * (1 + Math.sin(Date.now() * 0.003) * 0.5);
                this.size = this.baseSize + Math.sin(this.vibrationPhase) * 1.5;
                
                // è‡ªå¾‹æ€§ã®èŠ½ç”Ÿãˆ
                if (Math.random() < 0.01) {
                    this.autonomy = Math.min(0.3, this.autonomy + 0.005);
                }
                
                // è‰²å½©ã®åˆ†åŒ–
                this.currentHue = this.originalHue + (Math.sin(this.vibrationPhase) * 30);
                this.saturation = 40 + (this.autonomy * 40);
                this.lightness = 60 + (Math.sin(this.vibrationPhase) * 20);
                this.glow = this.autonomy * 0.3;
                
                // å½¢çŠ¶ã®å®Ÿé¨“
                const shapeRandom = Math.sin(this.vibrationPhase * 3);
                if (shapeRandom > 0.7) this.shape = 'triangle';
                else if (shapeRandom > 0.3) this.shape = 'square';
                else this.shape = 'circle';
                
                // å€‹äººçš„ãªæ–¹å‘æ€§
                const personalForce = 0.001 * this.autonomy;
                this.vx += Math.cos(this.personalDirection) * personalForce;
                this.vy += Math.sin(this.personalDirection) * personalForce;
            }

            updateCreativeScattering(mouseX, mouseY) {
                try {
                    // å…¥åŠ›å€¤ã®æ¤œè¨¼
                    if (!isFinite(mouseX) || !isFinite(mouseY)) {
                        mouseX = this.x || 0;
                        mouseY = this.y || 0;
                    }
                    
                    // åˆæœŸæ‹¡æ•£ãƒ•ã‚§ãƒ¼ã‚º - ã‚¹ãƒ†ãƒ¼ã‚¸ç§»è¡Œç›´å¾Œã«ç©æ¥µçš„ã«æ‹¡æ•£
                    if (!this.hasInitialDispersed) {
                        this.hasInitialDispersed = true;
                        this.initialDispersionTimer = 0;
                        
                        // åˆæœŸæ‹¡æ•£æ–¹å‘ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«è¨­å®š
                        this.dispersalDirection = Math.random() * Math.PI * 2;
                        this.dispersalForce = 0.4 + Math.random() * 0.3; // 0.4-0.7ã®æ‹¡æ•£åŠ›ï¼ˆå¾“æ¥ã®åŠåˆ†ç¨‹åº¦ï¼‰
                    }
                    
                    // åˆæœŸæ‹¡æ•£åŠ›ã®é©ç”¨ï¼ˆæœ€åˆã®4ç§’é–“ã«å»¶é•·ã—ã¦ã‚ˆã‚Šç·©ã‚„ã‹ã«ï¼‰
                    if (this.initialDispersionTimer < 240) { // 60fps * 4ç§’
                        this.initialDispersionTimer++;
                        const dispersionStrength = Math.max(0, 1 - (this.initialDispersionTimer / 240));
                        
                        this.vx += Math.cos(this.dispersalDirection) * this.dispersalForce * dispersionStrength * 0.01; // 0.02ã‹ã‚‰0.01ã«æ¸›å°‘
                        this.vy += Math.sin(this.dispersalDirection) * this.dispersalForce * dispersionStrength * 0.01;
                    }
                    
                    // é‡åŠ›ã‹ã‚‰ã®è§£æ”¾ï¼ˆå¾“æ¥ã‚ˆã‚Šå¼±ãèª¿æ•´ï¼‰
                    const dx = mouseX - this.x;
                    const dy = mouseY - this.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // åˆ†æ¯ã‚¼ãƒ­ãƒã‚§ãƒƒã‚¯
                    if (distance < 0.001) {
                        distance = 0.001;
                    }
                    
                    if (isFinite(distance) && distance > 0) {
                        // é‡åŠ›ã®å½±éŸ¿ã‚’å¤§å¹…ã«æ¸›å°‘ï¼ˆè‡ªå¾‹æ€§é‡è¦–ï¼‰
                        const force = 0.0002 * (1 - this.autonomy) * Math.max(0, 1 - this.autonomy);
                        if (isFinite(force)) {
                            const forceX = (dx / distance) * force;
                            const forceY = (dy / distance) * force;
                            
                            if (isFinite(forceX) && isFinite(forceY)) {
                                this.vx += forceX;
                                this.vy += forceY;
                            }
                        }
                    }

                    // æ€¥é€Ÿãªè‡ªå¾‹æ€§ã®ç™ºé”
                    this.autonomy = Math.min(0.95, this.autonomy + 0.008);
                    
                    // å‰µé€ çš„ãªè»Œé“ï¼ˆå®‰å…¨æ€§ãƒã‚§ãƒƒã‚¯ä»˜ãï¼‰- æ‹¡æ•£åŠ›å¼·åŒ–
                    if (isFinite(this.personalDirection)) {
                        this.personalDirection += 0.012 + (this.autonomy * 0.02); // å›è»¢é€Ÿåº¦ã‚’å°‘ã—ç·©ã‚„ã‹ã«
                        const creativityForce = 0.004 * this.autonomy + 0.001; // åŸºæœ¬å‰µé€ åŠ›ã‚’æ¸›å°‘
                        
                        // æ‹¡æ•£ä¿ƒé€²åŠ› - ä»–ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã¨ã®è·é›¢ã«åŸºã¥ãåç™ºåŠ›
                        const expansionForce = 0.002 * this.autonomy; // æ‹¡æ•£åŠ›ã‚’åŠåˆ†ã«
                        
                        if (isFinite(creativityForce) && isFinite(expansionForce)) {
                            const baseCreativeX = Math.cos(this.personalDirection) * creativityForce;
                            const baseCreativeY = Math.sin(this.personalDirection) * creativityForce;
                            
                            // æ‹¡æ•£æ–¹å‘ã¸ã®è¿½åŠ åŠ›
                            const expansionX = Math.cos(this.personalDirection + Math.PI/4) * expansionForce;
                            const expansionY = Math.sin(this.personalDirection + Math.PI/4) * expansionForce;
                            
                            this.vx += baseCreativeX + expansionX;
                            this.vy += baseCreativeY + expansionY;
                        }
                    } else {
                        this.personalDirection = Math.random() * Math.PI * 2;
                    }

                    // å¢ƒç•Œã§ã®åç™ºåŠ›å¼·åŒ–ï¼ˆç”»é¢ç«¯ã‹ã‚‰ã®è‡ªå¾‹çš„åç™ºï¼‰
                    const canvas = document.getElementById('growth-visualization-canvas');
                    if (canvas) {
                        const margin = 50;
                        if (this.x < margin) this.vx += 0.005 * this.autonomy; // å¢ƒç•Œåç™ºåŠ›ã‚‚åŠæ¸›
                        if (this.x > canvas.width - margin) this.vx -= 0.005 * this.autonomy;
                        if (this.y < margin) this.vy += 0.005 * this.autonomy;
                        if (this.y > canvas.height - margin) this.vy -= 0.005 * this.autonomy;
                    }

                    // ç”Ÿãç”Ÿãã¨ã—ãŸæŒ¯å‹•ï¼ˆå®‰å…¨æ€§ãƒã‚§ãƒƒã‚¯ä»˜ãï¼‰- æ´»ç™ºæ€§å‘ä¸Š
                    if (isFinite(this.vibrationPhase) && isFinite(this.personalFrequency)) {
                        this.vibrationPhase += this.personalFrequency * (2.5 + this.autonomy * 1.5);
                        const sizeModifier = Math.sin(this.vibrationPhase * 2) * (1.2 + this.autonomy * 2.5);
                        if (isFinite(sizeModifier)) {
                            this.size = this.baseSize + sizeModifier;
                        } else {
                            this.size = this.baseSize;
                        }
                    } else {
                        this.vibrationPhase = Math.random() * Math.PI * 2;
                        this.personalFrequency = 0.015 + Math.random() * 0.025; // æŒ¯å‹•é »åº¦å‘ä¸Š
                        this.size = this.baseSize;
                    }
                    
                    // ç‹¬è‡ªè‰²å½©ã®ç¢ºç«‹ï¼ˆå®‰å…¨æ€§ãƒã‚§ãƒƒã‚¯ä»˜ãï¼‰- ã‚ˆã‚Šé®®ã‚„ã‹ã«
                    if (isFinite(this.originalHue) && isFinite(this.personalDirection)) {
                        this.currentHue = this.originalHue + (Math.sin(this.personalDirection) * 90); // è‰²ç›¸å¤‰åŒ–æ‹¡å¤§
                        this.saturation = 70 + (this.autonomy * 25); // å½©åº¦å‘ä¸Š
                        this.lightness = 65 + (Math.sin(this.vibrationPhase) * 30); // æ˜åº¦å¤‰åŒ–æ‹¡å¤§
                        this.glow = this.autonomy * 1.2; // ã‚°ãƒ­ãƒ¼åŠ¹æœå¼·åŒ–
                    } else {
                        this.currentHue = this.originalHue || Math.random() * 360;
                        this.saturation = 75;
                        this.lightness = 70;
                        this.glow = 0.7;
                    }
                    
                    // å¤šæ§˜ãªå½¢çŠ¶ï¼ˆå®‰å…¨æ€§ãƒã‚§ãƒƒã‚¯ä»˜ãï¼‰
                    if (isFinite(this.personalDirection) && isFinite(this.vibrationPhase)) {
                        const uniqueShape = Math.sin(this.personalDirection * 2 + this.vibrationPhase);
                        if (uniqueShape > 0.6) this.shape = 'triangle';
                        else if (uniqueShape > 0.2) this.shape = 'square';
                        else if (uniqueShape > -0.2) this.shape = 'circle';
                        else this.shape = 'ellipse';
                    } else {
                        this.shape = 'circle';
                    }

                    // æ‘©æ“¦ã®è»½æ¸›ï¼ˆè‡ªå¾‹æ€§ãŒé«˜ã„ã»ã©æ…£æ€§ã‚’ä¿æŒï¼‰
                    const frictionReduction = 1 - (this.autonomy * 0.3);
                    this.vx *= (0.985 + (this.autonomy * 0.01)); // æ‘©æ“¦è»½æ¸›
                    this.vy *= (0.985 + (this.autonomy * 0.01)); // æ‘©æ“¦è»½æ¸›

                    // é€Ÿåº¦åˆ¶é™ï¼ˆç™ºæ•£é˜²æ­¢ï¼‰- ä¸Šé™ç·©å’Œ
                    const maxVelocity = 2.5 + (this.autonomy * 2.5); // è‡ªå¾‹æ€§ã«å¿œã˜ã¦æœ€å¤§é€Ÿåº¦å‘ä¸Šï¼ˆ2.5-5.0ã®ç¯„å›²ï¼‰
                    this.vx = Math.max(-maxVelocity, Math.min(maxVelocity, this.vx || 0));
                    this.vy = Math.max(-maxVelocity, Math.min(maxVelocity, this.vy || 0));
                    
                } catch (error) {
                    console.error('updateCreativeScattering error:', error);
                    // ã‚¨ãƒ©ãƒ¼æ™‚ã¯å®‰å…¨ãªå€¤ã«ãƒªã‚»ãƒƒãƒˆ
                    this.autonomy = 0.3;
                    this.size = this.baseSize;
                    this.shape = 'circle';
                    this.vx = (this.vx || 0) * 0.5;
                    this.vy = (this.vy || 0) * 0.5;
                    this.hasInitialDispersed = false;
                    this.personalDirection = Math.random() * Math.PI * 2;
                }
            }

            updateCosmicDance(mouseX, mouseY, particles) {
                // æ¥ç¶šãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³åˆ¶å¾¡ã®åˆæœŸåŒ–
                if (this.connectionFadeStartTime === null) {
                    this.connectionFadeStartTime = Date.now();
                    this.connectionFadeOpacity = 0.0;
                }
                
                // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é€²è¡Œåº¦ã®è¨ˆç®—
                const currentTime = Date.now();
                const timeSinceStageStart = currentTime - this.connectionFadeStartTime;
                
                if (timeSinceStageStart >= this.connectionFadeDelay) {
                    // é…å»¶æœŸé–“çµŒéå¾Œã€ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é–‹å§‹
                    const fadeProgress = Math.min(1.0, (timeSinceStageStart - this.connectionFadeDelay) / this.connectionFadeDuration);
                    this.connectionFadeOpacity = fadeProgress;
                } else {
                    // ã¾ã é…å»¶æœŸé–“ä¸­
                    this.connectionFadeOpacity = 0.0;
                }
                
                // ç›¸äº’ä½œç”¨ã®æº–å‚™
                this.connections = [];
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é–“ç›¸äº’ä½œç”¨ï¼ˆå‹•çš„ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å½¢æˆï¼‰
                particles.forEach(other => {
                    if (other === this) return;
                    
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // é©åº¦ãªè·é›¢ã‚’ä¿ã¤ãŸã‚ã®åç™ºåŠ›ï¼ˆè‡ªå¾‹æ€§ã®ç¶­æŒï¼‰
                    const minDistance = 40; // æœ€å°è·é›¢ï¼ˆå€‹äººç©ºé–“ã®ç¢ºä¿ï¼‰
                    if (distance < minDistance && distance > 0) {
                        const repulsionForce = 0.002 * (1 - distance / minDistance);
                        this.vx -= (dx / distance) * repulsionForce;
                        this.vy -= (dy / distance) * repulsionForce;
                    }
                    
                    // ä¸­è·é›¢ã§ã®å‹•çš„ãªæ¥ç¶šï¼ˆèª¿å’Œçš„ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼‰
                    const optimalDistance = 80; // æœ€é©ãªæ¥ç¶šè·é›¢
                    const maxConnectionDistance = 120; // æœ€å¤§æ¥ç¶šè·é›¢
                    
                    if (distance < maxConnectionDistance && distance > minDistance) {
                        // æ¥ç¶šã®è¨˜éŒ²ï¼ˆæç”»ç”¨ï¼‰
                        this.connections.push({
                            particle: other,
                            strength: Math.max(0, 1 - distance / maxConnectionDistance)
                        });
                        
                        // æœ€é©è·é›¢ã¸ã®ç©ã‚„ã‹ãªèª¿æ•´åŠ›
                        if (distance < optimalDistance) {
                            // å°‘ã—é›¢ã‚Œã‚‹æ–¹å‘ã¸
                            const adjustForce = 0.0003 * (1 - distance / optimalDistance);
                            this.vx -= (dx / distance) * adjustForce;
                            this.vy -= (dy / distance) * adjustForce;
                        } else {
                            // å°‘ã—è¿‘ã¥ãæ–¹å‘ã¸ï¼ˆå¼±ã„å¼•åŠ›ï¼‰
                            const harmonyForce = 0.0004 * (1 - distance / maxConnectionDistance);
                            this.vx += (dx / distance) * harmonyForce;
                            this.vy += (dy / distance) * harmonyForce;
                        }
                    }
                });

                // æœ€å¤§è‡ªå¾‹æ€§
                this.autonomy = Math.min(1.0, this.autonomy + 0.002);
                
                // ç‹¬è‡ªè»Œé“ã®ç¶­æŒï¼ˆå€‹æ€§ã®è¡¨ç¾ï¼‰
                this.personalDirection += 0.008 + (Math.sin(Date.now() * 0.001 + this.originalHue) * 0.008);
                const selfForce = 0.003; // è‡ªå¾‹æ€§ã‚’å¼·åŒ–
                this.vx += Math.cos(this.personalDirection) * selfForce;
                this.vy += Math.sin(this.personalDirection) * selfForce;
                
                // å€‹äººçš„ãªæŒ¯å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆç‹¬è‡ªæ€§ã®ç¶­æŒï¼‰ - æ–¹å‘æ€§ã‚’å‡ç­‰ã«åˆ†æ•£
                const personalOscillationX = 0.001 * Math.sin(Date.now() * 0.002 + this.originalHue * 0.1);
                const personalOscillationY = 0.001 * Math.sin(Date.now() * 0.002 + this.originalHue * 0.1 + Math.PI * 0.5);
                this.vx += personalOscillationX;
                this.vy += personalOscillationY;
                
                // ä¸­å¿ƒã¸ã®å¾©å¸°åŠ›ï¼ˆç”»é¢å…¨ä½“ã®å‡ç­‰ãªåˆ†å¸ƒã‚’ä¿ƒé€²ï¼‰
                const canvas = document.getElementById('journey-canvas');
                if (canvas) {
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const toCenterX = centerX - this.x;
                    const toCenterY = centerY - this.y;
                    const distanceToCenter = Math.sqrt(toCenterX * toCenterX + toCenterY * toCenterY);
                    
                    // ä¸­å¿ƒã‹ã‚‰é ã™ãã‚‹å ´åˆã€éå¸¸ã«å¼±ã„å¾©å¸°åŠ›ã‚’é©ç”¨
                    const maxRadius = Math.min(canvas.width, canvas.height) * 0.4;
                    if (distanceToCenter > maxRadius) {
                        const returnForce = 0.0002 * (distanceToCenter - maxRadius) / maxRadius;
                        this.vx += (toCenterX / distanceToCenter) * returnForce;
                        this.vy += (toCenterY / distanceToCenter) * returnForce;
                    }
                }

                // èª¿å’Œçš„ãªè„ˆå‹•
                this.vibrationPhase += this.personalFrequency * 1.5;
                this.size = this.baseSize + Math.sin(this.vibrationPhase) * 0.8;
                
                // æˆç†Ÿã—ãŸå€‹æ€§çš„ãªè‰²å½©ï¼ˆå¤šæ§˜æ€§ã®è¡¨ç¾ï¼‰
                const individualityFactor = Math.sin(this.vibrationPhase * 0.3 + this.originalHue * 0.05);
                this.currentHue = this.originalHue + (individualityFactor * 40); // ã‚ˆã‚Šåºƒã„è‰²å½©ç¯„å›²
                this.saturation = 75 + (Math.sin(this.vibrationPhase * 0.7) * 15); // å½©åº¦ã®å¤‰å‹•
                this.lightness = 75 + (Math.sin(this.vibrationPhase * 0.5) * 15); // æ˜åº¦ã®å¤‰å‹•
                this.glow = 0.4 + (Math.sin(this.vibrationPhase * 0.3) * 0.4); // ã‚ˆã‚Šå‹•çš„ãªè¼ã
                
                // å‰µé€ çš„ãªå½¢çŠ¶å¤‰åŒ–ï¼ˆå‰µé€ çš„æ•£ä¹±ã¨åŒæ§˜ã®ã‚­ãƒ©ã‚­ãƒ©åŠ¹æœï¼‰
                if (isFinite(this.personalDirection) && isFinite(this.vibrationPhase)) {
                    const harmonicShape = Math.sin(this.personalDirection * 1.5 + this.vibrationPhase * 0.8);
                    const dynamicShape = Math.cos(this.vibrationPhase * 1.2 + this.originalHue * 0.1);
                    
                    // ã‚ˆã‚Šæ´—ç·´ã•ã‚ŒãŸå½¢çŠ¶å¤‰åŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³
                    if (harmonicShape > 0.7) {
                        this.shape = 'triangle';
                    } else if (harmonicShape > 0.3) {
                        this.shape = 'square';
                    } else if (dynamicShape > 0.4) {
                        this.shape = 'ellipse';
                    } else {
                        this.shape = 'circle';
                    }
                } else {
                    this.shape = 'circle';
                }
            }

            handleBoundaries() {
                const canvas = document.getElementById('journey-canvas');
                if (!canvas) return;
                
                const margin = this.size + 10;
                
                // å¢ƒç•Œã§ã®åç™ºã‚’å¼·åŒ–ã—ã€åã‚Šã‚’é˜²ã
                if (this.x < margin) {
                    this.x = margin;
                    this.vx = Math.abs(this.vx) * 0.9; // åç™ºåŠ›ã‚’å¼·åŒ–
                    // è»½å¾®ãªä¸Šä¸‹ã®ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ ã‚’è¿½åŠ 
                    this.vy += (Math.random() - 0.5) * 0.1;
                }
                if (this.x > canvas.width - margin) {
                    this.x = canvas.width - margin;
                    this.vx = -Math.abs(this.vx) * 0.9; // åç™ºåŠ›ã‚’å¼·åŒ–
                    // è»½å¾®ãªä¸Šä¸‹ã®ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ ã‚’è¿½åŠ 
                    this.vy += (Math.random() - 0.5) * 0.1;
                }
                if (this.y < margin) {
                    this.y = margin;
                    this.vy = Math.abs(this.vy) * 0.9; // åç™ºåŠ›ã‚’å¼·åŒ–
                    // è»½å¾®ãªå·¦å³ã®ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ ã‚’è¿½åŠ 
                    this.vx += (Math.random() - 0.5) * 0.1;
                }
                if (this.y > canvas.height - margin) {
                    this.y = canvas.height - margin;
                    this.vy = -Math.abs(this.vy) * 0.9; // åç™ºåŠ›ã‚’å¼·åŒ–
                    // è»½å¾®ãªå·¦å³ã®ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ ã‚’è¿½åŠ 
                    this.vx += (Math.random() - 0.5) * 0.1;
                }
            }

            draw(ctx, stage) {
                // è»Œè·¡æç”»
                if (stage >= 1) {
                    this.drawTrail(ctx, stage);
                }
                
                // ã‚°ãƒ­ãƒ¼åŠ¹æœ
                if (this.glow > 0 && stage >= 2) {
                    this.drawGlow(ctx);
                }
                
                // ãƒ¡ã‚¤ãƒ³ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
                this.drawParticle(ctx);
                
                // æ¥ç¶šç·šï¼ˆæœ€çµ‚æ®µéšã®ã¿ï¼‰
                if (stage === 3) {
                    this.drawConnections(ctx);
                }
            }

            drawTrail(ctx, stage) {
                if (this.trail.length < 2) return;
                
                ctx.save();
                
                switch(stage) {
                    case 0:
                        ctx.strokeStyle = `hsla(${this.currentHue}, 30%, 50%, 0.2)`;
                        ctx.lineWidth = 1;
                        break;
                    case 1:
                        ctx.strokeStyle = `hsla(${this.currentHue}, 50%, 60%, 0.3)`;
                        ctx.lineWidth = 1.5;
                        break;
                    case 2:
                        ctx.strokeStyle = `hsla(${this.currentHue}, 70%, 70%, 0.5)`;
                        ctx.lineWidth = 2;
                        break;
                    case 3:
                        const gradient = ctx.createLinearGradient(
                            this.trail[0].x, this.trail[0].y,
                            this.x, this.y
                        );
                        gradient.addColorStop(0, `hsla(${this.currentHue}, 80%, 80%, 0)`);
                        gradient.addColorStop(1, `hsla(${this.currentHue}, 80%, 80%, 0.6)`);
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 3;
                        break;
                }
                
                ctx.beginPath();
                for (let i = 1; i < this.trail.length; i++) {
                    const point = this.trail[i];
                    ctx.globalAlpha = point.life * 0.5;
                    
                    if (i === 1) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                }
                ctx.stroke();
                ctx.restore();
            }

            drawGlow(ctx) {
                ctx.save();
                
                // Stage 3ã§ã¯ç‰¹ã«å¼·ã„ã‚°ãƒ­ãƒ¼åŠ¹æœã‚’é©ç”¨
                const stage = journeyCurrentStage;
                const glowIntensity = stage === 3 ? this.glow * 0.4 : this.glow * 0.2;
                const glowMultiplier = stage === 3 ? 2.5 : 1.5;
                
                ctx.globalAlpha = glowIntensity;
                const glowSize = this.size * (1.5 + this.glow * glowMultiplier);
                
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, glowSize
                );
                
                // Stage 3ã§ã¯å¤šå±¤ã‚°ãƒ­ãƒ¼åŠ¹æœ
                if (stage === 3) {
                    gradient.addColorStop(0, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 20}%, 0.6)`);
                    gradient.addColorStop(0.3, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 15}%, 0.3)`);
                    gradient.addColorStop(0.7, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 10}%, 0.1)`);
                    gradient.addColorStop(1, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 15}%, 0)`);
                } else {
                    gradient.addColorStop(0, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 15}%, 0.4)`);
                    gradient.addColorStop(1, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 15}%, 0)`);
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            drawParticle(ctx) {
                try {
                    ctx.save();
                    ctx.globalAlpha = 1.0;
                    
                    // å€¤ã®å®‰å…¨æ€§ãƒã‚§ãƒƒã‚¯
                    const hue = isFinite(this.currentHue) ? this.currentHue % 360 : 0;
                    const sat = Math.max(0, Math.min(100, this.saturation || 50));
                    const light = Math.max(0, Math.min(100, this.lightness || 50));
                    const size = Math.max(0.5, Math.min(20, this.size || 2));
                    const rotationAngle = isFinite(this.vibrationPhase) ? this.vibrationPhase : 0;
                    
                    // ä½ç½®ã®å®‰å…¨æ€§ãƒã‚§ãƒƒã‚¯
                    const x = isFinite(this.x) ? this.x : 0;
                    const y = isFinite(this.y) ? this.y : 0;
                    
                    // Stage 3ã§ã¯ç‰¹åˆ¥ãªã‚­ãƒ©ã‚­ãƒ©åŠ¹æœã‚’è¿½åŠ 
                    const stage = journeyCurrentStage;
                    const sparkleIntensity = stage === 3 ? this.glow * 0.8 : 0;
                    
                    ctx.fillStyle = `hsl(${hue}, ${sat}%, ${light}%)`;
                    ctx.strokeStyle = `hsl(${hue}, ${sat}%, ${Math.max(20, light - 20)}%)`;
                    ctx.lineWidth = stage === 3 ? 1.0 : 0.5; // Stage 3ã§ã¯è¼ªéƒ­ã‚’å¼·åŒ–
                    
                    ctx.translate(x, y);
                    ctx.rotate(rotationAngle);
                    
                    // Stage 3ã§ã¯è¿½åŠ ã®ã‚­ãƒ©ã‚­ãƒ©ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    if (stage === 3 && sparkleIntensity > 0.3) {
                        this.drawSparkles(ctx, size, hue, sat, light);
                    }
                    
                    ctx.beginPath();
                    switch(this.shape) {
                        case 'circle':
                            ctx.arc(0, 0, size, 0, Math.PI * 2);
                            break;
                        case 'ellipse':
                            ctx.scale(1, 0.6);
                            ctx.arc(0, 0, size, 0, Math.PI * 2);
                            break;
                        case 'triangle':
                            ctx.moveTo(0, -size);
                            ctx.lineTo(-size * 0.866, size * 0.5);
                            ctx.lineTo(size * 0.866, size * 0.5);
                            ctx.closePath();
                            break;
                        case 'square':
                            ctx.rect(-size * 0.7, -size * 0.7, size * 1.4, size * 1.4);
                            break;
                        default:
                            // ä¸æ˜ãªå½¢çŠ¶ã®å ´åˆã¯å††ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                            ctx.arc(0, 0, size, 0, Math.PI * 2);
                            break;
                    }
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.restore();
                } catch (error) {
                    console.error('drawParticle error:', error);
                    // ã‚¨ãƒ©ãƒ¼æ™‚ã¯æœ€å°é™ã®æç”»
                    try {
                        ctx.save();
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(this.x || 0, this.y || 0, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    } catch (fallbackError) {
                        console.error('Fallback drawing also failed:', fallbackError);
                    }
                }
            }

            drawConnections(ctx) {
                if (this.connections.length === 0 || this.connectionFadeOpacity <= 0) return;
                
                ctx.save();
                this.connections.forEach((connection, index) => {
                    if (Date.now() % 2 === 0 && index % 2 === 1) return;
                    
                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é€æ˜åº¦ã‚’é©ç”¨
                    const baseOpacity = Math.min(0.6, connection.strength * 0.5);
                    ctx.globalAlpha = baseOpacity * this.connectionFadeOpacity;
                    
                    const avgHue = (this.currentHue + connection.particle.currentHue) / 2;
                    ctx.strokeStyle = `hsl(${avgHue % 360}, 60%, 70%)`;
                    ctx.lineWidth = Math.max(0.5, connection.strength * 2);
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(connection.particle.x, connection.particle.y);
                    ctx.stroke();
                });
                ctx.restore();
            }
            
            drawSparkles(ctx, size, hue, sat, light) {
                // ã‚­ãƒ©ã‚­ãƒ©ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨ã®å°ã•ãªæ˜ŸçŠ¶ã®å›³å½¢ã‚’æç”»
                ctx.save();
                
                const sparkleCount = 4 + Math.floor(this.glow * 4); // è¼ãã«å¿œã˜ã¦ã‚¹ãƒ‘ãƒ¼ã‚¯ãƒ«æ•°ã‚’èª¿æ•´
                const sparkleRadius = size * 0.3;
                
                for (let i = 0; i < sparkleCount; i++) {
                    const angle = (i / sparkleCount) * Math.PI * 2 + this.vibrationPhase * 0.5;
                    const distance = sparkleRadius + Math.sin(this.vibrationPhase * 2 + i) * sparkleRadius * 0.3;
                    
                    const sparkleX = Math.cos(angle) * distance;
                    const sparkleY = Math.sin(angle) * distance;
                    
                    // ã‚¹ãƒ‘ãƒ¼ã‚¯ãƒ«ã®è‰²ã¯åŸºæœ¬è‰²ã‚ˆã‚Šæ˜ã‚‹ã
                    const sparkleHue = (hue + Math.sin(this.vibrationPhase + i) * 30) % 360;
                    const sparkleBrightness = Math.min(95, light + 20);
                    
                    ctx.globalAlpha = 0.3 + Math.sin(this.vibrationPhase * 3 + i) * 0.3;
                    ctx.fillStyle = `hsl(${sparkleHue}, ${sat}%, ${sparkleBrightness}%)`;
                    
                    // å°ã•ãªæ˜Ÿå½¢ã‚’æç”»
                    const sparkleSize = size * 0.15 * (0.5 + Math.sin(this.vibrationPhase * 2 + i) * 0.5);
                    ctx.beginPath();
                    for (let j = 0; j < 4; j++) {
                        const starAngle = (j / 4) * Math.PI * 2;
                        const x = sparkleX + Math.cos(starAngle) * sparkleSize;
                        const y = sparkleY + Math.sin(starAngle) * sparkleSize;
                        
                        if (j === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // Canvas 2D ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ç®¡ç†
        let journeyCanvas = null;
        let journeyCtx = null;
        let journeyParticles = [];
        let journeyMouseX = 0;
        let journeyMouseY = 0;
        let journeyCurrentStage = 0;
        let journeyAnimationId = null;

        const journeyStageDescriptions = [
            {
                title: "é‡åŠ›ã®æ”¯é…",
                description: "å¤–éƒ¨ã®æ¨©å¨ã«å¾“å±ã—ã¦ã„ã‚‹çŠ¶æ…‹"
            },
            {
                title: "æºã‚‰ãã¨å¢ƒç•ŒçŠ¶æ…‹", 
                description: "å†…ãªã‚‹å£°ã«è€³ã‚’å‚¾ã‘ã€æºã‚‰ããŒç”Ÿã¾ã‚Œã‚‹"
            },
            {
                title: "å‰µé€ çš„ãªæ•£ä¹±",
                description: "å€‹æ€§ãŒèŠ½å¹ãã€è‡ªå¾‹çš„ãªå‹•ãã‚’å§‹ã‚ã‚‹"
            },
            {
                title: "å‰µç™ºçš„ç›¸äº’ä½œç”¨",
                description: "è‡ªå¾‹çš„ãªä¸»ä½“ã®ç›¸äº’ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®å‰µç™º"
            }
        ];

        function initJourneyVisualization() {
            console.log('Canvas 2D ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–é–‹å§‹');
            
            try {
                journeyCanvas = document.getElementById('journey-canvas');
                if (!journeyCanvas) {
                    console.error('Canvasè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    return;
                }
                
                journeyCtx = journeyCanvas.getContext('2d');
                if (!journeyCtx) {
                    console.error('Canvas 2Dã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®å–å¾—ã«å¤±æ•—');
                    return;
                }
                
                initJourneyCanvas();
                createJourneyParticles();
                updateJourneyStageUI();
                updateJourneyButtonStates();
                addJourneyEventListeners();
                startJourneyAnimation();
                
                console.log('Canvas 2D ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–å®Œäº†');
            } catch (error) {
                console.error('Canvas 2D ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
            }
        }

        function cleanupJourneyVisualization() {
            console.log('Canvas 2D ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–‹å§‹');
            
            if (journeyAnimationId) {
                cancelAnimationFrame(journeyAnimationId);
                journeyAnimationId = null;
            }
            
            journeyParticles = [];
            journeyCurrentStage = 0;
            
            removeJourneyEventListeners();
            
            console.log('Canvas 2D ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†');
        }

        function initJourneyCanvas() {
            if (!journeyCanvas) return;
            
            const container = journeyCanvas.parentElement;
            journeyCanvas.width = container.clientWidth;
            journeyCanvas.height = container.clientHeight;
            
            journeyMouseX = journeyCanvas.width / 2;
            journeyMouseY = journeyCanvas.height / 2;
        }

        function createJourneyParticles() {
            journeyParticles = [];
            if (!journeyCanvas) return;
            
            const numParticles = Math.min(100, Math.floor(journeyCanvas.width * journeyCanvas.height / 10000));
            
            for (let i = 0; i < numParticles; i++) {
                journeyParticles.push(new EnhancedParticle(
                    Math.random() * journeyCanvas.width,
                    Math.random() * journeyCanvas.height
                ));
            }
        }

        function updateJourneyPhysicsInfo() {
            const avgAutonomy = journeyParticles.reduce((sum, p) => sum + p.autonomy, 0) / journeyParticles.length;
            const gravityStrength = journeyCurrentStage === 0 ? "å¼·" : journeyCurrentStage === 1 ? "ä¸­" : journeyCurrentStage === 2 ? "å¼±" : "ç„¡";
            
            let harmony = 0;
            if (journeyCurrentStage === 3) {
                // é©åº¦ãªè·é›¢ã‚’ä¿ã£ãŸè³ªã®é«˜ã„æ¥ç¶šã‚’è©•ä¾¡
                let qualityConnections = 0;
                let totalParticles = journeyParticles.length;
                
                journeyParticles.forEach(particle => {
                    particle.connections.forEach(connection => {
                        const dx = connection.particle.x - particle.x;
                        const dy = connection.particle.y - particle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // é©åº¦ãªè·é›¢ï¼ˆ60-100ãƒ”ã‚¯ã‚»ãƒ«ï¼‰ã®æ¥ç¶šã«ã‚ˆã‚Šé«˜ã„ã‚¹ã‚³ã‚¢ã‚’ä¸ãˆã‚‹
                        if (distance >= 60 && distance <= 100) {
                            qualityConnections += connection.strength * 1.5; // è³ªã®é«˜ã„æ¥ç¶šã«é«˜ã„ã‚¹ã‚³ã‚¢
                        } else if (distance >= 40 && distance <= 120) {
                            qualityConnections += connection.strength; // é€šå¸¸ã®ã‚¹ã‚³ã‚¢
                        } else {
                            qualityConnections += connection.strength * 0.5; // è¿‘ã™ãã‚‹/é ã™ãã‚‹æ¥ç¶šã¯ä½ã„ã‚¹ã‚³ã‚¢
                        }
                    });
                });
                
                harmony = Math.min(100, (qualityConnections / totalParticles) * 8);
            }
            
            const physicsInfo = document.getElementById('journey-physicsInfo');
            if (physicsInfo) {
                physicsInfo.innerHTML = 
                    `é‡åŠ›å¼·åº¦: ${gravityStrength}<br>` +
                    `è‡ªå¾‹æ€§: ${Math.round(avgAutonomy * 100)}%<br>` +
                    `èª¿å’Œåº¦: ${Math.round(harmony)}%`;
            }
        }

        function updateJourneyStageUI() {
            const stageInfo = document.getElementById('journey-stageInfo');
            if (stageInfo) {
                const stage = journeyStageDescriptions[journeyCurrentStage];
                stageInfo.innerHTML = `${stage.title}<br><small>${stage.description}</small>`;
            }
            
            // ãƒ‰ãƒƒãƒˆæ›´æ–°
            for (let i = 0; i < 4; i++) {
                const dot = document.getElementById(`journey-dot${i}`);
                if (dot) {
                    dot.classList.toggle('active', i === journeyCurrentStage);
                }
            }
        }

        function updateJourneyButtonStates() {
            const prevButton = document.getElementById('journey-prevButton');
            const nextButton = document.getElementById('journey-nextButton');
            
            if (prevButton) {
                prevButton.disabled = journeyCurrentStage === 0;
                prevButton.style.opacity = journeyCurrentStage === 0 ? '0.5' : '1';
            }
            
            if (nextButton) {
                nextButton.disabled = journeyCurrentStage === 3;
                nextButton.style.opacity = journeyCurrentStage === 3 ? '0.5' : '1';
            }
        }

        function nextJourneyStage() {
            if (journeyCurrentStage < 3) {
                console.log(`Switching from stage ${journeyCurrentStage} to ${journeyCurrentStage + 1}`);
                journeyCurrentStage++;
                updateJourneyStageUI();
                adjustJourneyParticlesForStage();
                updateJourneyButtonStates();
                console.log(`Stage switch completed. Current stage: ${journeyCurrentStage}`);
            }
        }

        function previousJourneyStage() {
            if (journeyCurrentStage > 0) {
                console.log(`Switching from stage ${journeyCurrentStage} to ${journeyCurrentStage - 1}`);
                journeyCurrentStage--;
                updateJourneyStageUI();
                adjustJourneyParticlesForStage();
                updateJourneyButtonStates();
                console.log(`Stage switch completed. Current stage: ${journeyCurrentStage}`);
            }
        }

        function resetJourney() {
            console.log('Resetting journey to stage 0');
            journeyCurrentStage = 0;
            createJourneyParticles();
            updateJourneyStageUI();
            updateJourneyButtonStates();
            console.log('Journey reset completed');
        }

        function toggleInstructions() {
            const instructionsElement = document.getElementById('journey-instructions');
            const detailElement = document.getElementById('instructions-detail');
            const arrowElement = document.getElementById('instructions-arrow');
            
            if (detailElement.classList.contains('show')) {
                // é–‰ã˜ã‚‹
                detailElement.classList.remove('show');
                arrowElement.textContent = 'â–¼';
                console.log('Instructions collapsed');
            } else {
                // é–‹ã
                detailElement.classList.add('show');
                arrowElement.textContent = 'â–²';
                console.log('Instructions expanded');
            }
        }

        function adjustJourneyParticlesForStage() {
            try {
                console.log(`Adjusting particles for stage ${journeyCurrentStage}`);
                if (journeyParticles.length > 0) {
                    journeyParticles.forEach((particle, index) => {
                        const maxVelocity = journeyCurrentStage === 3 ? 2.5 : 2; // Stage 3ã®é€Ÿåº¦åˆ¶é™ã‚’ç·©å’Œ
                        particle.vx = Math.max(-maxVelocity, Math.min(maxVelocity, particle.vx));
                        particle.vy = Math.max(-maxVelocity, Math.min(maxVelocity, particle.vy));
                        
                        particle.size = particle.baseSize;
                        particle.connections = [];
                        
                        if (journeyCurrentStage === 0) {
                            particle.autonomy = 0;
                            // æ¥ç¶šãƒ•ã‚§ãƒ¼ãƒ‰çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
                            particle.connectionFadeStartTime = null;
                            particle.connectionFadeOpacity = 0.0;
                        } else if (journeyCurrentStage === 1) {
                            particle.autonomy = Math.max(0, particle.autonomy);
                            // æ¥ç¶šãƒ•ã‚§ãƒ¼ãƒ‰çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
                            particle.connectionFadeStartTime = null;
                            particle.connectionFadeOpacity = 0.0;
                        } else if (journeyCurrentStage === 2) {
                            particle.autonomy = Math.max(0.1, particle.autonomy);
                            // å‰µé€ çš„æ•£ä¹±ã‚¹ãƒ†ãƒ¼ã‚¸ç§»è¡Œæ™‚ã®åˆæœŸåŒ–
                            particle.hasInitialDispersed = false;
                            particle.initialDispersionTimer = 0;
                            particle.dispersalDirection = Math.random() * Math.PI * 2;
                            particle.dispersalForce = 0.4 + Math.random() * 0.3; // ç©ã‚„ã‹ãªæ‹¡æ•£åŠ›ã«èª¿æ•´
                            // æ¥ç¶šãƒ•ã‚§ãƒ¼ãƒ‰çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
                            particle.connectionFadeStartTime = null;
                            particle.connectionFadeOpacity = 0.0;
                        } else if (journeyCurrentStage === 3) {
                            particle.autonomy = Math.max(0.8, particle.autonomy);
                            
                            // å‰µç™ºçš„ç›¸äº’ä½œç”¨ã‚¹ãƒ†ãƒ¼ã‚¸ç§»è¡Œæ™‚ã®æ¥ç¶šãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³åˆæœŸåŒ–
                            particle.connectionFadeStartTime = null;
                            particle.connectionFadeOpacity = 0.0;
                            
                            // Stage 3ç§»è¡Œæ™‚ã®åˆ†æ•£ä¿ƒé€²
                            const canvas = document.getElementById('journey-canvas');
                            if (canvas) {
                                const centerX = canvas.width / 2;
                                const centerY = canvas.height / 2;
                                const distanceToCenter = Math.sqrt((particle.x - centerX) ** 2 + (particle.y - centerY) ** 2);
                                
                                // ä¸­å¿ƒã«é›†ã¾ã‚Šã™ãã¦ã„ã‚‹å ´åˆã€å¤–å‘ãã®åˆæœŸé€Ÿåº¦ã‚’ä¸ãˆã‚‹
                                if (distanceToCenter < Math.min(canvas.width, canvas.height) * 0.15) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const disperseForce = 0.5 + Math.random() * 1.0;
                                    particle.vx += Math.cos(angle) * disperseForce;
                                    particle.vy += Math.sin(angle) * disperseForce;
                                }
                                
                                // å€‹äººçš„ãªæ–¹å‘æ€§ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«å†è¨­å®šï¼ˆå¤šæ§˜æ€§ã®ç¢ºä¿ï¼‰
                                particle.personalDirection = Math.random() * Math.PI * 2;
                            }
                        }
                        
                        console.log(`Particle ${index} stage set to ${journeyCurrentStage}`);
                    });
                    console.log(`Particle adjustment completed for stage ${journeyCurrentStage}`);
                } else {
                    console.warn('No particles available for stage adjustment');
                }
                
                if (journeyCurrentStage === 0) {
                    createJourneyParticles();
                }
            } catch (error) {
                console.error('Error adjusting particles for stage:', error);
            }
        }

        function startJourneyAnimation() {
            function animate() {
                try {
                    if (!journeyCanvas || !journeyCtx) {
                        console.warn('Canvas or context not available, stopping animation');
                        return;
                    }
                    
                    // èƒŒæ™¯ã‚¯ãƒªã‚¢
                    journeyCtx.clearRect(0, 0, journeyCanvas.width, journeyCanvas.height);
                    journeyCtx.fillStyle = '#0a0a0a';
                    journeyCtx.fillRect(0, 0, journeyCanvas.width, journeyCanvas.height);

                    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°ã¨æç”»ï¼ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä»˜ãï¼‰
                    journeyParticles.forEach((particle, index) => {
                        try {
                            particle.update(journeyCurrentStage, journeyMouseX, journeyMouseY, journeyParticles);
                            particle.draw(journeyCtx, journeyCurrentStage);
                        } catch (error) {
                            console.error(`Particle ${index} error in stage ${journeyCurrentStage}:`, error);
                            // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å€¤ã‚’ãƒªã‚»ãƒƒãƒˆ
                            particle.vx = particle.vx || 0;
                            particle.vy = particle.vy || 0;
                            particle.x = particle.x || journeyCanvas.width / 2;
                            particle.y = particle.y || journeyCanvas.height / 2;
                        }
                    });

                    // ç‰©ç†æƒ…å ±æ›´æ–°
                    updateJourneyPhysicsInfo();

                    journeyAnimationId = requestAnimationFrame(animate);
                } catch (error) {
                    console.error('Animation loop error:', error);
                    console.error('Error occurred at stage:', journeyCurrentStage);
                    console.error('Animation frame ID:', journeyAnimationId);
                    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åœæ­¢
                    if (journeyAnimationId) {
                        cancelAnimationFrame(journeyAnimationId);
                        journeyAnimationId = null;
                        console.log('Animation stopped due to error');
                    }
                }
            }
            
            animate();
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ç®¡ç†
        let journeyEventListeners = [];

        function addJourneyEventListeners() {
            if (!journeyCanvas) return;
            
            const mouseMoveHandler = (e) => {
                const rect = journeyCanvas.getBoundingClientRect();
                journeyMouseX = e.clientX - rect.left;
                journeyMouseY = e.clientY - rect.top;
            };
            
            const touchMoveHandler = (e) => {
                e.preventDefault();
                const rect = journeyCanvas.getBoundingClientRect();
                journeyMouseX = e.touches[0].clientX - rect.left;
                journeyMouseY = e.touches[0].clientY - rect.top;
            };
            
            const resizeHandler = () => {
                initJourneyCanvas();
                createJourneyParticles();
            };
            
            journeyCanvas.addEventListener('mousemove', mouseMoveHandler);
            journeyCanvas.addEventListener('touchmove', touchMoveHandler);
            window.addEventListener('resize', resizeHandler);
            
            journeyEventListeners.push(
                { element: journeyCanvas, event: 'mousemove', handler: mouseMoveHandler },
                { element: journeyCanvas, event: 'touchmove', handler: touchMoveHandler },
                { element: window, event: 'resize', handler: resizeHandler }
            );
        }

        function removeJourneyEventListeners() {
            journeyEventListeners.forEach(({ element, event, handler }) => {
                element.removeEventListener(event, handler);
            });
            journeyEventListeners = [];
        }

        // Stage click handling for dynamic linking
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—3Dçµ±åˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
            
            // Test toggleSection function availability
            if (typeof toggleSection === 'function') {
                console.log('toggleSection function is available');
                
                // Test with buttons
                const toggleButtons = document.querySelectorAll('button[onclick*="toggleSection"]');
                console.log('Found toggle buttons:', toggleButtons.length);
                
                toggleButtons.forEach((button, index) => {
                    console.log(`Button ${index}:`, button.textContent.trim());
                    button.addEventListener('click', (e) => {
                        console.log('Button clicked:', button.textContent.trim());
                    });
                });
            } else {
                console.error('toggleSection function is NOT available');
            }
            
            // Test DOM elements
            const detailedJourney = document.getElementById('detailed-journey');
            const refinedPhases = document.getElementById('refined-phases');
            
            console.log('detailed-journey element:', detailedJourney);
            console.log('refined-phases element:', refinedPhases);
            
            // Add click handlers to stage headings in text for dynamic linking
            setTimeout(() => {
                const stageHeadings = document.querySelectorAll('.sub-phase h4');
                stageHeadings.forEach(heading => {
                    const text = heading.textContent;
                    const stageMatch = text.match(/^(Ea|Eb|Ec|E\(I\)|E-I|I-E|I\(E\)|Ia|Ib|Ic):/);
                    if (stageMatch) {
                        let stageId = stageMatch[1];
                        // Convert special cases
                        if (stageId === 'E(I)') stageId = 'EI';
                        if (stageId === 'I(E)') stageId = 'IE';
                        
                        heading.style.cursor = 'pointer';
                        heading.style.transition = 'color 0.3s';
                        heading.style.color = '#667eea';
                        
                        heading.addEventListener('click', () => {
                            if (refinedVisualization && refinedVisualization.isInitialized) {
                                refinedVisualization.switchToStage(stageId);
                                
                                // Scroll to 3D area
                                const container = document.getElementById('refined-3d-container');
                                if (container) {
                                    container.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            }
                        });
                        
                        heading.addEventListener('mouseenter', () => {
                            heading.style.color = '#764ba2';
                        });
                        
                        heading.addEventListener('mouseleave', () => {
                            heading.style.color = '#667eea';
                        });
                    }
                });
            }, 1000);
        });
        
        // ã‚¸ãƒ£ãƒ¼ãƒ‹ãƒ¼ãƒãƒƒãƒ—é–‹é–‰æ©Ÿèƒ½
        function toggleJourneyMap() {
            const container = document.getElementById('journey-map-container');
            const icon = document.getElementById('journey-toggle-icon');
            
            if (container.style.display === 'none') {
                // é–‹ã
                container.style.display = 'block';
                icon.classList.add('rotated');
                icon.textContent = 'â–²';
                
                // iframe ã®ã‚µã‚¤ã‚ºèª¿æ•´
                adjustIframeHeight();
            } else {
                // é–‰ã˜ã‚‹
                container.style.display = 'none';
                icon.classList.remove('rotated');
                icon.textContent = 'â–¼';
            }
        }
        
        // ãƒ•ãƒ¬ãƒ¼ã‚ºã‚¯ãƒ©ã‚¦ãƒ‰é–‹é–‰æ©Ÿèƒ½
        function togglePhrasesCloud() {
            const container = document.getElementById('phrases-cloud-container');
            const icon = document.getElementById('phrases-toggle-icon');
            
            if (container.style.display === 'none') {
                // é–‹ã
                container.style.display = 'block';
                icon.classList.add('rotated');
                icon.textContent = 'â–²';
            } else {
                // é–‰ã˜ã‚‹
                container.style.display = 'none';
                icon.classList.remove('rotated');
                icon.textContent = 'â–¼';
            }
        }
        
        // iframe ã®å‹•çš„é«˜ã•èª¿æ•´ï¼ˆUXæœ€é©åŒ–ç‰ˆï¼‰
        let lastIframeHeight = 800; // åˆæœŸå€¤ã‚’ã‚°ãƒ©ãƒ•ãŒè¦‹ãˆã‚‹é«˜ã•ã«
        let heightAdjustmentSetup = false;
        
        function adjustIframeHeight() {
            if (heightAdjustmentSetup) return; // é‡è¤‡ãƒªã‚¹ãƒŠãƒ¼é˜²æ­¢
            heightAdjustmentSetup = true;
            
            const iframe = document.getElementById('journey-map-iframe');
            
            // PostMessage ã§iframeå†…ã®é«˜ã•ã‚’å—ä¿¡
            window.addEventListener('message', function(event) {
                if (event.data.type === 'IFRAME_HEIGHT_CHANGE' && iframe) {
                    let newHeight = event.data.height + 20; // ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’æœ€å°é™ã«
                    
                    // ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œï¼šç”»é¢ã‚µã‚¤ã‚ºã«å¿œã˜ãŸåˆ¶é™
                    const viewportHeight = window.innerHeight;
                    const maxAllowedHeight = Math.min(viewportHeight * 0.85, 1600);
                    
                    // æœ€å°é«˜ã•ã‚’800pxã€æœ€å¤§é«˜ã•ã‚’åˆ¶é™
                    newHeight = Math.max(800, Math.min(newHeight, maxAllowedHeight));
                    
                    // é«˜ã•ã®å¤‰åŒ–ãŒæœ€å°é™ã®å ´åˆã¯èª¿æ•´ã—ãªã„
                    if (Math.abs(newHeight - lastIframeHeight) < 5) {
                        return;
                    }
                    
                    lastIframeHeight = newHeight;
                    
                    // ã‚¹ãƒ ãƒ¼ã‚ºãªãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³
                    iframe.style.transition = 'height 0.3s ease-out';
                    iframe.style.height = newHeight + 'px';
                    
                    console.log('iframeé«˜ã•æœ€é©åŒ–:', {
                        received: event.data.height,
                        applied: newHeight,
                        viewport: viewportHeight
                    });
                    
                    // ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³çµ‚äº†å¾Œã«transitionã‚’å‰Šé™¤
                    setTimeout(() => {
                        iframe.style.transition = '';
                    }, 300);
                }
            });
        }
        
        // ã‚¢ã‚¤ãƒ‡ã‚¢ç‹¬ã‚Šè¨€ãƒ„ãƒ¼ãƒ«æ©Ÿèƒ½
        function openIdeaFeedbackTool() {
            // ãƒ¢ãƒ¼ãƒ€ãƒ«ã®ä½œæˆ
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 10000;
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 20px;
                box-sizing: border-box;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 12px;
                width: 100%;
                max-width: 800px;
                max-height: 90vh;
                overflow-y: auto;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            `;
            
            modalContent.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="margin: 0; color: #667eea;">ğŸ’­ ã‚¢ã‚¤ãƒ‡ã‚¢ç‹¬ã‚Šè¨€ãƒ„ãƒ¼ãƒ«</h2>
                    <button onclick="this.closest('.idea-feedback-modal').remove()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #999;">Ã—</button>
                </div>
                
                <p style="margin-bottom: 15px; color: #666; font-size: 16px; line-height: 1.6;">
                    <strong>ğŸ¯ ã“ã®ãƒ„ãƒ¼ãƒ«ã®ç›®çš„</strong><br>
                    ç¾åœ¨æ¤œè¨ä¸­ã®ã‚¢ã‚¤ãƒ‡ã‚¢ã«ã¤ã„ã¦ã€ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®è¦³ç‚¹ã‹ã‚‰ç”ŸæˆAIã«ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’ã‚‚ã‚‰ã†ãŸã‚ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç”Ÿæˆã—ã¾ã™ã€‚
                </p>
                
                <div style="background: #e8f4f8; border-left: 4px solid #2196f3; padding: 15px; margin-bottom: 15px; border-radius: 4px;">
                    <p style="margin: 0; color: #1976d2; font-weight: 500;">
                        ğŸ’¡ <strong>åŠ¹æœçš„ãªæ´»ç”¨æ–¹æ³•</strong><br>
                        æœ€çµ‚çš„ã«ç”ŸæˆAIã«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ›ã™ã‚‹éš›ã¯ã€ä½œæˆä¸­ã®ä¼ç”»æ›¸ãƒ»ææ¡ˆæ›¸ã‚‚æ·»ä»˜ã—ã¦å®Ÿè¡Œã™ã‚‹ã¨ã‚ˆã‚ŠåŠ¹æœçš„ã§ã™ã€‚
                    </p>
                </div>
                
                <div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin-bottom: 20px; border-radius: 4px;">
                    <p style="margin: 0; color: #856404; font-weight: 500;">
                        âš ï¸ <strong>é‡è¦ãªæ³¨æ„äº‹é …</strong><br>
                        â€¢ ç”ŸæˆAIã®åˆ©ç”¨ã«ã‚ãŸã£ã¦ã¯ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ã‚„æ©Ÿå¯†æƒ…å ±ã«ååˆ†æ³¨æ„ã—ã¦ãã ã•ã„<br>
                        â€¢ ä¼ç”»æ›¸ã«å¯¾ã™ã‚‹ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’ã‚‚ã‚‰ã†å ´åˆã¯ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®è¦³ç‚¹ã‹ã‚‰<strong>Microsoft Copilot</strong>ã‚’åˆ©ç”¨ã—ã¦ãã ã•ã„<br>
                        â€¢ <strong>GPT-5ã‚’ã‚ªãƒ³ã«ã—ãŸä¸Šã§å®Ÿè¡Œ</strong>ã—ã¦ãã ã•ã„
                    </p>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #333;">
                        ã‚¢ã‚¤ãƒ‡ã‚¢ãƒ»ä¼ç”»ã®æ¦‚è¦
                    </label>
                    <textarea id="ideaContent" 
                        placeholder="æ¤œè¨ä¸­ã®ã‚¢ã‚¤ãƒ‡ã‚¢ã‚„ä¼ç”»ã®å†…å®¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚&#10;- èƒŒæ™¯ãƒ»ç›®çš„&#10;- å…·ä½“çš„ãªå†…å®¹&#10;- å¯¾è±¡è€…&#10;- æœŸå¾…ã™ã‚‹åŠ¹æœãªã©"
                        style="width: 100%; height: 200px; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-family: inherit; resize: vertical; box-sizing: border-box;"></textarea>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #333;">
                        ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã®è¦³ç‚¹ï¼ˆè¤‡æ•°é¸æŠå¯ï¼‰
                    </label>
                    <div style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 10px;">
                        <label style="display: flex; align-items: center;">
                            <input type="checkbox" id="recognizing" value="recognizing" checked style="margin-right: 8px;">
                            èªè­˜è«–çš„æ¬¡å…ƒï¼šç§ã¯ã©ã®ã‚ˆã†ã«çŸ¥ã‚‹ã®ã‹ï¼Ÿ
                        </label>
                        <label style="display: flex; align-items: center;">
                            <input type="checkbox" id="intrapersonal" value="intrapersonal" checked style="margin-right: 8px;">
                            å¯¾è‡ªé–¢ä¿‚æ¬¡å…ƒï¼šç§ã¯ä½•è€…ã‹ï¼Ÿ
                        </label>
                        <label style="display: flex; align-items: center;">
                            <input type="checkbox" id="interpersonal" value="interpersonal" checked style="margin-right: 8px;">
                            å¯¾äººé–¢ä¿‚æ¬¡å…ƒï¼šä»–è€…ã¨ã©ã®ã‚ˆã†ã«é–¢ã‚ã‚‹ã‹ï¼Ÿ
                        </label>
                        <label style="display: flex; align-items: center;">
                            <input type="checkbox" id="phases" value="phases" checked style="margin-right: 8px;">
                            æˆé•·æ®µéšã®è€ƒæ…®
                        </label>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #333;">
                        ç‰¹ã«é‡è¦–ã—ãŸã„ç‚¹
                    </label>
                    <div style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 10px;">
                        <label style="display: flex; align-items: center;">
                            <input type="radio" name="focusArea" value="balanced" checked style="margin-right: 8px;">
                            ãƒãƒ©ãƒ³ã‚¹ã®å–ã‚ŒãŸç·åˆçš„ãªè©•ä¾¡
                        </label>
                        <label style="display: flex; align-items: center;">
                            <input type="radio" name="focusArea" value="theory" style="margin-right: 8px;">
                            ç†å¿µãƒ»ç†è«–é¢ã®æ·±ã„æ¤œè¨
                        </label>
                        <label style="display: flex; align-items: center;">
                            <input type="radio" name="focusArea" value="practice" style="margin-right: 8px;">
                            å®Ÿè·µãƒ»å®Ÿè£…é¢ã®å…·ä½“çš„æ¤œè¨
                        </label>
                        <label style="display: flex; align-items: center;">
                            <input type="radio" name="focusArea" value="student-centered" style="margin-right: 8px;">
                            å­¦ç”Ÿã®ä¸»ä½“æ€§ã¨æˆé•·
                        </label>
                    </div>
                </div>
                
                <div style="text-align: center; margin-top: 30px;">
                    <button onclick="generateFeedbackPrompt()" 
                        style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; padding: 12px 30px; border-radius: 8px; font-size: 16px; cursor: pointer; margin-right: 10px;">
                        ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç”Ÿæˆ
                    </button>
                    <button onclick="this.closest('.idea-feedback-modal').remove()" 
                        style="background: #ccc; color: #333; border: none; padding: 12px 30px; border-radius: 8px; font-size: 16px; cursor: pointer;">
                        é–‰ã˜ã‚‹
                    </button>
                </div>
                
                <div id="generatedPrompt" style="margin-top: 30px; display: none;">
                    <div id="completionMessage" style="background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px; padding: 15px; margin-bottom: 20px; display: none;">
                        <h4 style="color: #155724; margin: 0 0 10px 0; display: flex; align-items: center;">
                            âœ… ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç”Ÿæˆå®Œäº†ï¼
                        </h4>
                        <p style="color: #155724; margin: 0 0 10px 0; font-weight: 500;">
                            ä»¥ä¸‹ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ç”ŸæˆAIã«æŠ•å…¥ã—ã¦ãã ã•ã„
                        </p>
                        <div style="background: #ffff66; border: 1px solid #f5c6cb; border-radius: 6px; padding: 12px; margin-top: 10px;">
                            <p style="color: #721c24; margin: 0; font-size: 14px; font-weight: 500;">
                                âš ï¸ <strong>ç”ŸæˆAIæŠ•å…¥æ™‚ã®é‡è¦ãªæ³¨æ„ç‚¹</strong><br>
                                â€¢ <strong>Microsoft Copilot</strong>ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç¢ºä¿ã®ãŸã‚ï¼‰<br>
                                â€¢ <strong>GPT-5ã‚’ã‚ªãƒ³ã«ã—ã¦å®Ÿè¡Œ</strong>ã—ã¦ãã ã•ã„<br>
                                â€¢ ä¼ç”»æ›¸ãƒ»ææ¡ˆæ›¸ãŒã‚ã‚Œã°ä¸€ç·’ã«æ·»ä»˜ã™ã‚‹ã¨åŠ¹æœçš„ã§ã™<br>
                                â€¢ ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ã‚„æ©Ÿå¯†æƒ…å ±ã«ã”æ³¨æ„ãã ã•ã„
                            </p>
                        </div>
                    </div>
                    
                    <h3 style="color: #667eea; margin-bottom: 15px;">ç”Ÿæˆã•ã‚ŒãŸãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ</h3>
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 5px solid #667eea;">
                        <textarea id="promptOutput" readonly 
                            style="width: 100%; height: 300px; border: none; background: transparent; font-family: monospace; font-size: 14px; resize: vertical; box-sizing: border-box;"></textarea>
                    </div>
                    <button onclick="copyPromptToClipboard()" 
                        style="background: linear-gradient(135deg, #51cf66, #006600); color: white; border: none; padding: 10px 20px; border-radius: 6px; margin-top: 10px; cursor: pointer;">
                        ğŸ“‹ ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼
                    </button>
                </div>
            `;
            
            modal.className = 'idea-feedback-modal';
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // ãƒ¢ãƒ¼ãƒ€ãƒ«å¤–ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        function generateFeedbackPrompt() {
            const ideaContent = document.getElementById('ideaContent').value.trim();
            const focusArea = document.querySelector('input[name="focusArea"]:checked').value;
            
            if (!ideaContent) {
                alert('ã‚¢ã‚¤ãƒ‡ã‚¢ãƒ»ä¼ç”»ã®æ¦‚è¦ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
                return;
            }
            
            // ãƒã‚§ãƒƒã‚¯ã•ã‚ŒãŸè¦³ç‚¹ã‚’å–å¾—
            const selectedAspects = [];
            if (document.getElementById('recognizing').checked) selectedAspects.push('èªè­˜è«–çš„æ¬¡å…ƒï¼ˆEpistemologicalï¼‰');
            if (document.getElementById('intrapersonal').checked) selectedAspects.push('å¯¾è‡ªé–¢ä¿‚æ¬¡å…ƒï¼ˆIntrapersonalï¼‰');
            if (document.getElementById('interpersonal').checked) selectedAspects.push('å¯¾äººé–¢ä¿‚æ¬¡å…ƒï¼ˆInterpersonalï¼‰');
            if (document.getElementById('phases').checked) selectedAspects.push('æˆé•·æ®µéšã®è€ƒæ…®');
            
            const focusDescriptions = {
                'balanced': 'ãƒãƒ©ãƒ³ã‚¹ã®å–ã‚ŒãŸç·åˆçš„ãªè©•ä¾¡',
                'theory': 'ç†å¿µãƒ»ç†è«–é¢ã®æ·±ã„æ¤œè¨',
                'practice': 'å®Ÿè·µãƒ»å®Ÿè£…é¢ã®å…·ä½“çš„æ¤œè¨',
                'student-centered': 'å­¦ç”Ÿã®ä¸»ä½“æ€§ã¨æˆé•·',
            };
            
            const prompt = generateDetailedPrompt(ideaContent, selectedAspects, focusDescriptions[focusArea]);
            
            document.getElementById('promptOutput').value = prompt;
            document.getElementById('generatedPrompt').style.display = 'block';
            
            // å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
            document.getElementById('completionMessage').style.display = 'block';
            
            // å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¾ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
            setTimeout(() => {
                document.getElementById('completionMessage').scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'start' 
                });
            }, 100);
        }
        
        function generateDetailedPrompt(ideaContent, aspects, focusArea) {
            return `# ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã‚’é‡è¦–ã—ãŸå­¦ç”Ÿæ”¯æ´ç­–ã®ã‚¢ã‚¤ãƒ‡ã‚¢è©•ä¾¡

ä»¥ä¸‹ã®å­¦ç”Ÿæ”¯æ´ã®ã‚¢ã‚¤ãƒ‡ã‚¢ãƒ»ä¼ç”»ã«ã¤ã„ã¦ã€ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ç†è«–ã®è¦³ç‚¹ã‹ã‚‰å»ºè¨­çš„ãªãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚

## è©•ä¾¡å¯¾è±¡ã®ã‚¢ã‚¤ãƒ‡ã‚¢ãƒ»ä¼ç”»
${ideaContent}

## ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã®è¦³ç‚¹
é‡è¦–ã™ã‚‹è¦³ç‚¹ï¼š${focusArea}
è©•ä¾¡ã™ã‚‹æ¬¡å…ƒï¼š${aspects.join('ã€')}

## ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ç†è«–ã®è¦ç‚¹
ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã¨ã¯ã€Œè‡ªåˆ†è‡ªèº«ã®ä¿¡å¿µã€ä¾¡å€¤è¦³ã€ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã€ç¤¾ä¼šé–¢ä¿‚ã‚’å†…çš„ã«å®šç¾©ã™ã‚‹èƒ½åŠ›ã€ã§ã€ä»¥ä¸‹ã®3ã¤ã®æ¬¡å…ƒãŒã‚ã‚Šã¾ã™ï¼š

1. **èªè­˜è«–çš„æ¬¡å…ƒï¼ˆEpistemologicalï¼‰**: çŸ¥è­˜ã‚„çœŸç†ã‚’ã©ã†æ‰ãˆã‚‹ã‹
   - å¤–çš„æ¨©å¨ã‹ã‚‰ã®è„±å´ â†’ å†…çš„ãªçŸ¥è­˜æ§‹ç¯‰èƒ½åŠ›ã®ç™ºé”
   - è¤‡æ•°ã®è¦–ç‚¹ã‚’çµ±åˆã—ã€æ–‡è„ˆã«å¿œã˜ãŸåˆ¤æ–­ãŒã§ãã‚‹

2. **å¯¾è‡ªé–¢ä¿‚æ¬¡å…ƒï¼ˆIntrapersonalï¼‰**: è‡ªå·±æ¦‚å¿µã‚„ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£
   - ä»–è€…ã‹ã‚‰ã®æ‰¿èªä¾å­˜ â†’ å†…çš„ãªä¾¡å€¤è¦³ãƒ»ä¿¡å¿µã®ç¢ºç«‹
   - è‡ªåˆ†ã‚‰ã—ã•ã‚’è¿½æ±‚ã—ã€ä¸€è²«ã—ãŸã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’æ§‹ç¯‰

3. **å¯¾äººé–¢ä¿‚æ¬¡å…ƒï¼ˆInterpersonalï¼‰**: ä»–è€…ã¨ã®é–¢ä¿‚æ€§
   - ä»–è€…ã«åˆã‚ã›ã‚‹ â†’ ç›¸äº’ã«å°Šé‡ã—åˆã†é–¢ä¿‚æ€§ã®æ§‹ç¯‰
   - è‡ªåˆ†ã®ä¾¡å€¤è¦³ã‚’ä¿ã¡ãªãŒã‚‰ã€ä»–è€…ã¨å»ºè¨­çš„ãªé–¢ä¿‚ã‚’ç¯‰ã

## æˆé•·æ®µéš
- **ç¬¬1æ®µéšï¼ˆå¤–çš„å®šå¼åŒ–ï¼‰**: å¤–çš„æ¨©å¨ã«ä¾å­˜
- **ç¬¬2æ®µéšï¼ˆå²è·¯ï¼‰**: å†…çš„å£°ã¨å¤–çš„å½±éŸ¿ã®é–“ã§æºã‚Œå‹•ã
- **ç¬¬3æ®µéšï¼ˆã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ï¼‰**: å†…çš„ã«å®šç¾©ã•ã‚ŒãŸä¿¡å¿µãƒ»ä¾¡å€¤è¦³ã«åŸºã¥ã„ã¦è¡Œå‹•

## æ±‚ã‚ã‚‹ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯

### 1. ç†å¿µé¢ã®è©•ä¾¡
- ã“ã®ã‚¢ã‚¤ãƒ‡ã‚¢ã¯å­¦ç”Ÿã®ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®å¤‰å®¹ã‚’ã©ã®ã‚ˆã†ã«å¾ŒæŠ¼ã—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã‹ï¼Ÿ
- å„æ¬¡å…ƒï¼ˆèªè­˜è«–çš„ã€å¯¾è‡ªé–¢ä¿‚ã€å¯¾äººé–¢ä¿‚ï¼‰ã¸ã®é…æ…®ã¯ååˆ†ã§ã—ã‚‡ã†ã‹ï¼Ÿ
- æˆé•·æ®µéšã«å¿œã˜ãŸæ”¯æ´ã«ãªã£ã¦ã„ã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ

### 2. å®Ÿè·µé¢ã®è©•ä¾¡
- å®Ÿéš›ã®å®Ÿè£…ã«ãŠã„ã¦ã€å­¦ç”Ÿã®ä¸»ä½“æ€§ã‚’æãªã†ãƒªã‚¹ã‚¯ã¯ã‚ã‚Šã¾ã›ã‚“ã‹ï¼Ÿ
- é‹å–¶å´ãŒå¤–çš„æ¨©å¨ã¨ã—ã¦æ©Ÿèƒ½ã—ã¦ã—ã¾ã†å¯èƒ½æ€§ã¯ã‚ã‚Šã¾ã›ã‚“ã‹ï¼Ÿ
- ã‚ˆã‚ŠåŠ¹æœçš„ãªå®Ÿè·µæ–¹æ³•ãŒã‚ã‚Œã°ææ¡ˆã—ã¦ãã ã•ã„ã€‚

### 3. ä¼ç”»é‹å–¶å´ã¸ã®å•ã„ã‹ã‘
ã“ã®ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’å®Ÿè·µã™ã‚‹è‡ªåˆ†é”è‡ªèº«ã®æˆé•·ã«ã‚‚ã¤ãªãŒã‚‹ã‚ˆã†ã«ï¼š
- ã©ã®ã‚ˆã†ãªå•ã„ã‹ã‘ã‚„æŒ¯ã‚Šè¿”ã‚ŠãŒå¿…è¦ã§ã—ã‚‡ã†ã‹ï¼Ÿ
- ä¼ç”»æ™‚ã«æ»‘ã‚Šè¾¼ã‚“ã§ãã‚„ã™ã„æ€è€ƒã®ç™–ã€è¨€è‘‰é£ã„ã€æ„è­˜ä¸‹ã®ãƒã‚¤ã‚¢ã‚¹ã¯ä½•ã§ã—ã‚‡ã†ã‹ï¼Ÿ
- æ§˜ã€…ãªå–ã‚Šçµ„ã¿ãŒæœ‰æ©Ÿçš„ã«é€£æºã—å­¦ç”Ÿã®æˆé•·ã‚’å¾ŒæŠ¼ã—ã™ã‚‹ç’°å¢ƒã®å‰µç™ºã«å¿…è¦ãªã“ã¨ã¯ã©ã®ã‚ˆã†ãªã‚‚ã®ãŒã‚ã‚Šã¾ã™ã‹ï¼Ÿ

## ãŠé¡˜ã„
é æ…®ã®ãªã„ç‡ç›´ãªãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚æ”¹å–„ç‚¹ã‚„æ‡¸å¿µç‚¹ãŒã‚ã‚Œã°å…·ä½“çš„ã«æŒ‡æ‘˜ã—ã¦ãã ã•ã„ã€‚ã¾ãŸã€ã“ã®ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’ã‚ˆã‚ŠåŠ¹æœçš„ã«ã™ã‚‹ãŸã‚ã®å»ºè¨­çš„ãªææ¡ˆã‚‚ãŠé¡˜ã„ã—ã¾ã™ã€‚`;
        }
        
        function copyPromptToClipboard() {
            const promptText = document.getElementById('promptOutput').value;
            navigator.clipboard.writeText(promptText).then(function() {
                alert('ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼');
            }).catch(function(err) {
                console.error('ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ: ', err);
                alert('ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ‰‹å‹•ã§ãƒ†ã‚­ã‚¹ãƒˆã‚’é¸æŠã—ã¦ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„ã€‚');
            });
        }
    </script>
</body>
</html>
