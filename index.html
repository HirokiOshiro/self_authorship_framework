<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>セルフオーサーシップ理論フレームワーク</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans JP", sans-serif;
            line-height: 1.8;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background: linear-gradient(135deg, #c9ea66 0%, #7eceff 100%);
            color: white;
            padding: 40px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 {
            margin: 0;
            font-size: 2.5em;
        }
        .subtitle {
            margin-top: 10px;
            font-size: 1.2em;
            opacity: 0.9;
        }
        .section {
            background: white;
            padding: 30px;
            margin-bottom: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        h2 {
            color: #667eea;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        h3 {
            color: #764ba2;
            margin-top: 25px;
        }
        .dimension-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .dimension-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 5px solid #667eea;
        }
        .phase-container {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .phase-card {
            flex: 1;
            min-width: 250px;
            background: #fff;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .phase-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .phase-1 { border-color: #ff6b6b; }
        .phase-2 { border-color: #ffd43b; }
        .phase-3 { border-color: #51cf66; }
        .principle {
            background: #e3f2fd;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border-left: 5px solid #2196f3;
        }
        .checklist {
            background: #f0f4ff;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .checklist h4 {
            color: #667eea;
            margin-bottom: 15px;
        }
        .checklist ul {
            list-style: none;
            padding: 0;
        }
        .checklist li {
            padding: 8px 0;
            padding-left: 30px;
            position: relative;
        }
        .checklist li:before {
            content: "□";
            position: absolute;
            left: 0;
            color: #667eea;
            font-weight: bold;
        }
        .highlight {
            background: #ffeb3b;
            padding: 2px 6px;
            border-radius: 3px;
        }
        .example {
            background: #e8f5e9;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 4px solid #4caf50;
            font-style: italic;
        }
        .arrow {
            text-align: center;
            font-size: 2em;
            color: #667eea;
            margin: 20px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background: #667eea;
            color: white;
        }
        tr:nth-child(even) {
            background: #f9f9f9;
        }
        .practical-tips {
            background: #fff3cd;
            padding: 20px;
            border-radius: 8px;
            border-left: 5px solid #ffc107;
            margin: 20px 0;
        }
        .advanced-section {
            background: #f0f7ff;
            padding: 30px;
            margin: 20px 0;
            border-radius: 10px;
            border: 2px solid #667eea;
        }
        .sub-phase {
            background: #fafbfc;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }
        .sub-phase h4 {
            margin: 0 0 10px 0;
            color: #667eea;
        }
        .lpm-step {
            background: #f8f9fa;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 4px solid #2196f3;
        }
        .lpm-step h5 {
            margin: 0 0 10px 0;
            color: #2196f3;
        }
        .toggle-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px 0;
            transition: background 0.3s;
        }
        .toggle-button:hover {
            background: #764ba2;
        }
        .collapsible {
            display: none;
            margin-top: 20px;
        }
        .collapsible.active {
            display: block;
        }
        .journey-table {
            overflow-x: auto;
        }
        .journey-table table {
            font-size: 0.9em;
        }
        .journey-table td {
            vertical-align: top;
        }
        @media (max-width: 768px) {
            .phase-container {
                flex-direction: column;
            }
            .dimension-grid {
                grid-template-columns: 1fr;
            }
            .journey-table {
                overflow-x: scroll;
            }
        }
        
        /* 3D Integration Styles */
        .sa-3d-integration {
            margin: 30px 0;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .sa-3d-integration h4 {
            color: #667eea;
            margin: 0 0 15px 0;
            font-size: 1.3em;
        }
        
        .sa-3d-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .sa-3d-loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            z-index: 10;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(102, 126, 234, 0.3);
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Canvas 2D ビジュアライゼーション統合スタイル */
        .canvas-2d-integration {
            margin: 25px 0;
            padding: 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            border: 2px solid #dee2e6;
        }
        
        .canvas-2d-integration h4 {
            color: #667eea;
            margin: 0 0 15px 0;
            font-size: 1.3em;
        }
        
        .journey-canvas-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        #journey-canvas {
            display: block;
            cursor: crosshair;
            background: transparent;
            width: 100%;
            height: 100%;
        }
        
        .journey-controls {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 10;
            background: rgba(26, 26, 46, 0.95);
            padding: 12px;
            border-radius: 12px;
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 240px;
            color: white;
            font-size: 0.9em;
        }
        
        .journey-controls h5 {
            color: #ffffff;
            margin: 0 0 8px 0;
            font-size: 1em;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            text-align: center;
        }
        
        .journey-stage-info {
            margin-bottom: 10px;
            padding: 8px 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            font-size: 0.8em;
            line-height: 1.3;
            box-shadow: 0 3px 12px rgba(102, 126, 234, 0.3);
            text-align: center;
        }
        
        .journey-stage-info small {
            display: block;
            opacity: 0.9;
            font-size: 0.85em;
            margin-top: 2px;
        }
        
        .journey-button-group {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
        }
        
        .journey-controls button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
            font-weight: 500;
            transition: all 0.3s ease;
            flex: 1;
            box-shadow: 0 3px 12px rgba(102, 126, 234, 0.2);
        }
        
        .journey-controls button.reset-btn {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            padding: 6px 10px;
            font-size: 0.75em;
        }
        
        .journey-controls button:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .journey-controls button.reset-btn:hover {
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }
        
        .journey-controls button:disabled {
            cursor: not-allowed;
            opacity: 0.4;
            transform: none !important;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1) !important;
        }
        
        .journey-stage-indicator {
            display: flex;
            gap: 6px;
            margin-top: 8px;
            justify-content: center;
        }
        
        .journey-stage-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .journey-stage-dot.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transform: scale(1.3);
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.6);
        }
        
        .journey-instructions {
            position: absolute;
            top: 185px;
            left: 15px;
            background: rgba(26, 26, 46, 0.95);
            padding: 12px;
            border-radius: 12px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            width: 240px;
            font-size: 0.75em;
            line-height: 1.2;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            z-index: 10;
        }
        
        .journey-instructions:hover {
            background: rgba(102, 126, 234, 0.2);
            border-color: rgba(102, 126, 234, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.3);
        }
        
        .journey-instructions-detail {
            display: none;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.9em;
            line-height: 1.3;
            opacity: 0;
            animation: fadeIn 0.3s ease forwards;
        }
        
        .journey-instructions-detail.show {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .journey-physics-info {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(26, 26, 46, 0.95);
            padding: 10px 12px;
            border-radius: 8px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 0.8em;
            line-height: 1.3;
        }
        
        .sa-3d-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        .stage-info-display {
            color: white;
            text-align: center;
            margin-bottom: 10px;
            min-height: 40px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .stage-info-display h5 {
            margin: 0 0 5px 0;
            color: #667eea;
            font-size: 1em;
        }
        
        .stage-info-display p {
            margin: 0;
            font-size: 0.85em;
            opacity: 0.9;
        }
        
        .stage-controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .stage-btn {
            background: #334155;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s;
            min-width: 40px;
        }
        
        .stage-btn:hover {
            background: #475569;
            transform: translateY(-2px);
        }
        
        .stage-btn.active {
            background: #667eea;
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
        }
        
        .view-controls {
            display: flex;
            gap: 10px;
        }
        
        .view-controls button {
            background: #1e293b;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background 0.3s;
        }
        
        .view-controls button:hover {
            background: #475569;
        }
        
        /* 浮遊視点リセットボタン */
        .floating-view-control {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 100;
            background: rgba(30, 41, 59, 0.9);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.2);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .floating-view-control:hover {
            background: rgba(59, 130, 246, 0.9);
            border-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
        }
        
        .floating-view-control:active {
            transform: scale(0.95);
        }
        
        .floating-view-control .tooltip {
            position: absolute;
            bottom: -35px;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .floating-view-control:hover .tooltip {
            opacity: 1;
        }

        .sa-3d-description {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .sub-phase h4 {
            transition: all 0.3s;
        }
        
        .sub-phase h4:hover {
            color: #764ba2;
            cursor: pointer;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            .sa-3d-container {
                height: 350px;
            }
            
            .sa-3d-controls {
                padding: 12px 15px;
                bottom: 10px;
            }
            
            .stage-controls {
                gap: 6px;
            }
            
            .stage-btn {
                padding: 6px 8px;
                font-size: 0.75em;
                min-width: 35px;
            }
            
            /* Canvas 2D レスポンシブ対応 */
            .journey-canvas-container {
                height: 400px;
            }
            
            .journey-controls {
                padding: 10px;
                width: 200px;
                font-size: 0.85em;
            }
            
            .journey-controls button {
                padding: 6px 8px;
                font-size: 0.75em;
            }
            
            .journey-controls button.reset-btn {
                padding: 5px 8px;
                font-size: 0.7em;
            }
            
            .journey-instructions {
                top: 155px;
                left: 10px;
                right: auto;
                bottom: auto;
                width: 200px;
                padding: 10px;
                font-size: 0.65em;
            }
            
            .journey-physics-info {
                right: 10px;
                bottom: 70px;
                padding: 8px 10px;
                font-size: 0.75em;
            }
        }
        
        /* ジャーニーマップセクション用スタイル */
        .journey-map-section {
            background: #f8f9fa;
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
            border: 1px solid #e9ecef;
        }
        
        
        .toggle-icon {
            font-size: 1em;
            margin-left: 8px;
            transition: transform 0.3s ease;
        }
        
        .toggle-icon.rotated {
            transform: rotate(180deg);
        }
        
        .journey-map-container {
            padding: 0;
            transition: max-height 0.5s ease;
            overflow: hidden;
        }
        
        .journey-iframe-wrapper {
            padding: 20px;
            background: white;
        }
        
        .journey-map-description {
            padding: 20px 30px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
        }
        
        .journey-map-description h4 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .journey-map-description ul {
            margin-left: 20px;
        }
        
        .journey-map-description li {
            margin-bottom: 8px;
        }
        
        /* レスポンシブ対応 */
        @media (max-width: 768px) {
            .journey-iframe-wrapper {
                padding: 10px;
            }
            
            #journey-map-iframe {
                height: 550px; /* モバイルでもグラフが見える高さ */
            }
        }
        
        @media (max-width: 480px) {
            .journey-iframe-wrapper {
                padding: 8px;
            }
            
            #journey-map-iframe {
                height: 500px; /* 小画面でもできるだけグラフを表示 */
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>セルフオーサーシップ理論フレームワーク</h1>
        <p class="subtitle">大学における学生の成長支援のための実践的ガイド</p>
    </div>

    <div class="section">
        <h2>🎯 セルフオーサーシップとは？</h2>
        <p><strong>セルフオーサーシップ</strong>とは、<span class="highlight">「自己の信念、アイデンティティ、社会関係を定義する内的能力」</span>のことです。</p>
        <p>学生が外部の権威や期待に依存するのではなく、自分自身の内なる声に基づいて人生を切り開いていく力を指します。これは21世紀の高等教育における重要な学習成果として位置づけられています。</p>
        
        <div class="practical-tips">
            <strong>💡 なぜ重要？</strong>
            <ul>
                <li>批判的思考力と主体的な学習態度の育成</li>
                <li>複雑な社会で自律的に生きる力の獲得</li>
                <li>多様な価値観の中で自分の軸を持つ力の形成</li>
            </ul>
        </div>
    </div>

    <div class="section">
        <h2>📊 3つの成長次元</h2>
        <p>セルフオーサーシップの成長は、以下の3つの次元で捉えることができます：</p>
        
        <div class="dimension-grid">
            <div class="dimension-card">
                <h3>🧠 認識論的次元</h3>
                <p><strong>問い：「私はどのように知るのか？」</strong></p>
                <p>知識や真実をどのように捉え、理解するかに関する成長</p>
                <div class="example">
                    例：「教科書に書いてあるから正しい」から「複数の視点を比較検討して自分の考えを形成する」へ
                </div>
            </div>
            
            <div class="dimension-card">
                <h3>🪞 対自関係次元</h3>
                <p><strong>問い：「私は何者か？」</strong></p>
                <p>自己アイデンティティや価値観の形成に関する成長</p>
                <div class="example">
                    例：「親や周囲が期待する自分」から「自分自身で選択した価値観に基づく自分」へ
                </div>
            </div>
            
            <div class="dimension-card">
                <h3>🤝 対人関係次元</h3>
                <p><strong>問い：「他者とどのように関わるか？」</strong></p>
                <p>他者との関係性をいかに構築するかに関する成長</p>
                <div class="example">
                    例：「承認をしてもらうための関係」から「相互に自立した対等な関係性での協働」へ
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>🚀 成長の3局面（基本）</h2>
        <p>学生は以下の3つの局面を通じて成長していきます：</p>
        
        <div class="phase-container">
            <div class="phase-card phase-1">
                <h3>1️⃣ 外的公式に従う局面</h3>
                <p><strong>特徴：</strong></p>
                <ul>
                    <li>権威者の言うことを鵜呑みにする</li>
                    <li>他者からの承認を求める</li>
                    <li>外的な期待に自己を合わせる</li>
                </ul>
                <p><strong>学生の状態：</strong><br>
                「先生が言ったから」「みんながそうしているから」という理由で行動</p>
            </div>
            
            <div class="phase-card phase-2">
                <h3>2️⃣ 岐路の局面</h3>
                <p><strong>特徴：</strong></p>
                <ul>
                    <li>外的権威への疑問が生じる</li>
                    <li>内なる声の必要性を認識</li>
                    <li>葛藤や不協和を経験</li>
                </ul>
                <p><strong>学生の状態：</strong><br>
                「本当にそれでいいのか？」「自分の考えは？」という問いが生まれる</p>
            </div>
            
            <div class="phase-card phase-3">
                <h3>3️⃣ セルフオーサーシップ局面</h3>
                <p><strong>特徴：</strong></p>
                <ul>
                    <li>内なる声を信頼する</li>
                    <li>自己決定に基づく行動</li>
                    <li>内なる基盤の構築</li>
                </ul>
                <p><strong>学生の状態：</strong><br>
                「私はこう考える」「私の価値観に基づいて行動する」</p>
            </div>
        </div>
        
        <button class="toggle-button" onclick="toggleSection('detailed-journey')">🔍 より詳細な成長の旅を見る</button>
        
        <div id="detailed-journey" class="collapsible">
            <div class="advanced-section">
                <h3>🗺️ セルフオーサーシップへの成長の旅（詳細版）</h3>
                <p>各次元における成長の詳細な様相を以下の表に示します：</p>
                
                <!-- Canvas 2Dビジュアライゼーション統合エリア -->
                <div class="canvas-2d-integration">
                    <h4>🗺️ 成長の旅のビジュアライゼーション</h4>
                    <p>以下のインタラクティブなアニメーションは、セルフオーサーシップの成長イメージの表現です。マウスで操作してみてください。<br>🎨：これはセルフオーサーシップの成長を集団のダイナミクスという観点で比喩的に表現した一例です。</p>

                    <div id="journey-canvas-container" class="journey-canvas-container">
                        <canvas id="journey-canvas"></canvas>
                        <div class="journey-controls">
                            <h5>🗺️ 成長の旅</h5>
                            <div class="journey-stage-info" id="journey-stageInfo">
                                重力の支配<br><small>外部の権威に従属している状態</small>
                            </div>
                            
                            <div class="journey-button-group">
                                <button onclick="previousJourneyStage()" id="journey-prevButton" title="前のステージ">←</button>
                                <button onclick="nextJourneyStage()" id="journey-nextButton" title="次のステージ">→</button>
                                <button onclick="resetJourney()" class="reset-btn" title="リセット">🔄</button>
                            </div>
                            
                            <div class="journey-stage-indicator">
                                <div class="journey-stage-dot active" id="journey-dot0"></div>
                                <div class="journey-stage-dot" id="journey-dot1"></div>
                                <div class="journey-stage-dot" id="journey-dot2"></div>
                                <div class="journey-stage-dot" id="journey-dot3"></div>
                            </div>
                        </div>
                        
                        <div class="journey-instructions" onclick="toggleInstructions()" id="journey-instructions">
                            <p><small>💡 操作ガイド <span id="instructions-arrow">▼</span></small></p>
                            <div class="journey-instructions-detail" id="instructions-detail">
                                <p><small>
                                    🖱️ <strong>マウス/タッチ</strong><br>
                                    パーティクルに影響を与える<br><br>
                                    🎯 <strong>ステージ操作</strong><br>
                                    ←→ボタンで段階切り替え<br><br>
                                    🔄 <strong>リセット</strong><br>
                                    初期状態に戻す
                                </small></p>
                            </div>
                        </div>
                        
                        <!-- 物理情報表示セクションを非表示化
                        <div class="journey-physics-info" id="journey-physicsInfo">
                            重力強度: 強<br>
                            自律性: 0%<br>
                            調和度: 0%
                        </div>
                        -->
                    </div>
                </div>
                
                <div class="journey-table">
                    <table>
                        <thead>
                            <tr>
                                <th>次元</th>
                                <th>外的公式</th>
                                <th>岐路</th>
                                <th>セルフオーサーシップ</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>認識論的</strong></td>
                                <td>
                                    • 知識の源泉として権威に信頼を譲る<br>
                                    • 知識を確実（または部分的に確実）と見る<br>
                                    • 外的に規定される信念となるような知識命題を評価するための内なる基盤を欠く
                                </td>
                                <td>
                                    • 不確実性と多元的視点の自覚と受容を進める<br>
                                    • 権威者の知識を受容することから知識命題を採用するパーソナルなプロセスへ移る<br>
                                    • 信念を選択するために責任を持つ必要性を認める
                                </td>
                                <td>
                                    • 知識を文脈的なものと見る<br>
                                    • 利用可能なエビデンスや参照枠組みの観点で判断を構築・評価・解釈する<br>
                                    • 内的信念システムを発達させる
                                </td>
                            </tr>
                            <tr>
                                <td><strong>対自関係</strong></td>
                                <td>
                                    • 自分の価値観や社会的アイデンティティの自覚を欠く<br>
                                    • アイデンティティの諸要素の調整を欠く<br>
                                    • 他者からの肯定を要する
                                </td>
                                <td>
                                    • 外的な他者の物の見方から区別される、自身の価値観とアイデンティティの感覚の自覚を進める<br>
                                    • 生じつつある内的価値観と外的圧力との間に緊張がある<br>
                                    • 自らのアイデンティティを作り出すために責任を持つ必要性を認める
                                </td>
                                <td>
                                    • 内的に生成し、経験と選択の解釈を調整する<br>
                                    • 自己の感覚をつくる際に自身の価値観とアイデンティティを選択する<br>
                                    • 一貫した内的な自己の感覚に根ざす
                                </td>
                            </tr>
                            <tr>
                                <td><strong>対人関係</strong></td>
                                <td>
                                    • 同じような他者たちとの依存関係がアイデンティティと必要な肯定の源泉となる<br>
                                    • 他者の肯定を得ていくこととしての関係への参加
                                </td>
                                <td>
                                    • 依存関係の限界への自覚を進める<br>
                                    • 自身のアイデンティティを自立的な諸関係を構築することへ持っていく必要性を認める<br>
                                    • 自己を再構築する、または依存関係から脱出させるために闘う
                                </td>
                                <td>
                                    • 多様な他者たちと真正な相互依存関係に取り組むことができる<br>
                                    • 関係性の必要性を相互的に交渉する<br>
                                    • 他者の視点を本当の意味で考慮に入れる
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>🔬 成長局面の精緻化</h2>
        <p>ウォバシュ全国調査研究により、各局面にはさらに詳細な下位局面があることが明らかになりました。</p>
        
        <button class="toggle-button" onclick="toggleSection('refined-phases')">🔬 精緻化された成長局面を見る</button>
        
        <div id="refined-phases" class="collapsible">
            <div class="advanced-section">
                <!-- 3D可視化統合エリア -->
                <div class="sa-3d-integration">
                    <h4>🔬 成長局面の変容のイメージ</h4>
                    <p>以下の3Dアニメーションで、各成長段階を視覚的に体験できます。下のテキストの段階名をクリックして切り替えてください。<br>🎨：これは個人内のセルフオーサーシップの成長を比喩的に表現した一例です。</p>

                    <div id="refined-3d-container" class="sa-3d-container">
                        <div id="refined-3d-scene">
                            <!-- 3Dシーン内浮遊ボタン -->
                            <button id="reset-view-btn" class="floating-view-control">
                                <span>↺</span>
                                <span class="tooltip">視点リセット</span>
                            </button>
                        </div>
                        <div class="sa-3d-loading" id="refined-3d-loading">
                            <div class="loading-spinner"></div>
                            <p>3D環境を初期化中...</p>
                        </div>
                        <div class="sa-3d-controls" id="refined-3d-controls" style="display: none;">
                            <div class="stage-info-display" id="stage-info-display">
                                <h5 id="current-stage-title">Ea: 外的権威を信頼する</h5>
                                <p id="current-stage-description">混沌とした状態から成長が始まります</p>
                            </div>
                            <div class="stage-controls">
                                <button data-stage="Ea" class="stage-btn active">Ea</button>
                                <button data-stage="Eb" class="stage-btn">Eb</button>
                                <button data-stage="Ec" class="stage-btn">Ec</button>
                                <button data-stage="EI" class="stage-btn">E(I)</button>
                                <button data-stage="E-I" class="stage-btn">E-I</button>
                                <button data-stage="I-E" class="stage-btn">I-E</button>
                                <button data-stage="IE" class="stage-btn">I(E)</button>
                                <button data-stage="Ia" class="stage-btn">Ia</button>
                                <button data-stage="Ib" class="stage-btn">Ib</button>
                                <button data-stage="Ic" class="stage-btn">Ic</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="sa-3d-description">
                        <p><small>💡 3D空間をドラッグして視点を変更、マウスホイールでズームイン・アウト、下のテキストの段階名をクリックして成長段階を切り替えられます。</small></p>
                    </div>
                </div>
                
                <h3>外的な意味形成局面の詳細</h3>
                
                <div class="sub-phase">
                    <h4>Ea: 外的権威を信頼する</h4>
                    <p>一貫して盲目的に外的資源を信頼し、そのことの欠点の可能性を認識することもない。</p>
                </div>
                
                <div class="sub-phase">
                    <h4>Eb: 外的権威を信頼することとの緊張</h4>
                    <p>一貫して外的資源を信頼するが、そうすることの緊張を経験する（とくに外的資源の間に葛藤がある場合）。葛藤を解消しようとして複数の権威の方を見る。</p>
                </div>
                
                <div class="sub-phase">
                    <h4>Ec: 外的権威を信頼することの欠点を認識する</h4>
                    <p>外的権威への信頼を継続するが、そのことの欠点を認識している。</p>
                </div>
                
                <h3>岐路局面の詳細</h3>
                
                <div class="sub-phase">
                    <h4>E(I): 外的権威に疑問を持つ（岐路に入る）</h4>
                    <p>内なる声の必要性を自覚するも、外的資源への信頼を継続する。外的意味形成のジレンマを自覚するが、どう進めばいいかわからない。</p>
                </div>
                
                <div class="sub-phase">
                    <h4>E-I: 内なる声を構築する</h4>
                    <p>意味形成の新しい仕方を構築するよう能動的に動き始めるが、以前の外的位置に「後退する」こともある。</p>
                </div>
                
                <div class="sub-phase">
                    <h4>I-E: 内なる声を聴く（岐路から出る）</h4>
                    <p>内なる声を注意深く聞き取り始め、外的資源を押しのけつつある。外的資源がまだ強く、内なる声を一貫して維持することを難しくしている。</p>
                </div>
                
                <div class="sub-phase">
                    <h4>I(E): 内なる声を育む</h4>
                    <p>内なる声を能動的に育み始め、内なる声が多くの外的資源を媒介する。他者の視点が自身の視点を包摂してしまうそれまでの傾性に戻らないように意識する。</p>
                </div>
                
                <h3>内的な意味形成（セルフオーサーシップ）局面の詳細</h3>
                
                <div class="sub-phase">
                    <h4>Ia: 内なる声を信頼する</h4>
                    <p>信念、価値、アイデンティティ、関係を洗練するのに十分なほど内なる声を信頼する。反応を形作り、外的資源を管理するのに内なる声を活用する。</p>
                </div>
                
                <div class="sub-phase">
                    <h4>Ib: 内なる基盤を築く</h4>
                    <p>外的資源にどう反応するかを導く人生哲学へのコミットメントを形成するのに十分なほど内なる声を信頼する。</p>
                </div>
                
                <div class="sub-phase">
                    <h4>Ic: 内なるコミットメントを確保する</h4>
                    <p>人生哲学を自分の存在の核として固め、それを第二の性質として生きる。</p>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>🛠️ 実践原則：ラーニング・パートナーシップ・モデル（LPM）</h2>
        <p>学生のセルフオーサーシップ成長を支援する3つの実践原則：</p>
        
        <div class="principle">
            <h3>1. 学習者の知る能力を確かめる</h3>
            <p>学生がどのように知識を捉えているかを理解し、その段階に応じたサポートを提供する</p>
            <p><strong>実践例：</strong>「なぜそう思うの？」「どうやってその結論に至った？」という問いかけ</p>
        </div>
        
        <div class="principle">
            <h3>2. 学生の学びをその学生の経験の中に位置づける</h3>
            <p>抽象的な学びではなく、学生自身の経験と結びつけて理解を深める</p>
            <p><strong>実践例：</strong>「この理論はあなたの経験とどう関連する？」という振り返り</p>
        </div>
        
        <div class="principle">
            <h3>3. 学びを相互的な意味構成と定義する</h3>
            <p>教員と学生、学生同士が対等な立場で意味を構築していく</p>
            <p><strong>実践例：</strong>ディスカッションやグループワークでの協働的な知識構築</p>
        </div>
        
        <button class="toggle-button" onclick="toggleSection('lpm-steps')">📋 LPM実践の10ステップを見る</button>
        
        <div id="lpm-steps" class="collapsible">
            <div class="advanced-section">
                <h3>ラーニング・パートナーシップ・モデル（LPM）実践の10ステップ</h3>
                
                <h4>フェーズ1：学習目標と学習者のセルフオーサーシップ能力をアセスメントする</h4>
                
                <div class="lpm-step">
                    <h5>ステップ1：文脈の選定</h5>
                    <p>学生や同僚との関わりから、LPMを用いてセルフオーサーシップを向上するのに適した実践は何か？</p>
                    <p><em>例：卒業論文、ピア・サポート、キャリア相談</em></p>
                </div>
                
                <div class="lpm-step">
                    <h5>ステップ2：その文脈での学習目標の設定</h5>
                    <ul>
                        <li>その文脈で現在、達成しようとしている学習成果は何か？</li>
                        <li>セルフオーサーシップをより包括的な目標と考えると、現在設定している学習成果＝目標をどのように設定することになるか？</li>
                        <li>参加者に何をよりよく理解してもらいたいか？何をよりうまく取り組めるようになってもらいたいか？</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ステップ3：セルフオーサーシップの視点から学習目標の検討</h5>
                    <ul>
                        <li><strong>認知能力：</strong>それらの学習目標を達成するのに、どのような仕方で知識を構築するか？</li>
                        <li><strong>対自関係能力：</strong>自分自身をどのような仕方で見て理解することが求められるか？</li>
                        <li><strong>対人関係能力：</strong>他者との関係の中の自分自身をどのような仕方で理解することが求められるか？</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ステップ4：その文脈での学習者のセルフオーサーシップ特徴の考慮</h5>
                    <ul>
                        <li>学習者が共通して用いる知識構築の仕方は？</li>
                        <li>学習者によって示される自分自身の見方は？</li>
                        <li>学習者が示す他者との関係の中の自分自身の見方は？</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ステップ5：学習目標と学習者能力の間の整合性と不整合の特定</h5>
                    <ul>
                        <li>学習目標と学習者のセルフオーサーシップ能力はどのように結びつくか？</li>
                        <li>それらの間にある不整合はどこか？</li>
                        <li>どんな成長目標が、必要な能力と狙いとする学習成果の間を橋渡しするのに役立つか？</li>
                    </ul>
                </div>
                
                <h4>フェーズ2：「進化の架け橋」をデザインする</h4>
                
                <div class="lpm-step">
                    <h5>ステップ6：成長する「カリキュラム」の素描</h5>
                    <ul>
                        <li>学習目標と成長目標は、どのように時間をかけてステップに変換されるか？</li>
                        <li>学習者への関与の長さにともなって、最初の時点で、学習目標と成長目標はどのような形態となるか？</li>
                        <li>ステップのどれがこれまでに通過し、どれがこれから向かう必要のあるものか？</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ステップ7：3つの想定に取り組む</h5>
                    <p><strong>知識は複雑で社会的に構築される / 自己が知識構築の中心である / 熟練と権威は相互に共有される</strong></p>
                    <ul>
                        <li>あなたの実践領域において、これらの想定は現在どのような仕方で示されているか？</li>
                        <li>どうすればより効果的にこれらの想定を学習者に伝えられるか？</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ステップ8：3つの原則に取り組む</h5>
                    <p>学習者の知る能力を確かめる / 学習を学習者の経験に位置づける / 学習者と意味を相互構築する</p>
                    <ul>
                        <li>これらの原則は現在どのような仕方で示されているか？</li>
                        <li>どうすればより効果的にこれらの原則を学習者に伝えられるか？</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ステップ9：整合性と不整合を再吟味する</h5>
                    <ul>
                        <li>新しい計画は、整合しているところを揺るがさないか？</li>
                        <li>この計画は、どの不整合に取り組むのか？</li>
                        <li>取り組むべき不整合のうち、残るものはどれか？</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ステップ10：効果を評価するための計画を素描する</h5>
                    <ul>
                        <li>参加者のセルフオーサーシップ能力を促進するのにどれほど効果があったかを決めるエビデンスとして使えるものは何か？</li>
                        <li>そのエビデンスはどのように集められるだろうか？</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>📋 実践チェックリスト</h2>
        
        <div class="checklist">
            <h4>取り組み検討時の活用</h4>
            <ul>
                <li>学生に「自分の考え」を求める機会を設けているか</li>
                <li>多様な視点に触れる機会を提供しているか</li>
                <li>失敗を恐れず挑戦できる環境を作っているか</li>
                <li>振り返りと省察の時間を確保しているか</li>
                <li>学生の成長段階に応じた課題設定をしているか</li>
            </ul>
        </div>
        
        <div class="checklist">
            <h4>学生支援・アドバイジングでの活用</h4>
            <ul>
                <li>学生の現在の成長局面を把握しているか</li>
                <li>答えを与えるのではなく、問いを投げかけているか</li>
                <li>学生の内なる声に耳を傾けているか</li>
                <li>適切なチャレンジとサポートのバランスを取っているか</li>
                <li>学生の自己決定を尊重しているか</li>
            </ul>
        </div>
    </div>

    <div class="section">
        <h2>📈 成長を促す具体的な取り組み例</h2>
        
        <table>
            <thead>
                <tr>
                    <th>取り組み</th>
                    <th>期待される効果</th>
                    <th>対応する次元</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>ポートフォリオ作成</td>
                    <td>自己の成長過程の可視化と省察</td>
                    <td>対自関係</td>
                </tr>
                <tr>
                    <td>ディベート・討論</td>
                    <td>多様な視点の理解と自己の立場の明確化</td>
                    <td>認識論的</td>
                </tr>
                <tr>
                    <td>協働プロジェクト</td>
                    <td>相互依存的な関係構築の経験</td>
                    <td>対人関係</td>
                </tr>
                <tr>
                    <td>リフレクション・ジャーナル</td>
                    <td>内なる声の発見と育成</td>
                    <td>全次元</td>
                </tr>
                <tr>
                    <td>メンタリング・プログラム</td>
                    <td>対話を通じた自己理解の深化</td>
                    <td>全次元</td>
                </tr>
                <tr>
                    <td>サービス・ラーニング</td>
                    <td>社会的文脈での自己の位置づけの理解</td>
                    <td>全次元</td>
                </tr>
                <tr>
                    <td>ライティング・カリキュラム</td>
                    <td>段階的な知的成長と自己表現力の育成</td>
                    <td>認識論的・対自関係</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="section">
        <h2>💡 実践のポイント</h2>
        
        <div class="practical-tips">
            <h3>成長を支援する際の留意点</h3>
            <ul>
                <li><strong>非線形な成長を理解する：</strong>学生は3つの局面を行きつ戻りつしながら成長します</li>
                <li><strong>次元間の連動を意識する：</strong>3つの次元は相互に影響し合います</li>
                <li><strong>文脈の重要性：</strong>学生の背景や環境を考慮したサポートが必要です</li>
                <li><strong>不協和の活用：</strong>葛藤や矛盾は成長の契機となります</li>
                <li><strong>長期的視点：</strong>セルフオーサーシップの成長は時間がかかるプロセスです</li>
                <li><strong>対自関係次元が中心：</strong>セルフオーサーシップは対自関係次元を軸とする成長です</li>
            </ul>
        </div>
        
        <div class="practical-tips">
            <h3>成長の契機となるもの</h3>
            <ul>
                <li><strong>外的意味形成段階：</strong>外的権威や期待の間の衝突・葛藤（不協和）</li>
                <li><strong>岐路段階：</strong>内なる声の発見と活用経験</li>
                <li><strong>セルフオーサーシップ段階：</strong>内なる基盤に基づく自己決定と行動の積み重ね</li>
            </ul>
        </div>
        
        <!-- 新規追加：ジャーニーマップセクション -->
        <button class="toggle-button" onclick="toggleJourneyMap()">📊 成長の道のり（例）を見る <span class="toggle-icon" id="journey-toggle-icon">▼</span></button>
        
        <div class="journey-map-section">
            
            <div class="journey-map-container" id="journey-map-container" style="display: none;">
                <div class="journey-iframe-wrapper">
                    <iframe id="journey-map-iframe"
                            src="./journey-map-embed.html"
                            width="100%"
                            height="800px"
                            frameborder="0"
                            style="border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    </iframe>
                </div>
                
                <div class="journey-map-description">
                    <h4>ジャーニーマップについて</h4>
                    <p>このビューアは、セルフオーサーシップ理論に基づいた学生の成長過程を視覚化したものです。シナリオは生成AIを用いて作成した仮想のものです。</p>
                    <ul>
                        <li><strong>ペルソナ比較：</strong>異なる学習パターンの比較分析</li>
                        <li><strong>成長/停滞分析：</strong>成長・停滞パターンの可視化</li>
                        <li><strong>分岐点特定：</strong>重要な転換点の詳細分析</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>📚 参考情報</h2>
        <p>上記の情報は、Baxter Magoldaによるセルフオーサーシップ理論、および河井亨（2022）「<a href="https://ritsumei.repo.nii.ac.jp/records/16164">大学生におけるセルフ・オーサーシップの成長理論 : 成長理論のなかの位置づけおよび成長経路と影響要因の析出</a>」を参照しながら作成しています。</p>
        <p>より詳細な理論的背景や実践事例については、原著論文をご参照ください。</p>
    </div>

    <script>
        // Self-Authorship 3D Integration Module
        class CoreGeometryManager {
            constructor() {
                this.currentGeometry = null;
                this.transitionDuration = 2000; // 2秒のトランジション
            }

            createPolyhedronGeometry(stage) {
                // 段階に応じたサイズの決定
                const baseSize = this.getStageSize(stage);
                
                switch(stage) {
                    case 'Ea':
                    case 'Eb': 
                    case 'Ec':
                        // 正四面体 (Tetrahedron) - External Authority期
                        return new THREE.TetrahedronGeometry(baseSize);
                        
                    case 'EI':
                    case 'E-I':
                    case 'I-E':
                        // 正八面体 (Octahedron) - Transition期
                        return new THREE.OctahedronGeometry(baseSize);
                        
                    case 'IE':
                    case 'Ia':
                        // 正十二面体 (Dodecahedron) - Internal Foundation期
                        return new THREE.DodecahedronGeometry(baseSize);
                        
                    case 'Ib':
                    case 'Ic':
                        // 正二十面体 (Icosahedron) - Self-Authorship期
                        return new THREE.IcosahedronGeometry(baseSize);
                        
                    default:
                        // デフォルトは正四面体
                        return new THREE.TetrahedronGeometry(baseSize);
                }
            }

            getStageSize(stage) {
                // 成長に応じたサイズマッピング
                const sizeMap = {
                    // External Authority期 - 小さく、未発達
                    'Ea': 0.35,  // 最小サイズ
                    'Eb': 0.4,   // 少し成長
                    'Ec': 0.45,  // 疑問の兆し
                    
                    // Transition期 - 中程度、探求期
                    'EI': 0.5,   // 内的探求の始まり
                    'E-I': 0.55, // 内なる声の構築
                    'I-E': 0.6,  // 内なる声を聴く
                    
                    // Internal Foundation期 - 大きく、確立期
                    'IE': 0.65,  // 内なる声を育む
                    'Ia': 0.7,   // 内なる声を信頼
                    
                    // Self-Authorship期 - 最大、統合期
                    'Ib': 0.75,  // 内なる基盤確立
                    'Ic': 0.8    // 最大サイズ、完全な統合
                };
                
                return sizeMap[stage] || 0.35; // デフォルトは最小サイズ
            }

            getSizeDescription(stage) {
                const size = this.getStageSize(stage);
                const percentage = Math.round((size / 0.8) * 100); // 最大サイズを100%として
                return `サイズ: ${percentage}% (${size.toFixed(2)})`;
            }

            getPolyhedronName(stage) {
                const shapeName = this.getShapeName(stage);
                const sizeInfo = this.getSizeDescription(stage);
                return `${shapeName} - ${sizeInfo}`;
            }

            getShapeName(stage) {
                switch(stage) {
                    case 'Ea': case 'Eb': case 'Ec':
                        return 'Tetrahedron (正四面体)';
                    case 'EI': case 'E-I': case 'I-E':
                        return 'Octahedron (正八面体)';
                    case 'IE': case 'Ia':
                        return 'Dodecahedron (正十二面体)';
                    case 'Ib': case 'Ic':
                        return 'Icosahedron (正二十面体)';
                    default:
                        return 'Tetrahedron (正四面体)';
                }
            }

            createWireframeGeometry(geometry) {
                // ワイヤーフレーム効果用
                const wireframe = new THREE.WireframeGeometry(geometry);
                return wireframe;
            }
        }

        class RefinedSelfAuthorshipVisualization {
            constructor() {
                this.container = null;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.currentStage = 'Ea';
                this.isInitialized = false;
                this.isInitializing = false;
                this.animationFrameId = null;
                this.particles = [];
                this.core = null;
                this.coreLight = null;                // コア発光ライト
                this.baseCoreIntensity = 0.3;         // コアの基本光量
                this.currentCoreIntensity = 0.3;      // 現在のコア光量
                this.maxCoreIntensity = 1.5;          // 最大コア光量
                this.absorptionCount = 0;             // 吸収されたパーティクル数
                this.dimensionRings = [];  // 次元リングの参照を保持
                this.controls = null;
                
                // 多面体システム
                this.coreGeometryManager = new CoreGeometryManager();
                this.isTransitioning = false;        // 形状変更中フラグ
                
                // 段階的光強化システム - セルフオーサーシップの成長に応じたコア光の発達
                this.lightVeils = [];                 // 光のベール配列
                this.stageProgressionOrder = ['I-E', 'IE', 'Ia', 'Ib', 'Ic']; // 光のベールが出現するステージ順
                this.currentStageIndex = 0;           // 現在のステージインデックス
                
                // 光のベールが表示されないステージのリスト
                this.noLightVeilStages = ['Ea', 'Eb', 'Ec', 'EI', 'E-I'];
                
                // I(E)ステージ以降の光線接続システム
                this.connectionLines = [];            // パーティクル間の接続線
                this.connectionPairs = new Map();     // 接続ペアの管理
                this.maxConnections = 45;             // 最大接続数（Icステージの極めて豊富な接続に対応）
                this.connectionUpdateInterval = 10000; // 接続更新間隔（ミリ秒）- 経験の結びつきを長時間維持
                this.lastConnectionUpdate = 0;        // 最後の接続更新時刻
                
                // ステージ別接続制限 - セルフオーサーシップの成長に応じた経験統合能力の発達
                this.stageConnectionLimits = {
                    'IE': 3,      // IEステージ：内なる声を育む段階 - 少ない接続
                    'Ia': 8,      // Iaステージ：過去の意味づけ段階 - 基礎的な接続
                    'Ib': 12,      // Ibステージ：統合の基盤段階 - 中程度の接続
                    'Ic': 24      // Icステージ：発見と気づき段階 - 極めて豊富な接続（広範囲な経験統合・完全なコミットメント）
                };
                
                // Zoom controls
                this.defaultCameraZ = 10;
                this.minZoom = 3;
                this.maxZoom = 20;
                this.zoomSpeed = 0.1;
                
                // Dynamic particle management for questioning stage
                this.dynamicParticles = [];
                this.lastParticleSpawn = 0;
                this.persistentParticleIndices = new Set();
                
                // Colorful particle system for I(E) stages and beyond
                this.colorfulParticlePalette = [
                    0xff6b6b, 0x4ecdc4, 0x45b7d1, 0x96c93d, 0xffeaa7,
                    0xdda0dd, 0x98d8c8, 0xf7dc6f, 0xbb8fce, 0x85c1e9,
                    0xf8c471, 0x82e0aa, 0xf1948a, 0x85c1e9, 0xc39bd3,
                    0x7fb3d3, 0xaed6f1, 0xf9e79f, 0xa3e4d7, 0xd7bde2
                ];
                this.colorTransitionSpeed = 0.05;
                
                // I-E Stage Particle Emergence System
                this.isEmergingIE = false;           // I-E出現アニメーション中フラグ
                this.emergenceStartTime = 0;         // 出現開始時刻
                this.emergenceDelay = 500;           // 切り替え後の遅延（ms）
                this.emergenceDuration = 2500;       // 全パーティクル出現期間（ms）
                this.particleEmergenceInterval = 100; // パーティクル間出現間隔（ms）
                this.emergingParticles = [];         // 出現中パーティクルのリスト
            }
            
            async init(containerId) {
                if (this.isInitialized || this.isInitializing) return;
                this.isInitializing = true;
                
                this.container = document.getElementById(containerId);
                if (!this.container) {
                    console.error('コンテナが見つかりません:', containerId);
                    this.showError();
                    this.isInitializing = false;
                    return;
                }
                
                // WebGLサポートの確認
                if (!this.checkWebGLSupport()) {
                    console.error('WebGLがサポートされていません');
                    this.showError();
                    this.isInitializing = false;
                    return;
                }
                
                this.showLoading();
                
                try {
                    await this.createScene();
                    this.createControls();
                    this.bindEvents();
                    this.startAnimation();
                    this.hideLoading();
                    this.isInitialized = true;
                    console.log('3D環境が初期化されました');
                } catch (error) {
                    console.error('3D初期化エラー:', error);
                    console.error('エラー詳細:', error.message);
                    console.error('スタックトレース:', error.stack);
                    this.showError();
                } finally {
                    this.isInitializing = false;
                }
            }
            
            // WebGLサポートの確認
            checkWebGLSupport() {
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    return gl !== null;
                } catch (e) {
                    return false;
                }
            }

            showLoading() {
                const loading = document.getElementById('refined-3d-loading');
                if (loading) loading.style.display = 'flex';
            }
            
            hideLoading() {
                const loading = document.getElementById('refined-3d-loading');
                const controls = document.getElementById('refined-3d-controls');
                if (loading) loading.style.display = 'none';
                if (controls) controls.style.display = 'block';
            }
            
            showError() {
                const loading = document.getElementById('refined-3d-loading');
                if (loading) {
                    loading.innerHTML = `
                        <div style="text-align: center; color: #ff6b6b;">
                            <h4>3D表示エラー</h4>
                            <p>3D表示の初期化に失敗しました。</p>
                            <p>以下を確認してください：</p>
                            <ul style="text-align: left; max-width: 400px; margin: 0 auto;">
                                <li>ブラウザがWebGLをサポートしているか</li>
                                <li>ハードウェアアクセラレーションが有効か</li>
                                <li>ブラウザが最新版か</li>
                            </ul>
                            <p style="margin-top: 15px;">
                                <button onclick="location.reload()" style="padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                    再読み込み
                                </button>
                            </p>
                        </div>
                    `;
                }
            }
            
            async createScene() {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        try {
                            // Create Three.js scene
                            this.scene = new THREE.Scene();
                            this.scene.background = new THREE.Color(0x0a0a0a);
                            
                            // Create camera
                            const aspect = this.container.offsetWidth / this.container.offsetHeight;
                            this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
                            this.camera.position.set(0, 0, this.defaultCameraZ);
                            
                            // Create renderer
                            this.renderer = new THREE.WebGLRenderer({ antialias: true });
                            this.renderer.setSize(this.container.offsetWidth, this.container.offsetHeight);
                            this.renderer.setClearColor(0x0a0a0a);
                            
                            // Add renderer to container
                            const sceneElement = document.getElementById('refined-3d-scene');
                            if (sceneElement) {
                                sceneElement.appendChild(this.renderer.domElement);
                            }
                            
                            // Create basic 3D content
                            this.createInitialContent();
                        
                        // Add lighting
                        const ambientLight = new THREE.AmbientLight(0x606060, 0.5); // より明るい環境光
                        this.scene.add(ambientLight);
                        
                        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // より強い指向性ライト
                        directionalLight.position.set(10, 10, 5);
                        this.scene.add(directionalLight);
                        
                        // 追加のポイントライトで立体感を強化
                        const pointLight1 = new THREE.PointLight(0xffffff, 0.5, 100);
                        pointLight1.position.set(-10, -10, 10);
                        this.scene.add(pointLight1);
                            
                            const pointLight2 = new THREE.PointLight(0xffffff, 0.3, 100);
                            pointLight2.position.set(5, -5, -10);
                            this.scene.add(pointLight2);
                            
                            resolve();
                        } catch (error) {
                            console.error('createScene内でエラー:', error);
                            reject(error);
                        }
                    }, 2000); // 2秒の初期化時間
                });
            }
            
            createInitialContent() {
                // Create core (self) with polyhedron geometry
                this.createPolyhedronCore(this.currentStage);
                
                // Create core light for enhanced introspection effect
                this.coreLight = new THREE.PointLight(0xffffcc, this.baseCoreIntensity, 10);
                this.coreLight.position.set(0, 0, 0);
                this.scene.add(this.coreLight);
                
                // Initialize progressive light enhancement system
                this.initializeLightVeils();
                
                // Create dimension rings
                this.createDimensionRings();
                
                // Create stage-specific particles
                this.createStageParticles();
            }
            
            createDimensionRings() {
                // 既存のリングをクリア
                this.dimensionRings.forEach(ring => this.scene.remove(ring));
                this.dimensionRings = [];
                
                // 現在の段階番号を取得（初期化時はEa=1）
                const currentStageNumber = this.getStageNumber(this.currentStage || 'Ea');
                
                for (let i = 0; i < 3; i++) {
                    // 段階に応じた半径を取得
                    const radius = this.getDimensionRingRadius(i, currentStageNumber);
                    const geometry = new THREE.TorusGeometry(radius, 0.05, 8, 32);
                    
                    // 多面体コアと統一した材質システム
                    const material = new THREE.MeshPhongMaterial({ 
                        color: this.getDimensionRingColor(i, currentStageNumber),
                        transparent: true,
                        opacity: this.getDimensionRingOpacity(currentStageNumber),
                        shininess: this.getDimensionRingShininess(currentStageNumber),
                        emissive: this.getDimensionRingEmissive(i, currentStageNumber),
                        emissiveIntensity: this.getDimensionRingEmissiveIntensity(currentStageNumber),
                        specular: 0x888888 // 統一された反射光
                    });
                    
                    const ring = new THREE.Mesh(geometry, material);
                    ring.rotation.x = Math.PI / 2 + (i * Math.PI / 6);
                    
                    // 段階的進化のためのプロパティを追加
                    ring.userData = {
                        ringIndex: i,
                        baseRotationX: Math.PI / 2 + (i * Math.PI / 6),
                        baseRotationSpeed: 0.1 + i * 0.05, // 基本回転速度
                        rotationDirection: i % 2 === 0 ? 1 : -1,
                        interactionPhase: 0, // 相互作用の位相
                        synchronizationFactor: 0, // 同期度合い
                        materialEvolution: 0 // 材質進化度
                    };
                    
                    this.scene.add(ring);
                    this.dimensionRings.push(ring);
                }
            }
            
            // 段階に応じた次元リングの半径を決定
            getDimensionRingRadius(ringIndex, stage) {
                // 基本半径（初期サイズ）
                const baseRadii = [1.8, 2.5, 3.2]; // 内側、中間、外側リング
                const baseRadius = baseRadii[ringIndex];
                
                // 段階に応じたサイズ倍率
                let sizeMultiplier;
                
                if (stage <= 3) {
                    // Ea, Eb, Ec: 小さめから開始
                    sizeMultiplier = 0.7 + stage * 0.1; // 0.8-1.0倍
                } else if (stage <= 7) {
                    // EI, E-I, I-E, IE: 徐々に拡大
                    sizeMultiplier = 1.0 + (stage - 3) * 0.12; // 1.0-1.48倍
                } else {
                    // Ia, Ib, Ic: 最も大きく
                    sizeMultiplier = 1.48 + (stage - 7) * 0.08; // 1.48-1.72倍
                }
                
                return baseRadius * sizeMultiplier;
            }

            // 段階に応じた次元リングの色を決定（多面体コアと統一化）
            getDimensionRingColor(ringIndex, stage) {
                // 多面体コアの色システムと統一した色相配置
                const baseHues = [240, 300, 60]; // 青紫系, 紫系, 黄緑系
                const hue = baseHues[ringIndex];
                
                // 多面体コアのサイズ進化に合わせた色彩発展
                const coreProgress = this.getCoreProgress(stage);
                
                // 段階に応じた色彩パラメータ（コアシステムと統一）
                let saturation, lightness;
                
                if (stage <= 3) {
                    // EA段階: 落ち着いた基調色
                    saturation = 45 + coreProgress * 15;     // 45-60%
                    lightness = 25 + coreProgress * 15;      // 25-40%
                } else if (stage <= 7) {
                    // 岐路段階: 活発な変化を表現
                    const transitionFactor = (stage - 3) / 4;
                    saturation = 60 + transitionFactor * 20; // 60-80%
                    lightness = 40 + transitionFactor * 25;  // 40-65%
                } else {
                    // IA段階: 輝く完成形
                    const masterFactor = (stage - 7) / 3;
                    saturation = 80 + masterFactor * 15;     // 80-95%
                    lightness = 65 + masterFactor * 20;      // 65-85%
                }
                
                // リング間の微妙な色彩変化（統一感を保ちながら区別）
                const ringVariation = ringIndex * 0.05;
                saturation = Math.min(95, saturation + ringVariation * 10);
                lightness = Math.max(15, lightness - ringVariation * 5);
                
                return new THREE.Color().setHSL(hue / 360, saturation / 100, lightness / 100).getHex();
            }
            
            // 段階に応じた透明度を決定
            getDimensionRingOpacity(stage) {
                if (stage <= 3) {
                    // EA段階: 0.35-0.50
                    return 0.35 + stage * 0.05;
                } else if (stage <= 7) {
                    // 岐路段階: 0.50-0.82
                    return 0.50 + (stage - 3) * 0.08;
                } else {
                    // IA段階: 0.82-0.94 (最も明るく)
                    return 0.82 + (stage - 7) * 0.04;
                }
            }
            
            // 段階に応じた光沢度を決定（多面体コアと統一化）
            getDimensionRingShininess(stage) {
                // 多面体コアの光沢進化システムと統一
                const coreProgress = this.getCoreProgress(stage);
                
                if (stage <= 3) {
                    // EA段階: 低光沢から始まる（コアの控えめな輝き）
                    return 10 + coreProgress * 20; // 10-30
                } else if (stage <= 7) {
                    // 岐路段階: 変化的な光沢（コアの変容と同期）
                    const transitionIntensity = (stage - 3) / 4;
                    return 30 + transitionIntensity * 50; // 30-80
                } else {
                    // IA段階: 高光沢・輝く完成形（コアの洗練された輝き）
                    const masterIntensity = (stage - 7) / 3;
                    return 80 + masterIntensity * 60; // 80-140
                }
            }

            // 次元リングのエミッシブ（発光）色を決定
            getDimensionRingEmissive(ringIndex, stage) {
                // コアシステムと統一したエミッシブ効果
                const baseHues = [240, 300, 60]; // 各リングの基本色相
                const hue = baseHues[ringIndex];
                const coreProgress = this.getCoreProgress(stage);
                
                // 段階に応じたエミッシブ強度
                let emissiveSaturation, emissiveLightness;
                
                if (stage <= 3) {
                    // EA段階: 微細な内部光
                    emissiveSaturation = 20 + coreProgress * 10; // 20-30%
                    emissiveLightness = 5 + coreProgress * 5;    // 5-10%
                } else if (stage <= 7) {
                    // 岐路段階: 動的な発光
                    const transitionFactor = (stage - 3) / 4;
                    emissiveSaturation = 30 + transitionFactor * 25; // 30-55%
                    emissiveLightness = 10 + transitionFactor * 10;  // 10-20%
                } else {
                    // IA段階: 強い内部光
                    const masterFactor = (stage - 7) / 3;
                    emissiveSaturation = 55 + masterFactor * 20; // 55-75%
                    emissiveLightness = 20 + masterFactor * 15;  // 20-35%
                }
                
                return new THREE.Color().setHSL(hue / 360, emissiveSaturation / 100, emissiveLightness / 100).getHex();
            }

            // 次元リングのエミッシブ強度を決定
            getDimensionRingEmissiveIntensity(stage) {
                const coreProgress = this.getCoreProgress(stage);
                
                if (stage <= 3) {
                    // EA段階: 弱い発光
                    return 0.1 + coreProgress * 0.1; // 0.1-0.2
                } else if (stage <= 7) {
                    // 岐路段階: 中程度の発光
                    const transitionFactor = (stage - 3) / 4;
                    return 0.2 + transitionFactor * 0.3; // 0.2-0.5
                } else {
                    // IA段階: 強い発光
                    const masterFactor = (stage - 7) / 3;
                    return 0.5 + masterFactor * 0.3; // 0.5-0.8
                }
            }

            // 多面体コアの進化度合いを計算（統一化のためのベースメトリック）
            getCoreProgress(stage) {
                // 10段階の進化を0.0-1.0の範囲で正規化
                if (stage <= 1) return 0.0;
                if (stage >= 10) return 1.0;
                
                // 各段階グループ内での進行度を計算
                if (stage <= 3) {
                    // EA段階 (1-3): 基礎形成期
                    return (stage - 1) / 9; // 0.0-0.22
                } else if (stage <= 7) {
                    // 岐路段階 (4-7): 変容期
                    return (stage - 1) / 9; // 0.33-0.67
                } else {
                    // IA段階 (8-10): 完成期
                    return (stage - 1) / 9; // 0.78-1.0
                }
            }

            createPolyhedronCore(stage) {
                // 既存のコアを削除
                if (this.core) {
                    this.scene.remove(this.core);
                    if (this.core.geometry) this.core.geometry.dispose();
                    if (this.core.material) this.core.material.dispose();
                }

                // 段階に応じた多面体ジオメトリを作成
                const coreGeometry = this.coreGeometryManager.createPolyhedronGeometry(stage);
                
                // 段階データから色彩を取得
                const stageData = this.getStageData(stage);
                const stageColor = stageData.color;
                
                // 多面体用マテリアル（エッジを強調）
                const coreMaterial = new THREE.MeshPhongMaterial({ 
                    color: stageColor,
                    emissive: 0x333333,
                    transparent: true,
                    opacity: 0.85,
                    shininess: 100,
                    wireframe: false
                });
                
                // メインの多面体メッシュ
                this.core = new THREE.Mesh(coreGeometry, coreMaterial);
                this.scene.add(this.core);
                
                // ワイヤーフレーム効果（エッジ強調）
                const wireframeGeometry = this.coreGeometryManager.createWireframeGeometry(coreGeometry);
                const wireframeMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.6,
                    linewidth: 2
                });
                
                const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
                this.core.add(wireframe); // コアの子として追加
                
                // 頂点光点効果
                this.createVertexLights(coreGeometry, stageColor);
                
                console.log(`コア形状更新: ${this.coreGeometryManager.getPolyhedronName(stage)}`);
            }

            createVertexLights(geometry, baseColor) {
                // 頂点位置を取得
                const vertices = geometry.attributes.position.array;
                const vertexCount = vertices.length / 3;
                
                // 既存の頂点ライトを削除
                if (this.vertexLights) {
                    this.vertexLights.forEach(light => {
                        this.scene.remove(light);
                    });
                }
                this.vertexLights = [];
                
                // 各頂点に小さな光点を配置
                for (let i = 0; i < vertexCount; i += 3) { // 間引いて配置
                    const x = vertices[i * 3];
                    const y = vertices[i * 3 + 1];
                    const z = vertices[i * 3 + 2];
                    
                    // 小さな球体光点
                    const lightGeometry = new THREE.SphereGeometry(0.02, 8, 8);
                    const lightMaterial = new THREE.MeshBasicMaterial({ 
                        color: baseColor,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const lightSphere = new THREE.Mesh(lightGeometry, lightMaterial);
                    lightSphere.position.set(x, y, z);
                    
                    this.core.add(lightSphere); // コアの子として追加
                }
            }

            initializeLightVeils() {
                // 段階的光強化システム - セルフオーサーシップの成長に応じた光のベール
                // 各ステージで大幅にサイズが増加する透明な光のベールを作成
                
                // 既存のベールをクリア
                this.lightVeils.forEach(veil => this.scene.remove(veil));
                this.lightVeils = [];
                
                // 5段階の光のベールを作成（I-E, IE, Ia, Ib, Ic）
                // より大きなサイズ差で視覚的な層の重なりを明確に表現
                const baseRadii = [0.4, 0.6, 0.9, 1.3, 1.8]; // 段階的に大幅増加
                
                for (let i = 0; i < 5; i++) {
                    const radius = baseRadii[i];
                    const geometry = new THREE.SphereGeometry(radius, 32, 32);
                    
                    // シンプルで確実な光のベール - MeshBasicMaterialで自己発光
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xffffee,              // 暖かみのある柔らかな白
                        transparent: true,
                        opacity: 0.005 + i * 0.002,  // 極めて透明度を高くして背景がはっきり見えるように
                        fog: false,                   // フォグの影響を受けない
                        side: THREE.DoubleSide,       // 両面描画で光らしさを強化
                        blending: THREE.AdditiveBlending,  // 加算ブレンディングで光らしさを強化
                        depthWrite: false             // 深度書き込みを無効化して透明感向上
                    });
                    
                    const veil = new THREE.Mesh(geometry, material);
                    veil.position.set(0, 0, 0);
                    
                    // 放射状グラデーション効果をマテリアル自体で実現
                    veil.material.userData = {
                        baseOpacity: 0.005 + i * 0.002,    // 基準透明度を極めて透明に
                        emissiveStrength: 0.15 + i * 0.03,
                        layerIndex: i
                    };
                    
                    // 呼吸のような動きのためのパラメータ
                    veil.userData = {
                        baseRadius: radius,
                        breatheSpeed: 0.8 + i * 0.1,
                        breathePhase: i * Math.PI / 3,
                        stageIndex: i,
                        visible: false  // 初期状態では非表示
                    };
                    
                    veil.visible = false; // 初期状態では非表示
                    this.scene.add(veil);
                    this.lightVeils.push(veil);
                }
            }
            
            createStageParticles() {
                // Clear existing particles
                this.particles.forEach(particle => this.scene.remove(particle));
                this.particles = [];
                
                // Create particles based on current stage
                const stageData = this.getStageData(this.currentStage);
                const particleCount = stageData.particleCount;
                const color = stageData.color;
                
                for (let i = 0; i < particleCount; i++) {
                    // 経験のメタファーとしてランダムなサイズを生成
                    // 基本サイズ0.04に対して、0.5倍〜1.8倍の範囲でランダム化
                    const baseSize = 0.04;
                    const sizeVariation = 0.5 + Math.random() * 1.3; // 0.5 - 1.8倍
                    const particleSize = baseSize * sizeVariation;
                    
                    // 段階に応じたサイズ調整：後期段階ほど大きく、多様になる
                    const stageNumber = this.getStageNumber(this.currentStage);
                    let stageSizeMultiplier = 1.0;
                    
                    if (stageNumber >= 8) { // Ia, Ib, Ic段階
                        stageSizeMultiplier = 1.0 + (stageNumber - 7) * 0.15; // 最大1.45倍
                    } else if (stageNumber >= 5) { // E-I, I-E, IE段階
                        stageSizeMultiplier = 1.0 + (stageNumber - 4) * 0.08; // 最大1.24倍
                    }
                    
                    const finalSize = particleSize * stageSizeMultiplier;
                    const geometry = new THREE.SphereGeometry(finalSize, 12, 12); // ランダムサイズ適用、品質も向上
                    
                    // サイズに応じた視覚的効果の調整
                    const sizeRatio = finalSize / baseSize; // サイズ比を計算
                    const baseOpacity = 0.9;
                    const sizeAdjustedOpacity = Math.min(baseOpacity * (0.7 + sizeRatio * 0.3), 1.0); // 大きいほど少し透明に
                    const sizeAdjustedEmissive = Math.floor(0x111111 * (0.8 + sizeRatio * 0.4)); // 大きいほど少し明るく発光
                    const sizeAdjustedShininess = 80 + (sizeRatio - 1) * 40; // サイズに応じて光沢度調整
                    
                    const material = new THREE.MeshPhongMaterial({ 
                        color: color,
                        transparent: true,
                        opacity: sizeAdjustedOpacity,  // サイズ調整された透明度
                        emissive: sizeAdjustedEmissive,  // サイズ調整された発光
                        shininess: Math.max(50, Math.min(150, sizeAdjustedShininess))  // 光沢範囲制限（50-150）
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    
                    // Position particles based on stage characteristics
                    const radius = 1 + Math.random() * 5;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    particle.position.x = radius * Math.sin(phi) * Math.cos(theta);
                    particle.position.y = radius * Math.sin(phi) * Math.sin(theta);
                    particle.position.z = radius * Math.cos(phi);
                    
                    // Add dynamic properties based on stage behavior
                    particle.userData = {
                        originalPosition: particle.position.clone(),
                        baseRadius: radius,
                        baseTheta: theta,
                        basePhi: phi,
                        personalityFactor: Math.random(),
                        phaseOffset: Math.random() * Math.PI * 2,
                        speed: stageData.speed * (0.8 + Math.random() * 0.4),
                        cohesion: stageData.cohesion,
                        behavior: stageData.behavior,
                        pattern: stageData.pattern,
                        age: 0,
                        targetPosition: new THREE.Vector3(),
                        // サイズ関連情報を追加
                        originalSize: finalSize,
                        sizeRatio: sizeRatio,
                        baseSize: baseSize,
                        sizeVariation: sizeVariation
                    };
                    
                    this.scene.add(particle);
                    this.particles.push(particle);
                }
                
                // I(E)ステージ以降の場合、初期接続を即座に生成
                if (this.shouldShowConnections(this.currentStage)) {
                    setTimeout(() => {
                        this.updateConnections(true); // 強制更新で即座に接続表示
                    }, 200); // パーティクル配置完了を待つ
                }
            }
            
            // I(E)ステージ以降かどうかを判定
            isColorfulStage(stageId) {
                const colorfulStages = ['IE', 'Ia', 'Ib', 'Ic'];
                return colorfulStages.includes(stageId);
            }
            
            // I(E)ステージ以降で接続線を表示するかを判定
            shouldShowConnections(stageId) {
                const connectionStages = ['IE', 'Ia', 'Ib', 'Ic'];
                return connectionStages.includes(stageId);
            }
            
            // ステージに応じた最大接続数を取得
            getMaxConnectionsForStage(stageId) {
                return this.stageConnectionLimits[stageId] || this.maxConnections;
            }
            
            // パーティクル間の距離を計算
            calculateParticleDistance(particle1, particle2) {
                return particle1.position.distanceTo(particle2.position);
            }
            
            // 適切な接続パターンを選択（ハブ型・連鎖型・相互連結型など）
            selectConnectionPairs() {
                if (!this.shouldShowConnections(this.currentStage) || this.particles.length < 2) {
                    return [];
                }
                
                const connections = [];
                const usedParticles = new Set();
                const maxDistance = 4.5; // 最大接続距離
                const minDistance = 0.5; // 最小接続距離
                
                // 現在のステージに応じた最大接続数を取得
                const stageMaxConnections = this.getMaxConnectionsForStage(this.currentStage);
                
                // ステージ別の接続パターンを設定
                let patterns;
                if (this.currentStage === 'I-E') {
                    // I-Eステージ：内なる声を聴く - 控えめで思慮深い接続
                    patterns = [
                        { type: 'contemplative_pairs', weight: 0.4 },  // 思索的なペア接続
                        { type: 'chain', weight: 0.3 },                // 連鎖型（思考の流れ）
                        { type: 'triangle', weight: 0.2 },             // 小さな三角形（内的対話）
                        { type: 'introspective_hub', weight: 0.1 }     // 内省的ハブ
                    ];
                } else if (this.currentStage === 'IE') {
                    // IEステージ：シンプルな接続パターンのみ
                    patterns = [
                        { type: 'chain', weight: 0.5 },     // 連鎖型（シンプルな繋がり）
                        { type: 'triangle', weight: 0.3 },  // 三角形（基本的な相互連結）
                        { type: 'hub', weight: 0.2 }        // ハブ型（少数）
                    ];
                } else if (this.currentStage === 'Ic') {
                    // Icステージ：極めて豊富で複雑な接続パターン（完全なコミットメント段階）
                    patterns = [
                        { type: 'dense_network', weight: 0.25 },  // 密な全体ネットワーク
                        { type: 'multi_hub', weight: 0.2 },       // 複数ハブ型
                        { type: 'triangle', weight: 0.15 },       // 三角形（相互連結）
                        { type: 'star', weight: 0.15 },           // 星型（中心から放射）
                        { type: 'chain', weight: 0.1 },           // 連鎖型
                        { type: 'hub', weight: 0.1 },             // 単一ハブ型
                        { type: 'cycle', weight: 0.05 }           // 循環型
                    ];
                } else {
                    // その他のステージ：標準的なパターン
                    patterns = [
                        { type: 'hub', weight: 0.3 },        // ハブ型（1つの中心に複数接続）
                        { type: 'chain', weight: 0.25 },     // 連鎖型（A→B→C→D）
                        { type: 'triangle', weight: 0.2 },   // 三角形（相互連結）
                        { type: 'star', weight: 0.15 },      // 星型（中心から放射）
                        { type: 'cycle', weight: 0.1 }       // 循環型（A→B→C→A）
                    ];
                }
                
                // 距離マトリックスを計算
                const distanceMatrix = this.calculateDistanceMatrix();
                
                // パターンを順次生成（ステージ別の制限まで）
                let maxAttempts;
                if (this.currentStage === 'IE') {
                    maxAttempts = 3; // IEステージは少なめ
                } else if (this.currentStage === 'Ic') {
                    maxAttempts = 15; // Icステージは大幅に増加（複雑なネットワーク生成）
                } else {
                    maxAttempts = 6; // その他のステージは標準
                }
                
                for (let attempt = 0; attempt < maxAttempts && connections.length < stageMaxConnections; attempt++) {
                    const pattern = this.selectRandomPattern(patterns);
                    const patternConnections = this.generateConnectionPattern(
                        pattern.type, distanceMatrix, usedParticles, maxDistance, minDistance
                    );
                    
                    if (patternConnections.length > 0) {
                        connections.push(...patternConnections);
                    }
                }
                
                return connections;
            }
            
            // 距離マトリックスを計算
            calculateDistanceMatrix() {
                const matrix = [];
                for (let i = 0; i < this.particles.length; i++) {
                    matrix[i] = [];
                    for (let j = 0; j < this.particles.length; j++) {
                        if (i === j) {
                            matrix[i][j] = 0;
                        } else {
                            matrix[i][j] = this.calculateParticleDistance(this.particles[i], this.particles[j]);
                        }
                    }
                }
                return matrix;
            }
            
            // ランダムなパターンを選択
            selectRandomPattern(patterns) {
                const random = Math.random();
                let cumulative = 0;
                
                for (const pattern of patterns) {
                    cumulative += pattern.weight;
                    if (random <= cumulative) {
                        return pattern;
                    }
                }
                return patterns[patterns.length - 1];
            }
            
            // 指定されたパターンで接続を生成
            generateConnectionPattern(patternType, distanceMatrix, usedParticles, maxDistance, minDistance) {
                switch (patternType) {
                    case 'hub':
                        return this.generateHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'chain':
                        return this.generateChainPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'triangle':
                        return this.generateTrianglePattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'star':
                        return this.generateStarPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'cycle':
                        return this.generateCyclePattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'dense_network':
                        return this.generateDenseNetworkPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'multi_hub':
                        return this.generateMultiHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'contemplative_pairs':
                        return this.generateContemplativePairsPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'introspective_hub':
                        return this.generateIntrospectiveHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    default:
                        return [];
                }
            }
            
            // ハブ型パターン：1つの中心パーティクルに3-5個が接続
            generateHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 4) return [];
                
                // 中心となるパーティクルを選択
                const hubIndex = availableParticles[Math.floor(Math.random() * availableParticles.length)];
                usedParticles.add(hubIndex);
                
                // ハブからの接続数を決定（IEステージは控えめに）
                let connectionCount;
                if (this.currentStage === 'IE') {
                    connectionCount = 2 + Math.floor(Math.random() * 2); // 2-3個（控えめ）
                } else {
                    connectionCount = 3 + Math.floor(Math.random() * 3); // 3-5個（通常）
                }
                const connections = [];
                
                // ハブに接続する候補を距離順にソート
                const candidates = availableParticles
                    .filter(i => i !== hubIndex && !usedParticles.has(i))
                    .map(i => ({ index: i, distance: distanceMatrix[hubIndex][i] }))
                    .filter(c => c.distance >= minDistance && c.distance <= maxDistance)
                    .sort((a, b) => a.distance - b.distance);
                
                // 上位候補から接続
                for (let i = 0; i < Math.min(connectionCount, candidates.length); i++) {
                    const targetIndex = candidates[i].index;
                    connections.push({ pair: [hubIndex, targetIndex], type: 'hub' });
                    usedParticles.add(targetIndex);
                }
                
                return connections;
            }
            
            // 連鎖型パターン：A→B→C→D の線形接続
            generateChainPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 3) return [];
                
                // 連鎖の長さを決定（IEステージは短めに）
                let chainLength;
                if (this.currentStage === 'IE') {
                    chainLength = 2 + Math.floor(Math.random() * 2); // 2-3個（短い連鎖）
                } else {
                    chainLength = 3 + Math.floor(Math.random() * 3); // 3-5個（通常）
                }
                
                const chain = [availableParticles[Math.floor(Math.random() * availableParticles.length)]];
                usedParticles.add(chain[0]);
                
                // 連鎖を構築
                for (let i = 1; i < chainLength; i++) {
                    const lastIndex = chain[i - 1];
                    const candidates = availableParticles
                        .filter(j => !usedParticles.has(j))
                        .map(j => ({ index: j, distance: distanceMatrix[lastIndex][j] }))
                        .filter(c => c.distance >= minDistance && c.distance <= maxDistance)
                        .sort((a, b) => a.distance - b.distance);
                    
                    if (candidates.length === 0) break;
                    
                    const nextIndex = candidates[0].index;
                    chain.push(nextIndex);
                    usedParticles.add(nextIndex);
                }
                
                // 連鎖の接続を作成
                const connections = [];
                for (let i = 0; i < chain.length - 1; i++) {
                    connections.push({ pair: [chain[i], chain[i + 1]], type: 'chain' });
                }
                
                return connections;
            }
            
            // 三角形パターン：3つのパーティクルが相互に接続
            generateTrianglePattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 3) return [];
                
                // 最初の2つのパーティクルを選択
                const first = availableParticles[Math.floor(Math.random() * availableParticles.length)];
                const secondCandidates = availableParticles
                    .filter(i => i !== first)
                    .map(i => ({ index: i, distance: distanceMatrix[first][i] }))
                    .filter(c => c.distance >= minDistance && c.distance <= maxDistance);
                
                if (secondCandidates.length === 0) return [];
                
                const second = secondCandidates[Math.floor(Math.random() * secondCandidates.length)].index;
                
                // 3つ目のパーティクルを選択（両方に適切な距離）
                const thirdCandidates = availableParticles
                    .filter(i => i !== first && i !== second)
                    .filter(i => {
                        const d1 = distanceMatrix[first][i];
                        const d2 = distanceMatrix[second][i];
                        return d1 >= minDistance && d1 <= maxDistance && 
                               d2 >= minDistance && d2 <= maxDistance;
                    });
                
                if (thirdCandidates.length === 0) return [];
                
                const third = thirdCandidates[Math.floor(Math.random() * thirdCandidates.length)];
                
                // 使用済みとしてマーク
                usedParticles.add(first);
                usedParticles.add(second);
                usedParticles.add(third);
                
                return [
                    { pair: [first, second], type: 'triangle' },
                    { pair: [second, third], type: 'triangle' },
                    { pair: [third, first], type: 'triangle' }
                ];
            }
            
            // 星型パターン：中心から放射状に接続
            generateStarPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                return this.generateHubPattern(distanceMatrix, usedParticles, maxDistance * 1.2, minDistance);
            }
            
            // 循環型パターン：A→B→C→D→A の循環接続
            generateCyclePattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const chainConnections = this.generateChainPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                if (chainConnections.length < 2) return chainConnections;
                
                // すべてを循環タイプに変更
                chainConnections.forEach(connection => connection.type = 'cycle');
                
                // 最後と最初を接続して循環にする
                const firstParticle = chainConnections[0].pair[0];
                const lastParticle = chainConnections[chainConnections.length - 1].pair[1];
                const distance = distanceMatrix[lastParticle][firstParticle];
                
                if (distance >= minDistance && distance <= maxDistance) {
                    chainConnections.push({ pair: [lastParticle, firstParticle], type: 'cycle' });
                }
                
                return chainConnections;
            }
            
            // 密なネットワークパターン：Icステージ用の豊富な相互接続
            generateDenseNetworkPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 6) return [];
                
                const connections = [];
                const selectedParticles = [];
                
                // 6-8個のパーティクルを選択
                const networkSize = Math.min(6 + Math.floor(Math.random() * 3), availableParticles.length);
                
                for (let i = 0; i < networkSize; i++) {
                    const index = availableParticles[Math.floor(Math.random() * availableParticles.length)];
                    if (!selectedParticles.includes(index)) {
                        selectedParticles.push(index);
                        usedParticles.add(index);
                    }
                }
                
                // 選択されたパーティクル間で密な接続を作成
                for (let i = 0; i < selectedParticles.length; i++) {
                    for (let j = i + 1; j < selectedParticles.length; j++) {
                        const particle1 = selectedParticles[i];
                        const particle2 = selectedParticles[j];
                        const distance = distanceMatrix[particle1][particle2];
                        
                        if (distance >= minDistance && distance <= maxDistance) {
                            // 60%の確率で接続（密だが全てではない）
                            if (Math.random() < 0.6) {
                                connections.push({ pair: [particle1, particle2], type: 'dense_network' });
                            }
                        }
                    }
                }
                
                return connections;
            }
            
            // 複数ハブパターン：Icステージ用の複数の中心点を持つネットワーク
            generateMultiHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 8) return [];
                
                const connections = [];
                const hubCount = 2 + Math.floor(Math.random() * 2); // 2-3個のハブ
                const hubs = [];
                
                // ハブを選択
                for (let h = 0; h < hubCount && availableParticles.length > 0; h++) {
                    const hubIndex = availableParticles.splice(Math.floor(Math.random() * availableParticles.length), 1)[0];
                    hubs.push(hubIndex);
                    usedParticles.add(hubIndex);
                }
                
                // 各ハブから接続を作成
                hubs.forEach(hubIndex => {
                    const remainingParticles = availableParticles.filter(i => !usedParticles.has(i));
                    const connectionsPerHub = 2 + Math.floor(Math.random() * 3); // 2-4個の接続
                    
                    const candidates = remainingParticles
                        .map(i => ({ index: i, distance: distanceMatrix[hubIndex][i] }))
                        .filter(c => c.distance >= minDistance && c.distance <= maxDistance)
                        .sort((a, b) => a.distance - b.distance);
                    
                    for (let i = 0; i < Math.min(connectionsPerHub, candidates.length); i++) {
                        const targetIndex = candidates[i].index;
                        connections.push({ pair: [hubIndex, targetIndex], type: 'multi_hub' });
                        usedParticles.add(targetIndex);
                    }
                });
                
                // ハブ同士も接続する可能性
                for (let i = 0; i < hubs.length; i++) {
                    for (let j = i + 1; j < hubs.length; j++) {
                        const distance = distanceMatrix[hubs[i]][hubs[j]];
                        if (distance >= minDistance && distance <= maxDistance && Math.random() < 0.4) {
                            connections.push({ pair: [hubs[i], hubs[j]], type: 'multi_hub' });
                        }
                    }
                }
                
                return connections;
            }

            // 思索的ペアパターン：I-Eステージ用 - 内なる声を聴く過程での慎重な対話
            generateContemplativePairsPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 2) return [];
                
                const connections = [];
                const maxPairs = Math.min(3, Math.floor(availableParticles.length / 2)); // 最大3ペア
                
                // 適度な距離のペアを選択（近すぎず遠すぎず）
                for (let pairCount = 0; pairCount < maxPairs && availableParticles.length >= 2; pairCount++) {
                    const candidates = [];
                    
                    // 利用可能なペアの組み合わせを評価
                    for (let i = 0; i < availableParticles.length; i++) {
                        for (let j = i + 1; j < availableParticles.length; j++) {
                            const idx1 = availableParticles[i];
                            const idx2 = availableParticles[j];
                            const distance = distanceMatrix[idx1][idx2];
                            
                            // 思索に適した距離（中程度の距離を好む）
                            if (distance >= minDistance * 1.5 && distance <= maxDistance * 0.8) {
                                candidates.push({ 
                                    pair: [idx1, idx2], 
                                    distance: distance,
                                    suitability: 1.0 - Math.abs(distance - (maxDistance * 0.5)) / (maxDistance * 0.5)
                                });
                            }
                        }
                    }
                    
                    if (candidates.length === 0) break;
                    
                    // 最適な距離のペアを選択
                    candidates.sort((a, b) => b.suitability - a.suitability);
                    const selectedPair = candidates[0];
                    
                    connections.push({ pair: selectedPair.pair, type: 'contemplative' });
                    
                    // 使用済みに追加
                    usedParticles.add(selectedPair.pair[0]);
                    usedParticles.add(selectedPair.pair[1]);
                    
                    // availableParticlesからも削除
                    const removeIndices = [
                        availableParticles.indexOf(selectedPair.pair[0]),
                        availableParticles.indexOf(selectedPair.pair[1])
                    ].sort((a, b) => b - a); // 降順でソートして後ろから削除
                    
                    removeIndices.forEach(idx => availableParticles.splice(idx, 1));
                }
                
                return connections;
            }

            // 内省的ハブパターン：I-Eステージ用 - 控えめな中心的思考
            generateIntrospectiveHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 3) return [];
                
                const connections = [];
                
                // 中心となるパーティクルを選択（中央に近い位置を好む）
                let hubIndex = availableParticles[0];
                let minCenterDistance = Number.MAX_VALUE;
                
                for (const idx of availableParticles) {
                    const particle = this.particles[idx];
                    const centerDistance = particle.position.length(); // 原点からの距離
                    if (centerDistance < minCenterDistance) {
                        minCenterDistance = centerDistance;
                        hubIndex = idx;
                    }
                }
                
                usedParticles.add(hubIndex);
                
                // 控えめな接続（2-3個のみ）
                const connectionCount = 2 + Math.floor(Math.random() * 2);
                const candidates = availableParticles
                    .filter(i => i !== hubIndex)
                    .map(i => ({ index: i, distance: distanceMatrix[hubIndex][i] }))
                    .filter(c => c.distance >= minDistance && c.distance <= maxDistance * 0.7) // 近めの距離を好む
                    .sort((a, b) => a.distance - b.distance);
                
                for (let i = 0; i < Math.min(connectionCount, candidates.length); i++) {
                    const targetIndex = candidates[i].index;
                    connections.push({ pair: [hubIndex, targetIndex], type: 'introspective' });
                    usedParticles.add(targetIndex);
                }
                
                return connections;
            }

            // 使用可能なパーティクルのインデックスリストを取得
            getAvailableParticles(usedParticles) {
                const available = [];
                for (let i = 0; i < this.particles.length; i++) {
                    if (!usedParticles.has(i)) {
                        available.push(i);
                    }
                }
                return available;
            }
            
            // 接続線を作成（強化版）
            createConnectionLine(particle1, particle2, opacity = 0.4, lineType = 'normal') {
                const points = [particle1.position.clone(), particle2.position.clone()];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                
                // 線の種類に応じた透明度と太さを調整
                let actualOpacity = opacity;
                let lineWidth = 1;
                
                switch (lineType) {
                    case 'hub':        // ハブ接続は少し太く明るく
                        actualOpacity = opacity * 1.3;
                        lineWidth = 2;
                        break;
                    case 'chain':      // 連鎖接続は中程度
                        actualOpacity = opacity * 1.1;
                        lineWidth = 1.5;
                        break;
                    case 'cycle':      // 循環接続は脈動効果
                        actualOpacity = opacity * (0.8 + Math.sin(Date.now() * 0.003) * 0.3);
                        lineWidth = 1.8;
                        break;
                    case 'triangle':   // 相互接続は安定的に明るく
                        actualOpacity = opacity * 1.2;
                        lineWidth = 1.5;
                        break;
                    case 'contemplative': // 思索的接続は控えめで揺らぎあり
                        actualOpacity = opacity * (0.6 + Math.sin(Date.now() * 0.002) * 0.2);
                        lineWidth = 1.2;
                        break;
                    case 'introspective': // 内省的接続はより繊細
                        actualOpacity = opacity * 0.8;
                        lineWidth = 1.0;
                        break;
                        lineWidth = 1.3;
                        break;
                    default:
                        break;
                }
                
                // カラフルステージでは多様な色、それ以外は白〜青のグラデーション
                let color;
                if (this.isColorfulStage(this.currentStage)) {
                    color = this.colorfulParticlePalette[Math.floor(Math.random() * this.colorfulParticlePalette.length)];
                } else {
                    // 接続の種類に応じた色分け
                    const colors = {
                        'hub': 0xffdd44,         // ハブ：金色
                        'chain': 0x44ddff,       // 連鎖：青色
                        'cycle': 0xff44dd,       // 循環：紫色
                        'triangle': 0x44ff88,    // 相互：緑色
                        'dense_network': 0xff8844, // 密なネットワーク：オレンジ色
                        'multi_hub': 0x88ff44,   // 複数ハブ：明るい緑色
                        'normal': 0xcccccc       // 通常：白色
                    };
                    color = colors[lineType] || colors.normal;
                }
                
                const material = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: Math.min(actualOpacity, 0.8),
                    blending: THREE.AdditiveBlending,
                    linewidth: lineWidth  // Note: linewidth は WebGL では制限がある
                });
                
                const line = new THREE.Line(geometry, material);
                line.userData = { lineType: lineType }; // 種類を保存
                return line;
            }
            
            // 接続線を更新（強制更新オプション付き）
            updateConnections(forceUpdate = false) {
                const currentTime = Date.now();
                
                // ステージ別の更新間隔を設定
                let updateInterval;
                if (this.currentStage === 'Ic') {
                    updateInterval = 10000; // Icステージ：10秒間隔（標準的な更新頻度）
                } else if (this.currentStage === 'Ib') {
                    updateInterval = 10000; // Ibステージ：10秒間隔
                } else {
                    updateInterval = this.connectionUpdateInterval; // その他：標準間隔
                }
                
                // 定期的な更新チェック（強制更新の場合はスキップ）
                if (!forceUpdate && currentTime - this.lastConnectionUpdate < updateInterval) {
                    return;
                }
                
                this.lastConnectionUpdate = currentTime;
                
                // 既存の接続線をクリア
                this.clearConnections();
                
                // 新しい接続パターンを選択
                const connectionPairs = this.selectConnectionPairs();
                
                // 接続線を作成
                connectionPairs.forEach(connection => {
                    const [index1, index2] = connection.pair;
                    const lineType = connection.type;
                    const particle1 = this.particles[index1];
                    const particle2 = this.particles[index2];
                    
                    if (particle1 && particle2) {
                        const line = this.createConnectionLine(particle1, particle2, 0.4, lineType);
                        this.scene.add(line);
                        this.connectionLines.push({
                            line: line,
                            particle1Index: index1,
                            particle2Index: index2,
                            lineType: lineType
                        });
                    }
                });
            }
            
            // 接続線をクリア
            clearConnections() {
                this.connectionLines.forEach(connection => {
                    this.scene.remove(connection.line);
                    connection.line.geometry.dispose();
                    connection.line.material.dispose();
                });
                this.connectionLines = [];
            }
            
            // 既存の接続線の位置を更新（動的効果付き）
            updateConnectionPositions() {
                const time = Date.now() * 0.001;
                
                this.connectionLines.forEach(connection => {
                    const particle1 = this.particles[connection.particle1Index];
                    const particle2 = this.particles[connection.particle2Index];
                    
                    if (particle1 && particle2) {
                        const points = [particle1.position.clone(), particle2.position.clone()];
                        connection.line.geometry.setFromPoints(points);
                        connection.line.geometry.attributes.position.needsUpdate = true;
                        
                        // 接続タイプに応じた動的効果
                        if (connection.lineType === 'cycle') {
                            // 循環接続は脈動効果
                            const pulse = 0.3 + 0.4 * (0.5 + 0.5 * Math.sin(time * 3));
                            connection.line.material.opacity = pulse;
                        } else if (connection.lineType === 'hub') {
                            // ハブ接続は徐々に明るくなる効果
                            const glow = 0.4 + 0.3 * (0.5 + 0.5 * Math.sin(time * 1.5));
                            connection.line.material.opacity = glow;
                        } else if (connection.lineType === 'chain') {
                            // 連鎖接続は流れるような効果
                            const flow = 0.3 + 0.3 * (0.5 + 0.5 * Math.sin(time * 2 + connection.particle1Index));
                            connection.line.material.opacity = flow;
                        }
                    }
                });
            }
            
            // カラフルパーティクル用の色を取得
            getColorfulParticleColor(index, time) {
                const paletteIndex = (index + Math.floor(time * 2)) % this.colorfulParticlePalette.length;
                return this.colorfulParticlePalette[paletteIndex];
            }
            
            // パーティクルの色を動的に更新
            updateParticleColorDynamic(particle, index, time) {
                if (this.isColorfulStage(this.currentStage)) {
                    const targetColor = this.getColorfulParticleColor(index, time);
                    const currentColor = particle.material.color;
                    const targetColorObj = new THREE.Color(targetColor);
                    
                    // 滑らかな色変更
                    currentColor.lerp(targetColorObj, this.colorTransitionSpeed);
                }
            }
            
            getStageData(stage) {
                const stageMap = {
                    'Ea': { 
                        particleCount: 20, 
                        color: 0xff6b6b, 
                        description: '外的権威を信頼',
                        behavior: 'chaotic',           // 混沌とした動き
                        cohesion: 0.1,                // 結束度：非常に低い
                        speed: 0.8,                   // 速度：比較的低い
                        pattern: 'random'             // パターン：ランダム
                    },
                    'Eb': { 
                        particleCount: 25, 
                        color: 0xff8e53, 
                        description: '外的権威との緊張',
                        behavior: 'conflicted',       // 対立する動き
                        cohesion: 0.2,
                        speed: 1.2,                   // 緊張で速度上昇
                        pattern: 'opposing'           // 対立パターン
                    },
                    'Ec': { 
                        particleCount: 30, 
                        color: 0xffa726, 
                        description: '欠点の認識',
                        behavior: 'questioning',      // 疑問を示す動き
                        cohesion: 0.3,
                        speed: 0.9,
                        pattern: 'hesitant'           // ためらいのパターン
                    },
                    'EI': { 
                        particleCount: 20,  // 35から20に減少
                        color: 0xffeb3b, 
                        description: '疑問を持つ',
                        behavior: 'questioning_emergence',  // 疑問による出現・消失
                        cohesion: 0.4,
                        speed: 1.0,
                        pattern: 'dynamic_emergence'       // 動的出現パターン
                    },
                    'E-I': { 
                        particleCount: 40, 
                        color: 0xcddc39, 
                        description: '内なる声を構築',
                        behavior: 'building',         // 構築する動き
                        cohesion: 0.5,
                        speed: 1.1,
                        pattern: 'convergent'         // 収束パターン
                    },
                    'I-E': { 
                        particleCount: 45, 
                        color: 0x8bc34a, 
                        description: '内なる声を聴く',
                        behavior: 'listening',        // 聴く動き
                        cohesion: 0.1,                // 低い凝集力（自由な浮遊を維持）
                        speed: 0.5,                   // より静かに聴く
                        pattern: 'pulse'              // 脈動パターン
                    },
                    'IE': { 
                        particleCount: 50, 
                        color: 0x4caf50, 
                        description: '内なる声を育む',
                        behavior: 'nurturing',        // 育む動き
                        cohesion: 0.7,
                        speed: 0.9,
                        pattern: 'growth'             // 成長パターン
                    },
                    'Ia': { 
                        particleCount: 55, 
                        color: 0x26a69a, 
                        description: '内なる声を信頼',
                        behavior: 'trusting',         // 信頼する動き
                        cohesion: 0.8,
                        speed: 1.0,
                        pattern: 'stable_orbit'       // 安定軌道
                    },
                    'Ib': { 
                        particleCount: 60, 
                        color: 0x29b6f6, 
                        description: '内なる基盤',
                        behavior: 'foundation',       // 基盤形成
                        cohesion: 0.9,
                        speed: 0.8,
                        pattern: 'structured'         // 構造化パターン
                    },
                    'Ic': { 
                        particleCount: 65, 
                        color: 0x42a5f5,              // Ibの青をベースにした明るい色
                        description: 'コミットメント確保',
                        behavior: 'committed',        // コミット状態
                        cohesion: 1.0,                // 最高の結束
                        speed: 1.0,
                        pattern: 'wave_rotation'      // 波動回転パターン
                    }
                };
                return stageMap[stage] || stageMap['Ea'];
            }
            
            createControls() {
                // Add mouse controls for camera
                let mouseDown = false;
                let mouseX = 0;
                let mouseY = 0;
                
                const canvas = this.renderer.domElement;
                
                canvas.addEventListener('mousedown', (e) => {
                    mouseDown = true;
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!mouseDown) return;
                    
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    
                    this.camera.position.x += deltaX * 0.01;
                    this.camera.position.y -= deltaY * 0.01;
                    this.camera.lookAt(0, 0, 0);
                    
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                canvas.addEventListener('mouseup', () => {
                    mouseDown = false;
                });
                
                // Touch controls for mobile
                let touchStartX = 0;
                let touchStartY = 0;
                
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                });
                
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - touchStartX;
                    const deltaY = touch.clientY - touchStartY;
                    
                    this.camera.position.x += deltaX * 0.01;
                    this.camera.position.y -= deltaY * 0.01;
                    this.camera.lookAt(0, 0, 0);
                    
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                });
            }
            
            bindEvents() {
                // Stage button clicks
                const stageButtons = document.querySelectorAll('.stage-btn');
                stageButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const stage = btn.dataset.stage;
                        this.switchToStage(stage);
                    });
                });
                
                // View control buttons
                const resetBtn = document.getElementById('reset-view-btn');
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => {
                        this.resetView();
                    });
                }
                
                // Zoom controls via mouse wheel
                if (this.renderer && this.renderer.domElement) {
                    this.renderer.domElement.addEventListener('wheel', (e) => {
                        e.preventDefault();
                        this.handleZoom(e.deltaY);
                    }, { passive: false });
                }
                
                // Window resize
                window.addEventListener('resize', () => {
                    if (this.isInitialized) {
                        this.handleResize();
                    }
                });
            }
            
            switchToStage(stageId) {
                if (!this.isInitialized || this.isTransitioning) return;
                
                // Reset questioning stage specific data when switching stages
                this.persistentParticleIndices.clear();
                
                this.currentStage = stageId;
                
                // 多面体形状の更新
                this.updatePolyhedronShape(stageId);
                
                this.updateStageVisualization(stageId);
                this.updateActiveButton(stageId);
                console.log('Switched to stage:', stageId);
            }

            updatePolyhedronShape(stageId) {
                if (this.isTransitioning) return;
                
                this.isTransitioning = true;
                
                // 現在の形状から新しい形状へのトランジション
                const currentGeometry = this.core?.geometry;
                const newGeometry = this.coreGeometryManager.createPolyhedronGeometry(stageId);
                
                if (currentGeometry && newGeometry) {
                    // フェードアウト → 形状変更 → フェードイン
                    this.animatePolyhedronTransition(currentGeometry, newGeometry, stageId);
                } else {
                    // 初回または緊急時は直接作成
                    this.createPolyhedronCore(stageId);
                    this.isTransitioning = false;
                }
            }

            animatePolyhedronTransition(oldGeometry, newGeometry, stageId) {
                const transitionDuration = 1500; // 1.5秒のトランジション
                const fadeOutDuration = 500;
                const scaleTransitionDuration = 700; // スケール変更期間
                const fadeInDuration = 500;
                
                // 現在のサイズと新しいサイズを取得
                const oldSize = this.coreGeometryManager.getStageSize(this.currentStage);
                const newSize = this.coreGeometryManager.getStageSize(stageId);
                
                // フェードアウト
                const startOpacity = this.core.material.opacity;
                const startScale = this.core.scale.x;
                const fadeOutStart = Date.now();
                
                const fadeOut = () => {
                    const elapsed = Date.now() - fadeOutStart;
                    const progress = Math.min(elapsed / fadeOutDuration, 1);
                    
                    this.core.material.opacity = startOpacity * (1 - progress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(fadeOut);
                    } else {
                        // 形状変更
                        this.createPolyhedronCore(stageId);
                        
                        // スケールトランジション付きフェードイン
                        const targetOpacity = 0.85;
                        this.core.material.opacity = 0;
                        this.core.scale.set(oldSize / newSize, oldSize / newSize, oldSize / newSize); // 古いサイズから開始
                        
                        const fadeInStart = Date.now();
                        
                        const fadeIn = () => {
                            const elapsed = Date.now() - fadeInStart;
                            const progress = Math.min(elapsed / fadeInDuration, 1);
                            
                            // オパシティのフェードイン
                            this.core.material.opacity = targetOpacity * progress;
                            
                            // スケールの滑らかな変化
                            const scaleProgress = Math.min(elapsed / scaleTransitionDuration, 1);
                            const easeOut = 1 - Math.pow(1 - scaleProgress, 3); // イーズアウト
                            const currentScale = (oldSize / newSize) + (1 - oldSize / newSize) * easeOut;
                            this.core.scale.set(currentScale, currentScale, currentScale);
                            
                            if (progress < 1 || scaleProgress < 1) {
                                requestAnimationFrame(fadeIn);
                            } else {
                                // 最終的に正確なスケールに設定
                                this.core.scale.set(1, 1, 1);
                                this.isTransitioning = false;
                                console.log(`サイズ変更完了: ${oldSize.toFixed(2)} → ${newSize.toFixed(2)}`);
                            }
                        };
                        
                        fadeIn();
                    }
                };
                
                fadeOut();
            }
            
            updateStageVisualization(stageId) {
                // スムーズなトランジション効果
                this.transitionToStage(stageId);
                
                // Update core appearance based on stage
                const stageData = this.getStageData(stageId);
                if (this.core) {
                    // Core色をスムーズに変更
                    this.animateCoreColor(stageData.color);
                }
                
                // 段階に応じて次元リングを更新
                this.updateDimensionRings(stageId);
            }
            
            // 段階に応じて次元リングを更新（統一化されたビジュアルシステム）
            updateDimensionRings(stageId) {
                const stageNumber = this.getStageNumber(stageId);
                
                this.dimensionRings.forEach((ring, index) => {
                    if (!ring.userData) return;
                    
                    // 統一化された色調と質感を段階に応じて更新
                    const newColor = this.getDimensionRingColor(index, stageNumber);
                    const newOpacity = this.getDimensionRingOpacity(stageNumber);
                    const newShininess = this.getDimensionRingShininess(stageNumber);
                    const newEmissive = this.getDimensionRingEmissive(index, stageNumber);
                    const newEmissiveIntensity = this.getDimensionRingEmissiveIntensity(stageNumber);
                    
                    // サイズを段階に応じて更新
                    const newRadius = this.getDimensionRingRadius(index, stageNumber);
                    this.updateRingGeometry(ring, newRadius);
                    
                    // 統一化されたマテリアルシステムでスムーズなトランジション
                    this.animateRingProperties(ring, newColor, newOpacity, newShininess, newEmissive, newEmissiveIntensity);
                    
                    // 相互作用パターンを段階に応じて設定
                    ring.userData.interactionStrength = this.getInteractionStrength(stageNumber);
                    ring.userData.synchronizationFactor = this.getSynchronizationFactor(stageNumber);
                    ring.userData.materialEvolution = this.getCoreProgress(stageNumber); // 材質進化度を同期
                });
            }
            
            // リングのジオメトリを新しい半径で更新
            updateRingGeometry(ring, newRadius) {
                // 現在の半径と新しい半径を比較してログ出力
                const currentRadius = ring.geometry.parameters.radius;
                if (Math.abs(currentRadius - newRadius) > 0.1) {
                    console.log(`リング${ring.userData.ringIndex}のサイズ変更: ${currentRadius.toFixed(2)} → ${newRadius.toFixed(2)}`);
                }
                
                // 新しいジオメトリを作成
                const newGeometry = new THREE.TorusGeometry(newRadius, 0.05, 8, 32);
                
                // 古いジオメトリを破棄
                ring.geometry.dispose();
                
                // 新しいジオメトリを適用
                ring.geometry = newGeometry;
            }

            // 段階番号を取得
            getStageNumber(stageId) {
                const stageMap = {
                    'Ea': 1, 'Eb': 2, 'Ec': 3,    // External Authority 1-3
                    'EI': 4,                          // External-Internal (岐路段階の始まり)
                    'E-I': 5,                         // External to Internal
                    'I-E': 6,                         // Internal to External  
                    'IE': 7,                          // Internal-External
                    'Ia': 8, 'Ib': 9, 'Ic': 10    // Internal Authority 8-10
                };
                return stageMap[stageId] || 1;
            }
            
            // 統一化されたリングプロパティのアニメーション
            animateRingProperties(ring, newColor, newOpacity, newShininess, newEmissive, newEmissiveIntensity) {
                // 色のスムーズな変更
                const currentColor = new THREE.Color(ring.material.color);
                const targetColor = new THREE.Color(newColor);
                const currentEmissive = new THREE.Color(ring.material.emissive);
                const targetEmissive = new THREE.Color(newEmissive);
                
                // 統一化されたトランジション（多面体コアと同期）
                ring.material.color.lerp(targetColor, 0.1);
                ring.material.opacity = THREE.MathUtils.lerp(ring.material.opacity, newOpacity, 0.1);
                ring.material.shininess = THREE.MathUtils.lerp(ring.material.shininess, newShininess, 0.1);
                ring.material.emissive.lerp(targetEmissive, 0.1);
                ring.material.emissiveIntensity = THREE.MathUtils.lerp(ring.material.emissiveIntensity, newEmissiveIntensity, 0.1);
                
                // マテリアルの更新が必要であることを示す
                ring.material.needsUpdate = true;
            }
            
            // 段階に応じた相互作用の強度
            getInteractionStrength(stage) {
                if (stage <= 3) {
                    // EA段階: 0.05-0.20 (独立回転)
                    return 0.05 + stage * 0.05;
                } else if (stage <= 7) {
                    // 岐路段階: 0.20-0.80 (同期の始まり〜発展)
                    return 0.20 + (stage - 3) * 0.15;
                } else {
                    // IA段階: 0.80-0.98 (強い相互作用)
                    return 0.80 + (stage - 7) * 0.06;
                }
            }
            
            // 段階に応じた同期度合い
            getSynchronizationFactor(stage) {
                if (stage <= 3) {
                    // EA段階: 0 (完全に独立)
                    return 0;
                } else if (stage <= 7) {
                    // 岐路段階: 0-0.80 (徐々に同期)
                    return (stage - 3) * 0.20;
                } else {
                    // IA段階: 0.80-0.98 (高度な統合)
                    return 0.80 + (stage - 7) * 0.06;
                }
            }
            
            // 段階的進化する次元リングのアニメーション
            animateDimensionRingsEvolution(time) {
                const stageNumber = this.getStageNumber(this.currentStage);
                
                this.dimensionRings.forEach((ring, index) => {
                    if (!ring.userData) return;
                    
                    const userData = ring.userData;
                    const interactionStrength = userData.interactionStrength || 0;
                    const syncFactor = userData.synchronizationFactor || 0;
                    
                    // 基本回転速度の計算
                    let currentSpeed = userData.baseRotationSpeed;
                    
                    // 段階に応じた回転パターン
                    if (stageNumber <= 3) {
                        // 段階1-3: 独立回転（それぞれ独立）
                        ring.rotation.y += currentSpeed * userData.rotationDirection * 0.01;
                        ring.rotation.x = userData.baseRotationX + Math.sin(time * 0.3 + index) * 0.05;
                        
                    } else if (stageNumber <= 6) {
                        // 段階4-6: 弱い相互作用（同期の始まり）
                        const otherRingsInfluence = this.calculateRingInfluence(index, time);
                        const influenceStrength = interactionStrength * 0.5;
                        
                        ring.rotation.y += (currentSpeed + otherRingsInfluence * influenceStrength) * userData.rotationDirection * 0.01;
                        ring.rotation.x = userData.baseRotationX + 
                                         Math.sin(time * 0.4 + index) * 0.08 + 
                                         Math.sin(time * 0.2 + index * 2) * influenceStrength * 0.03;
                        
                    } else {
                        // 段階7-10: 複雑な相互作用（統合された動き）
                        const complexInteraction = this.calculateComplexInteraction(index, time, syncFactor);
                        
                        ring.rotation.y += (currentSpeed + complexInteraction.yInfluence) * userData.rotationDirection * 0.01;
                        ring.rotation.x = userData.baseRotationX + complexInteraction.xInfluence;
                        
                        // 高次段階では軌道も変化
                        const orbitalMotion = this.calculateOrbitalMotion(index, time, syncFactor);
                        ring.position.x = orbitalMotion.x;
                        ring.position.z = orbitalMotion.z;
                    }
                    
                    // すべての段階で色とプロパティの継続的更新
                    this.updateRingAppearanceContinuous(ring, index, stageNumber, time);
                });
            }
            
            // 他のリングからの影響を計算
            calculateRingInfluence(currentIndex, time) {
                let totalInfluence = 0;
                
                this.dimensionRings.forEach((otherRing, otherIndex) => {
                    if (otherIndex !== currentIndex && otherRing.userData) {
                        const distance = Math.abs(currentIndex - otherIndex);
                        const influence = Math.sin(time * 0.3 + otherIndex) / (distance + 1);
                        totalInfluence += influence;
                    }
                });
                
                return totalInfluence * 0.1;
            }
            
            // 複雑な相互作用の計算（高次段階用）
            calculateComplexInteraction(index, time, syncFactor) {
                const phase1 = time * 0.2 + index * Math.PI * 2 / 3;
                const phase2 = time * 0.15 + (index + 1) * Math.PI * 2 / 3;
                const phase3 = time * 0.25 + (index + 2) * Math.PI * 2 / 3;
                
                const yInfluence = (Math.sin(phase1) + Math.sin(phase2) * syncFactor) * 0.3;
                const xInfluence = (Math.sin(phase1) * 0.1 + 
                                  Math.cos(phase2) * syncFactor * 0.08 + 
                                  Math.sin(phase3) * syncFactor * 0.05);
                
                return { yInfluence, xInfluence };
            }
            
            // 軌道運動の計算（最高次段階用）
            calculateOrbitalMotion(index, time, syncFactor) {
                if (syncFactor < 0.5) {
                    return { x: 0, z: 0 }; // 軌道運動なし
                }
                
                const radius = 0.2 * syncFactor;
                const frequency = 0.1 + index * 0.05;
                const phase = index * Math.PI * 2 / 3;
                
                return {
                    x: Math.cos(time * frequency + phase) * radius,
                    z: Math.sin(time * frequency + phase) * radius
                };
            }
            
            // リングの外観の継続的更新
            updateRingAppearanceContinuous(ring, index, stageNumber, time) {
                // 呼吸のような光の変動
                const breathe = Math.sin(time * 0.5 + index) * 0.1 + 1;
                
                // 段階に応じた発光効果
                if (stageNumber >= 7) {
                    // 輝く質感の段階では発光効果を追加
                    const glow = Math.sin(time * 0.8 + index * 2) * 0.3 + 0.7;
                    ring.material.emissive = ring.material.color.clone().multiplyScalar(0.1 * glow);
                }
                
                // 透明度の微調整
                const baseOpacity = this.getDimensionRingOpacity(stageNumber);
                ring.material.opacity = baseOpacity * breathe;
            }

            transitionToStage(newStageId) {
                const oldStageData = this.getStageData(this.currentStage);
                const newStageData = this.getStageData(newStageId);
                
                // 接続線をクリア（全ステージ切り替え時）
                this.clearConnections();
                
                // ステージ切り替え時のコア光量リセット
                if (this.currentStage === 'EI' || newStageId !== 'EI') {
                    this.resetCoreIntensity();
                }
                
                // EIステージ固有の初期化
                if (newStageId === 'EI') {
                    // 既存の疑問フェーズをリセット
                    this.particles.forEach(particle => {
                        if (particle.userData) {
                            particle.userData.questioningPhase = null;
                        }
                    });
                    this.persistentParticleIndices.clear();
                    
                    // 即座に表示するパーティクルを設定（最初の5個）
                    const currentTime = Date.now() * 0.001;
                    this.particles.slice(0, 5).forEach((particle, index) => {
                        if (particle.userData) {
                            // 即座に表示されるパーティクルの初期設定
                            const angle = Math.random() * Math.PI * 2;
                            const radius = 1 + Math.random() * 2.5;
                            const height = (Math.random() - 0.5) * 3;
                            
                            const fixedPosition = {
                                x: radius * Math.cos(angle),
                                y: height,
                                z: radius * Math.sin(angle)
                            };
                            
                            particle.position.set(fixedPosition.x, fixedPosition.y, fixedPosition.z);
                            
                            // フェーズを初期化して即座に表示
                            particle.userData.questioningPhase = {
                                spawnTime: currentTime - 1, // 1秒前に生成されたことにして即座に表示
                                lifespan: 2 + Math.random() * 4,
                                isPersistent: Math.random() < 0.3,
                                fadeInDuration: 0.8,
                                fadeOutDuration: 1.2,
                                hasBeenPersistent: false,
                                fixedPosition: fixedPosition
                            };
                            
                            // 透明度を即座に設定
                            particle.material.opacity = 0.9;
                        }
                    });
                }
                
                // I(E)ステージ以降（Ia、Ib、Ic等）の接続線即座表示
                if (this.shouldShowConnections(newStageId)) {
                    // 接続更新タイマーをリセットして即座に接続を生成
                    this.lastConnectionUpdate = 0;
                    
                    // 少し遅延して接続を強制生成（パーティクルの初期化完了後）
                    setTimeout(() => {
                        this.updateConnections(true); // 強制更新
                    }, 100);
                }
                
                // I-E ステージ専用: パーティクル出現アニメーション初期化
                if (newStageId === 'I-E') {
                    // まず全パーティクルを完全にコア中心に移動・非表示化
                    this.particles.forEach((particle, index) => {
                        if (particle.userData) {
                            // コア中心に移動
                            particle.position.set(0, 0, 0);
                            // 完全に非表示
                            particle.visible = false;
                            particle.material.opacity = 0;
                            particle.scale.setScalar(0.1);
                            
                            // I-Eステージの動作パターンを設定（重要！）
                            particle.userData.behavior = newStageData.behavior;
                            particle.userData.pattern = newStageData.pattern; // 'pulse'に設定
                            particle.userData.cohesion = newStageData.cohesion;
                            particle.userData.speed = newStageData.speed * (0.8 + Math.random() * 0.4);
                            
                            // 出現先の目標位置を計算（放射状配置）
                            const radius = 1 + Math.random() * 4; // 1-5の範囲
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.random() * Math.PI;
                            
                            const targetX = radius * Math.sin(phi) * Math.cos(theta);
                            const targetY = radius * Math.sin(phi) * Math.sin(theta);
                            const targetZ = radius * Math.cos(phi);
                            
                            // 出現アニメーション用データを設定
                            particle.userData.emergenceStartPosition = new THREE.Vector3(0, 0, 0);
                            particle.userData.emergenceTargetPosition = new THREE.Vector3(targetX, targetY, targetZ);
                            
                            // originalPositionを最終目標位置に設定（パルス動作の基準点）
                            particle.userData.originalPosition = new THREE.Vector3(targetX, targetY, targetZ);
                        }
                    });
                    
                    // 出現アニメーション初期化
                    this.initializeIEEmergence();
                }
                
                // 既存パーティクルを新しい動作パターンに段階的に移行
                this.particles.forEach((particle, index) => {
                    if (particle.userData) {
                        // I-Eステージの場合は既に上で処理済み
                        if (newStageId === 'I-E') {
                            // I-Eステージでは色だけ更新（パターンは既に設定済み）
                            if (!this.isColorfulStage(newStageId)) {
                                particle.material.color.setHex(newStageData.color);
                            }
                            return;
                        }
                        
                        // 新しい動作パターンに更新
                        particle.userData.behavior = newStageData.behavior;
                        particle.userData.pattern = newStageData.pattern;
                        particle.userData.cohesion = newStageData.cohesion;
                        particle.userData.speed = newStageData.speed * (0.8 + Math.random() * 0.4);
                        
                        // カラフルステージでない場合は単色に戻す
                        if (!this.isColorfulStage(newStageId)) {
                            this.animateParticleColor(particle, newStageData.color, index * 50);
                        }
                        // カラフルステージの場合は色のトランジションをスキップ（動的に変化するため）
                    }
                });
                
                // パーティクル数の調整
                this.adjustParticleCount(newStageData.particleCount, newStageData.color);
                
                // 段階的光強化システム - ステージ進行に応じて光のベールを更新
                this.updateLightVeils(newStageId);
            }
            
            animateCoreColor(targetColor) {
                if (!this.core) return;
                
                const currentColor = this.core.material.emissive.getHex();
                const targetColorObj = new THREE.Color(targetColor);
                
                // スムーズな色変更アニメーション
                let progress = 0;
                const animateColor = () => {
                    progress += 0.05;
                    if (progress >= 1) {
                        this.core.material.emissive.setHex(targetColor);
                        return;
                    }
                    
                    const currentColorObj = new THREE.Color(currentColor);
                    currentColorObj.lerp(targetColorObj, progress);
                    this.core.material.emissive.copy(currentColorObj);
                    
                    requestAnimationFrame(animateColor);
                };
                animateColor();
            }
            
            animateParticleColor(particle, targetColor, delay = 0) {
                setTimeout(() => {
                    const currentColor = particle.material.color.getHex();
                    const targetColorObj = new THREE.Color(targetColor);
                    
                    let progress = 0;
                    const animateColor = () => {
                        progress += 0.03;
                        if (progress >= 1) {
                            particle.material.color.setHex(targetColor);
                            return;
                        }
                        
                        const currentColorObj = new THREE.Color(currentColor);
                        currentColorObj.lerp(targetColorObj, progress);
                        particle.material.color.copy(currentColorObj);
                        
                        requestAnimationFrame(animateColor);
                    };
                    animateColor();
                }, delay);
            }
            
            // I-E ステージ専用: パーティクル出現アニメーション初期化
            initializeIEEmergence() {
                this.isEmergingIE = true;
                this.emergenceStartTime = Date.now() + this.emergenceDelay;
                this.emergingParticles = [];
                
                // 全パーティクルを出現待ちリストに追加（シャッフルして自然な順序に）
                const particleIndices = this.particles.map((_, index) => index);
                this.shuffleArray(particleIndices);
                
                particleIndices.forEach((index, order) => {
                    this.emergingParticles.push({
                        particleIndex: index,
                        emergenceTime: this.emergenceStartTime + (order * this.particleEmergenceInterval),
                        hasEmerged: false,
                        emergenceProgress: 0
                    });
                });
                
                console.log(`I-E Emergence initialized: ${this.emergingParticles.length} particles scheduled`);
            }
            
            // 配列をシャッフルするヘルパー関数
            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }
            
            adjustParticleCount(targetCount, color) {
                const currentCount = this.particles.length;
                
                if (currentCount < targetCount) {
                    // パーティクルを追加
                    const toAdd = targetCount - currentCount;
                    for (let i = 0; i < toAdd; i++) {
                        setTimeout(() => {
                            this.addSingleParticle(color);
                        }, i * 100); // 段階的に追加
                    }
                } else if (currentCount > targetCount) {
                    // パーティクルを削除
                    const toRemove = currentCount - targetCount;
                    for (let i = 0; i < toRemove; i++) {
                        setTimeout(() => {
                            this.removeSingleParticle();
                        }, i * 50); // 段階的に削除
                    }
                }
            }
            
            updateLightVeils(currentStageId) {
                // 光のベールが表示されないステージの場合は全ベールを非表示
                if (this.noLightVeilStages.includes(currentStageId)) {
                    this.hideAllLightVeils();
                    return;
                }
                
                // ステージ進行順序に基づいて現在のステージまでの光のベールを表示
                const currentIndex = this.stageProgressionOrder.indexOf(currentStageId);
                
                if (currentIndex === -1) {
                    // 進行順序にないステージの場合も全ベールを非表示
                    this.hideAllLightVeils();
                    return;
                }
                
                // 現在のステージまでの光のベールを段階的に表示
                this.lightVeils.forEach((veil, index) => {
                    if (index <= currentIndex) {
                        // 段階的にフェードイン - より滑らかなアニメーション
                        setTimeout(() => {
                            veil.visible = true;
                            veil.userData.visible = true;
                            veil.userData.fadingIn = true; // フェードイン状態フラグ
                            veil.userData.fadeStartTime = Date.now(); // フェード開始時刻
                            veil.userData.fadeDuration = 2000; // 2秒間でフェードイン
                            
                            // 初期状態を完全透明に設定
                            if (veil.material.uniforms) {
                                veil.material.uniforms.opacity.value = 0;
                                veil.material.uniforms.emissiveIntensity.value = 0;
                            } else {
                                veil.material.opacity = 0;
                                if (veil.material.emissiveIntensity !== undefined) {
                                    veil.material.emissiveIntensity = 0;
                                }
                            }
                            
                        }, index * 500); // 各ベールを500ms間隔で段階的に表示（少し長めに）
                    } else {
                        // まだ到達していないステージのベールは非表示
                        veil.visible = false;
                        veil.userData.visible = false;
                        veil.userData.fadingIn = false;
                    }
                });
                
                // ステージインデックスを更新
                this.currentStageIndex = currentIndex;
            }
            
            hideAllLightVeils() {
                // 全ての光のベールを非表示にする（フェードアウト効果付き）
                this.lightVeils.forEach((veil, index) => {
                    if (veil.visible) {
                        // フェードアウトアニメーション
                        veil.userData.fadingOut = true;
                        veil.userData.fadeOutStartTime = Date.now();
                        veil.userData.fadeOutDuration = 1000; // 1秒間でフェードアウト
                        
                        // シェーダーマテリアル対応の初期値記録
                        if (veil.material.uniforms) {
                            veil.userData.fadeOutStartOpacity = veil.material.uniforms.opacity.value;
                            veil.userData.fadeOutStartEmissive = veil.material.uniforms.emissiveIntensity.value;
                        } else {
                            veil.userData.fadeOutStartOpacity = veil.material.opacity;
                            veil.userData.fadeOutStartEmissive = veil.material.emissiveIntensity || 0;
                        }
                        
                        veil.userData.fadingIn = false; // フェードインを停止
                    }
                });
                this.currentStageIndex = -1; // ベールなし状態
            }
            
            addSingleParticle(color) {
                // 経験のメタファーとしてランダムなサイズを生成
                const baseSize = 0.04;
                const sizeVariation = 0.5 + Math.random() * 1.3; // 0.5 - 1.8倍
                const particleSize = baseSize * sizeVariation;
                
                // 段階に応じたサイズ調整
                const stageNumber = this.getStageNumber(this.currentStage);
                let stageSizeMultiplier = 1.0;
                
                if (stageNumber >= 8) { // Ia, Ib, Ic段階
                    stageSizeMultiplier = 1.0 + (stageNumber - 7) * 0.15;
                } else if (stageNumber >= 5) { // E-I, I-E, IE段階
                    stageSizeMultiplier = 1.0 + (stageNumber - 4) * 0.08;
                }
                
                const finalSize = particleSize * stageSizeMultiplier;
                const geometry = new THREE.SphereGeometry(finalSize, 12, 12); // ランダムサイズ適用、品質も向上
                
                // カラフルステージの場合は初期色をランダムに設定
                const initialColor = this.isColorfulStage(this.currentStage) ? 
                    this.colorfulParticlePalette[Math.floor(Math.random() * this.colorfulParticlePalette.length)] : 
                    color;
                
                // サイズに応じた視覚的効果の調整
                const sizeRatio = finalSize / baseSize; // サイズ比を計算
                const baseOpacity = 0.0; // addSingleParticleは0から開始
                const sizeAdjustedEmissive = Math.floor(0x111111 * (0.8 + sizeRatio * 0.4)); // 大きいほど少し明るく発光
                const sizeAdjustedShininess = 80 + (sizeRatio - 1) * 40; // サイズに応じて光沢度調整
                
                const material = new THREE.MeshPhongMaterial({ 
                    color: initialColor,
                    transparent: true,
                    opacity: baseOpacity,  // 初期は0
                    emissive: sizeAdjustedEmissive,  // サイズ調整された発光
                    shininess: Math.max(50, Math.min(150, sizeAdjustedShininess))  // 光沢範囲制限
                });
                const particle = new THREE.Mesh(geometry, material);
                
                // ランダムな位置に配置
                const radius = 1 + Math.random() * 5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                particle.position.x = radius * Math.sin(phi) * Math.cos(theta);
                particle.position.y = radius * Math.sin(phi) * Math.sin(theta);
                particle.position.z = radius * Math.cos(phi);
                
                // ユーザーデータを設定
                const stageData = this.getStageData(this.currentStage);
                particle.userData = {
                    originalPosition: particle.position.clone(),
                    baseRadius: radius,
                    baseTheta: theta,
                    basePhi: phi,
                    personalityFactor: Math.random(),
                    phaseOffset: Math.random() * Math.PI * 2,
                    speed: stageData.speed * (0.8 + Math.random() * 0.4),
                    cohesion: stageData.cohesion,
                    behavior: stageData.behavior,
                    pattern: stageData.pattern,
                    age: 0,
                    targetPosition: new THREE.Vector3(),
                    // サイズ関連情報を追加
                    originalSize: finalSize,
                    sizeRatio: sizeRatio,
                    baseSize: baseSize,
                    sizeVariation: sizeVariation
                };
                
                // フェードイン効果
                let opacity = 0;
                const fadeIn = () => {
                    opacity += 0.02;
                    if (opacity >= 0.8) {
                        particle.material.opacity = 0.8;
                        return;
                    }
                    particle.material.opacity = opacity;
                    requestAnimationFrame(fadeIn);
                };
                fadeIn();
                
                this.scene.add(particle);
                this.particles.push(particle);
            }
            
            removeSingleParticle() {
                if (this.particles.length === 0) return;
                
                const particle = this.particles.pop();
                
                // フェードアウト効果
                let opacity = particle.material.opacity;
                const fadeOut = () => {
                    opacity -= 0.05;
                    if (opacity <= 0) {
                        this.scene.remove(particle);
                        particle.geometry.dispose();
                        particle.material.dispose();
                        return;
                    }
                    particle.material.opacity = opacity;
                    requestAnimationFrame(fadeOut);
                };
                fadeOut();
            }
            
            updateActiveButton(stageId) {
                const buttons = document.querySelectorAll('.stage-btn');
                buttons.forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.stage === stageId) {
                        btn.classList.add('active');
                    }
                });
                
                // 段階情報表示を更新
                this.updateStageInfo(stageId);
            }
            
            updateStageInfo(stageId) {
                const stageData = this.getStageData(stageId);
                const titleElement = document.getElementById('current-stage-title');
                const descElement = document.getElementById('current-stage-description');
                
                if (titleElement && descElement) {
                    titleElement.textContent = `${stageId}: ${stageData.description}`;
                    
                    // 段階に応じた詳細説明
                    const behaviorDescriptions = {
                        'chaotic': '混沌とした状態から成長が始まります',
                        'conflicted': '内面に対立する力が働いています',
                        'questioning': '疑問と気づきが生まれています',
                        'questioning_emergence': '疑問により様々な経験が思い浮かび、大切なものは心に残り続けます',
                        'searching': '新しい可能性を探索しています',
                        'building': '内なる基盤を構築しています',
                        'listening': '内なる声に耳を傾けています',
                        'nurturing': '自己の成長を育んでいます',
                        'trusting': '内なる声を信頼し始めています',
                        'foundation': '確固とした基盤を築いています',
                        'committed': '基盤の上で波のように躍動しながら完全なコミットメントを実現しています'
                    };
                    
                    descElement.textContent = behaviorDescriptions[stageData.behavior] || stageData.description;
                }
            }
            
            resetView() {
                this.camera.position.set(0, 0, this.defaultCameraZ);
                this.camera.lookAt(0, 0, 0);
            }
            
            handleZoom(deltaY) {
                if (!this.camera) return;
                
                // Zoom direction: positive deltaY = zoom out, negative deltaY = zoom in
                const zoomDirection = deltaY > 0 ? 1 : -1;
                const zoomAmount = zoomDirection * this.zoomSpeed;
                
                // Calculate new camera position
                const currentZ = this.camera.position.z;
                const newZ = currentZ + zoomAmount;
                
                // Clamp zoom within bounds
                const clampedZ = Math.max(this.minZoom, Math.min(this.maxZoom, newZ));
                
                // Apply smooth zoom
                this.camera.position.z = clampedZ;
                
                // Optionally update field of view for more dramatic zoom effect
                // this.camera.fov = Math.max(30, Math.min(75, 75 - (clampedZ - this.defaultCameraZ) * 2));
                // this.camera.updateProjectionMatrix();
            }
            
            handleResize() {
                const width = this.container.offsetWidth;
                const height = this.container.offsetHeight;
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }
            
            startAnimation() {
                const animate = () => {
                    this.animationFrameId = requestAnimationFrame(animate);
                    
                    const time = Date.now() * 0.001;
                    
                    // Core rotation
                    if (this.core) {
                        this.core.rotation.y += 0.005; // ゆっくりとした回転
                        this.core.rotation.x += 0.002;
                    }
                    
                    // 段階的進化する次元リングのアニメーション
                    this.animateDimensionRingsEvolution(time);
                    
                    // I-E ステージ: パーティクル出現アニメーション処理
                    if (this.isEmergingIE) {
                        this.updateIEEmergence();
                    }
                    
                    // Advanced particle animation based on stage behavior
                    this.particles.forEach((particle, index) => {
                        const userData = particle.userData;
                        if (!userData) return;
                        
                        userData.age += 0.016; // Approximate 60fps
                        
                        // Update colorful particles for I(E) stages and beyond
                        this.updateParticleColorDynamic(particle, index, time);
                        
                        this.updateParticleBehavior(particle, index, time);
                    });
                    
                    // Update particle connections for I(E) stages and beyond
                    if (this.shouldShowConnections(this.currentStage)) {
                        this.updateConnections();
                        this.updateConnectionPositions();
                    }
                    
                    // 光のベールの呼吸アニメーション
                    this.animateLightVeils(time);
                    
                    // 多面体コアの回転アニメーション
                    this.animatePolyhedronCore(time);
                    
                    this.renderer.render(this.scene, this.camera);
                };
                animate();
            }

            animatePolyhedronCore(time) {
                if (!this.core || this.isTransitioning) return;
                
                // 段階に応じた回転パターン
                const stageData = this.getStageData(this.currentStage);
                
                switch(this.currentStage) {
                    case 'Ea': case 'Eb': case 'Ec':
                        // 正四面体: 不安定な振動的回転
                        this.core.rotation.x = Math.sin(time * 0.003) * 0.3;
                        this.core.rotation.y += 0.01 + Math.sin(time * 0.002) * 0.005;
                        this.core.rotation.z = Math.cos(time * 0.0025) * 0.2;
                        break;
                        
                    case 'EI': case 'E-I': case 'I-E':
                        // 正八面体: 二重軸回転（葛藤表現）
                        this.core.rotation.x += 0.008;
                        this.core.rotation.y += 0.012;
                        this.core.rotation.z = Math.sin(time * 0.001) * 0.1;
                        break;
                        
                    case 'IE': case 'Ia':
                        // 正十二面体: 調和的な安定回転
                        this.core.rotation.x += 0.005;
                        this.core.rotation.y += 0.008;
                        this.core.rotation.z += 0.003;
                        break;
                        
                    case 'Ib': case 'Ic':
                        // 正二十面体: 複雑で美しい統合回転
                        this.core.rotation.x += 0.004;
                        this.core.rotation.y += 0.006;
                        this.core.rotation.z += 0.002;
                        // 微細な周期的変動
                        const fine = Math.sin(time * 0.001) * 0.05;
                        this.core.rotation.x += fine;
                        this.core.rotation.y += fine * 0.8;
                        this.core.rotation.z += fine * 0.6;
                        break;
                }
                
                // 段階共通: 発光効果の呼吸
                if (this.coreLight) {
                    const baseIntensity = this.baseCoreIntensity;
                    const breathe = Math.sin(time * 0.002) * 0.2 + 1;
                    this.coreLight.intensity = baseIntensity * breathe;
                }
            }
            
            animateLightVeils(time) {
                // 光のベールの呼吸アニメーション - セルフオーサーシップの成長エネルギーを表現
                this.lightVeils.forEach((veil, index) => {
                    const userData = veil.userData;
                    const now = Date.now();
                    
                    // フェードアウト処理
                    if (userData.fadingOut) {
                        const elapsed = now - userData.fadeOutStartTime;
                        const progress = Math.min(elapsed / userData.fadeOutDuration, 1);
                        
                        // イージング関数（ease-in）でフェードアウト
                        const easedProgress = Math.pow(progress, 2);
                        
                        // MeshBasicMaterial用のフェードアウト
                        veil.material.opacity = userData.fadeOutStartOpacity * (1 - easedProgress);
                        const colorFade = 1.0 * (1 - easedProgress);
                        veil.material.color.setRGB(colorFade, colorFade * 0.98, colorFade * 0.95); // 暖かみを保つ
                        
                        // フェードアウト完了チェック
                        if (progress >= 1) {
                            veil.visible = false;
                            veil.userData.visible = false;
                            veil.userData.fadingOut = false;
                        }
                        return; // フェードアウト中は他の処理をスキップ
                    }
                    
                    if (!veil.visible || !veil.userData.visible) return;
                    
                    // フェードインアニメーションの処理
                    if (userData.fadingIn) {
                        const elapsed = now - userData.fadeStartTime;
                        const progress = Math.min(elapsed / userData.fadeDuration, 1);
                        
                        // イージング関数（ease-out）でより自然なフェードイン
                        const easedProgress = 1 - Math.pow(1 - progress, 3);
                        
                        // 目標値の計算 - より透明感のある設定
                        const targetOpacity = 0.005 + userData.stageIndex * 0.002; // 極めて透明に設定
                        const targetEmissive = 0.15 + userData.stageIndex * 0.03;
                        
                        // シェーダーマテリアル用のフェードイン
                        if (veil.material.uniforms) {
                            veil.material.uniforms.opacity.value = targetOpacity * easedProgress;
                            veil.material.uniforms.emissiveIntensity.value = targetEmissive * easedProgress;
                            veil.material.uniforms.time.value = time; // 時間更新
                        } else {
                            // フォールバック：通常のマテリアル
                            veil.material.opacity = targetOpacity * easedProgress;
                            if (veil.material.emissiveIntensity !== undefined) {
                                veil.material.emissiveIntensity = targetEmissive * easedProgress;
                            }
                        }
                        
                        // フェードイン完了チェック
                        if (progress >= 1) {
                            userData.fadingIn = false;
                        }
                        
                        // フェードイン中はスケールアニメーションを控えめに
                        const breatheIntensity = easedProgress * 0.08; // フェードイン進行に応じて強化
                        const breathe = Math.sin(time * userData.breatheSpeed + userData.breathePhase) * breatheIntensity + 1;
                        veil.scale.setScalar(breathe);
                        
                    } else {
                        // 通常の呼吸アニメーション（フェードイン完了後）
                        const breathe = Math.sin(time * userData.breatheSpeed + userData.breathePhase) * 0.08 + 1;
                        veil.scale.setScalar(breathe);
                        
                        // コアとの同期効果（MeshBasicMaterial用）
                        const coreSync = Math.sin(time * 0.5) * 0.02 + 1; // コアとの同期パルス
                        const opacityVariation = Math.sin(time * userData.breatheSpeed * 0.7 + userData.breathePhase) * 0.03;
                        
                        // 基準値にコア同期と呼吸を適用
                        const materialData = veil.material.userData;
                        const baseOpacity = materialData.baseOpacity;
                        
                        // 自然な光の変動 - コアからの放射光として
                        veil.material.opacity = Math.max(0.002, (baseOpacity + opacityVariation) * breathe * coreSync);
                        
                        // 光の色の強度も変動させて光らしさを演出
                        const colorIntensity = 0.85 + (materialData.emissiveStrength * 0.15 * breathe * coreSync);
                        veil.material.color.setRGB(colorIntensity, colorIntensity * 0.98, colorIntensity * 0.95); // 暖かみのある色調
                    }
                });
            }
            
            // I-E ステージ: パーティクル出現アニメーション更新
            updateIEEmergence() {
                const currentTime = Date.now();
                let allEmerged = true;
                
                this.emergingParticles.forEach(emergenceData => {
                    if (emergenceData.hasEmerged) return;
                    
                    // まだ出現時刻に達していない
                    if (currentTime < emergenceData.emergenceTime) {
                        allEmerged = false;
                        return;
                    }
                    
                    const particle = this.particles[emergenceData.particleIndex];
                    if (!particle || !particle.userData) {
                        emergenceData.hasEmerged = true;
                        return;
                    }
                    
                    // 出現アニメーション開始
                    if (!emergenceData.hasEmerged) {
                        const elapsedTime = currentTime - emergenceData.emergenceTime;
                        const emergenceDuration = 1200; // 各パーティクルの出現期間を1.2秒に延長
                        emergenceData.emergenceProgress = Math.min(elapsedTime / emergenceDuration, 1);
                        
                        // より自然なイージング関数（ease-out cubic）
                        const easedProgress = 1 - Math.pow(1 - emergenceData.emergenceProgress, 2.5);
                        
                        // パーティクルを表示
                        particle.visible = true;
                        
                        // 位置: より滑らかな放射状移動
                        const startPos = particle.userData.emergenceStartPosition;
                        const targetPos = particle.userData.emergenceTargetPosition;
                        
                        // 放射方向ベクトルを計算
                        const direction = targetPos.clone().normalize();
                        const maxDistance = targetPos.length();
                        
                        // 加速度的な移動（最初はゆっくり、後で加速）
                        const currentDistance = maxDistance * easedProgress;
                        particle.position.copy(direction.multiplyScalar(currentDistance));
                        
                        // 透明度: より滑らかなフェードイン
                        const opacityProgress = Math.min(emergenceData.emergenceProgress * 1.5, 1);
                        particle.material.opacity = 0.9 * opacityProgress;
                        
                        // スケール: より滑らかなサイズ変化
                        const scaleProgress = Math.min(emergenceData.emergenceProgress * 1.2, 1);
                        const scale = 0.2 + (0.8 * scaleProgress);
                        particle.scale.setScalar(scale);
                        
                        // 軽微な回転効果（生命感を表現）
                        particle.rotation.z = emergenceData.emergenceProgress * Math.PI * 0.5;
                        
                        // 出現完了チェック
                        if (emergenceData.emergenceProgress >= 1) {
                            emergenceData.hasEmerged = true;
                            
                            // パルス動作の初期状態に合わせて位置を設定
                            const basePos = particle.userData.originalPosition;
                            const distance = basePos.length();
                            
                            // 現在の位置からパルス値を逆算して時間オフセットを設定
                            const currentDistance = particle.position.length();
                            const currentPulse = currentDistance / distance;
                            
                            // 現在のパルス値に対応する時間オフセットを計算
                            let targetPulse = Math.max(0.85, Math.min(1.0, currentPulse)); // 0.85-1.0の範囲に制限
                            let normalizedPulse = (targetPulse - 0.925) / 0.075; // -1から1の範囲に正規化
                            normalizedPulse = Math.max(-1, Math.min(1, normalizedPulse)); // 範囲を確実に制限
                            
                            const currentPhase = Math.asin(normalizedPulse);
                            particle.userData.pulseTimeOffset = currentPhase - (Date.now() * 0.001) * 1.2;
                            
                            // パルス動作と同じ計算式を使用して位置を微調整
                            const initialPulse = Math.sin((Date.now() * 0.001) * 1.2 + particle.userData.pulseTimeOffset) * 0.075 + 0.925;
                            const direction = basePos.clone().normalize();
                            const pulsedDistance = distance * initialPulse;
                            
                            particle.position.copy(direction);
                            particle.position.multiplyScalar(pulsedDistance);
                            
                            // 通常の動作に移行するため、初期設定をリセット
                            particle.material.opacity = 0.9;
                            particle.scale.setScalar(1);
                            particle.rotation.z = 0;
                        } else {
                            allEmerged = false;
                        }
                    }
                });
                
                // 全パーティクルの出現完了
                if (allEmerged) {
                    this.isEmergingIE = false;
                    console.log('I-E Emergence animation completed - transitioning to pulse behavior');
                    
                    // 全てのパーティクルのパターンを確実にpulseに設定
                    this.particles.children.forEach(particle => {
                        particle.userData.pattern = 'pulse';
                        particle.userData.cohesion = 0.2;
                        particle.userData.behavior = 'contemplative';
                    });
                    
                    console.log('I-E particles reset to pulse pattern - total particles:', this.particles.children.length);
                    
                    // 通常のpulseパターンに移行するため、出現アニメーションの一時的効果のみリセット
                    this.particles.forEach(particle => {
                        if (particle.userData) {
                            // originalPositionは既に適切に設定済みなので更新しない
                            
                            // 出現アニメーションの一時的な効果をリセット
                            particle.material.opacity = 0.9;
                            particle.scale.setScalar(1);
                            particle.rotation.z = 0;
                            particle.visible = true;
                            
                            // I-Eステージの設定を確実に適用
                            const stageData = this.getStageData('I-E');
                            particle.material.color.setHex(stageData.color);
                            particle.userData.pattern = 'pulse'; // 明示的にpulseパターンに設定
                            particle.userData.behavior = 'listening';
                            particle.userData.cohesion = 0.1; // 低い凝集力
                        }
                    });
                }
            }
            
            updateParticleBehavior(particle, index, time) {
                try {
                    const userData = particle.userData;
                    const stageData = this.getStageData(this.currentStage);
                    
                    // サイズに基づく動的効果の適用
                    if (userData.originalSize && userData.sizeRatio) {
                        // 大きなパーティクルは少しゆっくり動く（重い経験のメタファー）
                        const sizeSpeedModifier = 1.0 / (1.0 + (userData.sizeRatio - 1.0) * 0.3);
                        
                        // 小さなパーティクルは少し活発に動く（新しい経験のメタファー）
                        const sizePulseModifier = userData.sizeRatio < 1.0 ? 
                            1.0 + (1.0 - userData.sizeRatio) * 0.5 : 1.0;
                        
                        // 微細な脈動効果（経験の "生きている" 感覚を表現）
                        const pulse = 1.0 + Math.sin(time * 2.0 + userData.phaseOffset) * 0.05 * sizePulseModifier;
                        particle.scale.setScalar(pulse);
                        
                        // サイズ情報をuserDataに保存（他のアニメーションで使用）
                        userData.currentSpeedModifier = sizeSpeedModifier;
                        userData.currentPulseModifier = sizePulseModifier;
                    }
                    
                    switch (userData.pattern) {
                        case 'random':
                            this.animateRandomBehavior(particle, index, time);
                            break;
                        case 'opposing':
                            this.animateOpposingBehavior(particle, index, time);
                            break;
                        case 'hesitant':
                            this.animateHesitantBehavior(particle, index, time);
                            break;
                        case 'spiral_out':
                            this.animateSpiralOutBehavior(particle, index, time);
                            break;
                        case 'dynamic_emergence':
                            this.animateDynamicEmergenceBehavior(particle, index, time);
                            break;
                        case 'convergent':
                            this.animateConvergentBehavior(particle, index, time);
                            break;
                        case 'pulse':
                            this.animatePulseBehavior(particle, index, time);
                            break;
                        case 'growth':
                            this.animateGrowthBehavior(particle, index, time);
                            break;
                        case 'stable_orbit':
                            this.animateStableOrbitBehavior(particle, index, time);
                            break;
                        case 'structured':
                            this.animateStructuredBehavior(particle, index, time);
                            break;
                        case 'harmonious':
                            this.animateHarmoniousBehavior(particle, index, time);
                            break;
                        case 'wave_rotation':
                            this.animateHarmoniousBehavior(particle, index, time);
                            break;
                        default:
                            // フォールバック: 基本的な動き
                            this.animateRandomBehavior(particle, index, time);
                            break;
                    }
                } catch (error) {
                    console.error('Particle animation error:', error, 'Pattern:', userData?.pattern);
                    // エラーが発生した場合はランダム動作にフォールバック
                    this.animateRandomBehavior(particle, index, time);
                }
            }
            
            // 段階別アニメーション関数群
            animateRandomBehavior(particle, index, time) {
                // Ea: 混沌とした不規則な動き
                const userData = particle.userData;
                const speedModifier = userData.currentSpeedModifier || 1.0;
                const baseSpeed = 0.02 * speedModifier; // サイズに応じた速度調整
                
                const noise = Math.sin(time * 2 + index) * 0.5;
                particle.position.x += (Math.random() - 0.5) * baseSpeed;
                particle.position.y += (Math.random() - 0.5) * baseSpeed;
                particle.position.z += (Math.random() - 0.5) * baseSpeed;
                
                // 境界内に保持
                const distance = particle.position.length();
                if (distance > 6) {
                    particle.position.multiplyScalar(0.9);
                }
            }
            
            animateOpposingBehavior(particle, index, time) {
                // Eb: 対立する力による緊張状態
                const userData = particle.userData;
                const speedModifier = userData.currentSpeedModifier || 1.0;
                const baseIntensity = 0.03 * speedModifier; // サイズに応じた動きの強度調整
                
                const conflictDirection = index % 2 === 0 ? 1 : -1;
                const intensity = Math.sin(time * 3 + index) * conflictDirection;
                
                particle.position.x += Math.cos(time + index) * intensity * baseIntensity;
                particle.position.y += Math.sin(time * 1.5 + index) * intensity * baseIntensity;
                particle.rotation.z += intensity * 0.1 * speedModifier;
            }
            
            animateHesitantBehavior(particle, index, time) {
                // Ec: ためらいと気づきの動き
                const hesitation = Math.sin(time * 0.5 + index) * 0.5 + 0.5;
                const awareness = Math.cos(time * 0.3 + index * 0.1);
                
                particle.position.y += awareness * hesitation * 0.01;
                particle.material.opacity = 0.5 + hesitation * 0.3;
            }
            
            animateSpiralOutBehavior(particle, index, time) {
                // E(I): 外向きスパイラル - 疑問が外に向かう
                const userData = particle.userData;
                const spiralRadius = userData.baseRadius + time * 0.1;
                const spiralAngle = userData.baseTheta + time * userData.speed;
                
                particle.position.x = spiralRadius * Math.cos(spiralAngle);
                particle.position.z = spiralRadius * Math.sin(spiralAngle);
                particle.position.y += Math.sin(time + index) * 0.01;
            }
            
            animateConvergentBehavior(particle, index, time) {
                // E-I: 収束 - 内なる声の構築
                const userData = particle.userData;
                
                // I-Eステージのパーティクルがこのメソッドに来ていないか確認
                if (this.currentStage === 'I-E' && index === 0 && Math.random() < 0.05) {
                    console.warn('I-E stage particle in convergent behavior - pattern:', userData.pattern, 'should be pulse');
                }
                
                const centerPull = userData.cohesion * 0.03; // 少し強化
                const direction = new THREE.Vector3().subVectors(new THREE.Vector3(0, 0, 0), particle.position).normalize();
                
                // より強い中心への吸引力
                particle.position.add(direction.multiplyScalar(centerPull));
                
                // 垂直方向の微細な動きを抑制（より収束に集中）
                particle.position.y += Math.sin(time * 2 + index) * 0.003;
                
                // コア近くでは透明度を下げる（吸い込まれる感覚）
                const distanceToCore = particle.position.length();
                if (distanceToCore < 0.5) {
                    particle.material.opacity = Math.max(0.3, 0.9 * (distanceToCore / 0.5));
                }
            }
            
            animateDynamicEmergenceBehavior(particle, index, time) {
                // E(I): 動的出現・消失 - 疑問による経験の再評価
                const userData = particle.userData;
                
                // 疑問フェーズの管理
                if (!userData.questioningPhase) {
                    // transitionToStageで既に初期化されていない場合のみ初期設定
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 1 + Math.random() * 2.5;
                    const height = (Math.random() - 0.5) * 3;
                    
                    const fixedPosition = {
                        x: radius * Math.cos(angle),
                        y: height,
                        z: radius * Math.sin(angle)
                    };
                    
                    particle.position.set(fixedPosition.x, fixedPosition.y, fixedPosition.z);
                    
                    userData.questioningPhase = {
                        spawnTime: time,
                        lifespan: 1.5 + Math.random() * 4, // 1.5-5.5秒のライフスパン
                        isPersistent: Math.random() < 0.25, // 25%の確率で永続化
                        fadeInDuration: 0.8,
                        fadeOutDuration: 1.2,
                        hasBeenPersistent: false,
                        fixedPosition: fixedPosition
                    };
                }
                
                const phase = userData.questioningPhase;
                const age = time - phase.spawnTime;
                
                // 永続化判定（ライフスパンの70%経過時点で判定）
                if (!phase.hasBeenPersistent && age > phase.lifespan * 0.7 && phase.isPersistent) {
                    phase.hasBeenPersistent = true;
                    this.persistentParticleIndices.add(index);
                    phase.lifespan = Infinity; // 永続化
                }
                
                // フェード処理
                let alpha = 1;
                if (age < phase.fadeInDuration) {
                    // フェードイン
                    alpha = age / phase.fadeInDuration;
                } else if (age > phase.lifespan - phase.fadeOutDuration && phase.lifespan !== Infinity) {
                    // フェードアウト（永続パーティクル以外）
                    alpha = Math.max(0, (phase.lifespan - age) / phase.fadeOutDuration);
                }
                
                // パーティクルの再生成判定
                if (age > phase.lifespan && phase.lifespan !== Infinity) {
                    // 新しい位置で再出現
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 1 + Math.random() * 2.5;
                    const height = (Math.random() - 0.5) * 3;
                    
                    const newFixedPosition = {
                        x: radius * Math.cos(angle),
                        y: height,
                        z: radius * Math.sin(angle)
                    };
                    
                    particle.position.set(newFixedPosition.x, newFixedPosition.y, newFixedPosition.z);
                    
                    // 新しいフェーズを開始
                    userData.questioningPhase = {
                        spawnTime: time,
                        lifespan: 1.5 + Math.random() * 4,
                        isPersistent: Math.random() < 0.25,
                        fadeInDuration: 0.8,
                        fadeOutDuration: 1.2,
                        hasBeenPersistent: false,
                        fixedPosition: newFixedPosition
                    };
                    alpha = 0;
                } else {
                    // 固定位置に留まる（わずかな浮遊感のみ）
                    const basePos = phase.fixedPosition;
                    const gentleFloat = Math.sin(time * 0.5 + index * 0.3) * 0.05; // 非常に微細な浮遊
                    
                    particle.position.x = basePos.x;
                    particle.position.y = basePos.y + gentleFloat;
                    particle.position.z = basePos.z;
                }
                
                // 透明度とスケールの適用
                particle.material.opacity = alpha * 0.95;
                const scale = 0.7 + alpha * 0.5;
                
                // スケール設定の安全な処理
                if (particle.scale) {
                    particle.scale.setScalar(scale);
                } else {
                    particle.scale = new THREE.Vector3(scale, scale, scale);
                }
                
                // 永続パーティクルは少し明るく、より強い発光
                if (this.persistentParticleIndices.has(index)) {
                    if (particle.material.emissive) {
                        particle.material.emissive.setHex(0x666600); // より強い黄色の発光
                    }
                } else {
                    if (particle.material.emissive) {
                        particle.material.emissive.setHex(0x111111);
                    }
                }
            }
            
            animatePulseBehavior(particle, index, time) {
                // I-E: 脈動 - 内なる声を聴く（つかず離れずの状態）
                
                // 出現アニメーション中は通常のpulse動作をスキップ
                if (this.isEmergingIE) {
                    return;
                }
                
                const basePos = particle.userData.originalPosition;
                if (!basePos) return; // originalPositionが設定されていない場合はスキップ
                
                // デバッグ：パターンが正しく設定されているか確認（最初の数回のみ）
                if (index === 0 && Math.random() < 0.01) {
                    console.log('I-E Pulse behavior - pattern:', particle.userData.pattern, 'cohesion:', particle.userData.cohesion);
                }
                
                const distance = basePos.length();
                
                // 時間オフセットを使用した滑らかなパルス（設定されていない場合はindex基準）
                const timeOffset = particle.userData.pulseTimeOffset || (index * 0.15);
                
                // より短い距離での脈動（0.85-1.0の範囲に調整）
                const pulse = Math.sin(time * 1.2 + timeOffset) * 0.075 + 0.925;
                
                // 個別の思案プロセスを表現する微細な揺らぎ
                const contemplation = Math.sin(time * 2.3 + index * 0.3) * 0.03;
                const finalPulse = pulse + contemplation;
                
                // 基準位置からの脈動（コアに向かわず、元の位置周辺で脈動）
                const direction = basePos.clone().normalize();
                const pulsedDistance = distance * finalPulse;
                
                // 位置更新: 元の方向を維持しながら距離だけを脈動
                particle.position.copy(direction);
                particle.position.multiplyScalar(pulsedDistance);
                
                // 軽微な円軌道運動を追加（内なる声を「聴く」動きを表現）
                const orbitAngle = time * 0.3 + index * 0.5;
                const orbitRadius = 0.1;
                const orbitX = Math.cos(orbitAngle) * orbitRadius;
                const orbitZ = Math.sin(orbitAngle) * orbitRadius;
                
                particle.position.x += orbitX;
                particle.position.z += orbitZ;
                
                // 透明度も微細に変動（思考の深さを表現）
                particle.material.opacity = 0.7 + finalPulse * 0.2;
            }
            
            animateGrowthBehavior(particle, index, time) {
                // I(E): 成長パターン - 内なる声を育む
                const growth = Math.min(1, particle.userData.age * 0.1);
                const organic = Math.sin(time + index * 0.5) * growth;
                
                particle.position.y += organic * 0.015;
                particle.scale.setScalar(0.8 + growth * 0.4);
            }
            
            animateStableOrbitBehavior(particle, index, time) {
                // Ia: 安定軌道 - 信頼に基づく安定した動き
                const userData = particle.userData;
                const orbitRadius = userData.baseRadius;
                const orbitSpeed = userData.speed * 0.5;
                const angle = time * orbitSpeed + userData.phaseOffset;
                
                particle.position.x = orbitRadius * Math.cos(angle);
                particle.position.z = orbitRadius * Math.sin(angle);
                particle.position.y = userData.originalPosition.y + Math.sin(angle * 2) * 0.2;
            }
            
            animateStructuredBehavior(particle, index, time) {
                // Ib: 構造化 - 基盤形成（よりオーガニックな配置）
                const userData = particle.userData;
                
                // パーティクル固有のランダム要素を初期化（一度だけ）
                if (!userData.structuredParams) {
                    userData.structuredParams = {
                        layerGroup: Math.floor(index / 5) + Math.floor(index / 8), // より多様な層分布
                        baseAngleOffset: Math.random() * Math.PI * 2, // 各パーティクル固有の角度オフセット
                        radiusVariation: 0.7 + Math.random() * 0.6, // 半径のランダム変動
                        heightOffset: (Math.random() - 0.5) * 0.4, // 高さのランダムオフセット
                        rotationSpeed: 0.8 + Math.random() * 0.4, // 個別の回転速度
                        phaseShift: Math.random() * Math.PI * 2, // 波の位相シフト
                        verticalCenter: (Math.random() - 0.5) * 0.8 // 水平面を中心とした上下分散
                    };
                }
                
                const params = userData.structuredParams;
                const layer = Math.min(params.layerGroup, 4); // 最大5層に制限
                const layerRadius = (1 + layer * 0.7) * params.radiusVariation;
                
                // よりオーガニックな角度計算
                const baseAngle = params.baseAngleOffset + time * 0.2 * params.rotationSpeed;
                const angleNoise = Math.sin(time * 0.5 + params.phaseShift) * 0.3; // 角度のゆらぎ
                const finalAngle = baseAngle + angleNoise;
                
                // 半径にも微細な変動を追加
                const radiusNoise = Math.sin(time * 0.8 + index * 0.1) * 0.2;
                const finalRadius = layerRadius + radiusNoise;
                
                particle.position.x = finalRadius * Math.cos(finalAngle);
                particle.position.z = finalRadius * Math.sin(finalAngle);
                // 水平面（y=0）を中心に上下均等に分散
                particle.position.y = params.verticalCenter + params.heightOffset + Math.sin(time + params.phaseShift) * 0.15;
            }
            
            animateHarmoniousBehavior(particle, index, time) {
                // Ic: 波動回転 - Ibのオーガニック構造をベースに波のうねりと回転を追加
                // 広範囲な経験の結びつきを表現するため、より広い空間分散を実現
                const userData = particle.userData;
                
                // Ibのオーガニック構造パラメータを取得/初期化
                if (!userData.structuredParams) {
                    userData.structuredParams = {
                        layerGroup: Math.floor(index / 5) + Math.floor(index / 8),
                        baseAngleOffset: Math.random() * Math.PI * 2,
                        radiusVariation: 0.7 + Math.random() * 0.6,
                        heightOffset: (Math.random() - 0.5) * 1.2, // 高さの分散を3倍に拡大
                        rotationSpeed: 0.8 + Math.random() * 0.4,
                        phaseShift: Math.random() * Math.PI * 2,
                        verticalCenter: (Math.random() - 0.5) * 1.0 // 水平面を中心とした上下分散
                    };
                }
                
                const params = userData.structuredParams;
                const layer = Math.min(params.layerGroup, 4);
                const baseRadius = (1 + layer * 0.7) * params.radiusVariation;
                const baseAngle = params.baseAngleOffset + time * 0.2 * params.rotationSpeed;
                
                // 波のうねり成分を追加
                const waveFrequency = 0.5;
                const waveAmplitude = 0.4;
                const wavePhase = time * 2 + params.phaseShift;
                const wave = Math.sin(wavePhase * waveFrequency) * waveAmplitude;
                
                // 動的な回転半径（波の影響を受ける）
                const dynamicRadius = baseRadius + wave;
                
                // 基本回転に垂直な波動を追加（高さ方向の動きを拡大）
                const verticalWave = Math.sin(time * 1.5 + params.phaseShift) * 0.5; // 垂直波動を拡大
                const radialWave = Math.cos(time * 0.8 + index * 0.4) * 0.15;
                const angleNoise = Math.sin(time * 0.7 + params.phaseShift) * 0.2;
                
                particle.position.x = (dynamicRadius + radialWave) * Math.cos(baseAngle + angleNoise);
                particle.position.z = (dynamicRadius + radialWave) * Math.sin(baseAngle + angleNoise);
                // 水平面（y=0）を中心に上下均等に分散
                particle.position.y = params.verticalCenter + params.heightOffset + verticalWave + Math.sin(baseAngle * 3 + time) * 0.3;
                
                // より明るく活発な透明度変化
                const brightness = 0.8 + Math.sin(time * 2 + index) * 0.2;
                particle.material.opacity = Math.max(0.6, brightness);
            }
            
            // EI stage: パーティクル吸収とコア光量増加
            absorbParticleIntoCore(particle, index) {
                // パーティクルを削除
                this.scene.remove(particle);
                particle.geometry.dispose();
                particle.material.dispose();
                
                // パーティクル配列から削除
                const particleIndex = this.particles.indexOf(particle);
                if (particleIndex > -1) {
                    this.particles.splice(particleIndex, 1);
                }
                
                // 吸収カウントを増加
                this.absorptionCount++;
                
                // コア光量を増加（段階的に上限まで）
                const intensityIncrease = 0.05; // 1回の吸収での増加量
                this.currentCoreIntensity = Math.min(
                    this.maxCoreIntensity, 
                    this.currentCoreIntensity + intensityIncrease
                );
                
                // コアライトの強度を更新
                if (this.coreLight) {
                    this.coreLight.intensity = this.currentCoreIntensity;
                }
                
                // コア自体の発光も強化
                if (this.core && this.core.material) {
                    const emissiveIntensity = Math.min(0.8, 0.2 + (this.absorptionCount * 0.02));
                    this.core.material.emissive.setRGB(emissiveIntensity, emissiveIntensity, emissiveIntensity);
                }
                
                console.log(`パーティクル吸収: ${this.absorptionCount}個, コア光量: ${this.currentCoreIntensity.toFixed(2)}`);
            }
            
            // コア光量をリセット（ステージ切り替え時など）
            resetCoreIntensity() {
                this.absorptionCount = 0;
                this.currentCoreIntensity = this.baseCoreIntensity;
                
                if (this.coreLight) {
                    this.coreLight.intensity = this.baseCoreIntensity;
                }
                
                if (this.core && this.core.material) {
                    this.core.material.emissive.setRGB(0.27, 0.27, 0.27); // 0x444444相当
                }
            }
            
            cleanup() {
                console.log('3Dリソースをクリーンアップ中...');
                
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                
                // Remove particles
                this.particles.forEach(particle => {
                    this.scene.remove(particle);
                    particle.geometry.dispose();
                    particle.material.dispose();
                });
                this.particles = [];
                
                // Clean up connection lines
                this.clearConnections();
                
                // Remove dimension rings
                this.dimensionRings.forEach(ring => {
                    this.scene.remove(ring);
                    ring.geometry.dispose();
                    ring.material.dispose();
                });
                this.dimensionRings = [];
                
                // Clean up renderer
                if (this.renderer) {
                    const sceneElement = document.getElementById('refined-3d-scene');
                    if (sceneElement && this.renderer.domElement.parentNode === sceneElement) {
                        sceneElement.removeChild(this.renderer.domElement);
                    }
                    this.renderer.dispose();
                    this.renderer = null;
                }
                
                // Clean up scene
                if (this.scene) {
                    while(this.scene.children.length > 0) {
                        const object = this.scene.children[0];
                        if (object.geometry) object.geometry.dispose();
                        if (object.material) object.material.dispose();
                        this.scene.remove(object);
                    }
                    this.scene = null;
                }
                
                this.isInitialized = false;
                console.log('3Dリソースクリーンアップ完了');
            }
        }

        // Global instances
        let refinedVisualization = null;
        let journeyVisualization = null;

        // Enhanced toggleSection function with detailed debugging
        function toggleSection(sectionId) {
            console.log('toggleSection called with:', sectionId);
            const section = document.getElementById(sectionId);
            
            if (!section) {
                console.error('Section not found:', sectionId);
                alert('セクションが見つかりません: ' + sectionId);
                return;
            }
            
            console.log('Section element found:', section);
            section.classList.toggle('active');
            const isActive = section.classList.contains('active');
            console.log('Section', sectionId, 'is now', isActive ? 'active' : 'inactive');
            
            // Handle 3D initialization/cleanup for refined-phases section
            if (sectionId === 'refined-phases') {
                if (isActive) {
                    // Section opened - initialize 3D
                    console.log('精緻化セクションが開かれました - 3D初期化開始');
                    try {
                        if (!refinedVisualization) {
                            console.log('Creating new RefinedSelfAuthorshipVisualization instance');
                            refinedVisualization = new RefinedSelfAuthorshipVisualization();
                        }
                        console.log('Initializing 3D visualization');
                        refinedVisualization.init('refined-3d-container');
                    } catch (error) {
                        console.error('3D初期化エラー:', error);
                        alert('3D初期化エラー: ' + error.message);
                    }
                } else {
                    // Section closed - cleanup 3D
                    console.log('精緻化セクションが閉じられました - 3Dクリーンアップ開始');
                    try {
                        if (refinedVisualization) {
                            refinedVisualization.cleanup();
                        }
                    } catch (error) {
                        console.error('3Dクリーンアップエラー:', error);
                    }
                }
            }
            
            // Handle Canvas 2D initialization/cleanup for detailed-journey section
            if (sectionId === 'detailed-journey') {
                if (isActive) {
                    // Section opened - initialize Canvas 2D
                    console.log('詳細な旅セクションが開かれました - Canvas2D初期化開始');
                    try {
                        console.log('Calling initJourneyVisualization');
                        initJourneyVisualization();
                    } catch (error) {
                        console.error('Canvas2D初期化エラー:', error);
                        alert('Canvas2D初期化エラー: ' + error.message);
                    }
                } else {
                    // Section closed - cleanup Canvas 2D
                    console.log('詳細な旅セクションが閉じられました - Canvas2Dクリーンアップ開始');
                    try {
                        cleanupJourneyVisualization();
                    } catch (error) {
                        console.error('Canvas2Dクリーンアップエラー:', error);
                    }
                }
            }
        }

        // Make toggleSection globally available
        window.toggleSection = toggleSection;

        // Stage click handling for dynamic linking
        document.addEventListener('DOMContentLoaded', function() {
            console.log('セルフオーサーシップ3D統合システム準備完了');
            
            // Add click handlers to stage headings in text for dynamic linking
            setTimeout(() => {
                const stageHeadings = document.querySelectorAll('.sub-phase h4');
                stageHeadings.forEach(heading => {
                    const text = heading.textContent;
                    const stageMatch = text.match(/^(Ea|Eb|Ec|E\(I\)|E-I|I-E|I\(E\)|Ia|Ib|Ic):/);
                    if (stageMatch) {
                        let stageId = stageMatch[1];
                        // Convert special cases
                        if (stageId === 'E(I)') stageId = 'EI';
                        if (stageId === 'I(E)') stageId = 'IE';
                        
                        heading.style.cursor = 'pointer';
                        heading.style.transition = 'all 0.3s';
                        
                        heading.addEventListener('click', () => {
                            if (refinedVisualization && refinedVisualization.isInitialized) {
                                refinedVisualization.switchToStage(stageId);
                                
                                // Scroll to 3D area
                                const container = document.getElementById('refined-3d-container');
                                if (container) {
                                    container.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            }
                        });
                    }
                });
            }, 1000);
        });

        // ===== Canvas 2D ビジュアライゼーション統合コード =====
        
        class EnhancedParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.2;
                this.vy = (Math.random() - 0.5) * 0.2;
                this.baseSize = Math.random() * 3 + 2;
                this.size = this.baseSize;
                this.autonomy = 0.0;
                this.personalDirection = Math.random() * Math.PI * 2;
                this.personalFrequency = 0.01 + Math.random() * 0.02;
                this.vibrationPhase = Math.random() * Math.PI * 2;
                this.shape = 'circle';
                this.connections = [];
                
                // 接続フェードイン制御用プロパティ
                this.connectionFadeOpacity = 0.0;
                this.connectionFadeStartTime = null;
                this.connectionFadeDuration = 1500; // 1.5秒でフェードイン完了
                this.connectionFadeDelay = 1500;    // 1.5秒の遅延後にフェードイン開始
                
                // 色彩システム
                this.originalHue = Math.random() * 360;
                this.currentHue = this.originalHue;
                this.saturation = 30;
                this.lightness = 50;
                this.glow = 0;
                
                // 軌跡システム
                this.trail = [];
                this.maxTrailLength = 20;
            }

            update(stage, mouseX, mouseY, particles) {
                // 軌跡の更新
                this.trail.push({x: this.x, y: this.y, life: 1.0});
                while (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                this.trail.forEach(point => point.life *= 0.95);

                // 段階に応じた挙動
                switch(stage) {
                    case 0: this.updateGravityDominance(mouseX, mouseY); break;
                    case 1: this.updateChaosEdge(mouseX, mouseY); break;
                    case 2: this.updateCreativeScattering(mouseX, mouseY); break;
                    case 3: this.updateCosmicDance(mouseX, mouseY, particles); break;
                }

                // 境界処理
                this.handleBoundaries();
                
                // 位置更新
                this.x += this.vx;
                this.y += this.vy;

                // 摩擦
                this.vx *= 0.99;
                this.vy *= 0.99;
            }

            updateGravityDominance(mouseX, mouseY) {
                // 重力場の影響
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    const force = 0.004;
                    this.vx += (dx / distance) * force;
                    this.vy += (dy / distance) * force;
                }

                // 同調行動
                this.vibrationPhase += this.personalFrequency;
                this.size = this.baseSize + Math.sin(this.vibrationPhase) * 0.5;
                
                // 色彩の統一化
                this.currentHue = 240;
                this.saturation = 40;
                this.lightness = 60;
                this.glow = 0;
                this.autonomy = 0;
                this.shape = 'ellipse';
            }

            updateChaosEdge(mouseX, mouseY) {
                // 外部と内部の力の混在
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    const force = 0.002 * (1 - this.autonomy);
                    this.vx += (dx / distance) * force;
                    this.vy += (dy / distance) * force;
                }

                // 不規則な振動
                this.vibrationPhase += this.personalFrequency * (1 + Math.sin(Date.now() * 0.003) * 0.5);
                this.size = this.baseSize + Math.sin(this.vibrationPhase) * 1.5;
                
                // 自律性の芽生え
                if (Math.random() < 0.01) {
                    this.autonomy = Math.min(0.3, this.autonomy + 0.005);
                }
                
                // 色彩の分化
                this.currentHue = this.originalHue + (Math.sin(this.vibrationPhase) * 30);
                this.saturation = 40 + (this.autonomy * 40);
                this.lightness = 60 + (Math.sin(this.vibrationPhase) * 20);
                this.glow = this.autonomy * 0.3;
                
                // 形状の実験
                const shapeRandom = Math.sin(this.vibrationPhase * 3);
                if (shapeRandom > 0.7) this.shape = 'triangle';
                else if (shapeRandom > 0.3) this.shape = 'square';
                else this.shape = 'circle';
                
                // 個人的な方向性
                const personalForce = 0.001 * this.autonomy;
                this.vx += Math.cos(this.personalDirection) * personalForce;
                this.vy += Math.sin(this.personalDirection) * personalForce;
            }

            updateCreativeScattering(mouseX, mouseY) {
                try {
                    // 入力値の検証
                    if (!isFinite(mouseX) || !isFinite(mouseY)) {
                        mouseX = this.x || 0;
                        mouseY = this.y || 0;
                    }
                    
                    // 初期拡散フェーズ - ステージ移行直後に積極的に拡散
                    if (!this.hasInitialDispersed) {
                        this.hasInitialDispersed = true;
                        this.initialDispersionTimer = 0;
                        
                        // 初期拡散方向をランダムに設定
                        this.dispersalDirection = Math.random() * Math.PI * 2;
                        this.dispersalForce = 0.4 + Math.random() * 0.3; // 0.4-0.7の拡散力（従来の半分程度）
                    }
                    
                    // 初期拡散力の適用（最初の4秒間に延長してより緩やかに）
                    if (this.initialDispersionTimer < 240) { // 60fps * 4秒
                        this.initialDispersionTimer++;
                        const dispersionStrength = Math.max(0, 1 - (this.initialDispersionTimer / 240));
                        
                        this.vx += Math.cos(this.dispersalDirection) * this.dispersalForce * dispersionStrength * 0.01; // 0.02から0.01に減少
                        this.vy += Math.sin(this.dispersalDirection) * this.dispersalForce * dispersionStrength * 0.01;
                    }
                    
                    // 重力からの解放（従来より弱く調整）
                    const dx = mouseX - this.x;
                    const dy = mouseY - this.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // 分母ゼロチェック
                    if (distance < 0.001) {
                        distance = 0.001;
                    }
                    
                    if (isFinite(distance) && distance > 0) {
                        // 重力の影響を大幅に減少（自律性重視）
                        const force = 0.0002 * (1 - this.autonomy) * Math.max(0, 1 - this.autonomy);
                        if (isFinite(force)) {
                            const forceX = (dx / distance) * force;
                            const forceY = (dy / distance) * force;
                            
                            if (isFinite(forceX) && isFinite(forceY)) {
                                this.vx += forceX;
                                this.vy += forceY;
                            }
                        }
                    }

                    // 急速な自律性の発達
                    this.autonomy = Math.min(0.95, this.autonomy + 0.008);
                    
                    // 創造的な軌道（安全性チェック付き）- 拡散力強化
                    if (isFinite(this.personalDirection)) {
                        this.personalDirection += 0.012 + (this.autonomy * 0.02); // 回転速度を少し緩やかに
                        const creativityForce = 0.004 * this.autonomy + 0.001; // 基本創造力を減少
                        
                        // 拡散促進力 - 他のパーティクルとの距離に基づく反発力
                        const expansionForce = 0.002 * this.autonomy; // 拡散力を半分に
                        
                        if (isFinite(creativityForce) && isFinite(expansionForce)) {
                            const baseCreativeX = Math.cos(this.personalDirection) * creativityForce;
                            const baseCreativeY = Math.sin(this.personalDirection) * creativityForce;
                            
                            // 拡散方向への追加力
                            const expansionX = Math.cos(this.personalDirection + Math.PI/4) * expansionForce;
                            const expansionY = Math.sin(this.personalDirection + Math.PI/4) * expansionForce;
                            
                            this.vx += baseCreativeX + expansionX;
                            this.vy += baseCreativeY + expansionY;
                        }
                    } else {
                        this.personalDirection = Math.random() * Math.PI * 2;
                    }

                    // 境界での反発力強化（画面端からの自律的反発）
                    const canvas = document.getElementById('growth-visualization-canvas');
                    if (canvas) {
                        const margin = 50;
                        if (this.x < margin) this.vx += 0.005 * this.autonomy; // 境界反発力も半減
                        if (this.x > canvas.width - margin) this.vx -= 0.005 * this.autonomy;
                        if (this.y < margin) this.vy += 0.005 * this.autonomy;
                        if (this.y > canvas.height - margin) this.vy -= 0.005 * this.autonomy;
                    }

                    // 生き生きとした振動（安全性チェック付き）- 活発性向上
                    if (isFinite(this.vibrationPhase) && isFinite(this.personalFrequency)) {
                        this.vibrationPhase += this.personalFrequency * (2.5 + this.autonomy * 1.5);
                        const sizeModifier = Math.sin(this.vibrationPhase * 2) * (1.2 + this.autonomy * 2.5);
                        if (isFinite(sizeModifier)) {
                            this.size = this.baseSize + sizeModifier;
                        } else {
                            this.size = this.baseSize;
                        }
                    } else {
                        this.vibrationPhase = Math.random() * Math.PI * 2;
                        this.personalFrequency = 0.015 + Math.random() * 0.025; // 振動頻度向上
                        this.size = this.baseSize;
                    }
                    
                    // 独自色彩の確立（安全性チェック付き）- より鮮やかに
                    if (isFinite(this.originalHue) && isFinite(this.personalDirection)) {
                        this.currentHue = this.originalHue + (Math.sin(this.personalDirection) * 90); // 色相変化拡大
                        this.saturation = 70 + (this.autonomy * 25); // 彩度向上
                        this.lightness = 65 + (Math.sin(this.vibrationPhase) * 30); // 明度変化拡大
                        this.glow = this.autonomy * 1.2; // グロー効果強化
                    } else {
                        this.currentHue = this.originalHue || Math.random() * 360;
                        this.saturation = 75;
                        this.lightness = 70;
                        this.glow = 0.7;
                    }
                    
                    // 多様な形状（安全性チェック付き）
                    if (isFinite(this.personalDirection) && isFinite(this.vibrationPhase)) {
                        const uniqueShape = Math.sin(this.personalDirection * 2 + this.vibrationPhase);
                        if (uniqueShape > 0.6) this.shape = 'triangle';
                        else if (uniqueShape > 0.2) this.shape = 'square';
                        else if (uniqueShape > -0.2) this.shape = 'circle';
                        else this.shape = 'ellipse';
                    } else {
                        this.shape = 'circle';
                    }

                    // 摩擦の軽減（自律性が高いほど慣性を保持）
                    const frictionReduction = 1 - (this.autonomy * 0.3);
                    this.vx *= (0.985 + (this.autonomy * 0.01)); // 摩擦軽減
                    this.vy *= (0.985 + (this.autonomy * 0.01)); // 摩擦軽減

                    // 速度制限（発散防止）- 上限緩和
                    const maxVelocity = 2.5 + (this.autonomy * 2.5); // 自律性に応じて最大速度向上（2.5-5.0の範囲）
                    this.vx = Math.max(-maxVelocity, Math.min(maxVelocity, this.vx || 0));
                    this.vy = Math.max(-maxVelocity, Math.min(maxVelocity, this.vy || 0));
                    
                } catch (error) {
                    console.error('updateCreativeScattering error:', error);
                    // エラー時は安全な値にリセット
                    this.autonomy = 0.3;
                    this.size = this.baseSize;
                    this.shape = 'circle';
                    this.vx = (this.vx || 0) * 0.5;
                    this.vy = (this.vy || 0) * 0.5;
                    this.hasInitialDispersed = false;
                    this.personalDirection = Math.random() * Math.PI * 2;
                }
            }

            updateCosmicDance(mouseX, mouseY, particles) {
                // 接続フェードイン制御の初期化
                if (this.connectionFadeStartTime === null) {
                    this.connectionFadeStartTime = Date.now();
                    this.connectionFadeOpacity = 0.0;
                }
                
                // フェードイン進行度の計算
                const currentTime = Date.now();
                const timeSinceStageStart = currentTime - this.connectionFadeStartTime;
                
                if (timeSinceStageStart >= this.connectionFadeDelay) {
                    // 遅延期間経過後、フェードイン開始
                    const fadeProgress = Math.min(1.0, (timeSinceStageStart - this.connectionFadeDelay) / this.connectionFadeDuration);
                    this.connectionFadeOpacity = fadeProgress;
                } else {
                    // まだ遅延期間中
                    this.connectionFadeOpacity = 0.0;
                }
                
                // 相互作用の準備
                this.connections = [];
                
                // パーティクル間相互作用（動的なネットワーク形成）
                particles.forEach(other => {
                    if (other === this) return;
                    
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // 適度な距離を保つための反発力（自律性の維持）
                    const minDistance = 40; // 最小距離（個人空間の確保）
                    if (distance < minDistance && distance > 0) {
                        const repulsionForce = 0.002 * (1 - distance / minDistance);
                        this.vx -= (dx / distance) * repulsionForce;
                        this.vy -= (dy / distance) * repulsionForce;
                    }
                    
                    // 中距離での動的な接続（調和的なネットワーク）
                    const optimalDistance = 80; // 最適な接続距離
                    const maxConnectionDistance = 120; // 最大接続距離
                    
                    if (distance < maxConnectionDistance && distance > minDistance) {
                        // 接続の記録（描画用）
                        this.connections.push({
                            particle: other,
                            strength: Math.max(0, 1 - distance / maxConnectionDistance)
                        });
                        
                        // 最適距離への穏やかな調整力
                        if (distance < optimalDistance) {
                            // 少し離れる方向へ
                            const adjustForce = 0.0003 * (1 - distance / optimalDistance);
                            this.vx -= (dx / distance) * adjustForce;
                            this.vy -= (dy / distance) * adjustForce;
                        } else {
                            // 少し近づく方向へ（弱い引力）
                            const harmonyForce = 0.0004 * (1 - distance / maxConnectionDistance);
                            this.vx += (dx / distance) * harmonyForce;
                            this.vy += (dy / distance) * harmonyForce;
                        }
                    }
                });

                // 最大自律性
                this.autonomy = Math.min(1.0, this.autonomy + 0.002);
                
                // 独自軌道の維持（個性の表現）
                this.personalDirection += 0.008 + (Math.sin(Date.now() * 0.001 + this.originalHue) * 0.008);
                const selfForce = 0.003; // 自律性を強化
                this.vx += Math.cos(this.personalDirection) * selfForce;
                this.vy += Math.sin(this.personalDirection) * selfForce;
                
                // 個人的な振動パターン（独自性の維持） - 方向性を均等に分散
                const personalOscillationX = 0.001 * Math.sin(Date.now() * 0.002 + this.originalHue * 0.1);
                const personalOscillationY = 0.001 * Math.sin(Date.now() * 0.002 + this.originalHue * 0.1 + Math.PI * 0.5);
                this.vx += personalOscillationX;
                this.vy += personalOscillationY;
                
                // 中心への復帰力（画面全体の均等な分布を促進）
                const canvas = document.getElementById('journey-canvas');
                if (canvas) {
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const toCenterX = centerX - this.x;
                    const toCenterY = centerY - this.y;
                    const distanceToCenter = Math.sqrt(toCenterX * toCenterX + toCenterY * toCenterY);
                    
                    // 中心から遠すぎる場合、非常に弱い復帰力を適用
                    const maxRadius = Math.min(canvas.width, canvas.height) * 0.4;
                    if (distanceToCenter > maxRadius) {
                        const returnForce = 0.0002 * (distanceToCenter - maxRadius) / maxRadius;
                        this.vx += (toCenterX / distanceToCenter) * returnForce;
                        this.vy += (toCenterY / distanceToCenter) * returnForce;
                    }
                }

                // 調和的な脈動
                this.vibrationPhase += this.personalFrequency * 1.5;
                this.size = this.baseSize + Math.sin(this.vibrationPhase) * 0.8;
                
                // 成熟した個性的な色彩（多様性の表現）
                const individualityFactor = Math.sin(this.vibrationPhase * 0.3 + this.originalHue * 0.05);
                this.currentHue = this.originalHue + (individualityFactor * 40); // より広い色彩範囲
                this.saturation = 75 + (Math.sin(this.vibrationPhase * 0.7) * 15); // 彩度の変動
                this.lightness = 75 + (Math.sin(this.vibrationPhase * 0.5) * 15); // 明度の変動
                this.glow = 0.4 + (Math.sin(this.vibrationPhase * 0.3) * 0.4); // より動的な輝き
                
                // 創造的な形状変化（創造的散乱と同様のキラキラ効果）
                if (isFinite(this.personalDirection) && isFinite(this.vibrationPhase)) {
                    const harmonicShape = Math.sin(this.personalDirection * 1.5 + this.vibrationPhase * 0.8);
                    const dynamicShape = Math.cos(this.vibrationPhase * 1.2 + this.originalHue * 0.1);
                    
                    // より洗練された形状変化パターン
                    if (harmonicShape > 0.7) {
                        this.shape = 'triangle';
                    } else if (harmonicShape > 0.3) {
                        this.shape = 'square';
                    } else if (dynamicShape > 0.4) {
                        this.shape = 'ellipse';
                    } else {
                        this.shape = 'circle';
                    }
                } else {
                    this.shape = 'circle';
                }
            }

            handleBoundaries() {
                const canvas = document.getElementById('journey-canvas');
                if (!canvas) return;
                
                const margin = this.size + 10;
                
                // 境界での反発を強化し、偏りを防ぐ
                if (this.x < margin) {
                    this.x = margin;
                    this.vx = Math.abs(this.vx) * 0.9; // 反発力を強化
                    // 軽微な上下のランダム要素を追加
                    this.vy += (Math.random() - 0.5) * 0.1;
                }
                if (this.x > canvas.width - margin) {
                    this.x = canvas.width - margin;
                    this.vx = -Math.abs(this.vx) * 0.9; // 反発力を強化
                    // 軽微な上下のランダム要素を追加
                    this.vy += (Math.random() - 0.5) * 0.1;
                }
                if (this.y < margin) {
                    this.y = margin;
                    this.vy = Math.abs(this.vy) * 0.9; // 反発力を強化
                    // 軽微な左右のランダム要素を追加
                    this.vx += (Math.random() - 0.5) * 0.1;
                }
                if (this.y > canvas.height - margin) {
                    this.y = canvas.height - margin;
                    this.vy = -Math.abs(this.vy) * 0.9; // 反発力を強化
                    // 軽微な左右のランダム要素を追加
                    this.vx += (Math.random() - 0.5) * 0.1;
                }
            }

            draw(ctx, stage) {
                // 軌跡描画
                if (stage >= 1) {
                    this.drawTrail(ctx, stage);
                }
                
                // グロー効果
                if (this.glow > 0 && stage >= 2) {
                    this.drawGlow(ctx);
                }
                
                // メインパーティクル
                this.drawParticle(ctx);
                
                // 接続線（最終段階のみ）
                if (stage === 3) {
                    this.drawConnections(ctx);
                }
            }

            drawTrail(ctx, stage) {
                if (this.trail.length < 2) return;
                
                ctx.save();
                
                switch(stage) {
                    case 0:
                        ctx.strokeStyle = `hsla(${this.currentHue}, 30%, 50%, 0.2)`;
                        ctx.lineWidth = 1;
                        break;
                    case 1:
                        ctx.strokeStyle = `hsla(${this.currentHue}, 50%, 60%, 0.3)`;
                        ctx.lineWidth = 1.5;
                        break;
                    case 2:
                        ctx.strokeStyle = `hsla(${this.currentHue}, 70%, 70%, 0.5)`;
                        ctx.lineWidth = 2;
                        break;
                    case 3:
                        const gradient = ctx.createLinearGradient(
                            this.trail[0].x, this.trail[0].y,
                            this.x, this.y
                        );
                        gradient.addColorStop(0, `hsla(${this.currentHue}, 80%, 80%, 0)`);
                        gradient.addColorStop(1, `hsla(${this.currentHue}, 80%, 80%, 0.6)`);
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 3;
                        break;
                }
                
                ctx.beginPath();
                for (let i = 1; i < this.trail.length; i++) {
                    const point = this.trail[i];
                    ctx.globalAlpha = point.life * 0.5;
                    
                    if (i === 1) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                }
                ctx.stroke();
                ctx.restore();
            }

            drawGlow(ctx) {
                ctx.save();
                
                // Stage 3では特に強いグロー効果を適用
                const stage = journeyCurrentStage;
                const glowIntensity = stage === 3 ? this.glow * 0.4 : this.glow * 0.2;
                const glowMultiplier = stage === 3 ? 2.5 : 1.5;
                
                ctx.globalAlpha = glowIntensity;
                const glowSize = this.size * (1.5 + this.glow * glowMultiplier);
                
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, glowSize
                );
                
                // Stage 3では多層グロー効果
                if (stage === 3) {
                    gradient.addColorStop(0, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 20}%, 0.6)`);
                    gradient.addColorStop(0.3, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 15}%, 0.3)`);
                    gradient.addColorStop(0.7, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 10}%, 0.1)`);
                    gradient.addColorStop(1, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 15}%, 0)`);
                } else {
                    gradient.addColorStop(0, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 15}%, 0.4)`);
                    gradient.addColorStop(1, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 15}%, 0)`);
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            drawParticle(ctx) {
                try {
                    ctx.save();
                    ctx.globalAlpha = 1.0;
                    
                    // 値の安全性チェック
                    const hue = isFinite(this.currentHue) ? this.currentHue % 360 : 0;
                    const sat = Math.max(0, Math.min(100, this.saturation || 50));
                    const light = Math.max(0, Math.min(100, this.lightness || 50));
                    const size = Math.max(0.5, Math.min(20, this.size || 2));
                    const rotationAngle = isFinite(this.vibrationPhase) ? this.vibrationPhase : 0;
                    
                    // 位置の安全性チェック
                    const x = isFinite(this.x) ? this.x : 0;
                    const y = isFinite(this.y) ? this.y : 0;
                    
                    // Stage 3では特別なキラキラ効果を追加
                    const stage = journeyCurrentStage;
                    const sparkleIntensity = stage === 3 ? this.glow * 0.8 : 0;
                    
                    ctx.fillStyle = `hsl(${hue}, ${sat}%, ${light}%)`;
                    ctx.strokeStyle = `hsl(${hue}, ${sat}%, ${Math.max(20, light - 20)}%)`;
                    ctx.lineWidth = stage === 3 ? 1.0 : 0.5; // Stage 3では輪郭を強化
                    
                    ctx.translate(x, y);
                    ctx.rotate(rotationAngle);
                    
                    // Stage 3では追加のキラキラエフェクト
                    if (stage === 3 && sparkleIntensity > 0.3) {
                        this.drawSparkles(ctx, size, hue, sat, light);
                    }
                    
                    ctx.beginPath();
                    switch(this.shape) {
                        case 'circle':
                            ctx.arc(0, 0, size, 0, Math.PI * 2);
                            break;
                        case 'ellipse':
                            ctx.scale(1, 0.6);
                            ctx.arc(0, 0, size, 0, Math.PI * 2);
                            break;
                        case 'triangle':
                            ctx.moveTo(0, -size);
                            ctx.lineTo(-size * 0.866, size * 0.5);
                            ctx.lineTo(size * 0.866, size * 0.5);
                            ctx.closePath();
                            break;
                        case 'square':
                            ctx.rect(-size * 0.7, -size * 0.7, size * 1.4, size * 1.4);
                            break;
                        default:
                            // 不明な形状の場合は円にフォールバック
                            ctx.arc(0, 0, size, 0, Math.PI * 2);
                            break;
                    }
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.restore();
                } catch (error) {
                    console.error('drawParticle error:', error);
                    // エラー時は最小限の描画
                    try {
                        ctx.save();
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(this.x || 0, this.y || 0, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    } catch (fallbackError) {
                        console.error('Fallback drawing also failed:', fallbackError);
                    }
                }
            }

            drawConnections(ctx) {
                if (this.connections.length === 0 || this.connectionFadeOpacity <= 0) return;
                
                ctx.save();
                this.connections.forEach((connection, index) => {
                    if (Date.now() % 2 === 0 && index % 2 === 1) return;
                    
                    // フェードイン透明度を適用
                    const baseOpacity = Math.min(0.6, connection.strength * 0.5);
                    ctx.globalAlpha = baseOpacity * this.connectionFadeOpacity;
                    
                    const avgHue = (this.currentHue + connection.particle.currentHue) / 2;
                    ctx.strokeStyle = `hsl(${avgHue % 360}, 60%, 70%)`;
                    ctx.lineWidth = Math.max(0.5, connection.strength * 2);
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(connection.particle.x, connection.particle.y);
                    ctx.stroke();
                });
                ctx.restore();
            }
            
            drawSparkles(ctx, size, hue, sat, light) {
                // キラキラエフェクト用の小さな星状の図形を描画
                ctx.save();
                
                const sparkleCount = 4 + Math.floor(this.glow * 4); // 輝きに応じてスパークル数を調整
                const sparkleRadius = size * 0.3;
                
                for (let i = 0; i < sparkleCount; i++) {
                    const angle = (i / sparkleCount) * Math.PI * 2 + this.vibrationPhase * 0.5;
                    const distance = sparkleRadius + Math.sin(this.vibrationPhase * 2 + i) * sparkleRadius * 0.3;
                    
                    const sparkleX = Math.cos(angle) * distance;
                    const sparkleY = Math.sin(angle) * distance;
                    
                    // スパークルの色は基本色より明るく
                    const sparkleHue = (hue + Math.sin(this.vibrationPhase + i) * 30) % 360;
                    const sparkleBrightness = Math.min(95, light + 20);
                    
                    ctx.globalAlpha = 0.3 + Math.sin(this.vibrationPhase * 3 + i) * 0.3;
                    ctx.fillStyle = `hsl(${sparkleHue}, ${sat}%, ${sparkleBrightness}%)`;
                    
                    // 小さな星形を描画
                    const sparkleSize = size * 0.15 * (0.5 + Math.sin(this.vibrationPhase * 2 + i) * 0.5);
                    ctx.beginPath();
                    for (let j = 0; j < 4; j++) {
                        const starAngle = (j / 4) * Math.PI * 2;
                        const x = sparkleX + Math.cos(starAngle) * sparkleSize;
                        const y = sparkleY + Math.sin(starAngle) * sparkleSize;
                        
                        if (j === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // Canvas 2D ビジュアライゼーション管理
        let journeyCanvas = null;
        let journeyCtx = null;
        let journeyParticles = [];
        let journeyMouseX = 0;
        let journeyMouseY = 0;
        let journeyCurrentStage = 0;
        let journeyAnimationId = null;

        const journeyStageDescriptions = [
            {
                title: "重力の支配",
                description: "外部の権威に従属している状態"
            },
            {
                title: "揺らぎと境界状態", 
                description: "内なる声に耳を傾け、揺らぎが生まれる"
            },
            {
                title: "創造的な散乱",
                description: "個性が芽吹き、自律的な動きを始める"
            },
            {
                title: "創発的相互作用",
                description: "自律的な主体の相互ネットワークの創発"
            }
        ];

        function initJourneyVisualization() {
            console.log('Canvas 2D ビジュアライゼーション初期化開始');
            
            try {
                journeyCanvas = document.getElementById('journey-canvas');
                if (!journeyCanvas) {
                    console.error('Canvas要素が見つかりません');
                    return;
                }
                
                journeyCtx = journeyCanvas.getContext('2d');
                if (!journeyCtx) {
                    console.error('Canvas 2Dコンテキストの取得に失敗');
                    return;
                }
                
                initJourneyCanvas();
                createJourneyParticles();
                updateJourneyStageUI();
                updateJourneyButtonStates();
                addJourneyEventListeners();
                startJourneyAnimation();
                
                console.log('Canvas 2D ビジュアライゼーション初期化完了');
            } catch (error) {
                console.error('Canvas 2D ビジュアライゼーション初期化エラー:', error);
            }
        }

        function cleanupJourneyVisualization() {
            console.log('Canvas 2D ビジュアライゼーション クリーンアップ開始');
            
            if (journeyAnimationId) {
                cancelAnimationFrame(journeyAnimationId);
                journeyAnimationId = null;
            }
            
            journeyParticles = [];
            journeyCurrentStage = 0;
            
            removeJourneyEventListeners();
            
            console.log('Canvas 2D ビジュアライゼーション クリーンアップ完了');
        }

        function initJourneyCanvas() {
            if (!journeyCanvas) return;
            
            const container = journeyCanvas.parentElement;
            journeyCanvas.width = container.clientWidth;
            journeyCanvas.height = container.clientHeight;
            
            journeyMouseX = journeyCanvas.width / 2;
            journeyMouseY = journeyCanvas.height / 2;
        }

        function createJourneyParticles() {
            journeyParticles = [];
            if (!journeyCanvas) return;
            
            const numParticles = Math.min(100, Math.floor(journeyCanvas.width * journeyCanvas.height / 10000));
            
            for (let i = 0; i < numParticles; i++) {
                journeyParticles.push(new EnhancedParticle(
                    Math.random() * journeyCanvas.width,
                    Math.random() * journeyCanvas.height
                ));
            }
        }

        function updateJourneyPhysicsInfo() {
            const avgAutonomy = journeyParticles.reduce((sum, p) => sum + p.autonomy, 0) / journeyParticles.length;
            const gravityStrength = journeyCurrentStage === 0 ? "強" : journeyCurrentStage === 1 ? "中" : journeyCurrentStage === 2 ? "弱" : "無";
            
            let harmony = 0;
            if (journeyCurrentStage === 3) {
                // 適度な距離を保った質の高い接続を評価
                let qualityConnections = 0;
                let totalParticles = journeyParticles.length;
                
                journeyParticles.forEach(particle => {
                    particle.connections.forEach(connection => {
                        const dx = connection.particle.x - particle.x;
                        const dy = connection.particle.y - particle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // 適度な距離（60-100ピクセル）の接続により高いスコアを与える
                        if (distance >= 60 && distance <= 100) {
                            qualityConnections += connection.strength * 1.5; // 質の高い接続に高いスコア
                        } else if (distance >= 40 && distance <= 120) {
                            qualityConnections += connection.strength; // 通常のスコア
                        } else {
                            qualityConnections += connection.strength * 0.5; // 近すぎる/遠すぎる接続は低いスコア
                        }
                    });
                });
                
                harmony = Math.min(100, (qualityConnections / totalParticles) * 8);
            }
            
            const physicsInfo = document.getElementById('journey-physicsInfo');
            if (physicsInfo) {
                physicsInfo.innerHTML = 
                    `重力強度: ${gravityStrength}<br>` +
                    `自律性: ${Math.round(avgAutonomy * 100)}%<br>` +
                    `調和度: ${Math.round(harmony)}%`;
            }
        }

        function updateJourneyStageUI() {
            const stageInfo = document.getElementById('journey-stageInfo');
            if (stageInfo) {
                const stage = journeyStageDescriptions[journeyCurrentStage];
                stageInfo.innerHTML = `${stage.title}<br><small>${stage.description}</small>`;
            }
            
            // ドット更新
            for (let i = 0; i < 4; i++) {
                const dot = document.getElementById(`journey-dot${i}`);
                if (dot) {
                    dot.classList.toggle('active', i === journeyCurrentStage);
                }
            }
        }

        function updateJourneyButtonStates() {
            const prevButton = document.getElementById('journey-prevButton');
            const nextButton = document.getElementById('journey-nextButton');
            
            if (prevButton) {
                prevButton.disabled = journeyCurrentStage === 0;
                prevButton.style.opacity = journeyCurrentStage === 0 ? '0.5' : '1';
            }
            
            if (nextButton) {
                nextButton.disabled = journeyCurrentStage === 3;
                nextButton.style.opacity = journeyCurrentStage === 3 ? '0.5' : '1';
            }
        }

        function nextJourneyStage() {
            if (journeyCurrentStage < 3) {
                console.log(`Switching from stage ${journeyCurrentStage} to ${journeyCurrentStage + 1}`);
                journeyCurrentStage++;
                updateJourneyStageUI();
                adjustJourneyParticlesForStage();
                updateJourneyButtonStates();
                console.log(`Stage switch completed. Current stage: ${journeyCurrentStage}`);
            }
        }

        function previousJourneyStage() {
            if (journeyCurrentStage > 0) {
                console.log(`Switching from stage ${journeyCurrentStage} to ${journeyCurrentStage - 1}`);
                journeyCurrentStage--;
                updateJourneyStageUI();
                adjustJourneyParticlesForStage();
                updateJourneyButtonStates();
                console.log(`Stage switch completed. Current stage: ${journeyCurrentStage}`);
            }
        }

        function resetJourney() {
            console.log('Resetting journey to stage 0');
            journeyCurrentStage = 0;
            createJourneyParticles();
            updateJourneyStageUI();
            updateJourneyButtonStates();
            console.log('Journey reset completed');
        }

        function toggleInstructions() {
            const instructionsElement = document.getElementById('journey-instructions');
            const detailElement = document.getElementById('instructions-detail');
            const arrowElement = document.getElementById('instructions-arrow');
            
            if (detailElement.classList.contains('show')) {
                // 閉じる
                detailElement.classList.remove('show');
                arrowElement.textContent = '▼';
                console.log('Instructions collapsed');
            } else {
                // 開く
                detailElement.classList.add('show');
                arrowElement.textContent = '▲';
                console.log('Instructions expanded');
            }
        }

        function adjustJourneyParticlesForStage() {
            try {
                console.log(`Adjusting particles for stage ${journeyCurrentStage}`);
                if (journeyParticles.length > 0) {
                    journeyParticles.forEach((particle, index) => {
                        const maxVelocity = journeyCurrentStage === 3 ? 2.5 : 2; // Stage 3の速度制限を緩和
                        particle.vx = Math.max(-maxVelocity, Math.min(maxVelocity, particle.vx));
                        particle.vy = Math.max(-maxVelocity, Math.min(maxVelocity, particle.vy));
                        
                        particle.size = particle.baseSize;
                        particle.connections = [];
                        
                        if (journeyCurrentStage === 0) {
                            particle.autonomy = 0;
                            // 接続フェード状態リセット
                            particle.connectionFadeStartTime = null;
                            particle.connectionFadeOpacity = 0.0;
                        } else if (journeyCurrentStage === 1) {
                            particle.autonomy = Math.max(0, particle.autonomy);
                            // 接続フェード状態リセット
                            particle.connectionFadeStartTime = null;
                            particle.connectionFadeOpacity = 0.0;
                        } else if (journeyCurrentStage === 2) {
                            particle.autonomy = Math.max(0.1, particle.autonomy);
                            // 創造的散乱ステージ移行時の初期化
                            particle.hasInitialDispersed = false;
                            particle.initialDispersionTimer = 0;
                            particle.dispersalDirection = Math.random() * Math.PI * 2;
                            particle.dispersalForce = 0.4 + Math.random() * 0.3; // 穏やかな拡散力に調整
                            // 接続フェード状態リセット
                            particle.connectionFadeStartTime = null;
                            particle.connectionFadeOpacity = 0.0;
                        } else if (journeyCurrentStage === 3) {
                            particle.autonomy = Math.max(0.8, particle.autonomy);
                            
                            // 創発的相互作用ステージ移行時の接続フェードイン初期化
                            particle.connectionFadeStartTime = null;
                            particle.connectionFadeOpacity = 0.0;
                            
                            // Stage 3移行時の分散促進
                            const canvas = document.getElementById('journey-canvas');
                            if (canvas) {
                                const centerX = canvas.width / 2;
                                const centerY = canvas.height / 2;
                                const distanceToCenter = Math.sqrt((particle.x - centerX) ** 2 + (particle.y - centerY) ** 2);
                                
                                // 中心に集まりすぎている場合、外向きの初期速度を与える
                                if (distanceToCenter < Math.min(canvas.width, canvas.height) * 0.15) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const disperseForce = 0.5 + Math.random() * 1.0;
                                    particle.vx += Math.cos(angle) * disperseForce;
                                    particle.vy += Math.sin(angle) * disperseForce;
                                }
                                
                                // 個人的な方向性をランダムに再設定（多様性の確保）
                                particle.personalDirection = Math.random() * Math.PI * 2;
                            }
                        }
                        
                        console.log(`Particle ${index} stage set to ${journeyCurrentStage}`);
                    });
                    console.log(`Particle adjustment completed for stage ${journeyCurrentStage}`);
                } else {
                    console.warn('No particles available for stage adjustment');
                }
                
                if (journeyCurrentStage === 0) {
                    createJourneyParticles();
                }
            } catch (error) {
                console.error('Error adjusting particles for stage:', error);
            }
        }

        function startJourneyAnimation() {
            function animate() {
                try {
                    if (!journeyCanvas || !journeyCtx) {
                        console.warn('Canvas or context not available, stopping animation');
                        return;
                    }
                    
                    // 背景クリア
                    journeyCtx.clearRect(0, 0, journeyCanvas.width, journeyCanvas.height);
                    journeyCtx.fillStyle = '#0a0a0a';
                    journeyCtx.fillRect(0, 0, journeyCanvas.width, journeyCanvas.height);

                    // パーティクル更新と描画（エラーハンドリング付き）
                    journeyParticles.forEach((particle, index) => {
                        try {
                            particle.update(journeyCurrentStage, journeyMouseX, journeyMouseY, journeyParticles);
                            particle.draw(journeyCtx, journeyCurrentStage);
                        } catch (error) {
                            console.error(`Particle ${index} error in stage ${journeyCurrentStage}:`, error);
                            // エラーが発生したパーティクルの値をリセット
                            particle.vx = particle.vx || 0;
                            particle.vy = particle.vy || 0;
                            particle.x = particle.x || journeyCanvas.width / 2;
                            particle.y = particle.y || journeyCanvas.height / 2;
                        }
                    });

                    // 物理情報更新
                    updateJourneyPhysicsInfo();

                    journeyAnimationId = requestAnimationFrame(animate);
                } catch (error) {
                    console.error('Animation loop error:', error);
                    console.error('Error occurred at stage:', journeyCurrentStage);
                    console.error('Animation frame ID:', journeyAnimationId);
                    // アニメーションを停止
                    if (journeyAnimationId) {
                        cancelAnimationFrame(journeyAnimationId);
                        journeyAnimationId = null;
                        console.log('Animation stopped due to error');
                    }
                }
            }
            
            animate();
        }

        // イベントリスナー管理
        let journeyEventListeners = [];

        function addJourneyEventListeners() {
            if (!journeyCanvas) return;
            
            const mouseMoveHandler = (e) => {
                const rect = journeyCanvas.getBoundingClientRect();
                journeyMouseX = e.clientX - rect.left;
                journeyMouseY = e.clientY - rect.top;
            };
            
            const touchMoveHandler = (e) => {
                e.preventDefault();
                const rect = journeyCanvas.getBoundingClientRect();
                journeyMouseX = e.touches[0].clientX - rect.left;
                journeyMouseY = e.touches[0].clientY - rect.top;
            };
            
            const resizeHandler = () => {
                initJourneyCanvas();
                createJourneyParticles();
            };
            
            journeyCanvas.addEventListener('mousemove', mouseMoveHandler);
            journeyCanvas.addEventListener('touchmove', touchMoveHandler);
            window.addEventListener('resize', resizeHandler);
            
            journeyEventListeners.push(
                { element: journeyCanvas, event: 'mousemove', handler: mouseMoveHandler },
                { element: journeyCanvas, event: 'touchmove', handler: touchMoveHandler },
                { element: window, event: 'resize', handler: resizeHandler }
            );
        }

        function removeJourneyEventListeners() {
            journeyEventListeners.forEach(({ element, event, handler }) => {
                element.removeEventListener(event, handler);
            });
            journeyEventListeners = [];
        }

        // Stage click handling for dynamic linking
        document.addEventListener('DOMContentLoaded', function() {
            console.log('セルフオーサーシップ3D統合システム準備完了');
            
            // Test toggleSection function availability
            if (typeof toggleSection === 'function') {
                console.log('toggleSection function is available');
                
                // Test with buttons
                const toggleButtons = document.querySelectorAll('button[onclick*="toggleSection"]');
                console.log('Found toggle buttons:', toggleButtons.length);
                
                toggleButtons.forEach((button, index) => {
                    console.log(`Button ${index}:`, button.textContent.trim());
                    button.addEventListener('click', (e) => {
                        console.log('Button clicked:', button.textContent.trim());
                    });
                });
            } else {
                console.error('toggleSection function is NOT available');
            }
            
            // Test DOM elements
            const detailedJourney = document.getElementById('detailed-journey');
            const refinedPhases = document.getElementById('refined-phases');
            
            console.log('detailed-journey element:', detailedJourney);
            console.log('refined-phases element:', refinedPhases);
            
            // Add click handlers to stage headings in text for dynamic linking
            setTimeout(() => {
                const stageHeadings = document.querySelectorAll('.sub-phase h4');
                stageHeadings.forEach(heading => {
                    const text = heading.textContent;
                    const stageMatch = text.match(/^(Ea|Eb|Ec|E\(I\)|E-I|I-E|I\(E\)|Ia|Ib|Ic):/);
                    if (stageMatch) {
                        let stageId = stageMatch[1];
                        // Convert special cases
                        if (stageId === 'E(I)') stageId = 'EI';
                        if (stageId === 'I(E)') stageId = 'IE';
                        
                        heading.style.cursor = 'pointer';
                        heading.style.transition = 'color 0.3s';
                        heading.style.color = '#667eea';
                        
                        heading.addEventListener('click', () => {
                            if (refinedVisualization && refinedVisualization.isInitialized) {
                                refinedVisualization.switchToStage(stageId);
                                
                                // Scroll to 3D area
                                const container = document.getElementById('refined-3d-container');
                                if (container) {
                                    container.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            }
                        });
                        
                        heading.addEventListener('mouseenter', () => {
                            heading.style.color = '#764ba2';
                        });
                        
                        heading.addEventListener('mouseleave', () => {
                            heading.style.color = '#667eea';
                        });
                    }
                });
            }, 1000);
        });
        
        // ジャーニーマップ開閉機能
        function toggleJourneyMap() {
            const container = document.getElementById('journey-map-container');
            const icon = document.getElementById('journey-toggle-icon');
            
            if (container.style.display === 'none') {
                // 開く
                container.style.display = 'block';
                icon.classList.add('rotated');
                icon.textContent = '▲';
                
                // iframe のサイズ調整
                adjustIframeHeight();
            } else {
                // 閉じる
                container.style.display = 'none';
                icon.classList.remove('rotated');
                icon.textContent = '▼';
            }
        }
        
        // iframe の動的高さ調整（UX最適化版）
        let lastIframeHeight = 800; // 初期値をグラフが見える高さに
        let heightAdjustmentSetup = false;
        
        function adjustIframeHeight() {
            if (heightAdjustmentSetup) return; // 重複リスナー防止
            heightAdjustmentSetup = true;
            
            const iframe = document.getElementById('journey-map-iframe');
            
            // PostMessage でiframe内の高さを受信
            window.addEventListener('message', function(event) {
                if (event.data.type === 'IFRAME_HEIGHT_CHANGE' && iframe) {
                    let newHeight = event.data.height + 20; // パディングを最小限に
                    
                    // レスポンシブ対応：画面サイズに応じた制限
                    const viewportHeight = window.innerHeight;
                    const maxAllowedHeight = Math.min(viewportHeight * 0.85, 1600);
                    
                    // 最小高さを800px、最大高さを制限
                    newHeight = Math.max(800, Math.min(newHeight, maxAllowedHeight));
                    
                    // 高さの変化が最小限の場合は調整しない
                    if (Math.abs(newHeight - lastIframeHeight) < 5) {
                        return;
                    }
                    
                    lastIframeHeight = newHeight;
                    
                    // スムーズなトランジション
                    iframe.style.transition = 'height 0.3s ease-out';
                    iframe.style.height = newHeight + 'px';
                    
                    console.log('iframe高さ最適化:', {
                        received: event.data.height,
                        applied: newHeight,
                        viewport: viewportHeight
                    });
                    
                    // トランジション終了後にtransitionを削除
                    setTimeout(() => {
                        iframe.style.transition = '';
                    }, 300);
                }
            });
        }
    </script>
</body>
</html>
