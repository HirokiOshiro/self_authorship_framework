<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ç†è«–ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans JP", sans-serif;
            line-height: 1.8;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background: linear-gradient(135deg, #c9ea66 0%, #7eceff 100%);
            color: white;
            padding: 40px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 {
            margin: 0;
            font-size: 2.5em;
        }
        .subtitle {
            margin-top: 10px;
            font-size: 1.2em;
            opacity: 0.9;
        }
        .section {
            background: white;
            padding: 30px;
            margin-bottom: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        h2 {
            color: #667eea;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        h3 {
            color: #764ba2;
            margin-top: 25px;
        }
        .dimension-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .dimension-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 5px solid #667eea;
        }
        .phase-container {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .phase-card {
            flex: 1;
            min-width: 250px;
            background: #fff;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .phase-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .phase-1 { border-color: #ff6b6b; }
        .phase-2 { border-color: #ffd43b; }
        .phase-3 { border-color: #51cf66; }
        .principle {
            background: #e3f2fd;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border-left: 5px solid #2196f3;
        }
        .checklist {
            background: #f0f4ff;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .checklist h4 {
            color: #667eea;
            margin-bottom: 15px;
        }
        .checklist ul {
            list-style: none;
            padding: 0;
        }
        .checklist li {
            padding: 8px 0;
            padding-left: 30px;
            position: relative;
        }
        .checklist li:before {
            content: "â–¡";
            position: absolute;
            left: 0;
            color: #667eea;
            font-weight: bold;
        }
        .highlight {
            background: #ffeb3b;
            padding: 2px 6px;
            border-radius: 3px;
        }
        .example {
            background: #e8f5e9;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 4px solid #4caf50;
            font-style: italic;
        }
        .arrow {
            text-align: center;
            font-size: 2em;
            color: #667eea;
            margin: 20px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background: #667eea;
            color: white;
        }
        tr:nth-child(even) {
            background: #f9f9f9;
        }
        .practical-tips {
            background: #fff3cd;
            padding: 20px;
            border-radius: 8px;
            border-left: 5px solid #ffc107;
            margin: 20px 0;
        }
        .advanced-section {
            background: #f0f7ff;
            padding: 30px;
            margin: 20px 0;
            border-radius: 10px;
            border: 2px solid #667eea;
        }
        .sub-phase {
            background: #fafbfc;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }
        .sub-phase h4 {
            margin: 0 0 10px 0;
            color: #667eea;
        }
        .lpm-step {
            background: #f8f9fa;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 4px solid #2196f3;
        }
        .lpm-step h5 {
            margin: 0 0 10px 0;
            color: #2196f3;
        }
        .toggle-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px 0;
            transition: background 0.3s;
        }
        .toggle-button:hover {
            background: #764ba2;
        }
        .collapsible {
            display: none;
            margin-top: 20px;
        }
        .collapsible.active {
            display: block;
        }
        .journey-table {
            overflow-x: auto;
        }
        .journey-table table {
            font-size: 0.9em;
        }
        .journey-table td {
            vertical-align: top;
        }
        @media (max-width: 768px) {
            .phase-container {
                flex-direction: column;
            }
            .dimension-grid {
                grid-template-columns: 1fr;
            }
            .journey-table {
                overflow-x: scroll;
            }
        }
        
        /* 3D Integration Styles */
        .sa-3d-integration {
            margin: 30px 0;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .sa-3d-integration h4 {
            color: #667eea;
            margin: 0 0 15px 0;
            font-size: 1.3em;
        }
        
        .sa-3d-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .sa-3d-loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            z-index: 10;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(102, 126, 234, 0.3);
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Canvas 2D ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³çµ±åˆã‚¹ã‚¿ã‚¤ãƒ« */
        .canvas-2d-integration {
            margin: 25px 0;
            padding: 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            border: 2px solid #dee2e6;
        }
        
        .canvas-2d-integration h4 {
            color: #667eea;
            margin: 0 0 15px 0;
            font-size: 1.3em;
        }
        
        .journey-canvas-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        #journey-canvas {
            display: block;
            cursor: crosshair;
            background: transparent;
            width: 100%;
            height: 100%;
        }
        
        .journey-controls {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 10;
            background: rgba(26, 26, 46, 0.95);
            padding: 12px;
            border-radius: 12px;
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 240px;
            color: white;
            font-size: 0.9em;
        }
        
        .journey-controls h5 {
            color: #ffffff;
            margin: 0 0 8px 0;
            font-size: 1em;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            text-align: center;
        }
        
        .journey-stage-info {
            margin-bottom: 10px;
            padding: 8px 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            font-size: 0.8em;
            line-height: 1.3;
            box-shadow: 0 3px 12px rgba(102, 126, 234, 0.3);
            text-align: center;
        }
        
        .journey-stage-info small {
            display: block;
            opacity: 0.9;
            font-size: 0.85em;
            margin-top: 2px;
        }
        
        .journey-button-group {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
        }
        
        .journey-controls button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
            font-weight: 500;
            transition: all 0.3s ease;
            flex: 1;
            box-shadow: 0 3px 12px rgba(102, 126, 234, 0.2);
        }
        
        .journey-controls button.reset-btn {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            padding: 6px 10px;
            font-size: 0.75em;
        }
        
        .journey-controls button:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .journey-controls button.reset-btn:hover {
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }
        
        .journey-controls button:disabled {
            cursor: not-allowed;
            opacity: 0.4;
            transform: none !important;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1) !important;
        }
        
        .journey-stage-indicator {
            display: flex;
            gap: 6px;
            margin-top: 8px;
            justify-content: center;
        }
        
        .journey-stage-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .journey-stage-dot.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transform: scale(1.3);
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.6);
        }
        
        .journey-instructions {
            position: absolute;
            top: 185px;
            left: 15px;
            background: rgba(26, 26, 46, 0.95);
            padding: 12px;
            border-radius: 12px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            width: 240px;
            font-size: 0.75em;
            line-height: 1.2;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            z-index: 10;
        }
        
        .journey-instructions:hover {
            background: rgba(102, 126, 234, 0.2);
            border-color: rgba(102, 126, 234, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.3);
        }
        
        .journey-instructions-detail {
            display: none;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.9em;
            line-height: 1.3;
            opacity: 0;
            animation: fadeIn 0.3s ease forwards;
        }
        
        .journey-instructions-detail.show {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .journey-physics-info {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(26, 26, 46, 0.95);
            padding: 10px 12px;
            border-radius: 8px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 0.8em;
            line-height: 1.3;
        }
        
        .sa-3d-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        .stage-info-display {
            color: white;
            text-align: center;
            margin-bottom: 10px;
            min-height: 40px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .stage-info-display h5 {
            margin: 0 0 5px 0;
            color: #667eea;
            font-size: 1em;
        }
        
        .stage-info-display p {
            margin: 0;
            font-size: 0.85em;
            opacity: 0.9;
        }
        
        .stage-controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .stage-btn {
            background: #334155;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s;
            min-width: 40px;
        }
        
        .stage-btn:hover {
            background: #475569;
            transform: translateY(-2px);
        }
        
        .stage-btn.active {
            background: #667eea;
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
        }
        
        .view-controls {
            display: flex;
            gap: 10px;
        }
        
        .view-controls button {
            background: #1e293b;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background 0.3s;
        }
        
        .view-controls button:hover {
            background: #475569;
        }
        
        /* æµ®éŠè¦–ç‚¹ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ */
        .floating-view-control {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 100;
            background: rgba(30, 41, 59, 0.9);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.2);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .floating-view-control:hover {
            background: rgba(59, 130, 246, 0.9);
            border-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
        }
        
        .floating-view-control:active {
            transform: scale(0.95);
        }
        
        .floating-view-control .tooltip {
            position: absolute;
            bottom: -35px;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .floating-view-control:hover .tooltip {
            opacity: 1;
        }

        .sa-3d-description {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .sub-phase h4 {
            transition: all 0.3s;
        }
        
        .sub-phase h4:hover {
            color: #764ba2;
            cursor: pointer;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            .sa-3d-container {
                height: 350px;
            }
            
            .sa-3d-controls {
                padding: 12px 15px;
                bottom: 10px;
            }
            
            .stage-controls {
                gap: 6px;
            }
            
            .stage-btn {
                padding: 6px 8px;
                font-size: 0.75em;
                min-width: 35px;
            }
            
            /* Canvas 2D ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
            .journey-canvas-container {
                height: 400px;
            }
            
            .journey-controls {
                padding: 10px;
                width: 200px;
                font-size: 0.85em;
            }
            
            .journey-controls button {
                padding: 6px 8px;
                font-size: 0.75em;
            }
            
            .journey-controls button.reset-btn {
                padding: 5px 8px;
                font-size: 0.7em;
            }
            
            .journey-instructions {
                top: 155px;
                left: 10px;
                right: auto;
                bottom: auto;
                width: 200px;
                padding: 10px;
                font-size: 0.65em;
            }
            
            .journey-physics-info {
                right: 10px;
                bottom: 70px;
                padding: 8px 10px;
                font-size: 0.75em;
            }
        }
        
        /* ã‚¸ãƒ£ãƒ¼ãƒ‹ãƒ¼ãƒãƒƒãƒ—ã‚»ã‚¯ã‚·ãƒ§ãƒ³ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
        .journey-map-section {
            background: #f8f9fa;
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
            border: 1px solid #e9ecef;
        }
        
        
        .toggle-icon {
            font-size: 1em;
            margin-left: 8px;
            transition: transform 0.3s ease;
        }
        
        .toggle-icon.rotated {
            transform: rotate(180deg);
        }
        
        .journey-map-container {
            padding: 0;
            transition: max-height 0.5s ease;
            overflow: hidden;
        }
        
        .journey-iframe-wrapper {
            padding: 20px;
            background: white;
        }
        
        .journey-map-description {
            padding: 20px 30px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
        }
        
        .journey-map-description h4 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .journey-map-description ul {
            margin-left: 20px;
        }
        
        .journey-map-description li {
            margin-bottom: 8px;
        }
        
        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
        @media (max-width: 768px) {
            .journey-iframe-wrapper {
                padding: 10px;
            }
            
            #journey-map-iframe {
                height: 550px; /* ãƒ¢ãƒã‚¤ãƒ«ã§ã‚‚ã‚°ãƒ©ãƒ•ãŒè¦‹ãˆã‚‹é«˜ã• */
            }
        }
        
        @media (max-width: 480px) {
            .journey-iframe-wrapper {
                padding: 8px;
            }
            
            #journey-map-iframe {
                height: 500px; /* å°ç”»é¢ã§ã‚‚ã§ãã‚‹ã ã‘ã‚°ãƒ©ãƒ•ã‚’è¡¨ç¤º */
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ç†è«–ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯</h1>
        <p class="subtitle">å¤§å­¦ã«ãŠã‘ã‚‹å­¦ç”Ÿã®æˆé•·æ”¯æ´ã®ãŸã‚ã®å®Ÿè·µçš„ã‚¬ã‚¤ãƒ‰</p>
    </div>

    <div class="section">
        <h2>ğŸ¯ ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã¨ã¯ï¼Ÿ</h2>
        <p><strong>ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—</strong>ã¨ã¯ã€<span class="highlight">ã€Œè‡ªå·±ã®ä¿¡å¿µã€ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã€ç¤¾ä¼šé–¢ä¿‚ã‚’å®šç¾©ã™ã‚‹å†…çš„èƒ½åŠ›ã€</span>ã®ã“ã¨ã§ã™ã€‚</p>
        <p>å­¦ç”ŸãŒå¤–éƒ¨ã®æ¨©å¨ã‚„æœŸå¾…ã«ä¾å­˜ã™ã‚‹ã®ã§ã¯ãªãã€è‡ªåˆ†è‡ªèº«ã®å†…ãªã‚‹å£°ã«åŸºã¥ã„ã¦äººç”Ÿã‚’åˆ‡ã‚Šé–‹ã„ã¦ã„ãåŠ›ã‚’æŒ‡ã—ã¾ã™ã€‚ã“ã‚Œã¯21ä¸–ç´€ã®é«˜ç­‰æ•™è‚²ã«ãŠã‘ã‚‹é‡è¦ãªå­¦ç¿’æˆæœã¨ã—ã¦ä½ç½®ã¥ã‘ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚</p>
        
        <div class="practical-tips">
            <strong>ğŸ’¡ ãªãœé‡è¦ï¼Ÿ</strong>
            <ul>
                <li>æ‰¹åˆ¤çš„æ€è€ƒåŠ›ã¨ä¸»ä½“çš„ãªå­¦ç¿’æ…‹åº¦ã®è‚²æˆ</li>
                <li>è¤‡é›‘ãªç¤¾ä¼šã§è‡ªå¾‹çš„ã«ç”Ÿãã‚‹åŠ›ã®ç²å¾—</li>
                <li>å¤šæ§˜ãªä¾¡å€¤è¦³ã®ä¸­ã§è‡ªåˆ†ã®è»¸ã‚’æŒã¤åŠ›ã®å½¢æˆ</li>
            </ul>
        </div>
    </div>

    <div class="section">
        <h2>ğŸ“Š 3ã¤ã®æˆé•·æ¬¡å…ƒ</h2>
        <p>ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã¯ã€ä»¥ä¸‹ã®3ã¤ã®æ¬¡å…ƒã§æ‰ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼š</p>
        
        <div class="dimension-grid">
            <div class="dimension-card">
                <h3>ğŸ§  èªè­˜è«–çš„æ¬¡å…ƒ</h3>
                <p><strong>å•ã„ï¼šã€Œç§ã¯ã©ã®ã‚ˆã†ã«çŸ¥ã‚‹ã®ã‹ï¼Ÿã€</strong></p>
                <p>çŸ¥è­˜ã‚„çœŸå®Ÿã‚’ã©ã®ã‚ˆã†ã«æ‰ãˆã€ç†è§£ã™ã‚‹ã‹ã«é–¢ã™ã‚‹æˆé•·</p>
                <div class="example">
                    ä¾‹ï¼šã€Œæ•™ç§‘æ›¸ã«æ›¸ã„ã¦ã‚ã‚‹ã‹ã‚‰æ­£ã—ã„ã€ã‹ã‚‰ã€Œè¤‡æ•°ã®è¦–ç‚¹ã‚’æ¯”è¼ƒæ¤œè¨ã—ã¦è‡ªåˆ†ã®è€ƒãˆã‚’å½¢æˆã™ã‚‹ã€ã¸
                </div>
            </div>
            
            <div class="dimension-card">
                <h3>ğŸª å¯¾è‡ªé–¢ä¿‚æ¬¡å…ƒ</h3>
                <p><strong>å•ã„ï¼šã€Œç§ã¯ä½•è€…ã‹ï¼Ÿã€</strong></p>
                <p>è‡ªå·±ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚„ä¾¡å€¤è¦³ã®å½¢æˆã«é–¢ã™ã‚‹æˆé•·</p>
                <div class="example">
                    ä¾‹ï¼šã€Œè¦ªã‚„å‘¨å›²ãŒæœŸå¾…ã™ã‚‹è‡ªåˆ†ã€ã‹ã‚‰ã€Œè‡ªåˆ†è‡ªèº«ã§é¸æŠã—ãŸä¾¡å€¤è¦³ã«åŸºã¥ãè‡ªåˆ†ã€ã¸
                </div>
            </div>
            
            <div class="dimension-card">
                <h3>ğŸ¤ å¯¾äººé–¢ä¿‚æ¬¡å…ƒ</h3>
                <p><strong>å•ã„ï¼šã€Œä»–è€…ã¨ã©ã®ã‚ˆã†ã«é–¢ã‚ã‚‹ã‹ï¼Ÿã€</strong></p>
                <p>ä»–è€…ã¨ã®é–¢ä¿‚æ€§ã‚’ã„ã‹ã«æ§‹ç¯‰ã™ã‚‹ã‹ã«é–¢ã™ã‚‹æˆé•·</p>
                <div class="example">
                    ä¾‹ï¼šã€Œæ‰¿èªã‚’ã—ã¦ã‚‚ã‚‰ã†ãŸã‚ã®é–¢ä¿‚ã€ã‹ã‚‰ã€Œç›¸äº’ã«è‡ªç«‹ã—ãŸå¯¾ç­‰ãªé–¢ä¿‚æ€§ã§ã®å”åƒã€ã¸
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>ğŸš€ æˆé•·ã®3å±€é¢ï¼ˆåŸºæœ¬ï¼‰</h2>
        <p>å­¦ç”Ÿã¯ä»¥ä¸‹ã®3ã¤ã®å±€é¢ã‚’é€šã˜ã¦æˆé•·ã—ã¦ã„ãã¾ã™ï¼š</p>
        
        <div class="phase-container">
            <div class="phase-card phase-1">
                <h3>1ï¸âƒ£ å¤–çš„å…¬å¼ã«å¾“ã†å±€é¢</h3>
                <p><strong>ç‰¹å¾´ï¼š</strong></p>
                <ul>
                    <li>æ¨©å¨è€…ã®è¨€ã†ã“ã¨ã‚’éµœå‘‘ã¿ã«ã™ã‚‹</li>
                    <li>ä»–è€…ã‹ã‚‰ã®æ‰¿èªã‚’æ±‚ã‚ã‚‹</li>
                    <li>å¤–çš„ãªæœŸå¾…ã«è‡ªå·±ã‚’åˆã‚ã›ã‚‹</li>
                </ul>
                <p><strong>å­¦ç”Ÿã®çŠ¶æ…‹ï¼š</strong><br>
                ã€Œå…ˆç”ŸãŒè¨€ã£ãŸã‹ã‚‰ã€ã€Œã¿ã‚“ãªãŒãã†ã—ã¦ã„ã‚‹ã‹ã‚‰ã€ã¨ã„ã†ç†ç”±ã§è¡Œå‹•</p>
            </div>
            
            <div class="phase-card phase-2">
                <h3>2ï¸âƒ£ å²è·¯ã®å±€é¢</h3>
                <p><strong>ç‰¹å¾´ï¼š</strong></p>
                <ul>
                    <li>å¤–çš„æ¨©å¨ã¸ã®ç–‘å•ãŒç”Ÿã˜ã‚‹</li>
                    <li>å†…ãªã‚‹å£°ã®å¿…è¦æ€§ã‚’èªè­˜</li>
                    <li>è‘›è—¤ã‚„ä¸å”å’Œã‚’çµŒé¨“</li>
                </ul>
                <p><strong>å­¦ç”Ÿã®çŠ¶æ…‹ï¼š</strong><br>
                ã€Œæœ¬å½“ã«ãã‚Œã§ã„ã„ã®ã‹ï¼Ÿã€ã€Œè‡ªåˆ†ã®è€ƒãˆã¯ï¼Ÿã€ã¨ã„ã†å•ã„ãŒç”Ÿã¾ã‚Œã‚‹</p>
            </div>
            
            <div class="phase-card phase-3">
                <h3>3ï¸âƒ£ ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—å±€é¢</h3>
                <p><strong>ç‰¹å¾´ï¼š</strong></p>
                <ul>
                    <li>å†…ãªã‚‹å£°ã‚’ä¿¡é ¼ã™ã‚‹</li>
                    <li>è‡ªå·±æ±ºå®šã«åŸºã¥ãè¡Œå‹•</li>
                    <li>å†…ãªã‚‹åŸºç›¤ã®æ§‹ç¯‰</li>
                </ul>
                <p><strong>å­¦ç”Ÿã®çŠ¶æ…‹ï¼š</strong><br>
                ã€Œç§ã¯ã“ã†è€ƒãˆã‚‹ã€ã€Œç§ã®ä¾¡å€¤è¦³ã«åŸºã¥ã„ã¦è¡Œå‹•ã™ã‚‹ã€</p>
            </div>
        </div>
        
        <button class="toggle-button" onclick="toggleSection('detailed-journey')">ğŸ” ã‚ˆã‚Šè©³ç´°ãªæˆé•·ã®æ—…ã‚’è¦‹ã‚‹</button>
        
        <div id="detailed-journey" class="collapsible">
            <div class="advanced-section">
                <h3>ğŸ—ºï¸ ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã¸ã®æˆé•·ã®æ—…ï¼ˆè©³ç´°ç‰ˆï¼‰</h3>
                <p>å„æ¬¡å…ƒã«ãŠã‘ã‚‹æˆé•·ã®è©³ç´°ãªæ§˜ç›¸ã‚’ä»¥ä¸‹ã®è¡¨ã«ç¤ºã—ã¾ã™ï¼š</p>
                
                <!-- Canvas 2Dãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³çµ±åˆã‚¨ãƒªã‚¢ -->
                <div class="canvas-2d-integration">
                    <h4>ğŸ—ºï¸ æˆé•·ã®æ—…ã®ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³</h4>
                    <p>ä»¥ä¸‹ã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã‚¤ãƒ¡ãƒ¼ã‚¸ã®è¡¨ç¾ã§ã™ã€‚ãƒã‚¦ã‚¹ã§æ“ä½œã—ã¦ã¿ã¦ãã ã•ã„ã€‚<br>ğŸ¨ï¼šã“ã‚Œã¯ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã‚’é›†å›£ã®ãƒ€ã‚¤ãƒŠãƒŸã‚¯ã‚¹ã¨ã„ã†è¦³ç‚¹ã§æ¯”å–©çš„ã«è¡¨ç¾ã—ãŸä¸€ä¾‹ã§ã™ã€‚</p>

                    <div id="journey-canvas-container" class="journey-canvas-container">
                        <canvas id="journey-canvas"></canvas>
                        <div class="journey-controls">
                            <h5>ğŸ—ºï¸ æˆé•·ã®æ—…</h5>
                            <div class="journey-stage-info" id="journey-stageInfo">
                                é‡åŠ›ã®æ”¯é…<br><small>å¤–éƒ¨ã®æ¨©å¨ã«å¾“å±ã—ã¦ã„ã‚‹çŠ¶æ…‹</small>
                            </div>
                            
                            <div class="journey-button-group">
                                <button onclick="previousJourneyStage()" id="journey-prevButton" title="å‰ã®ã‚¹ãƒ†ãƒ¼ã‚¸">â†</button>
                                <button onclick="nextJourneyStage()" id="journey-nextButton" title="æ¬¡ã®ã‚¹ãƒ†ãƒ¼ã‚¸">â†’</button>
                                <button onclick="resetJourney()" class="reset-btn" title="ãƒªã‚»ãƒƒãƒˆ">ğŸ”„</button>
                            </div>
                            
                            <div class="journey-stage-indicator">
                                <div class="journey-stage-dot active" id="journey-dot0"></div>
                                <div class="journey-stage-dot" id="journey-dot1"></div>
                                <div class="journey-stage-dot" id="journey-dot2"></div>
                                <div class="journey-stage-dot" id="journey-dot3"></div>
                            </div>
                        </div>
                        
                        <div class="journey-instructions" onclick="toggleInstructions()" id="journey-instructions">
                            <p><small>ğŸ’¡ æ“ä½œã‚¬ã‚¤ãƒ‰ <span id="instructions-arrow">â–¼</span></small></p>
                            <div class="journey-instructions-detail" id="instructions-detail">
                                <p><small>
                                    ğŸ–±ï¸ <strong>ãƒã‚¦ã‚¹/ã‚¿ãƒƒãƒ</strong><br>
                                    ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã«å½±éŸ¿ã‚’ä¸ãˆã‚‹<br><br>
                                    ğŸ¯ <strong>ã‚¹ãƒ†ãƒ¼ã‚¸æ“ä½œ</strong><br>
                                    â†â†’ãƒœã‚¿ãƒ³ã§æ®µéšåˆ‡ã‚Šæ›¿ãˆ<br><br>
                                    ğŸ”„ <strong>ãƒªã‚»ãƒƒãƒˆ</strong><br>
                                    åˆæœŸçŠ¶æ…‹ã«æˆ»ã™
                                </small></p>
                            </div>
                        </div>
                        
                        <!-- ç‰©ç†æƒ…å ±è¡¨ç¤ºã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’éè¡¨ç¤ºåŒ–
                        <div class="journey-physics-info" id="journey-physicsInfo">
                            é‡åŠ›å¼·åº¦: å¼·<br>
                            è‡ªå¾‹æ€§: 0%<br>
                            èª¿å’Œåº¦: 0%
                        </div>
                        -->
                    </div>
                </div>
                
                <div class="journey-table">
                    <table>
                        <thead>
                            <tr>
                                <th>æ¬¡å…ƒ</th>
                                <th>å¤–çš„å…¬å¼</th>
                                <th>å²è·¯</th>
                                <th>ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>èªè­˜è«–çš„</strong></td>
                                <td>
                                    â€¢ çŸ¥è­˜ã®æºæ³‰ã¨ã—ã¦æ¨©å¨ã«ä¿¡é ¼ã‚’è­²ã‚‹<br>
                                    â€¢ çŸ¥è­˜ã‚’ç¢ºå®Ÿï¼ˆã¾ãŸã¯éƒ¨åˆ†çš„ã«ç¢ºå®Ÿï¼‰ã¨è¦‹ã‚‹<br>
                                    â€¢ å¤–çš„ã«è¦å®šã•ã‚Œã‚‹ä¿¡å¿µã¨ãªã‚‹ã‚ˆã†ãªçŸ¥è­˜å‘½é¡Œã‚’è©•ä¾¡ã™ã‚‹ãŸã‚ã®å†…ãªã‚‹åŸºç›¤ã‚’æ¬ ã
                                </td>
                                <td>
                                    â€¢ ä¸ç¢ºå®Ÿæ€§ã¨å¤šå…ƒçš„è¦–ç‚¹ã®è‡ªè¦šã¨å—å®¹ã‚’é€²ã‚ã‚‹<br>
                                    â€¢ æ¨©å¨è€…ã®çŸ¥è­˜ã‚’å—å®¹ã™ã‚‹ã“ã¨ã‹ã‚‰çŸ¥è­˜å‘½é¡Œã‚’æ¡ç”¨ã™ã‚‹ãƒ‘ãƒ¼ã‚½ãƒŠãƒ«ãªãƒ—ãƒ­ã‚»ã‚¹ã¸ç§»ã‚‹<br>
                                    â€¢ ä¿¡å¿µã‚’é¸æŠã™ã‚‹ãŸã‚ã«è²¬ä»»ã‚’æŒã¤å¿…è¦æ€§ã‚’èªã‚ã‚‹
                                </td>
                                <td>
                                    â€¢ çŸ¥è­˜ã‚’æ–‡è„ˆçš„ãªã‚‚ã®ã¨è¦‹ã‚‹<br>
                                    â€¢ åˆ©ç”¨å¯èƒ½ãªã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹ã‚„å‚ç…§æ çµ„ã¿ã®è¦³ç‚¹ã§åˆ¤æ–­ã‚’æ§‹ç¯‰ãƒ»è©•ä¾¡ãƒ»è§£é‡ˆã™ã‚‹<br>
                                    â€¢ å†…çš„ä¿¡å¿µã‚·ã‚¹ãƒ†ãƒ ã‚’ç™ºé”ã•ã›ã‚‹
                                </td>
                            </tr>
                            <tr>
                                <td><strong>å¯¾è‡ªé–¢ä¿‚</strong></td>
                                <td>
                                    â€¢ è‡ªåˆ†ã®ä¾¡å€¤è¦³ã‚„ç¤¾ä¼šçš„ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®è‡ªè¦šã‚’æ¬ ã<br>
                                    â€¢ ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®è«¸è¦ç´ ã®èª¿æ•´ã‚’æ¬ ã<br>
                                    â€¢ ä»–è€…ã‹ã‚‰ã®è‚¯å®šã‚’è¦ã™ã‚‹
                                </td>
                                <td>
                                    â€¢ å¤–çš„ãªä»–è€…ã®ç‰©ã®è¦‹æ–¹ã‹ã‚‰åŒºåˆ¥ã•ã‚Œã‚‹ã€è‡ªèº«ã®ä¾¡å€¤è¦³ã¨ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®æ„Ÿè¦šã®è‡ªè¦šã‚’é€²ã‚ã‚‹<br>
                                    â€¢ ç”Ÿã˜ã¤ã¤ã‚ã‚‹å†…çš„ä¾¡å€¤è¦³ã¨å¤–çš„åœ§åŠ›ã¨ã®é–“ã«ç·Šå¼µãŒã‚ã‚‹<br>
                                    â€¢ è‡ªã‚‰ã®ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ä½œã‚Šå‡ºã™ãŸã‚ã«è²¬ä»»ã‚’æŒã¤å¿…è¦æ€§ã‚’èªã‚ã‚‹
                                </td>
                                <td>
                                    â€¢ å†…çš„ã«ç”Ÿæˆã—ã€çµŒé¨“ã¨é¸æŠã®è§£é‡ˆã‚’èª¿æ•´ã™ã‚‹<br>
                                    â€¢ è‡ªå·±ã®æ„Ÿè¦šã‚’ã¤ãã‚‹éš›ã«è‡ªèº«ã®ä¾¡å€¤è¦³ã¨ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’é¸æŠã™ã‚‹<br>
                                    â€¢ ä¸€è²«ã—ãŸå†…çš„ãªè‡ªå·±ã®æ„Ÿè¦šã«æ ¹ã–ã™
                                </td>
                            </tr>
                            <tr>
                                <td><strong>å¯¾äººé–¢ä¿‚</strong></td>
                                <td>
                                    â€¢ åŒã˜ã‚ˆã†ãªä»–è€…ãŸã¡ã¨ã®ä¾å­˜é–¢ä¿‚ãŒã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã¨å¿…è¦ãªè‚¯å®šã®æºæ³‰ã¨ãªã‚‹<br>
                                    â€¢ ä»–è€…ã®è‚¯å®šã‚’å¾—ã¦ã„ãã“ã¨ã¨ã—ã¦ã®é–¢ä¿‚ã¸ã®å‚åŠ 
                                </td>
                                <td>
                                    â€¢ ä¾å­˜é–¢ä¿‚ã®é™ç•Œã¸ã®è‡ªè¦šã‚’é€²ã‚ã‚‹<br>
                                    â€¢ è‡ªèº«ã®ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’è‡ªç«‹çš„ãªè«¸é–¢ä¿‚ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ã¸æŒã£ã¦ã„ãå¿…è¦æ€§ã‚’èªã‚ã‚‹<br>
                                    â€¢ è‡ªå·±ã‚’å†æ§‹ç¯‰ã™ã‚‹ã€ã¾ãŸã¯ä¾å­˜é–¢ä¿‚ã‹ã‚‰è„±å‡ºã•ã›ã‚‹ãŸã‚ã«é—˜ã†
                                </td>
                                <td>
                                    â€¢ å¤šæ§˜ãªä»–è€…ãŸã¡ã¨çœŸæ­£ãªç›¸äº’ä¾å­˜é–¢ä¿‚ã«å–ã‚Šçµ„ã‚€ã“ã¨ãŒã§ãã‚‹<br>
                                    â€¢ é–¢ä¿‚æ€§ã®å¿…è¦æ€§ã‚’ç›¸äº’çš„ã«äº¤æ¸‰ã™ã‚‹<br>
                                    â€¢ ä»–è€…ã®è¦–ç‚¹ã‚’æœ¬å½“ã®æ„å‘³ã§è€ƒæ…®ã«å…¥ã‚Œã‚‹
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>ğŸ”¬ æˆé•·å±€é¢ã®ç²¾ç·»åŒ–</h2>
        <p>ã‚¦ã‚©ãƒã‚·ãƒ¥å…¨å›½èª¿æŸ»ç ”ç©¶ã«ã‚ˆã‚Šã€å„å±€é¢ã«ã¯ã•ã‚‰ã«è©³ç´°ãªä¸‹ä½å±€é¢ãŒã‚ã‚‹ã“ã¨ãŒæ˜ã‚‰ã‹ã«ãªã‚Šã¾ã—ãŸã€‚</p>
        
        <button class="toggle-button" onclick="toggleSection('refined-phases')">ğŸ”¬ ç²¾ç·»åŒ–ã•ã‚ŒãŸæˆé•·å±€é¢ã‚’è¦‹ã‚‹</button>
        
        <div id="refined-phases" class="collapsible">
            <div class="advanced-section">
                <!-- 3Då¯è¦–åŒ–çµ±åˆã‚¨ãƒªã‚¢ -->
                <div class="sa-3d-integration">
                    <h4>ğŸ”¬ æˆé•·å±€é¢ã®å¤‰å®¹ã®ã‚¤ãƒ¡ãƒ¼ã‚¸</h4>
                    <p>ä»¥ä¸‹ã®3Dã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§ã€å„æˆé•·æ®µéšã‚’è¦–è¦šçš„ã«ä½“é¨“ã§ãã¾ã™ã€‚ä¸‹ã®ãƒ†ã‚­ã‚¹ãƒˆã®æ®µéšåã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦åˆ‡ã‚Šæ›¿ãˆã¦ãã ã•ã„ã€‚<br>ğŸ¨ï¼šã“ã‚Œã¯å€‹äººå†…ã®ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã‚’æ¯”å–©çš„ã«è¡¨ç¾ã—ãŸä¸€ä¾‹ã§ã™ã€‚</p>

                    <div id="refined-3d-container" class="sa-3d-container">
                        <div id="refined-3d-scene">
                            <!-- 3Dã‚·ãƒ¼ãƒ³å†…æµ®éŠãƒœã‚¿ãƒ³ -->
                            <button id="reset-view-btn" class="floating-view-control">
                                <span>â†º</span>
                                <span class="tooltip">è¦–ç‚¹ãƒªã‚»ãƒƒãƒˆ</span>
                            </button>
                        </div>
                        <div class="sa-3d-loading" id="refined-3d-loading">
                            <div class="loading-spinner"></div>
                            <p>3Dç’°å¢ƒã‚’åˆæœŸåŒ–ä¸­...</p>
                        </div>
                        <div class="sa-3d-controls" id="refined-3d-controls" style="display: none;">
                            <div class="stage-info-display" id="stage-info-display">
                                <h5 id="current-stage-title">Ea: å¤–çš„æ¨©å¨ã‚’ä¿¡é ¼ã™ã‚‹</h5>
                                <p id="current-stage-description">æ··æ²Œã¨ã—ãŸçŠ¶æ…‹ã‹ã‚‰æˆé•·ãŒå§‹ã¾ã‚Šã¾ã™</p>
                            </div>
                            <div class="stage-controls">
                                <button data-stage="Ea" class="stage-btn active">Ea</button>
                                <button data-stage="Eb" class="stage-btn">Eb</button>
                                <button data-stage="Ec" class="stage-btn">Ec</button>
                                <button data-stage="EI" class="stage-btn">E(I)</button>
                                <button data-stage="E-I" class="stage-btn">E-I</button>
                                <button data-stage="I-E" class="stage-btn">I-E</button>
                                <button data-stage="IE" class="stage-btn">I(E)</button>
                                <button data-stage="Ia" class="stage-btn">Ia</button>
                                <button data-stage="Ib" class="stage-btn">Ib</button>
                                <button data-stage="Ic" class="stage-btn">Ic</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="sa-3d-description">
                        <p><small>ğŸ’¡ 3Dç©ºé–“ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦è¦–ç‚¹ã‚’å¤‰æ›´ã€ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ ã‚¤ãƒ³ãƒ»ã‚¢ã‚¦ãƒˆã€ä¸‹ã®ãƒ†ã‚­ã‚¹ãƒˆã®æ®µéšåã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦æˆé•·æ®µéšã‚’åˆ‡ã‚Šæ›¿ãˆã‚‰ã‚Œã¾ã™ã€‚</small></p>
                    </div>
                </div>
                
                <h3>å¤–çš„ãªæ„å‘³å½¢æˆå±€é¢ã®è©³ç´°</h3>
                
                <div class="sub-phase">
                    <h4>Ea: å¤–çš„æ¨©å¨ã‚’ä¿¡é ¼ã™ã‚‹</h4>
                    <p>ä¸€è²«ã—ã¦ç›²ç›®çš„ã«å¤–çš„è³‡æºã‚’ä¿¡é ¼ã—ã€ãã®ã“ã¨ã®æ¬ ç‚¹ã®å¯èƒ½æ€§ã‚’èªè­˜ã™ã‚‹ã“ã¨ã‚‚ãªã„ã€‚</p>
                </div>
                
                <div class="sub-phase">
                    <h4>Eb: å¤–çš„æ¨©å¨ã‚’ä¿¡é ¼ã™ã‚‹ã“ã¨ã¨ã®ç·Šå¼µ</h4>
                    <p>ä¸€è²«ã—ã¦å¤–çš„è³‡æºã‚’ä¿¡é ¼ã™ã‚‹ãŒã€ãã†ã™ã‚‹ã“ã¨ã®ç·Šå¼µã‚’çµŒé¨“ã™ã‚‹ï¼ˆã¨ãã«å¤–çš„è³‡æºã®é–“ã«è‘›è—¤ãŒã‚ã‚‹å ´åˆï¼‰ã€‚è‘›è—¤ã‚’è§£æ¶ˆã—ã‚ˆã†ã¨ã—ã¦è¤‡æ•°ã®æ¨©å¨ã®æ–¹ã‚’è¦‹ã‚‹ã€‚</p>
                </div>
                
                <div class="sub-phase">
                    <h4>Ec: å¤–çš„æ¨©å¨ã‚’ä¿¡é ¼ã™ã‚‹ã“ã¨ã®æ¬ ç‚¹ã‚’èªè­˜ã™ã‚‹</h4>
                    <p>å¤–çš„æ¨©å¨ã¸ã®ä¿¡é ¼ã‚’ç¶™ç¶šã™ã‚‹ãŒã€ãã®ã“ã¨ã®æ¬ ç‚¹ã‚’èªè­˜ã—ã¦ã„ã‚‹ã€‚</p>
                </div>
                
                <h3>å²è·¯å±€é¢ã®è©³ç´°</h3>
                
                <div class="sub-phase">
                    <h4>E(I): å¤–çš„æ¨©å¨ã«ç–‘å•ã‚’æŒã¤ï¼ˆå²è·¯ã«å…¥ã‚‹ï¼‰</h4>
                    <p>å†…ãªã‚‹å£°ã®å¿…è¦æ€§ã‚’è‡ªè¦šã™ã‚‹ã‚‚ã€å¤–çš„è³‡æºã¸ã®ä¿¡é ¼ã‚’ç¶™ç¶šã™ã‚‹ã€‚å¤–çš„æ„å‘³å½¢æˆã®ã‚¸ãƒ¬ãƒ³ãƒã‚’è‡ªè¦šã™ã‚‹ãŒã€ã©ã†é€²ã‚ã°ã„ã„ã‹ã‚ã‹ã‚‰ãªã„ã€‚</p>
                </div>
                
                <div class="sub-phase">
                    <h4>E-I: å†…ãªã‚‹å£°ã‚’æ§‹ç¯‰ã™ã‚‹</h4>
                    <p>æ„å‘³å½¢æˆã®æ–°ã—ã„ä»•æ–¹ã‚’æ§‹ç¯‰ã™ã‚‹ã‚ˆã†èƒ½å‹•çš„ã«å‹•ãå§‹ã‚ã‚‹ãŒã€ä»¥å‰ã®å¤–çš„ä½ç½®ã«ã€Œå¾Œé€€ã™ã‚‹ã€ã“ã¨ã‚‚ã‚ã‚‹ã€‚</p>
                </div>
                
                <div class="sub-phase">
                    <h4>I-E: å†…ãªã‚‹å£°ã‚’è´ãï¼ˆå²è·¯ã‹ã‚‰å‡ºã‚‹ï¼‰</h4>
                    <p>å†…ãªã‚‹å£°ã‚’æ³¨æ„æ·±ãèãå–ã‚Šå§‹ã‚ã€å¤–çš„è³‡æºã‚’æŠ¼ã—ã®ã‘ã¤ã¤ã‚ã‚‹ã€‚å¤–çš„è³‡æºãŒã¾ã å¼·ãã€å†…ãªã‚‹å£°ã‚’ä¸€è²«ã—ã¦ç¶­æŒã™ã‚‹ã“ã¨ã‚’é›£ã—ãã—ã¦ã„ã‚‹ã€‚</p>
                </div>
                
                <div class="sub-phase">
                    <h4>I(E): å†…ãªã‚‹å£°ã‚’è‚²ã‚€</h4>
                    <p>å†…ãªã‚‹å£°ã‚’èƒ½å‹•çš„ã«è‚²ã¿å§‹ã‚ã€å†…ãªã‚‹å£°ãŒå¤šãã®å¤–çš„è³‡æºã‚’åª’ä»‹ã™ã‚‹ã€‚ä»–è€…ã®è¦–ç‚¹ãŒè‡ªèº«ã®è¦–ç‚¹ã‚’åŒ…æ‘‚ã—ã¦ã—ã¾ã†ãã‚Œã¾ã§ã®å‚¾æ€§ã«æˆ»ã‚‰ãªã„ã‚ˆã†ã«æ„è­˜ã™ã‚‹ã€‚</p>
                </div>
                
                <h3>å†…çš„ãªæ„å‘³å½¢æˆï¼ˆã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ï¼‰å±€é¢ã®è©³ç´°</h3>
                
                <div class="sub-phase">
                    <h4>Ia: å†…ãªã‚‹å£°ã‚’ä¿¡é ¼ã™ã‚‹</h4>
                    <p>ä¿¡å¿µã€ä¾¡å€¤ã€ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã€é–¢ä¿‚ã‚’æ´—ç·´ã™ã‚‹ã®ã«ååˆ†ãªã»ã©å†…ãªã‚‹å£°ã‚’ä¿¡é ¼ã™ã‚‹ã€‚åå¿œã‚’å½¢ä½œã‚Šã€å¤–çš„è³‡æºã‚’ç®¡ç†ã™ã‚‹ã®ã«å†…ãªã‚‹å£°ã‚’æ´»ç”¨ã™ã‚‹ã€‚</p>
                </div>
                
                <div class="sub-phase">
                    <h4>Ib: å†…ãªã‚‹åŸºç›¤ã‚’ç¯‰ã</h4>
                    <p>å¤–çš„è³‡æºã«ã©ã†åå¿œã™ã‚‹ã‹ã‚’å°ãäººç”Ÿå“²å­¦ã¸ã®ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒ³ãƒˆã‚’å½¢æˆã™ã‚‹ã®ã«ååˆ†ãªã»ã©å†…ãªã‚‹å£°ã‚’ä¿¡é ¼ã™ã‚‹ã€‚</p>
                </div>
                
                <div class="sub-phase">
                    <h4>Ic: å†…ãªã‚‹ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒ³ãƒˆã‚’ç¢ºä¿ã™ã‚‹</h4>
                    <p>äººç”Ÿå“²å­¦ã‚’è‡ªåˆ†ã®å­˜åœ¨ã®æ ¸ã¨ã—ã¦å›ºã‚ã€ãã‚Œã‚’ç¬¬äºŒã®æ€§è³ªã¨ã—ã¦ç”Ÿãã‚‹ã€‚</p>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>ğŸ› ï¸ å®Ÿè·µåŸå‰‡ï¼šãƒ©ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ»ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ã‚·ãƒƒãƒ—ãƒ»ãƒ¢ãƒ‡ãƒ«ï¼ˆLPMï¼‰</h2>
        <p>å­¦ç”Ÿã®ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—æˆé•·ã‚’æ”¯æ´ã™ã‚‹3ã¤ã®å®Ÿè·µåŸå‰‡ï¼š</p>
        
        <div class="principle">
            <h3>1. å­¦ç¿’è€…ã®çŸ¥ã‚‹èƒ½åŠ›ã‚’ç¢ºã‹ã‚ã‚‹</h3>
            <p>å­¦ç”ŸãŒã©ã®ã‚ˆã†ã«çŸ¥è­˜ã‚’æ‰ãˆã¦ã„ã‚‹ã‹ã‚’ç†è§£ã—ã€ãã®æ®µéšã«å¿œã˜ãŸã‚µãƒãƒ¼ãƒˆã‚’æä¾›ã™ã‚‹</p>
            <p><strong>å®Ÿè·µä¾‹ï¼š</strong>ã€Œãªãœãã†æ€ã†ã®ï¼Ÿã€ã€Œã©ã†ã‚„ã£ã¦ãã®çµè«–ã«è‡³ã£ãŸï¼Ÿã€ã¨ã„ã†å•ã„ã‹ã‘</p>
        </div>
        
        <div class="principle">
            <h3>2. å­¦ç”Ÿã®å­¦ã³ã‚’ãã®å­¦ç”Ÿã®çµŒé¨“ã®ä¸­ã«ä½ç½®ã¥ã‘ã‚‹</h3>
            <p>æŠ½è±¡çš„ãªå­¦ã³ã§ã¯ãªãã€å­¦ç”Ÿè‡ªèº«ã®çµŒé¨“ã¨çµã³ã¤ã‘ã¦ç†è§£ã‚’æ·±ã‚ã‚‹</p>
            <p><strong>å®Ÿè·µä¾‹ï¼š</strong>ã€Œã“ã®ç†è«–ã¯ã‚ãªãŸã®çµŒé¨“ã¨ã©ã†é–¢é€£ã™ã‚‹ï¼Ÿã€ã¨ã„ã†æŒ¯ã‚Šè¿”ã‚Š</p>
        </div>
        
        <div class="principle">
            <h3>3. å­¦ã³ã‚’ç›¸äº’çš„ãªæ„å‘³æ§‹æˆã¨å®šç¾©ã™ã‚‹</h3>
            <p>æ•™å“¡ã¨å­¦ç”Ÿã€å­¦ç”ŸåŒå£«ãŒå¯¾ç­‰ãªç«‹å ´ã§æ„å‘³ã‚’æ§‹ç¯‰ã—ã¦ã„ã</p>
            <p><strong>å®Ÿè·µä¾‹ï¼š</strong>ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ã‚„ã‚°ãƒ«ãƒ¼ãƒ—ãƒ¯ãƒ¼ã‚¯ã§ã®å”åƒçš„ãªçŸ¥è­˜æ§‹ç¯‰</p>
        </div>
        
        <button class="toggle-button" onclick="toggleSection('lpm-steps')">ğŸ“‹ LPMå®Ÿè·µã®10ã‚¹ãƒ†ãƒƒãƒ—ã‚’è¦‹ã‚‹</button>
        
        <div id="lpm-steps" class="collapsible">
            <div class="advanced-section">
                <h3>ãƒ©ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ»ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ã‚·ãƒƒãƒ—ãƒ»ãƒ¢ãƒ‡ãƒ«ï¼ˆLPMï¼‰å®Ÿè·µã®10ã‚¹ãƒ†ãƒƒãƒ—</h3>
                
                <h4>ãƒ•ã‚§ãƒ¼ã‚º1ï¼šå­¦ç¿’ç›®æ¨™ã¨å­¦ç¿’è€…ã®ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—èƒ½åŠ›ã‚’ã‚¢ã‚»ã‚¹ãƒ¡ãƒ³ãƒˆã™ã‚‹</h4>
                
                <div class="lpm-step">
                    <h5>ã‚¹ãƒ†ãƒƒãƒ—1ï¼šæ–‡è„ˆã®é¸å®š</h5>
                    <p>å­¦ç”Ÿã‚„åŒåƒšã¨ã®é–¢ã‚ã‚Šã‹ã‚‰ã€LPMã‚’ç”¨ã„ã¦ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã‚’å‘ä¸Šã™ã‚‹ã®ã«é©ã—ãŸå®Ÿè·µã¯ä½•ã‹ï¼Ÿ</p>
                    <p><em>ä¾‹ï¼šå’æ¥­è«–æ–‡ã€ãƒ”ã‚¢ãƒ»ã‚µãƒãƒ¼ãƒˆã€ã‚­ãƒ£ãƒªã‚¢ç›¸è«‡</em></p>
                </div>
                
                <div class="lpm-step">
                    <h5>ã‚¹ãƒ†ãƒƒãƒ—2ï¼šãã®æ–‡è„ˆã§ã®å­¦ç¿’ç›®æ¨™ã®è¨­å®š</h5>
                    <ul>
                        <li>ãã®æ–‡è„ˆã§ç¾åœ¨ã€é”æˆã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹å­¦ç¿’æˆæœã¯ä½•ã‹ï¼Ÿ</li>
                        <li>ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã‚’ã‚ˆã‚ŠåŒ…æ‹¬çš„ãªç›®æ¨™ã¨è€ƒãˆã‚‹ã¨ã€ç¾åœ¨è¨­å®šã—ã¦ã„ã‚‹å­¦ç¿’æˆæœï¼ç›®æ¨™ã‚’ã©ã®ã‚ˆã†ã«è¨­å®šã™ã‚‹ã“ã¨ã«ãªã‚‹ã‹ï¼Ÿ</li>
                        <li>å‚åŠ è€…ã«ä½•ã‚’ã‚ˆã‚Šã‚ˆãç†è§£ã—ã¦ã‚‚ã‚‰ã„ãŸã„ã‹ï¼Ÿä½•ã‚’ã‚ˆã‚Šã†ã¾ãå–ã‚Šçµ„ã‚ã‚‹ã‚ˆã†ã«ãªã£ã¦ã‚‚ã‚‰ã„ãŸã„ã‹ï¼Ÿ</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ã‚¹ãƒ†ãƒƒãƒ—3ï¼šã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®è¦–ç‚¹ã‹ã‚‰å­¦ç¿’ç›®æ¨™ã®æ¤œè¨</h5>
                    <ul>
                        <li><strong>èªçŸ¥èƒ½åŠ›ï¼š</strong>ãã‚Œã‚‰ã®å­¦ç¿’ç›®æ¨™ã‚’é”æˆã™ã‚‹ã®ã«ã€ã©ã®ã‚ˆã†ãªä»•æ–¹ã§çŸ¥è­˜ã‚’æ§‹ç¯‰ã™ã‚‹ã‹ï¼Ÿ</li>
                        <li><strong>å¯¾è‡ªé–¢ä¿‚èƒ½åŠ›ï¼š</strong>è‡ªåˆ†è‡ªèº«ã‚’ã©ã®ã‚ˆã†ãªä»•æ–¹ã§è¦‹ã¦ç†è§£ã™ã‚‹ã“ã¨ãŒæ±‚ã‚ã‚‰ã‚Œã‚‹ã‹ï¼Ÿ</li>
                        <li><strong>å¯¾äººé–¢ä¿‚èƒ½åŠ›ï¼š</strong>ä»–è€…ã¨ã®é–¢ä¿‚ã®ä¸­ã®è‡ªåˆ†è‡ªèº«ã‚’ã©ã®ã‚ˆã†ãªä»•æ–¹ã§ç†è§£ã™ã‚‹ã“ã¨ãŒæ±‚ã‚ã‚‰ã‚Œã‚‹ã‹ï¼Ÿ</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ã‚¹ãƒ†ãƒƒãƒ—4ï¼šãã®æ–‡è„ˆã§ã®å­¦ç¿’è€…ã®ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ç‰¹å¾´ã®è€ƒæ…®</h5>
                    <ul>
                        <li>å­¦ç¿’è€…ãŒå…±é€šã—ã¦ç”¨ã„ã‚‹çŸ¥è­˜æ§‹ç¯‰ã®ä»•æ–¹ã¯ï¼Ÿ</li>
                        <li>å­¦ç¿’è€…ã«ã‚ˆã£ã¦ç¤ºã•ã‚Œã‚‹è‡ªåˆ†è‡ªèº«ã®è¦‹æ–¹ã¯ï¼Ÿ</li>
                        <li>å­¦ç¿’è€…ãŒç¤ºã™ä»–è€…ã¨ã®é–¢ä¿‚ã®ä¸­ã®è‡ªåˆ†è‡ªèº«ã®è¦‹æ–¹ã¯ï¼Ÿ</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ã‚¹ãƒ†ãƒƒãƒ—5ï¼šå­¦ç¿’ç›®æ¨™ã¨å­¦ç¿’è€…èƒ½åŠ›ã®é–“ã®æ•´åˆæ€§ã¨ä¸æ•´åˆã®ç‰¹å®š</h5>
                    <ul>
                        <li>å­¦ç¿’ç›®æ¨™ã¨å­¦ç¿’è€…ã®ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—èƒ½åŠ›ã¯ã©ã®ã‚ˆã†ã«çµã³ã¤ãã‹ï¼Ÿ</li>
                        <li>ãã‚Œã‚‰ã®é–“ã«ã‚ã‚‹ä¸æ•´åˆã¯ã©ã“ã‹ï¼Ÿ</li>
                        <li>ã©ã‚“ãªæˆé•·ç›®æ¨™ãŒã€å¿…è¦ãªèƒ½åŠ›ã¨ç‹™ã„ã¨ã™ã‚‹å­¦ç¿’æˆæœã®é–“ã‚’æ©‹æ¸¡ã—ã™ã‚‹ã®ã«å½¹ç«‹ã¤ã‹ï¼Ÿ</li>
                    </ul>
                </div>
                
                <h4>ãƒ•ã‚§ãƒ¼ã‚º2ï¼šã€Œé€²åŒ–ã®æ¶ã‘æ©‹ã€ã‚’ãƒ‡ã‚¶ã‚¤ãƒ³ã™ã‚‹</h4>
                
                <div class="lpm-step">
                    <h5>ã‚¹ãƒ†ãƒƒãƒ—6ï¼šæˆé•·ã™ã‚‹ã€Œã‚«ãƒªã‚­ãƒ¥ãƒ©ãƒ ã€ã®ç´ æ</h5>
                    <ul>
                        <li>å­¦ç¿’ç›®æ¨™ã¨æˆé•·ç›®æ¨™ã¯ã€ã©ã®ã‚ˆã†ã«æ™‚é–“ã‚’ã‹ã‘ã¦ã‚¹ãƒ†ãƒƒãƒ—ã«å¤‰æ›ã•ã‚Œã‚‹ã‹ï¼Ÿ</li>
                        <li>å­¦ç¿’è€…ã¸ã®é–¢ä¸ã®é•·ã•ã«ã¨ã‚‚ãªã£ã¦ã€æœ€åˆã®æ™‚ç‚¹ã§ã€å­¦ç¿’ç›®æ¨™ã¨æˆé•·ç›®æ¨™ã¯ã©ã®ã‚ˆã†ãªå½¢æ…‹ã¨ãªã‚‹ã‹ï¼Ÿ</li>
                        <li>ã‚¹ãƒ†ãƒƒãƒ—ã®ã©ã‚ŒãŒã“ã‚Œã¾ã§ã«é€šéã—ã€ã©ã‚ŒãŒã“ã‚Œã‹ã‚‰å‘ã‹ã†å¿…è¦ã®ã‚ã‚‹ã‚‚ã®ã‹ï¼Ÿ</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ã‚¹ãƒ†ãƒƒãƒ—7ï¼š3ã¤ã®æƒ³å®šã«å–ã‚Šçµ„ã‚€</h5>
                    <p><strong>çŸ¥è­˜ã¯è¤‡é›‘ã§ç¤¾ä¼šçš„ã«æ§‹ç¯‰ã•ã‚Œã‚‹ / è‡ªå·±ãŒçŸ¥è­˜æ§‹ç¯‰ã®ä¸­å¿ƒã§ã‚ã‚‹ / ç†Ÿç·´ã¨æ¨©å¨ã¯ç›¸äº’ã«å…±æœ‰ã•ã‚Œã‚‹</strong></p>
                    <ul>
                        <li>ã‚ãªãŸã®å®Ÿè·µé ˜åŸŸã«ãŠã„ã¦ã€ã“ã‚Œã‚‰ã®æƒ³å®šã¯ç¾åœ¨ã©ã®ã‚ˆã†ãªä»•æ–¹ã§ç¤ºã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ</li>
                        <li>ã©ã†ã™ã‚Œã°ã‚ˆã‚ŠåŠ¹æœçš„ã«ã“ã‚Œã‚‰ã®æƒ³å®šã‚’å­¦ç¿’è€…ã«ä¼ãˆã‚‰ã‚Œã‚‹ã‹ï¼Ÿ</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ã‚¹ãƒ†ãƒƒãƒ—8ï¼š3ã¤ã®åŸå‰‡ã«å–ã‚Šçµ„ã‚€</h5>
                    <p>å­¦ç¿’è€…ã®çŸ¥ã‚‹èƒ½åŠ›ã‚’ç¢ºã‹ã‚ã‚‹ / å­¦ç¿’ã‚’å­¦ç¿’è€…ã®çµŒé¨“ã«ä½ç½®ã¥ã‘ã‚‹ / å­¦ç¿’è€…ã¨æ„å‘³ã‚’ç›¸äº’æ§‹ç¯‰ã™ã‚‹</p>
                    <ul>
                        <li>ã“ã‚Œã‚‰ã®åŸå‰‡ã¯ç¾åœ¨ã©ã®ã‚ˆã†ãªä»•æ–¹ã§ç¤ºã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ</li>
                        <li>ã©ã†ã™ã‚Œã°ã‚ˆã‚ŠåŠ¹æœçš„ã«ã“ã‚Œã‚‰ã®åŸå‰‡ã‚’å­¦ç¿’è€…ã«ä¼ãˆã‚‰ã‚Œã‚‹ã‹ï¼Ÿ</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ã‚¹ãƒ†ãƒƒãƒ—9ï¼šæ•´åˆæ€§ã¨ä¸æ•´åˆã‚’å†åŸå‘³ã™ã‚‹</h5>
                    <ul>
                        <li>æ–°ã—ã„è¨ˆç”»ã¯ã€æ•´åˆã—ã¦ã„ã‚‹ã¨ã“ã‚ã‚’æºã‚‹ãŒã•ãªã„ã‹ï¼Ÿ</li>
                        <li>ã“ã®è¨ˆç”»ã¯ã€ã©ã®ä¸æ•´åˆã«å–ã‚Šçµ„ã‚€ã®ã‹ï¼Ÿ</li>
                        <li>å–ã‚Šçµ„ã‚€ã¹ãä¸æ•´åˆã®ã†ã¡ã€æ®‹ã‚‹ã‚‚ã®ã¯ã©ã‚Œã‹ï¼Ÿ</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ã‚¹ãƒ†ãƒƒãƒ—10ï¼šåŠ¹æœã‚’è©•ä¾¡ã™ã‚‹ãŸã‚ã®è¨ˆç”»ã‚’ç´ æã™ã‚‹</h5>
                    <ul>
                        <li>å‚åŠ è€…ã®ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—èƒ½åŠ›ã‚’ä¿ƒé€²ã™ã‚‹ã®ã«ã©ã‚Œã»ã©åŠ¹æœãŒã‚ã£ãŸã‹ã‚’æ±ºã‚ã‚‹ã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹ã¨ã—ã¦ä½¿ãˆã‚‹ã‚‚ã®ã¯ä½•ã‹ï¼Ÿ</li>
                        <li>ãã®ã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹ã¯ã©ã®ã‚ˆã†ã«é›†ã‚ã‚‰ã‚Œã‚‹ã ã‚ã†ã‹ï¼Ÿ</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>ğŸ“‹ å®Ÿè·µãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ</h2>
        
        <div class="checklist">
            <h4>å–ã‚Šçµ„ã¿æ¤œè¨æ™‚ã®æ´»ç”¨</h4>
            <ul>
                <li>å­¦ç”Ÿã«ã€Œè‡ªåˆ†ã®è€ƒãˆã€ã‚’æ±‚ã‚ã‚‹æ©Ÿä¼šã‚’è¨­ã‘ã¦ã„ã‚‹ã‹</li>
                <li>å¤šæ§˜ãªè¦–ç‚¹ã«è§¦ã‚Œã‚‹æ©Ÿä¼šã‚’æä¾›ã—ã¦ã„ã‚‹ã‹</li>
                <li>å¤±æ•—ã‚’æã‚ŒãšæŒ‘æˆ¦ã§ãã‚‹ç’°å¢ƒã‚’ä½œã£ã¦ã„ã‚‹ã‹</li>
                <li>æŒ¯ã‚Šè¿”ã‚Šã¨çœå¯Ÿã®æ™‚é–“ã‚’ç¢ºä¿ã—ã¦ã„ã‚‹ã‹</li>
                <li>å­¦ç”Ÿã®æˆé•·æ®µéšã«å¿œã˜ãŸèª²é¡Œè¨­å®šã‚’ã—ã¦ã„ã‚‹ã‹</li>
            </ul>
        </div>
        
        <div class="checklist">
            <h4>å­¦ç”Ÿæ”¯æ´ãƒ»ã‚¢ãƒ‰ãƒã‚¤ã‚¸ãƒ³ã‚°ã§ã®æ´»ç”¨</h4>
            <ul>
                <li>å­¦ç”Ÿã®ç¾åœ¨ã®æˆé•·å±€é¢ã‚’æŠŠæ¡ã—ã¦ã„ã‚‹ã‹</li>
                <li>ç­”ãˆã‚’ä¸ãˆã‚‹ã®ã§ã¯ãªãã€å•ã„ã‚’æŠ•ã’ã‹ã‘ã¦ã„ã‚‹ã‹</li>
                <li>å­¦ç”Ÿã®å†…ãªã‚‹å£°ã«è€³ã‚’å‚¾ã‘ã¦ã„ã‚‹ã‹</li>
                <li>é©åˆ‡ãªãƒãƒ£ãƒ¬ãƒ³ã‚¸ã¨ã‚µãƒãƒ¼ãƒˆã®ãƒãƒ©ãƒ³ã‚¹ã‚’å–ã£ã¦ã„ã‚‹ã‹</li>
                <li>å­¦ç”Ÿã®è‡ªå·±æ±ºå®šã‚’å°Šé‡ã—ã¦ã„ã‚‹ã‹</li>
            </ul>
        </div>
    </div>

    <div class="section">
        <h2>ğŸ“ˆ æˆé•·ã‚’ä¿ƒã™å…·ä½“çš„ãªå–ã‚Šçµ„ã¿ä¾‹</h2>
        
        <table>
            <thead>
                <tr>
                    <th>å–ã‚Šçµ„ã¿</th>
                    <th>æœŸå¾…ã•ã‚Œã‚‹åŠ¹æœ</th>
                    <th>å¯¾å¿œã™ã‚‹æ¬¡å…ƒ</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªä½œæˆ</td>
                    <td>è‡ªå·±ã®æˆé•·éç¨‹ã®å¯è¦–åŒ–ã¨çœå¯Ÿ</td>
                    <td>å¯¾è‡ªé–¢ä¿‚</td>
                </tr>
                <tr>
                    <td>ãƒ‡ã‚£ãƒ™ãƒ¼ãƒˆãƒ»è¨è«–</td>
                    <td>å¤šæ§˜ãªè¦–ç‚¹ã®ç†è§£ã¨è‡ªå·±ã®ç«‹å ´ã®æ˜ç¢ºåŒ–</td>
                    <td>èªè­˜è«–çš„</td>
                </tr>
                <tr>
                    <td>å”åƒãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ</td>
                    <td>ç›¸äº’ä¾å­˜çš„ãªé–¢ä¿‚æ§‹ç¯‰ã®çµŒé¨“</td>
                    <td>å¯¾äººé–¢ä¿‚</td>
                </tr>
                <tr>
                    <td>ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãƒ»ã‚¸ãƒ£ãƒ¼ãƒŠãƒ«</td>
                    <td>å†…ãªã‚‹å£°ã®ç™ºè¦‹ã¨è‚²æˆ</td>
                    <td>å…¨æ¬¡å…ƒ</td>
                </tr>
                <tr>
                    <td>ãƒ¡ãƒ³ã‚¿ãƒªãƒ³ã‚°ãƒ»ãƒ—ãƒ­ã‚°ãƒ©ãƒ </td>
                    <td>å¯¾è©±ã‚’é€šã˜ãŸè‡ªå·±ç†è§£ã®æ·±åŒ–</td>
                    <td>å…¨æ¬¡å…ƒ</td>
                </tr>
                <tr>
                    <td>ã‚µãƒ¼ãƒ“ã‚¹ãƒ»ãƒ©ãƒ¼ãƒ‹ãƒ³ã‚°</td>
                    <td>ç¤¾ä¼šçš„æ–‡è„ˆã§ã®è‡ªå·±ã®ä½ç½®ã¥ã‘ã®ç†è§£</td>
                    <td>å…¨æ¬¡å…ƒ</td>
                </tr>
                <tr>
                    <td>ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°ãƒ»ã‚«ãƒªã‚­ãƒ¥ãƒ©ãƒ </td>
                    <td>æ®µéšçš„ãªçŸ¥çš„æˆé•·ã¨è‡ªå·±è¡¨ç¾åŠ›ã®è‚²æˆ</td>
                    <td>èªè­˜è«–çš„ãƒ»å¯¾è‡ªé–¢ä¿‚</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="section">
        <h2>ğŸ’¡ å®Ÿè·µã®ãƒã‚¤ãƒ³ãƒˆ</h2>
        
        <div class="practical-tips">
            <h3>æˆé•·ã‚’æ”¯æ´ã™ã‚‹éš›ã®ç•™æ„ç‚¹</h3>
            <ul>
                <li><strong>éç·šå½¢ãªæˆé•·ã‚’ç†è§£ã™ã‚‹ï¼š</strong>å­¦ç”Ÿã¯3ã¤ã®å±€é¢ã‚’è¡Œãã¤æˆ»ã‚Šã¤ã—ãªãŒã‚‰æˆé•·ã—ã¾ã™</li>
                <li><strong>æ¬¡å…ƒé–“ã®é€£å‹•ã‚’æ„è­˜ã™ã‚‹ï¼š</strong>3ã¤ã®æ¬¡å…ƒã¯ç›¸äº’ã«å½±éŸ¿ã—åˆã„ã¾ã™</li>
                <li><strong>æ–‡è„ˆã®é‡è¦æ€§ï¼š</strong>å­¦ç”Ÿã®èƒŒæ™¯ã‚„ç’°å¢ƒã‚’è€ƒæ…®ã—ãŸã‚µãƒãƒ¼ãƒˆãŒå¿…è¦ã§ã™</li>
                <li><strong>ä¸å”å’Œã®æ´»ç”¨ï¼š</strong>è‘›è—¤ã‚„çŸ›ç›¾ã¯æˆé•·ã®å¥‘æ©Ÿã¨ãªã‚Šã¾ã™</li>
                <li><strong>é•·æœŸçš„è¦–ç‚¹ï¼š</strong>ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã¯æ™‚é–“ãŒã‹ã‹ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã§ã™</li>
                <li><strong>å¯¾è‡ªé–¢ä¿‚æ¬¡å…ƒãŒä¸­å¿ƒï¼š</strong>ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã¯å¯¾è‡ªé–¢ä¿‚æ¬¡å…ƒã‚’è»¸ã¨ã™ã‚‹æˆé•·ã§ã™</li>
            </ul>
        </div>
        
        <div class="practical-tips">
            <h3>æˆé•·ã®å¥‘æ©Ÿã¨ãªã‚‹ã‚‚ã®</h3>
            <ul>
                <li><strong>å¤–çš„æ„å‘³å½¢æˆæ®µéšï¼š</strong>å¤–çš„æ¨©å¨ã‚„æœŸå¾…ã®é–“ã®è¡çªãƒ»è‘›è—¤ï¼ˆä¸å”å’Œï¼‰</li>
                <li><strong>å²è·¯æ®µéšï¼š</strong>å†…ãªã‚‹å£°ã®ç™ºè¦‹ã¨æ´»ç”¨çµŒé¨“</li>
                <li><strong>ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—æ®µéšï¼š</strong>å†…ãªã‚‹åŸºç›¤ã«åŸºã¥ãè‡ªå·±æ±ºå®šã¨è¡Œå‹•ã®ç©ã¿é‡ã­</li>
            </ul>
        </div>
        
        <!-- æ–°è¦è¿½åŠ ï¼šã‚¸ãƒ£ãƒ¼ãƒ‹ãƒ¼ãƒãƒƒãƒ—ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <button class="toggle-button" onclick="toggleJourneyMap()">ğŸ“Š æˆé•·ã®é“ã®ã‚Šï¼ˆä¾‹ï¼‰ã‚’è¦‹ã‚‹ <span class="toggle-icon" id="journey-toggle-icon">â–¼</span></button>
        
        <div class="journey-map-section">
            
            <div class="journey-map-container" id="journey-map-container" style="display: none;">
                <div class="journey-iframe-wrapper">
                    <iframe id="journey-map-iframe"
                            src="./journey-map-embed.html"
                            width="100%"
                            height="800px"
                            frameborder="0"
                            style="border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    </iframe>
                </div>
                
                <div class="journey-map-description">
                    <h4>ã‚¸ãƒ£ãƒ¼ãƒ‹ãƒ¼ãƒãƒƒãƒ—ã«ã¤ã„ã¦</h4>
                    <p>ã“ã®ãƒ“ãƒ¥ãƒ¼ã‚¢ã¯ã€ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ç†è«–ã«åŸºã¥ã„ãŸå­¦ç”Ÿã®æˆé•·éç¨‹ã‚’è¦–è¦šåŒ–ã—ãŸã‚‚ã®ã§ã™ã€‚ã‚·ãƒŠãƒªã‚ªã¯ç”ŸæˆAIã‚’ç”¨ã„ã¦ä½œæˆã—ãŸä»®æƒ³ã®ã‚‚ã®ã§ã™ã€‚</p>
                    <ul>
                        <li><strong>ãƒšãƒ«ã‚½ãƒŠæ¯”è¼ƒï¼š</strong>ç•°ãªã‚‹å­¦ç¿’ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¯”è¼ƒåˆ†æ</li>
                        <li><strong>æˆé•·/åœæ»åˆ†æï¼š</strong>æˆé•·ãƒ»åœæ»ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å¯è¦–åŒ–</li>
                        <li><strong>åˆ†å²ç‚¹ç‰¹å®šï¼š</strong>é‡è¦ãªè»¢æ›ç‚¹ã®è©³ç´°åˆ†æ</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>ğŸ“š å‚è€ƒæƒ…å ±</h2>
        <p>ä¸Šè¨˜ã®æƒ…å ±ã¯ã€Baxter Magoldaã«ã‚ˆã‚‹ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ç†è«–ã€ãŠã‚ˆã³æ²³äº•äº¨ï¼ˆ2022ï¼‰ã€Œ<a href="https://ritsumei.repo.nii.ac.jp/records/16164">å¤§å­¦ç”Ÿã«ãŠã‘ã‚‹ã‚»ãƒ«ãƒ•ãƒ»ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ç†è«– : æˆé•·ç†è«–ã®ãªã‹ã®ä½ç½®ã¥ã‘ãŠã‚ˆã³æˆé•·çµŒè·¯ã¨å½±éŸ¿è¦å› ã®æå‡º</a>ã€ã‚’å‚ç…§ã—ãªãŒã‚‰ä½œæˆã—ã¦ã„ã¾ã™ã€‚</p>
        <p>ã‚ˆã‚Šè©³ç´°ãªç†è«–çš„èƒŒæ™¯ã‚„å®Ÿè·µäº‹ä¾‹ã«ã¤ã„ã¦ã¯ã€åŸè‘—è«–æ–‡ã‚’ã”å‚ç…§ãã ã•ã„ã€‚</p>
    </div>

    <script>
        // Self-Authorship 3D Integration Module
        class CoreGeometryManager {
            constructor() {
                this.currentGeometry = null;
                this.transitionDuration = 2000; // 2ç§’ã®ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³
            }

            createPolyhedronGeometry(stage) {
                // æ®µéšã«å¿œã˜ãŸã‚µã‚¤ã‚ºã®æ±ºå®š
                const baseSize = this.getStageSize(stage);
                
                switch(stage) {
                    case 'Ea':
                    case 'Eb': 
                    case 'Ec':
                        // æ­£å››é¢ä½“ (Tetrahedron) - External AuthorityæœŸ
                        return new THREE.TetrahedronGeometry(baseSize);
                        
                    case 'EI':
                    case 'E-I':
                    case 'I-E':
                        // æ­£å…«é¢ä½“ (Octahedron) - TransitionæœŸ
                        return new THREE.OctahedronGeometry(baseSize);
                        
                    case 'IE':
                    case 'Ia':
                        // æ­£åäºŒé¢ä½“ (Dodecahedron) - Internal FoundationæœŸ
                        return new THREE.DodecahedronGeometry(baseSize);
                        
                    case 'Ib':
                    case 'Ic':
                        // æ­£äºŒåé¢ä½“ (Icosahedron) - Self-AuthorshipæœŸ
                        return new THREE.IcosahedronGeometry(baseSize);
                        
                    default:
                        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æ­£å››é¢ä½“
                        return new THREE.TetrahedronGeometry(baseSize);
                }
            }

            getStageSize(stage) {
                // æˆé•·ã«å¿œã˜ãŸã‚µã‚¤ã‚ºãƒãƒƒãƒ”ãƒ³ã‚°
                const sizeMap = {
                    // External AuthorityæœŸ - å°ã•ãã€æœªç™ºé”
                    'Ea': 0.35,  // æœ€å°ã‚µã‚¤ã‚º
                    'Eb': 0.4,   // å°‘ã—æˆé•·
                    'Ec': 0.45,  // ç–‘å•ã®å…†ã—
                    
                    // TransitionæœŸ - ä¸­ç¨‹åº¦ã€æ¢æ±‚æœŸ
                    'EI': 0.5,   // å†…çš„æ¢æ±‚ã®å§‹ã¾ã‚Š
                    'E-I': 0.55, // å†…ãªã‚‹å£°ã®æ§‹ç¯‰
                    'I-E': 0.6,  // å†…ãªã‚‹å£°ã‚’è´ã
                    
                    // Internal FoundationæœŸ - å¤§ããã€ç¢ºç«‹æœŸ
                    'IE': 0.65,  // å†…ãªã‚‹å£°ã‚’è‚²ã‚€
                    'Ia': 0.7,   // å†…ãªã‚‹å£°ã‚’ä¿¡é ¼
                    
                    // Self-AuthorshipæœŸ - æœ€å¤§ã€çµ±åˆæœŸ
                    'Ib': 0.75,  // å†…ãªã‚‹åŸºç›¤ç¢ºç«‹
                    'Ic': 0.8    // æœ€å¤§ã‚µã‚¤ã‚ºã€å®Œå…¨ãªçµ±åˆ
                };
                
                return sizeMap[stage] || 0.35; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æœ€å°ã‚µã‚¤ã‚º
            }

            getSizeDescription(stage) {
                const size = this.getStageSize(stage);
                const percentage = Math.round((size / 0.8) * 100); // æœ€å¤§ã‚µã‚¤ã‚ºã‚’100%ã¨ã—ã¦
                return `ã‚µã‚¤ã‚º: ${percentage}% (${size.toFixed(2)})`;
            }

            getPolyhedronName(stage) {
                const shapeName = this.getShapeName(stage);
                const sizeInfo = this.getSizeDescription(stage);
                return `${shapeName} - ${sizeInfo}`;
            }

            getShapeName(stage) {
                switch(stage) {
                    case 'Ea': case 'Eb': case 'Ec':
                        return 'Tetrahedron (æ­£å››é¢ä½“)';
                    case 'EI': case 'E-I': case 'I-E':
                        return 'Octahedron (æ­£å…«é¢ä½“)';
                    case 'IE': case 'Ia':
                        return 'Dodecahedron (æ­£åäºŒé¢ä½“)';
                    case 'Ib': case 'Ic':
                        return 'Icosahedron (æ­£äºŒåé¢ä½“)';
                    default:
                        return 'Tetrahedron (æ­£å››é¢ä½“)';
                }
            }

            createWireframeGeometry(geometry) {
                // ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ åŠ¹æœç”¨
                const wireframe = new THREE.WireframeGeometry(geometry);
                return wireframe;
            }
        }

        class RefinedSelfAuthorshipVisualization {
            constructor() {
                this.container = null;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.currentStage = 'Ea';
                this.isInitialized = false;
                this.isInitializing = false;
                this.animationFrameId = null;
                this.particles = [];
                this.core = null;
                this.coreLight = null;                // ã‚³ã‚¢ç™ºå…‰ãƒ©ã‚¤ãƒˆ
                this.baseCoreIntensity = 0.3;         // ã‚³ã‚¢ã®åŸºæœ¬å…‰é‡
                this.currentCoreIntensity = 0.3;      // ç¾åœ¨ã®ã‚³ã‚¢å…‰é‡
                this.maxCoreIntensity = 1.5;          // æœ€å¤§ã‚³ã‚¢å…‰é‡
                this.absorptionCount = 0;             // å¸åã•ã‚ŒãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°
                this.dimensionRings = [];  // æ¬¡å…ƒãƒªãƒ³ã‚°ã®å‚ç…§ã‚’ä¿æŒ
                this.controls = null;
                
                // å¤šé¢ä½“ã‚·ã‚¹ãƒ†ãƒ 
                this.coreGeometryManager = new CoreGeometryManager();
                this.isTransitioning = false;        // å½¢çŠ¶å¤‰æ›´ä¸­ãƒ•ãƒ©ã‚°
                
                // æ®µéšçš„å…‰å¼·åŒ–ã‚·ã‚¹ãƒ†ãƒ  - ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã«å¿œã˜ãŸã‚³ã‚¢å…‰ã®ç™ºé”
                this.lightVeils = [];                 // å…‰ã®ãƒ™ãƒ¼ãƒ«é…åˆ—
                this.stageProgressionOrder = ['I-E', 'IE', 'Ia', 'Ib', 'Ic']; // å…‰ã®ãƒ™ãƒ¼ãƒ«ãŒå‡ºç¾ã™ã‚‹ã‚¹ãƒ†ãƒ¼ã‚¸é †
                this.currentStageIndex = 0;           // ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
                
                // å…‰ã®ãƒ™ãƒ¼ãƒ«ãŒè¡¨ç¤ºã•ã‚Œãªã„ã‚¹ãƒ†ãƒ¼ã‚¸ã®ãƒªã‚¹ãƒˆ
                this.noLightVeilStages = ['Ea', 'Eb', 'Ec', 'EI', 'E-I'];
                
                // I(E)ã‚¹ãƒ†ãƒ¼ã‚¸ä»¥é™ã®å…‰ç·šæ¥ç¶šã‚·ã‚¹ãƒ†ãƒ 
                this.connectionLines = [];            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é–“ã®æ¥ç¶šç·š
                this.connectionPairs = new Map();     // æ¥ç¶šãƒšã‚¢ã®ç®¡ç†
                this.maxConnections = 45;             // æœ€å¤§æ¥ç¶šæ•°ï¼ˆIcã‚¹ãƒ†ãƒ¼ã‚¸ã®æ¥µã‚ã¦è±Šå¯Œãªæ¥ç¶šã«å¯¾å¿œï¼‰
                this.connectionUpdateInterval = 10000; // æ¥ç¶šæ›´æ–°é–“éš”ï¼ˆãƒŸãƒªç§’ï¼‰- çµŒé¨“ã®çµã³ã¤ãã‚’é•·æ™‚é–“ç¶­æŒ
                this.lastConnectionUpdate = 0;        // æœ€å¾Œã®æ¥ç¶šæ›´æ–°æ™‚åˆ»
                
                // ã‚¹ãƒ†ãƒ¼ã‚¸åˆ¥æ¥ç¶šåˆ¶é™ - ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã«å¿œã˜ãŸçµŒé¨“çµ±åˆèƒ½åŠ›ã®ç™ºé”
                this.stageConnectionLimits = {
                    'IE': 3,      // IEã‚¹ãƒ†ãƒ¼ã‚¸ï¼šå†…ãªã‚‹å£°ã‚’è‚²ã‚€æ®µéš - å°‘ãªã„æ¥ç¶š
                    'Ia': 8,      // Iaã‚¹ãƒ†ãƒ¼ã‚¸ï¼šéå»ã®æ„å‘³ã¥ã‘æ®µéš - åŸºç¤çš„ãªæ¥ç¶š
                    'Ib': 12,      // Ibã‚¹ãƒ†ãƒ¼ã‚¸ï¼šçµ±åˆã®åŸºç›¤æ®µéš - ä¸­ç¨‹åº¦ã®æ¥ç¶š
                    'Ic': 24      // Icã‚¹ãƒ†ãƒ¼ã‚¸ï¼šç™ºè¦‹ã¨æ°—ã¥ãæ®µéš - æ¥µã‚ã¦è±Šå¯Œãªæ¥ç¶šï¼ˆåºƒç¯„å›²ãªçµŒé¨“çµ±åˆãƒ»å®Œå…¨ãªã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒ³ãƒˆï¼‰
                };
                
                // Zoom controls
                this.defaultCameraZ = 10;
                this.minZoom = 3;
                this.maxZoom = 20;
                this.zoomSpeed = 0.1;
                
                // Dynamic particle management for questioning stage
                this.dynamicParticles = [];
                this.lastParticleSpawn = 0;
                this.persistentParticleIndices = new Set();
                
                // Colorful particle system for I(E) stages and beyond
                this.colorfulParticlePalette = [
                    0xff6b6b, 0x4ecdc4, 0x45b7d1, 0x96c93d, 0xffeaa7,
                    0xdda0dd, 0x98d8c8, 0xf7dc6f, 0xbb8fce, 0x85c1e9,
                    0xf8c471, 0x82e0aa, 0xf1948a, 0x85c1e9, 0xc39bd3,
                    0x7fb3d3, 0xaed6f1, 0xf9e79f, 0xa3e4d7, 0xd7bde2
                ];
                this.colorTransitionSpeed = 0.05;
                
                // I-E Stage Particle Emergence System
                this.isEmergingIE = false;           // I-Eå‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ãƒ•ãƒ©ã‚°
                this.emergenceStartTime = 0;         // å‡ºç¾é–‹å§‹æ™‚åˆ»
                this.emergenceDelay = 500;           // åˆ‡ã‚Šæ›¿ãˆå¾Œã®é…å»¶ï¼ˆmsï¼‰
                this.emergenceDuration = 2500;       // å…¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å‡ºç¾æœŸé–“ï¼ˆmsï¼‰
                this.particleEmergenceInterval = 100; // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é–“å‡ºç¾é–“éš”ï¼ˆmsï¼‰
                this.emergingParticles = [];         // å‡ºç¾ä¸­ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒªã‚¹ãƒˆ
            }
            
            async init(containerId) {
                if (this.isInitialized || this.isInitializing) return;
                this.isInitializing = true;
                
                this.container = document.getElementById(containerId);
                if (!this.container) {
                    console.error('ã‚³ãƒ³ãƒ†ãƒŠãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:', containerId);
                    this.showError();
                    this.isInitializing = false;
                    return;
                }
                
                // WebGLã‚µãƒãƒ¼ãƒˆã®ç¢ºèª
                if (!this.checkWebGLSupport()) {
                    console.error('WebGLãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“');
                    this.showError();
                    this.isInitializing = false;
                    return;
                }
                
                this.showLoading();
                
                try {
                    await this.createScene();
                    this.createControls();
                    this.bindEvents();
                    this.startAnimation();
                    this.hideLoading();
                    this.isInitialized = true;
                    console.log('3Dç’°å¢ƒãŒåˆæœŸåŒ–ã•ã‚Œã¾ã—ãŸ');
                } catch (error) {
                    console.error('3DåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
                    console.error('ã‚¨ãƒ©ãƒ¼è©³ç´°:', error.message);
                    console.error('ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹:', error.stack);
                    this.showError();
                } finally {
                    this.isInitializing = false;
                }
            }
            
            // WebGLã‚µãƒãƒ¼ãƒˆã®ç¢ºèª
            checkWebGLSupport() {
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    return gl !== null;
                } catch (e) {
                    return false;
                }
            }

            showLoading() {
                const loading = document.getElementById('refined-3d-loading');
                if (loading) loading.style.display = 'flex';
            }
            
            hideLoading() {
                const loading = document.getElementById('refined-3d-loading');
                const controls = document.getElementById('refined-3d-controls');
                if (loading) loading.style.display = 'none';
                if (controls) controls.style.display = 'block';
            }
            
            showError() {
                const loading = document.getElementById('refined-3d-loading');
                if (loading) {
                    loading.innerHTML = `
                        <div style="text-align: center; color: #ff6b6b;">
                            <h4>3Dè¡¨ç¤ºã‚¨ãƒ©ãƒ¼</h4>
                            <p>3Dè¡¨ç¤ºã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</p>
                            <p>ä»¥ä¸‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼š</p>
                            <ul style="text-align: left; max-width: 400px; margin: 0 auto;">
                                <li>ãƒ–ãƒ©ã‚¦ã‚¶ãŒWebGLã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‹</li>
                                <li>ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã‚¢ã‚¯ã‚»ãƒ©ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãŒæœ‰åŠ¹ã‹</li>
                                <li>ãƒ–ãƒ©ã‚¦ã‚¶ãŒæœ€æ–°ç‰ˆã‹</li>
                            </ul>
                            <p style="margin-top: 15px;">
                                <button onclick="location.reload()" style="padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                    å†èª­ã¿è¾¼ã¿
                                </button>
                            </p>
                        </div>
                    `;
                }
            }
            
            async createScene() {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        try {
                            // Create Three.js scene
                            this.scene = new THREE.Scene();
                            this.scene.background = new THREE.Color(0x0a0a0a);
                            
                            // Create camera
                            const aspect = this.container.offsetWidth / this.container.offsetHeight;
                            this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
                            this.camera.position.set(0, 0, this.defaultCameraZ);
                            
                            // Create renderer
                            this.renderer = new THREE.WebGLRenderer({ antialias: true });
                            this.renderer.setSize(this.container.offsetWidth, this.container.offsetHeight);
                            this.renderer.setClearColor(0x0a0a0a);
                            
                            // Add renderer to container
                            const sceneElement = document.getElementById('refined-3d-scene');
                            if (sceneElement) {
                                sceneElement.appendChild(this.renderer.domElement);
                            }
                            
                            // Create basic 3D content
                            this.createInitialContent();
                        
                        // Add lighting
                        const ambientLight = new THREE.AmbientLight(0x606060, 0.5); // ã‚ˆã‚Šæ˜ã‚‹ã„ç’°å¢ƒå…‰
                        this.scene.add(ambientLight);
                        
                        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // ã‚ˆã‚Šå¼·ã„æŒ‡å‘æ€§ãƒ©ã‚¤ãƒˆ
                        directionalLight.position.set(10, 10, 5);
                        this.scene.add(directionalLight);
                        
                        // è¿½åŠ ã®ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆã§ç«‹ä½“æ„Ÿã‚’å¼·åŒ–
                        const pointLight1 = new THREE.PointLight(0xffffff, 0.5, 100);
                        pointLight1.position.set(-10, -10, 10);
                        this.scene.add(pointLight1);
                            
                            const pointLight2 = new THREE.PointLight(0xffffff, 0.3, 100);
                            pointLight2.position.set(5, -5, -10);
                            this.scene.add(pointLight2);
                            
                            resolve();
                        } catch (error) {
                            console.error('createSceneå†…ã§ã‚¨ãƒ©ãƒ¼:', error);
                            reject(error);
                        }
                    }, 2000); // 2ç§’ã®åˆæœŸåŒ–æ™‚é–“
                });
            }
            
            createInitialContent() {
                // Create core (self) with polyhedron geometry
                this.createPolyhedronCore(this.currentStage);
                
                // Create core light for enhanced introspection effect
                this.coreLight = new THREE.PointLight(0xffffcc, this.baseCoreIntensity, 10);
                this.coreLight.position.set(0, 0, 0);
                this.scene.add(this.coreLight);
                
                // Initialize progressive light enhancement system
                this.initializeLightVeils();
                
                // Create dimension rings
                this.createDimensionRings();
                
                // Create stage-specific particles
                this.createStageParticles();
            }
            
            createDimensionRings() {
                // æ—¢å­˜ã®ãƒªãƒ³ã‚°ã‚’ã‚¯ãƒªã‚¢
                this.dimensionRings.forEach(ring => this.scene.remove(ring));
                this.dimensionRings = [];
                
                // ç¾åœ¨ã®æ®µéšç•ªå·ã‚’å–å¾—ï¼ˆåˆæœŸåŒ–æ™‚ã¯Ea=1ï¼‰
                const currentStageNumber = this.getStageNumber(this.currentStage || 'Ea');
                
                for (let i = 0; i < 3; i++) {
                    // æ®µéšã«å¿œã˜ãŸåŠå¾„ã‚’å–å¾—
                    const radius = this.getDimensionRingRadius(i, currentStageNumber);
                    const geometry = new THREE.TorusGeometry(radius, 0.05, 8, 32);
                    
                    // å¤šé¢ä½“ã‚³ã‚¢ã¨çµ±ä¸€ã—ãŸæè³ªã‚·ã‚¹ãƒ†ãƒ 
                    const material = new THREE.MeshPhongMaterial({ 
                        color: this.getDimensionRingColor(i, currentStageNumber),
                        transparent: true,
                        opacity: this.getDimensionRingOpacity(currentStageNumber),
                        shininess: this.getDimensionRingShininess(currentStageNumber),
                        emissive: this.getDimensionRingEmissive(i, currentStageNumber),
                        emissiveIntensity: this.getDimensionRingEmissiveIntensity(currentStageNumber),
                        specular: 0x888888 // çµ±ä¸€ã•ã‚ŒãŸåå°„å…‰
                    });
                    
                    const ring = new THREE.Mesh(geometry, material);
                    ring.rotation.x = Math.PI / 2 + (i * Math.PI / 6);
                    
                    // æ®µéšçš„é€²åŒ–ã®ãŸã‚ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¿½åŠ 
                    ring.userData = {
                        ringIndex: i,
                        baseRotationX: Math.PI / 2 + (i * Math.PI / 6),
                        baseRotationSpeed: 0.1 + i * 0.05, // åŸºæœ¬å›è»¢é€Ÿåº¦
                        rotationDirection: i % 2 === 0 ? 1 : -1,
                        interactionPhase: 0, // ç›¸äº’ä½œç”¨ã®ä½ç›¸
                        synchronizationFactor: 0, // åŒæœŸåº¦åˆã„
                        materialEvolution: 0 // æè³ªé€²åŒ–åº¦
                    };
                    
                    this.scene.add(ring);
                    this.dimensionRings.push(ring);
                }
            }
            
            // æ®µéšã«å¿œã˜ãŸæ¬¡å…ƒãƒªãƒ³ã‚°ã®åŠå¾„ã‚’æ±ºå®š
            getDimensionRingRadius(ringIndex, stage) {
                // åŸºæœ¬åŠå¾„ï¼ˆåˆæœŸã‚µã‚¤ã‚ºï¼‰
                const baseRadii = [1.8, 2.5, 3.2]; // å†…å´ã€ä¸­é–“ã€å¤–å´ãƒªãƒ³ã‚°
                const baseRadius = baseRadii[ringIndex];
                
                // æ®µéšã«å¿œã˜ãŸã‚µã‚¤ã‚ºå€ç‡
                let sizeMultiplier;
                
                if (stage <= 3) {
                    // Ea, Eb, Ec: å°ã•ã‚ã‹ã‚‰é–‹å§‹
                    sizeMultiplier = 0.7 + stage * 0.1; // 0.8-1.0å€
                } else if (stage <= 7) {
                    // EI, E-I, I-E, IE: å¾ã€…ã«æ‹¡å¤§
                    sizeMultiplier = 1.0 + (stage - 3) * 0.12; // 1.0-1.48å€
                } else {
                    // Ia, Ib, Ic: æœ€ã‚‚å¤§ãã
                    sizeMultiplier = 1.48 + (stage - 7) * 0.08; // 1.48-1.72å€
                }
                
                return baseRadius * sizeMultiplier;
            }

            // æ®µéšã«å¿œã˜ãŸæ¬¡å…ƒãƒªãƒ³ã‚°ã®è‰²ã‚’æ±ºå®šï¼ˆå¤šé¢ä½“ã‚³ã‚¢ã¨çµ±ä¸€åŒ–ï¼‰
            getDimensionRingColor(ringIndex, stage) {
                // å¤šé¢ä½“ã‚³ã‚¢ã®è‰²ã‚·ã‚¹ãƒ†ãƒ ã¨çµ±ä¸€ã—ãŸè‰²ç›¸é…ç½®
                const baseHues = [240, 300, 60]; // é’ç´«ç³», ç´«ç³», é»„ç·‘ç³»
                const hue = baseHues[ringIndex];
                
                // å¤šé¢ä½“ã‚³ã‚¢ã®ã‚µã‚¤ã‚ºé€²åŒ–ã«åˆã‚ã›ãŸè‰²å½©ç™ºå±•
                const coreProgress = this.getCoreProgress(stage);
                
                // æ®µéšã«å¿œã˜ãŸè‰²å½©ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ ã¨çµ±ä¸€ï¼‰
                let saturation, lightness;
                
                if (stage <= 3) {
                    // EAæ®µéš: è½ã¡ç€ã„ãŸåŸºèª¿è‰²
                    saturation = 45 + coreProgress * 15;     // 45-60%
                    lightness = 25 + coreProgress * 15;      // 25-40%
                } else if (stage <= 7) {
                    // å²è·¯æ®µéš: æ´»ç™ºãªå¤‰åŒ–ã‚’è¡¨ç¾
                    const transitionFactor = (stage - 3) / 4;
                    saturation = 60 + transitionFactor * 20; // 60-80%
                    lightness = 40 + transitionFactor * 25;  // 40-65%
                } else {
                    // IAæ®µéš: è¼ãå®Œæˆå½¢
                    const masterFactor = (stage - 7) / 3;
                    saturation = 80 + masterFactor * 15;     // 80-95%
                    lightness = 65 + masterFactor * 20;      // 65-85%
                }
                
                // ãƒªãƒ³ã‚°é–“ã®å¾®å¦™ãªè‰²å½©å¤‰åŒ–ï¼ˆçµ±ä¸€æ„Ÿã‚’ä¿ã¡ãªãŒã‚‰åŒºåˆ¥ï¼‰
                const ringVariation = ringIndex * 0.05;
                saturation = Math.min(95, saturation + ringVariation * 10);
                lightness = Math.max(15, lightness - ringVariation * 5);
                
                return new THREE.Color().setHSL(hue / 360, saturation / 100, lightness / 100).getHex();
            }
            
            // æ®µéšã«å¿œã˜ãŸé€æ˜åº¦ã‚’æ±ºå®š
            getDimensionRingOpacity(stage) {
                if (stage <= 3) {
                    // EAæ®µéš: 0.35-0.50
                    return 0.35 + stage * 0.05;
                } else if (stage <= 7) {
                    // å²è·¯æ®µéš: 0.50-0.82
                    return 0.50 + (stage - 3) * 0.08;
                } else {
                    // IAæ®µéš: 0.82-0.94 (æœ€ã‚‚æ˜ã‚‹ã)
                    return 0.82 + (stage - 7) * 0.04;
                }
            }
            
            // æ®µéšã«å¿œã˜ãŸå…‰æ²¢åº¦ã‚’æ±ºå®šï¼ˆå¤šé¢ä½“ã‚³ã‚¢ã¨çµ±ä¸€åŒ–ï¼‰
            getDimensionRingShininess(stage) {
                // å¤šé¢ä½“ã‚³ã‚¢ã®å…‰æ²¢é€²åŒ–ã‚·ã‚¹ãƒ†ãƒ ã¨çµ±ä¸€
                const coreProgress = this.getCoreProgress(stage);
                
                if (stage <= 3) {
                    // EAæ®µéš: ä½å…‰æ²¢ã‹ã‚‰å§‹ã¾ã‚‹ï¼ˆã‚³ã‚¢ã®æ§ãˆã‚ãªè¼ãï¼‰
                    return 10 + coreProgress * 20; // 10-30
                } else if (stage <= 7) {
                    // å²è·¯æ®µéš: å¤‰åŒ–çš„ãªå…‰æ²¢ï¼ˆã‚³ã‚¢ã®å¤‰å®¹ã¨åŒæœŸï¼‰
                    const transitionIntensity = (stage - 3) / 4;
                    return 30 + transitionIntensity * 50; // 30-80
                } else {
                    // IAæ®µéš: é«˜å…‰æ²¢ãƒ»è¼ãå®Œæˆå½¢ï¼ˆã‚³ã‚¢ã®æ´—ç·´ã•ã‚ŒãŸè¼ãï¼‰
                    const masterIntensity = (stage - 7) / 3;
                    return 80 + masterIntensity * 60; // 80-140
                }
            }

            // æ¬¡å…ƒãƒªãƒ³ã‚°ã®ã‚¨ãƒŸãƒƒã‚·ãƒ–ï¼ˆç™ºå…‰ï¼‰è‰²ã‚’æ±ºå®š
            getDimensionRingEmissive(ringIndex, stage) {
                // ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ ã¨çµ±ä¸€ã—ãŸã‚¨ãƒŸãƒƒã‚·ãƒ–åŠ¹æœ
                const baseHues = [240, 300, 60]; // å„ãƒªãƒ³ã‚°ã®åŸºæœ¬è‰²ç›¸
                const hue = baseHues[ringIndex];
                const coreProgress = this.getCoreProgress(stage);
                
                // æ®µéšã«å¿œã˜ãŸã‚¨ãƒŸãƒƒã‚·ãƒ–å¼·åº¦
                let emissiveSaturation, emissiveLightness;
                
                if (stage <= 3) {
                    // EAæ®µéš: å¾®ç´°ãªå†…éƒ¨å…‰
                    emissiveSaturation = 20 + coreProgress * 10; // 20-30%
                    emissiveLightness = 5 + coreProgress * 5;    // 5-10%
                } else if (stage <= 7) {
                    // å²è·¯æ®µéš: å‹•çš„ãªç™ºå…‰
                    const transitionFactor = (stage - 3) / 4;
                    emissiveSaturation = 30 + transitionFactor * 25; // 30-55%
                    emissiveLightness = 10 + transitionFactor * 10;  // 10-20%
                } else {
                    // IAæ®µéš: å¼·ã„å†…éƒ¨å…‰
                    const masterFactor = (stage - 7) / 3;
                    emissiveSaturation = 55 + masterFactor * 20; // 55-75%
                    emissiveLightness = 20 + masterFactor * 15;  // 20-35%
                }
                
                return new THREE.Color().setHSL(hue / 360, emissiveSaturation / 100, emissiveLightness / 100).getHex();
            }

            // æ¬¡å…ƒãƒªãƒ³ã‚°ã®ã‚¨ãƒŸãƒƒã‚·ãƒ–å¼·åº¦ã‚’æ±ºå®š
            getDimensionRingEmissiveIntensity(stage) {
                const coreProgress = this.getCoreProgress(stage);
                
                if (stage <= 3) {
                    // EAæ®µéš: å¼±ã„ç™ºå…‰
                    return 0.1 + coreProgress * 0.1; // 0.1-0.2
                } else if (stage <= 7) {
                    // å²è·¯æ®µéš: ä¸­ç¨‹åº¦ã®ç™ºå…‰
                    const transitionFactor = (stage - 3) / 4;
                    return 0.2 + transitionFactor * 0.3; // 0.2-0.5
                } else {
                    // IAæ®µéš: å¼·ã„ç™ºå…‰
                    const masterFactor = (stage - 7) / 3;
                    return 0.5 + masterFactor * 0.3; // 0.5-0.8
                }
            }

            // å¤šé¢ä½“ã‚³ã‚¢ã®é€²åŒ–åº¦åˆã„ã‚’è¨ˆç®—ï¼ˆçµ±ä¸€åŒ–ã®ãŸã‚ã®ãƒ™ãƒ¼ã‚¹ãƒ¡ãƒˆãƒªãƒƒã‚¯ï¼‰
            getCoreProgress(stage) {
                // 10æ®µéšã®é€²åŒ–ã‚’0.0-1.0ã®ç¯„å›²ã§æ­£è¦åŒ–
                if (stage <= 1) return 0.0;
                if (stage >= 10) return 1.0;
                
                // å„æ®µéšã‚°ãƒ«ãƒ¼ãƒ—å†…ã§ã®é€²è¡Œåº¦ã‚’è¨ˆç®—
                if (stage <= 3) {
                    // EAæ®µéš (1-3): åŸºç¤å½¢æˆæœŸ
                    return (stage - 1) / 9; // 0.0-0.22
                } else if (stage <= 7) {
                    // å²è·¯æ®µéš (4-7): å¤‰å®¹æœŸ
                    return (stage - 1) / 9; // 0.33-0.67
                } else {
                    // IAæ®µéš (8-10): å®ŒæˆæœŸ
                    return (stage - 1) / 9; // 0.78-1.0
                }
            }

            createPolyhedronCore(stage) {
                // æ—¢å­˜ã®ã‚³ã‚¢ã‚’å‰Šé™¤
                if (this.core) {
                    this.scene.remove(this.core);
                    if (this.core.geometry) this.core.geometry.dispose();
                    if (this.core.material) this.core.material.dispose();
                }

                // æ®µéšã«å¿œã˜ãŸå¤šé¢ä½“ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’ä½œæˆ
                const coreGeometry = this.coreGeometryManager.createPolyhedronGeometry(stage);
                
                // æ®µéšãƒ‡ãƒ¼ã‚¿ã‹ã‚‰è‰²å½©ã‚’å–å¾—
                const stageData = this.getStageData(stage);
                const stageColor = stageData.color;
                
                // å¤šé¢ä½“ç”¨ãƒãƒ†ãƒªã‚¢ãƒ«ï¼ˆã‚¨ãƒƒã‚¸ã‚’å¼·èª¿ï¼‰
                const coreMaterial = new THREE.MeshPhongMaterial({ 
                    color: stageColor,
                    emissive: 0x333333,
                    transparent: true,
                    opacity: 0.85,
                    shininess: 100,
                    wireframe: false
                });
                
                // ãƒ¡ã‚¤ãƒ³ã®å¤šé¢ä½“ãƒ¡ãƒƒã‚·ãƒ¥
                this.core = new THREE.Mesh(coreGeometry, coreMaterial);
                this.scene.add(this.core);
                
                // ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ åŠ¹æœï¼ˆã‚¨ãƒƒã‚¸å¼·èª¿ï¼‰
                const wireframeGeometry = this.coreGeometryManager.createWireframeGeometry(coreGeometry);
                const wireframeMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.6,
                    linewidth: 2
                });
                
                const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
                this.core.add(wireframe); // ã‚³ã‚¢ã®å­ã¨ã—ã¦è¿½åŠ 
                
                // é ‚ç‚¹å…‰ç‚¹åŠ¹æœ
                this.createVertexLights(coreGeometry, stageColor);
                
                console.log(`ã‚³ã‚¢å½¢çŠ¶æ›´æ–°: ${this.coreGeometryManager.getPolyhedronName(stage)}`);
            }

            createVertexLights(geometry, baseColor) {
                // é ‚ç‚¹ä½ç½®ã‚’å–å¾—
                const vertices = geometry.attributes.position.array;
                const vertexCount = vertices.length / 3;
                
                // æ—¢å­˜ã®é ‚ç‚¹ãƒ©ã‚¤ãƒˆã‚’å‰Šé™¤
                if (this.vertexLights) {
                    this.vertexLights.forEach(light => {
                        this.scene.remove(light);
                    });
                }
                this.vertexLights = [];
                
                // å„é ‚ç‚¹ã«å°ã•ãªå…‰ç‚¹ã‚’é…ç½®
                for (let i = 0; i < vertexCount; i += 3) { // é–“å¼•ã„ã¦é…ç½®
                    const x = vertices[i * 3];
                    const y = vertices[i * 3 + 1];
                    const z = vertices[i * 3 + 2];
                    
                    // å°ã•ãªçƒä½“å…‰ç‚¹
                    const lightGeometry = new THREE.SphereGeometry(0.02, 8, 8);
                    const lightMaterial = new THREE.MeshBasicMaterial({ 
                        color: baseColor,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const lightSphere = new THREE.Mesh(lightGeometry, lightMaterial);
                    lightSphere.position.set(x, y, z);
                    
                    this.core.add(lightSphere); // ã‚³ã‚¢ã®å­ã¨ã—ã¦è¿½åŠ 
                }
            }

            initializeLightVeils() {
                // æ®µéšçš„å…‰å¼·åŒ–ã‚·ã‚¹ãƒ†ãƒ  - ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã«å¿œã˜ãŸå…‰ã®ãƒ™ãƒ¼ãƒ«
                // å„ã‚¹ãƒ†ãƒ¼ã‚¸ã§å¤§å¹…ã«ã‚µã‚¤ã‚ºãŒå¢—åŠ ã™ã‚‹é€æ˜ãªå…‰ã®ãƒ™ãƒ¼ãƒ«ã‚’ä½œæˆ
                
                // æ—¢å­˜ã®ãƒ™ãƒ¼ãƒ«ã‚’ã‚¯ãƒªã‚¢
                this.lightVeils.forEach(veil => this.scene.remove(veil));
                this.lightVeils = [];
                
                // 5æ®µéšã®å…‰ã®ãƒ™ãƒ¼ãƒ«ã‚’ä½œæˆï¼ˆI-E, IE, Ia, Ib, Icï¼‰
                // ã‚ˆã‚Šå¤§ããªã‚µã‚¤ã‚ºå·®ã§è¦–è¦šçš„ãªå±¤ã®é‡ãªã‚Šã‚’æ˜ç¢ºã«è¡¨ç¾
                const baseRadii = [0.4, 0.6, 0.9, 1.3, 1.8]; // æ®µéšçš„ã«å¤§å¹…å¢—åŠ 
                
                for (let i = 0; i < 5; i++) {
                    const radius = baseRadii[i];
                    const geometry = new THREE.SphereGeometry(radius, 32, 32);
                    
                    // ã‚·ãƒ³ãƒ—ãƒ«ã§ç¢ºå®Ÿãªå…‰ã®ãƒ™ãƒ¼ãƒ« - MeshBasicMaterialã§è‡ªå·±ç™ºå…‰
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xffffee,              // æš–ã‹ã¿ã®ã‚ã‚‹æŸ”ã‚‰ã‹ãªç™½
                        transparent: true,
                        opacity: 0.005 + i * 0.002,  // æ¥µã‚ã¦é€æ˜åº¦ã‚’é«˜ãã—ã¦èƒŒæ™¯ãŒã¯ã£ãã‚Šè¦‹ãˆã‚‹ã‚ˆã†ã«
                        fog: false,                   // ãƒ•ã‚©ã‚°ã®å½±éŸ¿ã‚’å—ã‘ãªã„
                        side: THREE.DoubleSide,       // ä¸¡é¢æç”»ã§å…‰ã‚‰ã—ã•ã‚’å¼·åŒ–
                        blending: THREE.AdditiveBlending,  // åŠ ç®—ãƒ–ãƒ¬ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã§å…‰ã‚‰ã—ã•ã‚’å¼·åŒ–
                        depthWrite: false             // æ·±åº¦æ›¸ãè¾¼ã¿ã‚’ç„¡åŠ¹åŒ–ã—ã¦é€æ˜æ„Ÿå‘ä¸Š
                    });
                    
                    const veil = new THREE.Mesh(geometry, material);
                    veil.position.set(0, 0, 0);
                    
                    // æ”¾å°„çŠ¶ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœã‚’ãƒãƒ†ãƒªã‚¢ãƒ«è‡ªä½“ã§å®Ÿç¾
                    veil.material.userData = {
                        baseOpacity: 0.005 + i * 0.002,    // åŸºæº–é€æ˜åº¦ã‚’æ¥µã‚ã¦é€æ˜ã«
                        emissiveStrength: 0.15 + i * 0.03,
                        layerIndex: i
                    };
                    
                    // å‘¼å¸ã®ã‚ˆã†ãªå‹•ãã®ãŸã‚ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
                    veil.userData = {
                        baseRadius: radius,
                        breatheSpeed: 0.8 + i * 0.1,
                        breathePhase: i * Math.PI / 3,
                        stageIndex: i,
                        visible: false  // åˆæœŸçŠ¶æ…‹ã§ã¯éè¡¨ç¤º
                    };
                    
                    veil.visible = false; // åˆæœŸçŠ¶æ…‹ã§ã¯éè¡¨ç¤º
                    this.scene.add(veil);
                    this.lightVeils.push(veil);
                }
            }
            
            createStageParticles() {
                // Clear existing particles
                this.particles.forEach(particle => this.scene.remove(particle));
                this.particles = [];
                
                // Create particles based on current stage
                const stageData = this.getStageData(this.currentStage);
                const particleCount = stageData.particleCount;
                const color = stageData.color;
                
                for (let i = 0; i < particleCount; i++) {
                    // çµŒé¨“ã®ãƒ¡ã‚¿ãƒ•ã‚¡ãƒ¼ã¨ã—ã¦ãƒ©ãƒ³ãƒ€ãƒ ãªã‚µã‚¤ã‚ºã‚’ç”Ÿæˆ
                    // åŸºæœ¬ã‚µã‚¤ã‚º0.04ã«å¯¾ã—ã¦ã€0.5å€ã€œ1.8å€ã®ç¯„å›²ã§ãƒ©ãƒ³ãƒ€ãƒ åŒ–
                    const baseSize = 0.04;
                    const sizeVariation = 0.5 + Math.random() * 1.3; // 0.5 - 1.8å€
                    const particleSize = baseSize * sizeVariation;
                    
                    // æ®µéšã«å¿œã˜ãŸã‚µã‚¤ã‚ºèª¿æ•´ï¼šå¾ŒæœŸæ®µéšã»ã©å¤§ããã€å¤šæ§˜ã«ãªã‚‹
                    const stageNumber = this.getStageNumber(this.currentStage);
                    let stageSizeMultiplier = 1.0;
                    
                    if (stageNumber >= 8) { // Ia, Ib, Icæ®µéš
                        stageSizeMultiplier = 1.0 + (stageNumber - 7) * 0.15; // æœ€å¤§1.45å€
                    } else if (stageNumber >= 5) { // E-I, I-E, IEæ®µéš
                        stageSizeMultiplier = 1.0 + (stageNumber - 4) * 0.08; // æœ€å¤§1.24å€
                    }
                    
                    const finalSize = particleSize * stageSizeMultiplier;
                    const geometry = new THREE.SphereGeometry(finalSize, 12, 12); // ãƒ©ãƒ³ãƒ€ãƒ ã‚µã‚¤ã‚ºé©ç”¨ã€å“è³ªã‚‚å‘ä¸Š
                    
                    // ã‚µã‚¤ã‚ºã«å¿œã˜ãŸè¦–è¦šçš„åŠ¹æœã®èª¿æ•´
                    const sizeRatio = finalSize / baseSize; // ã‚µã‚¤ã‚ºæ¯”ã‚’è¨ˆç®—
                    const baseOpacity = 0.9;
                    const sizeAdjustedOpacity = Math.min(baseOpacity * (0.7 + sizeRatio * 0.3), 1.0); // å¤§ãã„ã»ã©å°‘ã—é€æ˜ã«
                    const sizeAdjustedEmissive = Math.floor(0x111111 * (0.8 + sizeRatio * 0.4)); // å¤§ãã„ã»ã©å°‘ã—æ˜ã‚‹ãç™ºå…‰
                    const sizeAdjustedShininess = 80 + (sizeRatio - 1) * 40; // ã‚µã‚¤ã‚ºã«å¿œã˜ã¦å…‰æ²¢åº¦èª¿æ•´
                    
                    const material = new THREE.MeshPhongMaterial({ 
                        color: color,
                        transparent: true,
                        opacity: sizeAdjustedOpacity,  // ã‚µã‚¤ã‚ºèª¿æ•´ã•ã‚ŒãŸé€æ˜åº¦
                        emissive: sizeAdjustedEmissive,  // ã‚µã‚¤ã‚ºèª¿æ•´ã•ã‚ŒãŸç™ºå…‰
                        shininess: Math.max(50, Math.min(150, sizeAdjustedShininess))  // å…‰æ²¢ç¯„å›²åˆ¶é™ï¼ˆ50-150ï¼‰
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    
                    // Position particles based on stage characteristics
                    const radius = 1 + Math.random() * 5;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    particle.position.x = radius * Math.sin(phi) * Math.cos(theta);
                    particle.position.y = radius * Math.sin(phi) * Math.sin(theta);
                    particle.position.z = radius * Math.cos(phi);
                    
                    // Add dynamic properties based on stage behavior
                    particle.userData = {
                        originalPosition: particle.position.clone(),
                        baseRadius: radius,
                        baseTheta: theta,
                        basePhi: phi,
                        personalityFactor: Math.random(),
                        phaseOffset: Math.random() * Math.PI * 2,
                        speed: stageData.speed * (0.8 + Math.random() * 0.4),
                        cohesion: stageData.cohesion,
                        behavior: stageData.behavior,
                        pattern: stageData.pattern,
                        age: 0,
                        targetPosition: new THREE.Vector3(),
                        // ã‚µã‚¤ã‚ºé–¢é€£æƒ…å ±ã‚’è¿½åŠ 
                        originalSize: finalSize,
                        sizeRatio: sizeRatio,
                        baseSize: baseSize,
                        sizeVariation: sizeVariation
                    };
                    
                    this.scene.add(particle);
                    this.particles.push(particle);
                }
                
                // I(E)ã‚¹ãƒ†ãƒ¼ã‚¸ä»¥é™ã®å ´åˆã€åˆæœŸæ¥ç¶šã‚’å³åº§ã«ç”Ÿæˆ
                if (this.shouldShowConnections(this.currentStage)) {
                    setTimeout(() => {
                        this.updateConnections(true); // å¼·åˆ¶æ›´æ–°ã§å³åº§ã«æ¥ç¶šè¡¨ç¤º
                    }, 200); // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é…ç½®å®Œäº†ã‚’å¾…ã¤
                }
            }
            
            // I(E)ã‚¹ãƒ†ãƒ¼ã‚¸ä»¥é™ã‹ã©ã†ã‹ã‚’åˆ¤å®š
            isColorfulStage(stageId) {
                const colorfulStages = ['IE', 'Ia', 'Ib', 'Ic'];
                return colorfulStages.includes(stageId);
            }
            
            // I(E)ã‚¹ãƒ†ãƒ¼ã‚¸ä»¥é™ã§æ¥ç¶šç·šã‚’è¡¨ç¤ºã™ã‚‹ã‹ã‚’åˆ¤å®š
            shouldShowConnections(stageId) {
                const connectionStages = ['IE', 'Ia', 'Ib', 'Ic'];
                return connectionStages.includes(stageId);
            }
            
            // ã‚¹ãƒ†ãƒ¼ã‚¸ã«å¿œã˜ãŸæœ€å¤§æ¥ç¶šæ•°ã‚’å–å¾—
            getMaxConnectionsForStage(stageId) {
                return this.stageConnectionLimits[stageId] || this.maxConnections;
            }
            
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é–“ã®è·é›¢ã‚’è¨ˆç®—
            calculateParticleDistance(particle1, particle2) {
                return particle1.position.distanceTo(particle2.position);
            }
            
            // é©åˆ‡ãªæ¥ç¶šãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é¸æŠï¼ˆãƒãƒ–å‹ãƒ»é€£é–å‹ãƒ»ç›¸äº’é€£çµå‹ãªã©ï¼‰
            selectConnectionPairs() {
                if (!this.shouldShowConnections(this.currentStage) || this.particles.length < 2) {
                    return [];
                }
                
                const connections = [];
                const usedParticles = new Set();
                const maxDistance = 4.5; // æœ€å¤§æ¥ç¶šè·é›¢
                const minDistance = 0.5; // æœ€å°æ¥ç¶šè·é›¢
                
                // ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã«å¿œã˜ãŸæœ€å¤§æ¥ç¶šæ•°ã‚’å–å¾—
                const stageMaxConnections = this.getMaxConnectionsForStage(this.currentStage);
                
                // ã‚¹ãƒ†ãƒ¼ã‚¸åˆ¥ã®æ¥ç¶šãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¨­å®š
                let patterns;
                if (this.currentStage === 'I-E') {
                    // I-Eã‚¹ãƒ†ãƒ¼ã‚¸ï¼šå†…ãªã‚‹å£°ã‚’è´ã - æ§ãˆã‚ã§æ€æ…®æ·±ã„æ¥ç¶š
                    patterns = [
                        { type: 'contemplative_pairs', weight: 0.4 },  // æ€ç´¢çš„ãªãƒšã‚¢æ¥ç¶š
                        { type: 'chain', weight: 0.3 },                // é€£é–å‹ï¼ˆæ€è€ƒã®æµã‚Œï¼‰
                        { type: 'triangle', weight: 0.2 },             // å°ã•ãªä¸‰è§’å½¢ï¼ˆå†…çš„å¯¾è©±ï¼‰
                        { type: 'introspective_hub', weight: 0.1 }     // å†…çœçš„ãƒãƒ–
                    ];
                } else if (this.currentStage === 'IE') {
                    // IEã‚¹ãƒ†ãƒ¼ã‚¸ï¼šã‚·ãƒ³ãƒ—ãƒ«ãªæ¥ç¶šãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã¿
                    patterns = [
                        { type: 'chain', weight: 0.5 },     // é€£é–å‹ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãªç¹‹ãŒã‚Šï¼‰
                        { type: 'triangle', weight: 0.3 },  // ä¸‰è§’å½¢ï¼ˆåŸºæœ¬çš„ãªç›¸äº’é€£çµï¼‰
                        { type: 'hub', weight: 0.2 }        // ãƒãƒ–å‹ï¼ˆå°‘æ•°ï¼‰
                    ];
                } else if (this.currentStage === 'Ic') {
                    // Icã‚¹ãƒ†ãƒ¼ã‚¸ï¼šæ¥µã‚ã¦è±Šå¯Œã§è¤‡é›‘ãªæ¥ç¶šãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå®Œå…¨ãªã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒ³ãƒˆæ®µéšï¼‰
                    patterns = [
                        { type: 'dense_network', weight: 0.25 },  // å¯†ãªå…¨ä½“ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯
                        { type: 'multi_hub', weight: 0.2 },       // è¤‡æ•°ãƒãƒ–å‹
                        { type: 'triangle', weight: 0.15 },       // ä¸‰è§’å½¢ï¼ˆç›¸äº’é€£çµï¼‰
                        { type: 'star', weight: 0.15 },           // æ˜Ÿå‹ï¼ˆä¸­å¿ƒã‹ã‚‰æ”¾å°„ï¼‰
                        { type: 'chain', weight: 0.1 },           // é€£é–å‹
                        { type: 'hub', weight: 0.1 },             // å˜ä¸€ãƒãƒ–å‹
                        { type: 'cycle', weight: 0.05 }           // å¾ªç’°å‹
                    ];
                } else {
                    // ãã®ä»–ã®ã‚¹ãƒ†ãƒ¼ã‚¸ï¼šæ¨™æº–çš„ãªãƒ‘ã‚¿ãƒ¼ãƒ³
                    patterns = [
                        { type: 'hub', weight: 0.3 },        // ãƒãƒ–å‹ï¼ˆ1ã¤ã®ä¸­å¿ƒã«è¤‡æ•°æ¥ç¶šï¼‰
                        { type: 'chain', weight: 0.25 },     // é€£é–å‹ï¼ˆAâ†’Bâ†’Câ†’Dï¼‰
                        { type: 'triangle', weight: 0.2 },   // ä¸‰è§’å½¢ï¼ˆç›¸äº’é€£çµï¼‰
                        { type: 'star', weight: 0.15 },      // æ˜Ÿå‹ï¼ˆä¸­å¿ƒã‹ã‚‰æ”¾å°„ï¼‰
                        { type: 'cycle', weight: 0.1 }       // å¾ªç’°å‹ï¼ˆAâ†’Bâ†’Câ†’Aï¼‰
                    ];
                }
                
                // è·é›¢ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
                const distanceMatrix = this.calculateDistanceMatrix();
                
                // ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é †æ¬¡ç”Ÿæˆï¼ˆã‚¹ãƒ†ãƒ¼ã‚¸åˆ¥ã®åˆ¶é™ã¾ã§ï¼‰
                let maxAttempts;
                if (this.currentStage === 'IE') {
                    maxAttempts = 3; // IEã‚¹ãƒ†ãƒ¼ã‚¸ã¯å°‘ãªã‚
                } else if (this.currentStage === 'Ic') {
                    maxAttempts = 15; // Icã‚¹ãƒ†ãƒ¼ã‚¸ã¯å¤§å¹…ã«å¢—åŠ ï¼ˆè¤‡é›‘ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç”Ÿæˆï¼‰
                } else {
                    maxAttempts = 6; // ãã®ä»–ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¯æ¨™æº–
                }
                
                for (let attempt = 0; attempt < maxAttempts && connections.length < stageMaxConnections; attempt++) {
                    const pattern = this.selectRandomPattern(patterns);
                    const patternConnections = this.generateConnectionPattern(
                        pattern.type, distanceMatrix, usedParticles, maxDistance, minDistance
                    );
                    
                    if (patternConnections.length > 0) {
                        connections.push(...patternConnections);
                    }
                }
                
                return connections;
            }
            
            // è·é›¢ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
            calculateDistanceMatrix() {
                const matrix = [];
                for (let i = 0; i < this.particles.length; i++) {
                    matrix[i] = [];
                    for (let j = 0; j < this.particles.length; j++) {
                        if (i === j) {
                            matrix[i][j] = 0;
                        } else {
                            matrix[i][j] = this.calculateParticleDistance(this.particles[i], this.particles[j]);
                        }
                    }
                }
                return matrix;
            }
            
            // ãƒ©ãƒ³ãƒ€ãƒ ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é¸æŠ
            selectRandomPattern(patterns) {
                const random = Math.random();
                let cumulative = 0;
                
                for (const pattern of patterns) {
                    cumulative += pattern.weight;
                    if (random <= cumulative) {
                        return pattern;
                    }
                }
                return patterns[patterns.length - 1];
            }
            
            // æŒ‡å®šã•ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã§æ¥ç¶šã‚’ç”Ÿæˆ
            generateConnectionPattern(patternType, distanceMatrix, usedParticles, maxDistance, minDistance) {
                switch (patternType) {
                    case 'hub':
                        return this.generateHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'chain':
                        return this.generateChainPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'triangle':
                        return this.generateTrianglePattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'star':
                        return this.generateStarPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'cycle':
                        return this.generateCyclePattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'dense_network':
                        return this.generateDenseNetworkPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'multi_hub':
                        return this.generateMultiHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'contemplative_pairs':
                        return this.generateContemplativePairsPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'introspective_hub':
                        return this.generateIntrospectiveHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    default:
                        return [];
                }
            }
            
            // ãƒãƒ–å‹ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼š1ã¤ã®ä¸­å¿ƒãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã«3-5å€‹ãŒæ¥ç¶š
            generateHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 4) return [];
                
                // ä¸­å¿ƒã¨ãªã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’é¸æŠ
                const hubIndex = availableParticles[Math.floor(Math.random() * availableParticles.length)];
                usedParticles.add(hubIndex);
                
                // ãƒãƒ–ã‹ã‚‰ã®æ¥ç¶šæ•°ã‚’æ±ºå®šï¼ˆIEã‚¹ãƒ†ãƒ¼ã‚¸ã¯æ§ãˆã‚ã«ï¼‰
                let connectionCount;
                if (this.currentStage === 'IE') {
                    connectionCount = 2 + Math.floor(Math.random() * 2); // 2-3å€‹ï¼ˆæ§ãˆã‚ï¼‰
                } else {
                    connectionCount = 3 + Math.floor(Math.random() * 3); // 3-5å€‹ï¼ˆé€šå¸¸ï¼‰
                }
                const connections = [];
                
                // ãƒãƒ–ã«æ¥ç¶šã™ã‚‹å€™è£œã‚’è·é›¢é †ã«ã‚½ãƒ¼ãƒˆ
                const candidates = availableParticles
                    .filter(i => i !== hubIndex && !usedParticles.has(i))
                    .map(i => ({ index: i, distance: distanceMatrix[hubIndex][i] }))
                    .filter(c => c.distance >= minDistance && c.distance <= maxDistance)
                    .sort((a, b) => a.distance - b.distance);
                
                // ä¸Šä½å€™è£œã‹ã‚‰æ¥ç¶š
                for (let i = 0; i < Math.min(connectionCount, candidates.length); i++) {
                    const targetIndex = candidates[i].index;
                    connections.push({ pair: [hubIndex, targetIndex], type: 'hub' });
                    usedParticles.add(targetIndex);
                }
                
                return connections;
            }
            
            // é€£é–å‹ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼šAâ†’Bâ†’Câ†’D ã®ç·šå½¢æ¥ç¶š
            generateChainPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 3) return [];
                
                // é€£é–ã®é•·ã•ã‚’æ±ºå®šï¼ˆIEã‚¹ãƒ†ãƒ¼ã‚¸ã¯çŸ­ã‚ã«ï¼‰
                let chainLength;
                if (this.currentStage === 'IE') {
                    chainLength = 2 + Math.floor(Math.random() * 2); // 2-3å€‹ï¼ˆçŸ­ã„é€£é–ï¼‰
                } else {
                    chainLength = 3 + Math.floor(Math.random() * 3); // 3-5å€‹ï¼ˆé€šå¸¸ï¼‰
                }
                
                const chain = [availableParticles[Math.floor(Math.random() * availableParticles.length)]];
                usedParticles.add(chain[0]);
                
                // é€£é–ã‚’æ§‹ç¯‰
                for (let i = 1; i < chainLength; i++) {
                    const lastIndex = chain[i - 1];
                    const candidates = availableParticles
                        .filter(j => !usedParticles.has(j))
                        .map(j => ({ index: j, distance: distanceMatrix[lastIndex][j] }))
                        .filter(c => c.distance >= minDistance && c.distance <= maxDistance)
                        .sort((a, b) => a.distance - b.distance);
                    
                    if (candidates.length === 0) break;
                    
                    const nextIndex = candidates[0].index;
                    chain.push(nextIndex);
                    usedParticles.add(nextIndex);
                }
                
                // é€£é–ã®æ¥ç¶šã‚’ä½œæˆ
                const connections = [];
                for (let i = 0; i < chain.length - 1; i++) {
                    connections.push({ pair: [chain[i], chain[i + 1]], type: 'chain' });
                }
                
                return connections;
            }
            
            // ä¸‰è§’å½¢ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼š3ã¤ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãŒç›¸äº’ã«æ¥ç¶š
            generateTrianglePattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 3) return [];
                
                // æœ€åˆã®2ã¤ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’é¸æŠ
                const first = availableParticles[Math.floor(Math.random() * availableParticles.length)];
                const secondCandidates = availableParticles
                    .filter(i => i !== first)
                    .map(i => ({ index: i, distance: distanceMatrix[first][i] }))
                    .filter(c => c.distance >= minDistance && c.distance <= maxDistance);
                
                if (secondCandidates.length === 0) return [];
                
                const second = secondCandidates[Math.floor(Math.random() * secondCandidates.length)].index;
                
                // 3ã¤ç›®ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’é¸æŠï¼ˆä¸¡æ–¹ã«é©åˆ‡ãªè·é›¢ï¼‰
                const thirdCandidates = availableParticles
                    .filter(i => i !== first && i !== second)
                    .filter(i => {
                        const d1 = distanceMatrix[first][i];
                        const d2 = distanceMatrix[second][i];
                        return d1 >= minDistance && d1 <= maxDistance && 
                               d2 >= minDistance && d2 <= maxDistance;
                    });
                
                if (thirdCandidates.length === 0) return [];
                
                const third = thirdCandidates[Math.floor(Math.random() * thirdCandidates.length)];
                
                // ä½¿ç”¨æ¸ˆã¿ã¨ã—ã¦ãƒãƒ¼ã‚¯
                usedParticles.add(first);
                usedParticles.add(second);
                usedParticles.add(third);
                
                return [
                    { pair: [first, second], type: 'triangle' },
                    { pair: [second, third], type: 'triangle' },
                    { pair: [third, first], type: 'triangle' }
                ];
            }
            
            // æ˜Ÿå‹ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼šä¸­å¿ƒã‹ã‚‰æ”¾å°„çŠ¶ã«æ¥ç¶š
            generateStarPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                return this.generateHubPattern(distanceMatrix, usedParticles, maxDistance * 1.2, minDistance);
            }
            
            // å¾ªç’°å‹ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼šAâ†’Bâ†’Câ†’Dâ†’A ã®å¾ªç’°æ¥ç¶š
            generateCyclePattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const chainConnections = this.generateChainPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                if (chainConnections.length < 2) return chainConnections;
                
                // ã™ã¹ã¦ã‚’å¾ªç’°ã‚¿ã‚¤ãƒ—ã«å¤‰æ›´
                chainConnections.forEach(connection => connection.type = 'cycle');
                
                // æœ€å¾Œã¨æœ€åˆã‚’æ¥ç¶šã—ã¦å¾ªç’°ã«ã™ã‚‹
                const firstParticle = chainConnections[0].pair[0];
                const lastParticle = chainConnections[chainConnections.length - 1].pair[1];
                const distance = distanceMatrix[lastParticle][firstParticle];
                
                if (distance >= minDistance && distance <= maxDistance) {
                    chainConnections.push({ pair: [lastParticle, firstParticle], type: 'cycle' });
                }
                
                return chainConnections;
            }
            
            // å¯†ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼šIcã‚¹ãƒ†ãƒ¼ã‚¸ç”¨ã®è±Šå¯Œãªç›¸äº’æ¥ç¶š
            generateDenseNetworkPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 6) return [];
                
                const connections = [];
                const selectedParticles = [];
                
                // 6-8å€‹ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’é¸æŠ
                const networkSize = Math.min(6 + Math.floor(Math.random() * 3), availableParticles.length);
                
                for (let i = 0; i < networkSize; i++) {
                    const index = availableParticles[Math.floor(Math.random() * availableParticles.length)];
                    if (!selectedParticles.includes(index)) {
                        selectedParticles.push(index);
                        usedParticles.add(index);
                    }
                }
                
                // é¸æŠã•ã‚ŒãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é–“ã§å¯†ãªæ¥ç¶šã‚’ä½œæˆ
                for (let i = 0; i < selectedParticles.length; i++) {
                    for (let j = i + 1; j < selectedParticles.length; j++) {
                        const particle1 = selectedParticles[i];
                        const particle2 = selectedParticles[j];
                        const distance = distanceMatrix[particle1][particle2];
                        
                        if (distance >= minDistance && distance <= maxDistance) {
                            // 60%ã®ç¢ºç‡ã§æ¥ç¶šï¼ˆå¯†ã ãŒå…¨ã¦ã§ã¯ãªã„ï¼‰
                            if (Math.random() < 0.6) {
                                connections.push({ pair: [particle1, particle2], type: 'dense_network' });
                            }
                        }
                    }
                }
                
                return connections;
            }
            
            // è¤‡æ•°ãƒãƒ–ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼šIcã‚¹ãƒ†ãƒ¼ã‚¸ç”¨ã®è¤‡æ•°ã®ä¸­å¿ƒç‚¹ã‚’æŒã¤ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯
            generateMultiHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 8) return [];
                
                const connections = [];
                const hubCount = 2 + Math.floor(Math.random() * 2); // 2-3å€‹ã®ãƒãƒ–
                const hubs = [];
                
                // ãƒãƒ–ã‚’é¸æŠ
                for (let h = 0; h < hubCount && availableParticles.length > 0; h++) {
                    const hubIndex = availableParticles.splice(Math.floor(Math.random() * availableParticles.length), 1)[0];
                    hubs.push(hubIndex);
                    usedParticles.add(hubIndex);
                }
                
                // å„ãƒãƒ–ã‹ã‚‰æ¥ç¶šã‚’ä½œæˆ
                hubs.forEach(hubIndex => {
                    const remainingParticles = availableParticles.filter(i => !usedParticles.has(i));
                    const connectionsPerHub = 2 + Math.floor(Math.random() * 3); // 2-4å€‹ã®æ¥ç¶š
                    
                    const candidates = remainingParticles
                        .map(i => ({ index: i, distance: distanceMatrix[hubIndex][i] }))
                        .filter(c => c.distance >= minDistance && c.distance <= maxDistance)
                        .sort((a, b) => a.distance - b.distance);
                    
                    for (let i = 0; i < Math.min(connectionsPerHub, candidates.length); i++) {
                        const targetIndex = candidates[i].index;
                        connections.push({ pair: [hubIndex, targetIndex], type: 'multi_hub' });
                        usedParticles.add(targetIndex);
                    }
                });
                
                // ãƒãƒ–åŒå£«ã‚‚æ¥ç¶šã™ã‚‹å¯èƒ½æ€§
                for (let i = 0; i < hubs.length; i++) {
                    for (let j = i + 1; j < hubs.length; j++) {
                        const distance = distanceMatrix[hubs[i]][hubs[j]];
                        if (distance >= minDistance && distance <= maxDistance && Math.random() < 0.4) {
                            connections.push({ pair: [hubs[i], hubs[j]], type: 'multi_hub' });
                        }
                    }
                }
                
                return connections;
            }

            // æ€ç´¢çš„ãƒšã‚¢ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼šI-Eã‚¹ãƒ†ãƒ¼ã‚¸ç”¨ - å†…ãªã‚‹å£°ã‚’è´ãéç¨‹ã§ã®æ…é‡ãªå¯¾è©±
            generateContemplativePairsPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 2) return [];
                
                const connections = [];
                const maxPairs = Math.min(3, Math.floor(availableParticles.length / 2)); // æœ€å¤§3ãƒšã‚¢
                
                // é©åº¦ãªè·é›¢ã®ãƒšã‚¢ã‚’é¸æŠï¼ˆè¿‘ã™ããšé ã™ããšï¼‰
                for (let pairCount = 0; pairCount < maxPairs && availableParticles.length >= 2; pairCount++) {
                    const candidates = [];
                    
                    // åˆ©ç”¨å¯èƒ½ãªãƒšã‚¢ã®çµ„ã¿åˆã‚ã›ã‚’è©•ä¾¡
                    for (let i = 0; i < availableParticles.length; i++) {
                        for (let j = i + 1; j < availableParticles.length; j++) {
                            const idx1 = availableParticles[i];
                            const idx2 = availableParticles[j];
                            const distance = distanceMatrix[idx1][idx2];
                            
                            // æ€ç´¢ã«é©ã—ãŸè·é›¢ï¼ˆä¸­ç¨‹åº¦ã®è·é›¢ã‚’å¥½ã‚€ï¼‰
                            if (distance >= minDistance * 1.5 && distance <= maxDistance * 0.8) {
                                candidates.push({ 
                                    pair: [idx1, idx2], 
                                    distance: distance,
                                    suitability: 1.0 - Math.abs(distance - (maxDistance * 0.5)) / (maxDistance * 0.5)
                                });
                            }
                        }
                    }
                    
                    if (candidates.length === 0) break;
                    
                    // æœ€é©ãªè·é›¢ã®ãƒšã‚¢ã‚’é¸æŠ
                    candidates.sort((a, b) => b.suitability - a.suitability);
                    const selectedPair = candidates[0];
                    
                    connections.push({ pair: selectedPair.pair, type: 'contemplative' });
                    
                    // ä½¿ç”¨æ¸ˆã¿ã«è¿½åŠ 
                    usedParticles.add(selectedPair.pair[0]);
                    usedParticles.add(selectedPair.pair[1]);
                    
                    // availableParticlesã‹ã‚‰ã‚‚å‰Šé™¤
                    const removeIndices = [
                        availableParticles.indexOf(selectedPair.pair[0]),
                        availableParticles.indexOf(selectedPair.pair[1])
                    ].sort((a, b) => b - a); // é™é †ã§ã‚½ãƒ¼ãƒˆã—ã¦å¾Œã‚ã‹ã‚‰å‰Šé™¤
                    
                    removeIndices.forEach(idx => availableParticles.splice(idx, 1));
                }
                
                return connections;
            }

            // å†…çœçš„ãƒãƒ–ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼šI-Eã‚¹ãƒ†ãƒ¼ã‚¸ç”¨ - æ§ãˆã‚ãªä¸­å¿ƒçš„æ€è€ƒ
            generateIntrospectiveHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 3) return [];
                
                const connections = [];
                
                // ä¸­å¿ƒã¨ãªã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’é¸æŠï¼ˆä¸­å¤®ã«è¿‘ã„ä½ç½®ã‚’å¥½ã‚€ï¼‰
                let hubIndex = availableParticles[0];
                let minCenterDistance = Number.MAX_VALUE;
                
                for (const idx of availableParticles) {
                    const particle = this.particles[idx];
                    const centerDistance = particle.position.length(); // åŸç‚¹ã‹ã‚‰ã®è·é›¢
                    if (centerDistance < minCenterDistance) {
                        minCenterDistance = centerDistance;
                        hubIndex = idx;
                    }
                }
                
                usedParticles.add(hubIndex);
                
                // æ§ãˆã‚ãªæ¥ç¶šï¼ˆ2-3å€‹ã®ã¿ï¼‰
                const connectionCount = 2 + Math.floor(Math.random() * 2);
                const candidates = availableParticles
                    .filter(i => i !== hubIndex)
                    .map(i => ({ index: i, distance: distanceMatrix[hubIndex][i] }))
                    .filter(c => c.distance >= minDistance && c.distance <= maxDistance * 0.7) // è¿‘ã‚ã®è·é›¢ã‚’å¥½ã‚€
                    .sort((a, b) => a.distance - b.distance);
                
                for (let i = 0; i < Math.min(connectionCount, candidates.length); i++) {
                    const targetIndex = candidates[i].index;
                    connections.push({ pair: [hubIndex, targetIndex], type: 'introspective' });
                    usedParticles.add(targetIndex);
                }
                
                return connections;
            }

            // ä½¿ç”¨å¯èƒ½ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒªã‚¹ãƒˆã‚’å–å¾—
            getAvailableParticles(usedParticles) {
                const available = [];
                for (let i = 0; i < this.particles.length; i++) {
                    if (!usedParticles.has(i)) {
                        available.push(i);
                    }
                }
                return available;
            }
            
            // æ¥ç¶šç·šã‚’ä½œæˆï¼ˆå¼·åŒ–ç‰ˆï¼‰
            createConnectionLine(particle1, particle2, opacity = 0.4, lineType = 'normal') {
                const points = [particle1.position.clone(), particle2.position.clone()];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                
                // ç·šã®ç¨®é¡ã«å¿œã˜ãŸé€æ˜åº¦ã¨å¤ªã•ã‚’èª¿æ•´
                let actualOpacity = opacity;
                let lineWidth = 1;
                
                switch (lineType) {
                    case 'hub':        // ãƒãƒ–æ¥ç¶šã¯å°‘ã—å¤ªãæ˜ã‚‹ã
                        actualOpacity = opacity * 1.3;
                        lineWidth = 2;
                        break;
                    case 'chain':      // é€£é–æ¥ç¶šã¯ä¸­ç¨‹åº¦
                        actualOpacity = opacity * 1.1;
                        lineWidth = 1.5;
                        break;
                    case 'cycle':      // å¾ªç’°æ¥ç¶šã¯è„ˆå‹•åŠ¹æœ
                        actualOpacity = opacity * (0.8 + Math.sin(Date.now() * 0.003) * 0.3);
                        lineWidth = 1.8;
                        break;
                    case 'triangle':   // ç›¸äº’æ¥ç¶šã¯å®‰å®šçš„ã«æ˜ã‚‹ã
                        actualOpacity = opacity * 1.2;
                        lineWidth = 1.5;
                        break;
                    case 'contemplative': // æ€ç´¢çš„æ¥ç¶šã¯æ§ãˆã‚ã§æºã‚‰ãã‚ã‚Š
                        actualOpacity = opacity * (0.6 + Math.sin(Date.now() * 0.002) * 0.2);
                        lineWidth = 1.2;
                        break;
                    case 'introspective': // å†…çœçš„æ¥ç¶šã¯ã‚ˆã‚Šç¹Šç´°
                        actualOpacity = opacity * 0.8;
                        lineWidth = 1.0;
                        break;
                        lineWidth = 1.3;
                        break;
                    default:
                        break;
                }
                
                // ã‚«ãƒ©ãƒ•ãƒ«ã‚¹ãƒ†ãƒ¼ã‚¸ã§ã¯å¤šæ§˜ãªè‰²ã€ãã‚Œä»¥å¤–ã¯ç™½ã€œé’ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                let color;
                if (this.isColorfulStage(this.currentStage)) {
                    color = this.colorfulParticlePalette[Math.floor(Math.random() * this.colorfulParticlePalette.length)];
                } else {
                    // æ¥ç¶šã®ç¨®é¡ã«å¿œã˜ãŸè‰²åˆ†ã‘
                    const colors = {
                        'hub': 0xffdd44,         // ãƒãƒ–ï¼šé‡‘è‰²
                        'chain': 0x44ddff,       // é€£é–ï¼šé’è‰²
                        'cycle': 0xff44dd,       // å¾ªç’°ï¼šç´«è‰²
                        'triangle': 0x44ff88,    // ç›¸äº’ï¼šç·‘è‰²
                        'dense_network': 0xff8844, // å¯†ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼šã‚ªãƒ¬ãƒ³ã‚¸è‰²
                        'multi_hub': 0x88ff44,   // è¤‡æ•°ãƒãƒ–ï¼šæ˜ã‚‹ã„ç·‘è‰²
                        'normal': 0xcccccc       // é€šå¸¸ï¼šç™½è‰²
                    };
                    color = colors[lineType] || colors.normal;
                }
                
                const material = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: Math.min(actualOpacity, 0.8),
                    blending: THREE.AdditiveBlending,
                    linewidth: lineWidth  // Note: linewidth ã¯ WebGL ã§ã¯åˆ¶é™ãŒã‚ã‚‹
                });
                
                const line = new THREE.Line(geometry, material);
                line.userData = { lineType: lineType }; // ç¨®é¡ã‚’ä¿å­˜
                return line;
            }
            
            // æ¥ç¶šç·šã‚’æ›´æ–°ï¼ˆå¼·åˆ¶æ›´æ–°ã‚ªãƒ—ã‚·ãƒ§ãƒ³ä»˜ãï¼‰
            updateConnections(forceUpdate = false) {
                const currentTime = Date.now();
                
                // ã‚¹ãƒ†ãƒ¼ã‚¸åˆ¥ã®æ›´æ–°é–“éš”ã‚’è¨­å®š
                let updateInterval;
                if (this.currentStage === 'Ic') {
                    updateInterval = 10000; // Icã‚¹ãƒ†ãƒ¼ã‚¸ï¼š10ç§’é–“éš”ï¼ˆæ¨™æº–çš„ãªæ›´æ–°é »åº¦ï¼‰
                } else if (this.currentStage === 'Ib') {
                    updateInterval = 10000; // Ibã‚¹ãƒ†ãƒ¼ã‚¸ï¼š10ç§’é–“éš”
                } else {
                    updateInterval = this.connectionUpdateInterval; // ãã®ä»–ï¼šæ¨™æº–é–“éš”
                }
                
                // å®šæœŸçš„ãªæ›´æ–°ãƒã‚§ãƒƒã‚¯ï¼ˆå¼·åˆ¶æ›´æ–°ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—ï¼‰
                if (!forceUpdate && currentTime - this.lastConnectionUpdate < updateInterval) {
                    return;
                }
                
                this.lastConnectionUpdate = currentTime;
                
                // æ—¢å­˜ã®æ¥ç¶šç·šã‚’ã‚¯ãƒªã‚¢
                this.clearConnections();
                
                // æ–°ã—ã„æ¥ç¶šãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é¸æŠ
                const connectionPairs = this.selectConnectionPairs();
                
                // æ¥ç¶šç·šã‚’ä½œæˆ
                connectionPairs.forEach(connection => {
                    const [index1, index2] = connection.pair;
                    const lineType = connection.type;
                    const particle1 = this.particles[index1];
                    const particle2 = this.particles[index2];
                    
                    if (particle1 && particle2) {
                        const line = this.createConnectionLine(particle1, particle2, 0.4, lineType);
                        this.scene.add(line);
                        this.connectionLines.push({
                            line: line,
                            particle1Index: index1,
                            particle2Index: index2,
                            lineType: lineType
                        });
                    }
                });
            }
            
            // æ¥ç¶šç·šã‚’ã‚¯ãƒªã‚¢
            clearConnections() {
                this.connectionLines.forEach(connection => {
                    this.scene.remove(connection.line);
                    connection.line.geometry.dispose();
                    connection.line.material.dispose();
                });
                this.connectionLines = [];
            }
            
            // æ—¢å­˜ã®æ¥ç¶šç·šã®ä½ç½®ã‚’æ›´æ–°ï¼ˆå‹•çš„åŠ¹æœä»˜ãï¼‰
            updateConnectionPositions() {
                const time = Date.now() * 0.001;
                
                this.connectionLines.forEach(connection => {
                    const particle1 = this.particles[connection.particle1Index];
                    const particle2 = this.particles[connection.particle2Index];
                    
                    if (particle1 && particle2) {
                        const points = [particle1.position.clone(), particle2.position.clone()];
                        connection.line.geometry.setFromPoints(points);
                        connection.line.geometry.attributes.position.needsUpdate = true;
                        
                        // æ¥ç¶šã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸå‹•çš„åŠ¹æœ
                        if (connection.lineType === 'cycle') {
                            // å¾ªç’°æ¥ç¶šã¯è„ˆå‹•åŠ¹æœ
                            const pulse = 0.3 + 0.4 * (0.5 + 0.5 * Math.sin(time * 3));
                            connection.line.material.opacity = pulse;
                        } else if (connection.lineType === 'hub') {
                            // ãƒãƒ–æ¥ç¶šã¯å¾ã€…ã«æ˜ã‚‹ããªã‚‹åŠ¹æœ
                            const glow = 0.4 + 0.3 * (0.5 + 0.5 * Math.sin(time * 1.5));
                            connection.line.material.opacity = glow;
                        } else if (connection.lineType === 'chain') {
                            // é€£é–æ¥ç¶šã¯æµã‚Œã‚‹ã‚ˆã†ãªåŠ¹æœ
                            const flow = 0.3 + 0.3 * (0.5 + 0.5 * Math.sin(time * 2 + connection.particle1Index));
                            connection.line.material.opacity = flow;
                        }
                    }
                });
            }
            
            // ã‚«ãƒ©ãƒ•ãƒ«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”¨ã®è‰²ã‚’å–å¾—
            getColorfulParticleColor(index, time) {
                const paletteIndex = (index + Math.floor(time * 2)) % this.colorfulParticlePalette.length;
                return this.colorfulParticlePalette[paletteIndex];
            }
            
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®è‰²ã‚’å‹•çš„ã«æ›´æ–°
            updateParticleColorDynamic(particle, index, time) {
                if (this.isColorfulStage(this.currentStage)) {
                    const targetColor = this.getColorfulParticleColor(index, time);
                    const currentColor = particle.material.color;
                    const targetColorObj = new THREE.Color(targetColor);
                    
                    // æ»‘ã‚‰ã‹ãªè‰²å¤‰æ›´
                    currentColor.lerp(targetColorObj, this.colorTransitionSpeed);
                }
            }
            
            getStageData(stage) {
                const stageMap = {
                    'Ea': { 
                        particleCount: 20, 
                        color: 0xff6b6b, 
                        description: 'å¤–çš„æ¨©å¨ã‚’ä¿¡é ¼',
                        behavior: 'chaotic',           // æ··æ²Œã¨ã—ãŸå‹•ã
                        cohesion: 0.1,                // çµæŸåº¦ï¼šéå¸¸ã«ä½ã„
                        speed: 0.8,                   // é€Ÿåº¦ï¼šæ¯”è¼ƒçš„ä½ã„
                        pattern: 'random'             // ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼šãƒ©ãƒ³ãƒ€ãƒ 
                    },
                    'Eb': { 
                        particleCount: 25, 
                        color: 0xff8e53, 
                        description: 'å¤–çš„æ¨©å¨ã¨ã®ç·Šå¼µ',
                        behavior: 'conflicted',       // å¯¾ç«‹ã™ã‚‹å‹•ã
                        cohesion: 0.2,
                        speed: 1.2,                   // ç·Šå¼µã§é€Ÿåº¦ä¸Šæ˜‡
                        pattern: 'opposing'           // å¯¾ç«‹ãƒ‘ã‚¿ãƒ¼ãƒ³
                    },
                    'Ec': { 
                        particleCount: 30, 
                        color: 0xffa726, 
                        description: 'æ¬ ç‚¹ã®èªè­˜',
                        behavior: 'questioning',      // ç–‘å•ã‚’ç¤ºã™å‹•ã
                        cohesion: 0.3,
                        speed: 0.9,
                        pattern: 'hesitant'           // ãŸã‚ã‚‰ã„ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
                    },
                    'EI': { 
                        particleCount: 20,  // 35ã‹ã‚‰20ã«æ¸›å°‘
                        color: 0xffeb3b, 
                        description: 'ç–‘å•ã‚’æŒã¤',
                        behavior: 'questioning_emergence',  // ç–‘å•ã«ã‚ˆã‚‹å‡ºç¾ãƒ»æ¶ˆå¤±
                        cohesion: 0.4,
                        speed: 1.0,
                        pattern: 'dynamic_emergence'       // å‹•çš„å‡ºç¾ãƒ‘ã‚¿ãƒ¼ãƒ³
                    },
                    'E-I': { 
                        particleCount: 40, 
                        color: 0xcddc39, 
                        description: 'å†…ãªã‚‹å£°ã‚’æ§‹ç¯‰',
                        behavior: 'building',         // æ§‹ç¯‰ã™ã‚‹å‹•ã
                        cohesion: 0.5,
                        speed: 1.1,
                        pattern: 'convergent'         // åæŸãƒ‘ã‚¿ãƒ¼ãƒ³
                    },
                    'I-E': { 
                        particleCount: 45, 
                        color: 0x8bc34a, 
                        description: 'å†…ãªã‚‹å£°ã‚’è´ã',
                        behavior: 'listening',        // è´ãå‹•ã
                        cohesion: 0.1,                // ä½ã„å‡é›†åŠ›ï¼ˆè‡ªç”±ãªæµ®éŠã‚’ç¶­æŒï¼‰
                        speed: 0.5,                   // ã‚ˆã‚Šé™ã‹ã«è´ã
                        pattern: 'pulse'              // è„ˆå‹•ãƒ‘ã‚¿ãƒ¼ãƒ³
                    },
                    'IE': { 
                        particleCount: 50, 
                        color: 0x4caf50, 
                        description: 'å†…ãªã‚‹å£°ã‚’è‚²ã‚€',
                        behavior: 'nurturing',        // è‚²ã‚€å‹•ã
                        cohesion: 0.7,
                        speed: 0.9,
                        pattern: 'growth'             // æˆé•·ãƒ‘ã‚¿ãƒ¼ãƒ³
                    },
                    'Ia': { 
                        particleCount: 55, 
                        color: 0x26a69a, 
                        description: 'å†…ãªã‚‹å£°ã‚’ä¿¡é ¼',
                        behavior: 'trusting',         // ä¿¡é ¼ã™ã‚‹å‹•ã
                        cohesion: 0.8,
                        speed: 1.0,
                        pattern: 'stable_orbit'       // å®‰å®šè»Œé“
                    },
                    'Ib': { 
                        particleCount: 60, 
                        color: 0x29b6f6, 
                        description: 'å†…ãªã‚‹åŸºç›¤',
                        behavior: 'foundation',       // åŸºç›¤å½¢æˆ
                        cohesion: 0.9,
                        speed: 0.8,
                        pattern: 'structured'         // æ§‹é€ åŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³
                    },
                    'Ic': { 
                        particleCount: 65, 
                        color: 0x42a5f5,              // Ibã®é’ã‚’ãƒ™ãƒ¼ã‚¹ã«ã—ãŸæ˜ã‚‹ã„è‰²
                        description: 'ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒ³ãƒˆç¢ºä¿',
                        behavior: 'committed',        // ã‚³ãƒŸãƒƒãƒˆçŠ¶æ…‹
                        cohesion: 1.0,                // æœ€é«˜ã®çµæŸ
                        speed: 1.0,
                        pattern: 'wave_rotation'      // æ³¢å‹•å›è»¢ãƒ‘ã‚¿ãƒ¼ãƒ³
                    }
                };
                return stageMap[stage] || stageMap['Ea'];
            }
            
            createControls() {
                // Add mouse controls for camera
                let mouseDown = false;
                let mouseX = 0;
                let mouseY = 0;
                
                const canvas = this.renderer.domElement;
                
                canvas.addEventListener('mousedown', (e) => {
                    mouseDown = true;
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!mouseDown) return;
                    
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    
                    this.camera.position.x += deltaX * 0.01;
                    this.camera.position.y -= deltaY * 0.01;
                    this.camera.lookAt(0, 0, 0);
                    
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                canvas.addEventListener('mouseup', () => {
                    mouseDown = false;
                });
                
                // Touch controls for mobile
                let touchStartX = 0;
                let touchStartY = 0;
                
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                });
                
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - touchStartX;
                    const deltaY = touch.clientY - touchStartY;
                    
                    this.camera.position.x += deltaX * 0.01;
                    this.camera.position.y -= deltaY * 0.01;
                    this.camera.lookAt(0, 0, 0);
                    
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                });
            }
            
            bindEvents() {
                // Stage button clicks
                const stageButtons = document.querySelectorAll('.stage-btn');
                stageButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const stage = btn.dataset.stage;
                        this.switchToStage(stage);
                    });
                });
                
                // View control buttons
                const resetBtn = document.getElementById('reset-view-btn');
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => {
                        this.resetView();
                    });
                }
                
                // Zoom controls via mouse wheel
                if (this.renderer && this.renderer.domElement) {
                    this.renderer.domElement.addEventListener('wheel', (e) => {
                        e.preventDefault();
                        this.handleZoom(e.deltaY);
                    }, { passive: false });
                }
                
                // Window resize
                window.addEventListener('resize', () => {
                    if (this.isInitialized) {
                        this.handleResize();
                    }
                });
            }
            
            switchToStage(stageId) {
                if (!this.isInitialized || this.isTransitioning) return;
                
                // Reset questioning stage specific data when switching stages
                this.persistentParticleIndices.clear();
                
                this.currentStage = stageId;
                
                // å¤šé¢ä½“å½¢çŠ¶ã®æ›´æ–°
                this.updatePolyhedronShape(stageId);
                
                this.updateStageVisualization(stageId);
                this.updateActiveButton(stageId);
                console.log('Switched to stage:', stageId);
            }

            updatePolyhedronShape(stageId) {
                if (this.isTransitioning) return;
                
                this.isTransitioning = true;
                
                // ç¾åœ¨ã®å½¢çŠ¶ã‹ã‚‰æ–°ã—ã„å½¢çŠ¶ã¸ã®ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³
                const currentGeometry = this.core?.geometry;
                const newGeometry = this.coreGeometryManager.createPolyhedronGeometry(stageId);
                
                if (currentGeometry && newGeometry) {
                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ â†’ å½¢çŠ¶å¤‰æ›´ â†’ ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
                    this.animatePolyhedronTransition(currentGeometry, newGeometry, stageId);
                } else {
                    // åˆå›ã¾ãŸã¯ç·Šæ€¥æ™‚ã¯ç›´æ¥ä½œæˆ
                    this.createPolyhedronCore(stageId);
                    this.isTransitioning = false;
                }
            }

            animatePolyhedronTransition(oldGeometry, newGeometry, stageId) {
                const transitionDuration = 1500; // 1.5ç§’ã®ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³
                const fadeOutDuration = 500;
                const scaleTransitionDuration = 700; // ã‚¹ã‚±ãƒ¼ãƒ«å¤‰æ›´æœŸé–“
                const fadeInDuration = 500;
                
                // ç¾åœ¨ã®ã‚µã‚¤ã‚ºã¨æ–°ã—ã„ã‚µã‚¤ã‚ºã‚’å–å¾—
                const oldSize = this.coreGeometryManager.getStageSize(this.currentStage);
                const newSize = this.coreGeometryManager.getStageSize(stageId);
                
                // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
                const startOpacity = this.core.material.opacity;
                const startScale = this.core.scale.x;
                const fadeOutStart = Date.now();
                
                const fadeOut = () => {
                    const elapsed = Date.now() - fadeOutStart;
                    const progress = Math.min(elapsed / fadeOutDuration, 1);
                    
                    this.core.material.opacity = startOpacity * (1 - progress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(fadeOut);
                    } else {
                        // å½¢çŠ¶å¤‰æ›´
                        this.createPolyhedronCore(stageId);
                        
                        // ã‚¹ã‚±ãƒ¼ãƒ«ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ä»˜ããƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
                        const targetOpacity = 0.85;
                        this.core.material.opacity = 0;
                        this.core.scale.set(oldSize / newSize, oldSize / newSize, oldSize / newSize); // å¤ã„ã‚µã‚¤ã‚ºã‹ã‚‰é–‹å§‹
                        
                        const fadeInStart = Date.now();
                        
                        const fadeIn = () => {
                            const elapsed = Date.now() - fadeInStart;
                            const progress = Math.min(elapsed / fadeInDuration, 1);
                            
                            // ã‚ªãƒ‘ã‚·ãƒ†ã‚£ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
                            this.core.material.opacity = targetOpacity * progress;
                            
                            // ã‚¹ã‚±ãƒ¼ãƒ«ã®æ»‘ã‚‰ã‹ãªå¤‰åŒ–
                            const scaleProgress = Math.min(elapsed / scaleTransitionDuration, 1);
                            const easeOut = 1 - Math.pow(1 - scaleProgress, 3); // ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆ
                            const currentScale = (oldSize / newSize) + (1 - oldSize / newSize) * easeOut;
                            this.core.scale.set(currentScale, currentScale, currentScale);
                            
                            if (progress < 1 || scaleProgress < 1) {
                                requestAnimationFrame(fadeIn);
                            } else {
                                // æœ€çµ‚çš„ã«æ­£ç¢ºãªã‚¹ã‚±ãƒ¼ãƒ«ã«è¨­å®š
                                this.core.scale.set(1, 1, 1);
                                this.isTransitioning = false;
                                console.log(`ã‚µã‚¤ã‚ºå¤‰æ›´å®Œäº†: ${oldSize.toFixed(2)} â†’ ${newSize.toFixed(2)}`);
                            }
                        };
                        
                        fadeIn();
                    }
                };
                
                fadeOut();
            }
            
            updateStageVisualization(stageId) {
                // ã‚¹ãƒ ãƒ¼ã‚ºãªãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³åŠ¹æœ
                this.transitionToStage(stageId);
                
                // Update core appearance based on stage
                const stageData = this.getStageData(stageId);
                if (this.core) {
                    // Coreè‰²ã‚’ã‚¹ãƒ ãƒ¼ã‚ºã«å¤‰æ›´
                    this.animateCoreColor(stageData.color);
                }
                
                // æ®µéšã«å¿œã˜ã¦æ¬¡å…ƒãƒªãƒ³ã‚°ã‚’æ›´æ–°
                this.updateDimensionRings(stageId);
            }
            
            // æ®µéšã«å¿œã˜ã¦æ¬¡å…ƒãƒªãƒ³ã‚°ã‚’æ›´æ–°ï¼ˆçµ±ä¸€åŒ–ã•ã‚ŒãŸãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ã‚·ã‚¹ãƒ†ãƒ ï¼‰
            updateDimensionRings(stageId) {
                const stageNumber = this.getStageNumber(stageId);
                
                this.dimensionRings.forEach((ring, index) => {
                    if (!ring.userData) return;
                    
                    // çµ±ä¸€åŒ–ã•ã‚ŒãŸè‰²èª¿ã¨è³ªæ„Ÿã‚’æ®µéšã«å¿œã˜ã¦æ›´æ–°
                    const newColor = this.getDimensionRingColor(index, stageNumber);
                    const newOpacity = this.getDimensionRingOpacity(stageNumber);
                    const newShininess = this.getDimensionRingShininess(stageNumber);
                    const newEmissive = this.getDimensionRingEmissive(index, stageNumber);
                    const newEmissiveIntensity = this.getDimensionRingEmissiveIntensity(stageNumber);
                    
                    // ã‚µã‚¤ã‚ºã‚’æ®µéšã«å¿œã˜ã¦æ›´æ–°
                    const newRadius = this.getDimensionRingRadius(index, stageNumber);
                    this.updateRingGeometry(ring, newRadius);
                    
                    // çµ±ä¸€åŒ–ã•ã‚ŒãŸãƒãƒ†ãƒªã‚¢ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã§ã‚¹ãƒ ãƒ¼ã‚ºãªãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³
                    this.animateRingProperties(ring, newColor, newOpacity, newShininess, newEmissive, newEmissiveIntensity);
                    
                    // ç›¸äº’ä½œç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ®µéšã«å¿œã˜ã¦è¨­å®š
                    ring.userData.interactionStrength = this.getInteractionStrength(stageNumber);
                    ring.userData.synchronizationFactor = this.getSynchronizationFactor(stageNumber);
                    ring.userData.materialEvolution = this.getCoreProgress(stageNumber); // æè³ªé€²åŒ–åº¦ã‚’åŒæœŸ
                });
            }
            
            // ãƒªãƒ³ã‚°ã®ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’æ–°ã—ã„åŠå¾„ã§æ›´æ–°
            updateRingGeometry(ring, newRadius) {
                // ç¾åœ¨ã®åŠå¾„ã¨æ–°ã—ã„åŠå¾„ã‚’æ¯”è¼ƒã—ã¦ãƒ­ã‚°å‡ºåŠ›
                const currentRadius = ring.geometry.parameters.radius;
                if (Math.abs(currentRadius - newRadius) > 0.1) {
                    console.log(`ãƒªãƒ³ã‚°${ring.userData.ringIndex}ã®ã‚µã‚¤ã‚ºå¤‰æ›´: ${currentRadius.toFixed(2)} â†’ ${newRadius.toFixed(2)}`);
                }
                
                // æ–°ã—ã„ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’ä½œæˆ
                const newGeometry = new THREE.TorusGeometry(newRadius, 0.05, 8, 32);
                
                // å¤ã„ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’ç ´æ£„
                ring.geometry.dispose();
                
                // æ–°ã—ã„ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’é©ç”¨
                ring.geometry = newGeometry;
            }

            // æ®µéšç•ªå·ã‚’å–å¾—
            getStageNumber(stageId) {
                const stageMap = {
                    'Ea': 1, 'Eb': 2, 'Ec': 3,    // External Authority 1-3
                    'EI': 4,                          // External-Internal (å²è·¯æ®µéšã®å§‹ã¾ã‚Š)
                    'E-I': 5,                         // External to Internal
                    'I-E': 6,                         // Internal to External  
                    'IE': 7,                          // Internal-External
                    'Ia': 8, 'Ib': 9, 'Ic': 10    // Internal Authority 8-10
                };
                return stageMap[stageId] || 1;
            }
            
            // çµ±ä¸€åŒ–ã•ã‚ŒãŸãƒªãƒ³ã‚°ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            animateRingProperties(ring, newColor, newOpacity, newShininess, newEmissive, newEmissiveIntensity) {
                // è‰²ã®ã‚¹ãƒ ãƒ¼ã‚ºãªå¤‰æ›´
                const currentColor = new THREE.Color(ring.material.color);
                const targetColor = new THREE.Color(newColor);
                const currentEmissive = new THREE.Color(ring.material.emissive);
                const targetEmissive = new THREE.Color(newEmissive);
                
                // çµ±ä¸€åŒ–ã•ã‚ŒãŸãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ï¼ˆå¤šé¢ä½“ã‚³ã‚¢ã¨åŒæœŸï¼‰
                ring.material.color.lerp(targetColor, 0.1);
                ring.material.opacity = THREE.MathUtils.lerp(ring.material.opacity, newOpacity, 0.1);
                ring.material.shininess = THREE.MathUtils.lerp(ring.material.shininess, newShininess, 0.1);
                ring.material.emissive.lerp(targetEmissive, 0.1);
                ring.material.emissiveIntensity = THREE.MathUtils.lerp(ring.material.emissiveIntensity, newEmissiveIntensity, 0.1);
                
                // ãƒãƒ†ãƒªã‚¢ãƒ«ã®æ›´æ–°ãŒå¿…è¦ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™
                ring.material.needsUpdate = true;
            }
            
            // æ®µéšã«å¿œã˜ãŸç›¸äº’ä½œç”¨ã®å¼·åº¦
            getInteractionStrength(stage) {
                if (stage <= 3) {
                    // EAæ®µéš: 0.05-0.20 (ç‹¬ç«‹å›è»¢)
                    return 0.05 + stage * 0.05;
                } else if (stage <= 7) {
                    // å²è·¯æ®µéš: 0.20-0.80 (åŒæœŸã®å§‹ã¾ã‚Šã€œç™ºå±•)
                    return 0.20 + (stage - 3) * 0.15;
                } else {
                    // IAæ®µéš: 0.80-0.98 (å¼·ã„ç›¸äº’ä½œç”¨)
                    return 0.80 + (stage - 7) * 0.06;
                }
            }
            
            // æ®µéšã«å¿œã˜ãŸåŒæœŸåº¦åˆã„
            getSynchronizationFactor(stage) {
                if (stage <= 3) {
                    // EAæ®µéš: 0 (å®Œå…¨ã«ç‹¬ç«‹)
                    return 0;
                } else if (stage <= 7) {
                    // å²è·¯æ®µéš: 0-0.80 (å¾ã€…ã«åŒæœŸ)
                    return (stage - 3) * 0.20;
                } else {
                    // IAæ®µéš: 0.80-0.98 (é«˜åº¦ãªçµ±åˆ)
                    return 0.80 + (stage - 7) * 0.06;
                }
            }
            
            // æ®µéšçš„é€²åŒ–ã™ã‚‹æ¬¡å…ƒãƒªãƒ³ã‚°ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            animateDimensionRingsEvolution(time) {
                const stageNumber = this.getStageNumber(this.currentStage);
                
                this.dimensionRings.forEach((ring, index) => {
                    if (!ring.userData) return;
                    
                    const userData = ring.userData;
                    const interactionStrength = userData.interactionStrength || 0;
                    const syncFactor = userData.synchronizationFactor || 0;
                    
                    // åŸºæœ¬å›è»¢é€Ÿåº¦ã®è¨ˆç®—
                    let currentSpeed = userData.baseRotationSpeed;
                    
                    // æ®µéšã«å¿œã˜ãŸå›è»¢ãƒ‘ã‚¿ãƒ¼ãƒ³
                    if (stageNumber <= 3) {
                        // æ®µéš1-3: ç‹¬ç«‹å›è»¢ï¼ˆãã‚Œãã‚Œç‹¬ç«‹ï¼‰
                        ring.rotation.y += currentSpeed * userData.rotationDirection * 0.01;
                        ring.rotation.x = userData.baseRotationX + Math.sin(time * 0.3 + index) * 0.05;
                        
                    } else if (stageNumber <= 6) {
                        // æ®µéš4-6: å¼±ã„ç›¸äº’ä½œç”¨ï¼ˆåŒæœŸã®å§‹ã¾ã‚Šï¼‰
                        const otherRingsInfluence = this.calculateRingInfluence(index, time);
                        const influenceStrength = interactionStrength * 0.5;
                        
                        ring.rotation.y += (currentSpeed + otherRingsInfluence * influenceStrength) * userData.rotationDirection * 0.01;
                        ring.rotation.x = userData.baseRotationX + 
                                         Math.sin(time * 0.4 + index) * 0.08 + 
                                         Math.sin(time * 0.2 + index * 2) * influenceStrength * 0.03;
                        
                    } else {
                        // æ®µéš7-10: è¤‡é›‘ãªç›¸äº’ä½œç”¨ï¼ˆçµ±åˆã•ã‚ŒãŸå‹•ãï¼‰
                        const complexInteraction = this.calculateComplexInteraction(index, time, syncFactor);
                        
                        ring.rotation.y += (currentSpeed + complexInteraction.yInfluence) * userData.rotationDirection * 0.01;
                        ring.rotation.x = userData.baseRotationX + complexInteraction.xInfluence;
                        
                        // é«˜æ¬¡æ®µéšã§ã¯è»Œé“ã‚‚å¤‰åŒ–
                        const orbitalMotion = this.calculateOrbitalMotion(index, time, syncFactor);
                        ring.position.x = orbitalMotion.x;
                        ring.position.z = orbitalMotion.z;
                    }
                    
                    // ã™ã¹ã¦ã®æ®µéšã§è‰²ã¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®ç¶™ç¶šçš„æ›´æ–°
                    this.updateRingAppearanceContinuous(ring, index, stageNumber, time);
                });
            }
            
            // ä»–ã®ãƒªãƒ³ã‚°ã‹ã‚‰ã®å½±éŸ¿ã‚’è¨ˆç®—
            calculateRingInfluence(currentIndex, time) {
                let totalInfluence = 0;
                
                this.dimensionRings.forEach((otherRing, otherIndex) => {
                    if (otherIndex !== currentIndex && otherRing.userData) {
                        const distance = Math.abs(currentIndex - otherIndex);
                        const influence = Math.sin(time * 0.3 + otherIndex) / (distance + 1);
                        totalInfluence += influence;
                    }
                });
                
                return totalInfluence * 0.1;
            }
            
            // è¤‡é›‘ãªç›¸äº’ä½œç”¨ã®è¨ˆç®—ï¼ˆé«˜æ¬¡æ®µéšç”¨ï¼‰
            calculateComplexInteraction(index, time, syncFactor) {
                const phase1 = time * 0.2 + index * Math.PI * 2 / 3;
                const phase2 = time * 0.15 + (index + 1) * Math.PI * 2 / 3;
                const phase3 = time * 0.25 + (index + 2) * Math.PI * 2 / 3;
                
                const yInfluence = (Math.sin(phase1) + Math.sin(phase2) * syncFactor) * 0.3;
                const xInfluence = (Math.sin(phase1) * 0.1 + 
                                  Math.cos(phase2) * syncFactor * 0.08 + 
                                  Math.sin(phase3) * syncFactor * 0.05);
                
                return { yInfluence, xInfluence };
            }
            
            // è»Œé“é‹å‹•ã®è¨ˆç®—ï¼ˆæœ€é«˜æ¬¡æ®µéšç”¨ï¼‰
            calculateOrbitalMotion(index, time, syncFactor) {
                if (syncFactor < 0.5) {
                    return { x: 0, z: 0 }; // è»Œé“é‹å‹•ãªã—
                }
                
                const radius = 0.2 * syncFactor;
                const frequency = 0.1 + index * 0.05;
                const phase = index * Math.PI * 2 / 3;
                
                return {
                    x: Math.cos(time * frequency + phase) * radius,
                    z: Math.sin(time * frequency + phase) * radius
                };
            }
            
            // ãƒªãƒ³ã‚°ã®å¤–è¦³ã®ç¶™ç¶šçš„æ›´æ–°
            updateRingAppearanceContinuous(ring, index, stageNumber, time) {
                // å‘¼å¸ã®ã‚ˆã†ãªå…‰ã®å¤‰å‹•
                const breathe = Math.sin(time * 0.5 + index) * 0.1 + 1;
                
                // æ®µéšã«å¿œã˜ãŸç™ºå…‰åŠ¹æœ
                if (stageNumber >= 7) {
                    // è¼ãè³ªæ„Ÿã®æ®µéšã§ã¯ç™ºå…‰åŠ¹æœã‚’è¿½åŠ 
                    const glow = Math.sin(time * 0.8 + index * 2) * 0.3 + 0.7;
                    ring.material.emissive = ring.material.color.clone().multiplyScalar(0.1 * glow);
                }
                
                // é€æ˜åº¦ã®å¾®èª¿æ•´
                const baseOpacity = this.getDimensionRingOpacity(stageNumber);
                ring.material.opacity = baseOpacity * breathe;
            }

            transitionToStage(newStageId) {
                const oldStageData = this.getStageData(this.currentStage);
                const newStageData = this.getStageData(newStageId);
                
                // æ¥ç¶šç·šã‚’ã‚¯ãƒªã‚¢ï¼ˆå…¨ã‚¹ãƒ†ãƒ¼ã‚¸åˆ‡ã‚Šæ›¿ãˆæ™‚ï¼‰
                this.clearConnections();
                
                // ã‚¹ãƒ†ãƒ¼ã‚¸åˆ‡ã‚Šæ›¿ãˆæ™‚ã®ã‚³ã‚¢å…‰é‡ãƒªã‚»ãƒƒãƒˆ
                if (this.currentStage === 'EI' || newStageId !== 'EI') {
                    this.resetCoreIntensity();
                }
                
                // EIã‚¹ãƒ†ãƒ¼ã‚¸å›ºæœ‰ã®åˆæœŸåŒ–
                if (newStageId === 'EI') {
                    // æ—¢å­˜ã®ç–‘å•ãƒ•ã‚§ãƒ¼ã‚ºã‚’ãƒªã‚»ãƒƒãƒˆ
                    this.particles.forEach(particle => {
                        if (particle.userData) {
                            particle.userData.questioningPhase = null;
                        }
                    });
                    this.persistentParticleIndices.clear();
                    
                    // å³åº§ã«è¡¨ç¤ºã™ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è¨­å®šï¼ˆæœ€åˆã®5å€‹ï¼‰
                    const currentTime = Date.now() * 0.001;
                    this.particles.slice(0, 5).forEach((particle, index) => {
                        if (particle.userData) {
                            // å³åº§ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åˆæœŸè¨­å®š
                            const angle = Math.random() * Math.PI * 2;
                            const radius = 1 + Math.random() * 2.5;
                            const height = (Math.random() - 0.5) * 3;
                            
                            const fixedPosition = {
                                x: radius * Math.cos(angle),
                                y: height,
                                z: radius * Math.sin(angle)
                            };
                            
                            particle.position.set(fixedPosition.x, fixedPosition.y, fixedPosition.z);
                            
                            // ãƒ•ã‚§ãƒ¼ã‚ºã‚’åˆæœŸåŒ–ã—ã¦å³åº§ã«è¡¨ç¤º
                            particle.userData.questioningPhase = {
                                spawnTime: currentTime - 1, // 1ç§’å‰ã«ç”Ÿæˆã•ã‚ŒãŸã“ã¨ã«ã—ã¦å³åº§ã«è¡¨ç¤º
                                lifespan: 2 + Math.random() * 4,
                                isPersistent: Math.random() < 0.3,
                                fadeInDuration: 0.8,
                                fadeOutDuration: 1.2,
                                hasBeenPersistent: false,
                                fixedPosition: fixedPosition
                            };
                            
                            // é€æ˜åº¦ã‚’å³åº§ã«è¨­å®š
                            particle.material.opacity = 0.9;
                        }
                    });
                }
                
                // I(E)ã‚¹ãƒ†ãƒ¼ã‚¸ä»¥é™ï¼ˆIaã€Ibã€Icç­‰ï¼‰ã®æ¥ç¶šç·šå³åº§è¡¨ç¤º
                if (this.shouldShowConnections(newStageId)) {
                    // æ¥ç¶šæ›´æ–°ã‚¿ã‚¤ãƒãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦å³åº§ã«æ¥ç¶šã‚’ç”Ÿæˆ
                    this.lastConnectionUpdate = 0;
                    
                    // å°‘ã—é…å»¶ã—ã¦æ¥ç¶šã‚’å¼·åˆ¶ç”Ÿæˆï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åˆæœŸåŒ–å®Œäº†å¾Œï¼‰
                    setTimeout(() => {
                        this.updateConnections(true); // å¼·åˆ¶æ›´æ–°
                    }, 100);
                }
                
                // I-E ã‚¹ãƒ†ãƒ¼ã‚¸å°‚ç”¨: ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
                if (newStageId === 'I-E') {
                    // ã¾ãšå…¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å®Œå…¨ã«ã‚³ã‚¢ä¸­å¿ƒã«ç§»å‹•ãƒ»éè¡¨ç¤ºåŒ–
                    this.particles.forEach((particle, index) => {
                        if (particle.userData) {
                            // ã‚³ã‚¢ä¸­å¿ƒã«ç§»å‹•
                            particle.position.set(0, 0, 0);
                            // å®Œå…¨ã«éè¡¨ç¤º
                            particle.visible = false;
                            particle.material.opacity = 0;
                            particle.scale.setScalar(0.1);
                            
                            // I-Eã‚¹ãƒ†ãƒ¼ã‚¸ã®å‹•ä½œãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¨­å®šï¼ˆé‡è¦ï¼ï¼‰
                            particle.userData.behavior = newStageData.behavior;
                            particle.userData.pattern = newStageData.pattern; // 'pulse'ã«è¨­å®š
                            particle.userData.cohesion = newStageData.cohesion;
                            particle.userData.speed = newStageData.speed * (0.8 + Math.random() * 0.4);
                            
                            // å‡ºç¾å…ˆã®ç›®æ¨™ä½ç½®ã‚’è¨ˆç®—ï¼ˆæ”¾å°„çŠ¶é…ç½®ï¼‰
                            const radius = 1 + Math.random() * 4; // 1-5ã®ç¯„å›²
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.random() * Math.PI;
                            
                            const targetX = radius * Math.sin(phi) * Math.cos(theta);
                            const targetY = radius * Math.sin(phi) * Math.sin(theta);
                            const targetZ = radius * Math.cos(phi);
                            
                            // å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ãƒ‡ãƒ¼ã‚¿ã‚’è¨­å®š
                            particle.userData.emergenceStartPosition = new THREE.Vector3(0, 0, 0);
                            particle.userData.emergenceTargetPosition = new THREE.Vector3(targetX, targetY, targetZ);
                            
                            // originalPositionã‚’æœ€çµ‚ç›®æ¨™ä½ç½®ã«è¨­å®šï¼ˆãƒ‘ãƒ«ã‚¹å‹•ä½œã®åŸºæº–ç‚¹ï¼‰
                            particle.userData.originalPosition = new THREE.Vector3(targetX, targetY, targetZ);
                        }
                    });
                    
                    // å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
                    this.initializeIEEmergence();
                }
                
                // æ—¢å­˜ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’æ–°ã—ã„å‹•ä½œãƒ‘ã‚¿ãƒ¼ãƒ³ã«æ®µéšçš„ã«ç§»è¡Œ
                this.particles.forEach((particle, index) => {
                    if (particle.userData) {
                        // I-Eã‚¹ãƒ†ãƒ¼ã‚¸ã®å ´åˆã¯æ—¢ã«ä¸Šã§å‡¦ç†æ¸ˆã¿
                        if (newStageId === 'I-E') {
                            // I-Eã‚¹ãƒ†ãƒ¼ã‚¸ã§ã¯è‰²ã ã‘æ›´æ–°ï¼ˆãƒ‘ã‚¿ãƒ¼ãƒ³ã¯æ—¢ã«è¨­å®šæ¸ˆã¿ï¼‰
                            if (!this.isColorfulStage(newStageId)) {
                                particle.material.color.setHex(newStageData.color);
                            }
                            return;
                        }
                        
                        // æ–°ã—ã„å‹•ä½œãƒ‘ã‚¿ãƒ¼ãƒ³ã«æ›´æ–°
                        particle.userData.behavior = newStageData.behavior;
                        particle.userData.pattern = newStageData.pattern;
                        particle.userData.cohesion = newStageData.cohesion;
                        particle.userData.speed = newStageData.speed * (0.8 + Math.random() * 0.4);
                        
                        // ã‚«ãƒ©ãƒ•ãƒ«ã‚¹ãƒ†ãƒ¼ã‚¸ã§ãªã„å ´åˆã¯å˜è‰²ã«æˆ»ã™
                        if (!this.isColorfulStage(newStageId)) {
                            this.animateParticleColor(particle, newStageData.color, index * 50);
                        }
                        // ã‚«ãƒ©ãƒ•ãƒ«ã‚¹ãƒ†ãƒ¼ã‚¸ã®å ´åˆã¯è‰²ã®ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆå‹•çš„ã«å¤‰åŒ–ã™ã‚‹ãŸã‚ï¼‰
                    }
                });
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°ã®èª¿æ•´
                this.adjustParticleCount(newStageData.particleCount, newStageData.color);
                
                // æ®µéšçš„å…‰å¼·åŒ–ã‚·ã‚¹ãƒ†ãƒ  - ã‚¹ãƒ†ãƒ¼ã‚¸é€²è¡Œã«å¿œã˜ã¦å…‰ã®ãƒ™ãƒ¼ãƒ«ã‚’æ›´æ–°
                this.updateLightVeils(newStageId);
            }
            
            animateCoreColor(targetColor) {
                if (!this.core) return;
                
                const currentColor = this.core.material.emissive.getHex();
                const targetColorObj = new THREE.Color(targetColor);
                
                // ã‚¹ãƒ ãƒ¼ã‚ºãªè‰²å¤‰æ›´ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                let progress = 0;
                const animateColor = () => {
                    progress += 0.05;
                    if (progress >= 1) {
                        this.core.material.emissive.setHex(targetColor);
                        return;
                    }
                    
                    const currentColorObj = new THREE.Color(currentColor);
                    currentColorObj.lerp(targetColorObj, progress);
                    this.core.material.emissive.copy(currentColorObj);
                    
                    requestAnimationFrame(animateColor);
                };
                animateColor();
            }
            
            animateParticleColor(particle, targetColor, delay = 0) {
                setTimeout(() => {
                    const currentColor = particle.material.color.getHex();
                    const targetColorObj = new THREE.Color(targetColor);
                    
                    let progress = 0;
                    const animateColor = () => {
                        progress += 0.03;
                        if (progress >= 1) {
                            particle.material.color.setHex(targetColor);
                            return;
                        }
                        
                        const currentColorObj = new THREE.Color(currentColor);
                        currentColorObj.lerp(targetColorObj, progress);
                        particle.material.color.copy(currentColorObj);
                        
                        requestAnimationFrame(animateColor);
                    };
                    animateColor();
                }, delay);
            }
            
            // I-E ã‚¹ãƒ†ãƒ¼ã‚¸å°‚ç”¨: ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
            initializeIEEmergence() {
                this.isEmergingIE = true;
                this.emergenceStartTime = Date.now() + this.emergenceDelay;
                this.emergingParticles = [];
                
                // å…¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å‡ºç¾å¾…ã¡ãƒªã‚¹ãƒˆã«è¿½åŠ ï¼ˆã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ã¦è‡ªç„¶ãªé †åºã«ï¼‰
                const particleIndices = this.particles.map((_, index) => index);
                this.shuffleArray(particleIndices);
                
                particleIndices.forEach((index, order) => {
                    this.emergingParticles.push({
                        particleIndex: index,
                        emergenceTime: this.emergenceStartTime + (order * this.particleEmergenceInterval),
                        hasEmerged: false,
                        emergenceProgress: 0
                    });
                });
                
                console.log(`I-E Emergence initialized: ${this.emergingParticles.length} particles scheduled`);
            }
            
            // é…åˆ—ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }
            
            adjustParticleCount(targetCount, color) {
                const currentCount = this.particles.length;
                
                if (currentCount < targetCount) {
                    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è¿½åŠ 
                    const toAdd = targetCount - currentCount;
                    for (let i = 0; i < toAdd; i++) {
                        setTimeout(() => {
                            this.addSingleParticle(color);
                        }, i * 100); // æ®µéšçš„ã«è¿½åŠ 
                    }
                } else if (currentCount > targetCount) {
                    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å‰Šé™¤
                    const toRemove = currentCount - targetCount;
                    for (let i = 0; i < toRemove; i++) {
                        setTimeout(() => {
                            this.removeSingleParticle();
                        }, i * 50); // æ®µéšçš„ã«å‰Šé™¤
                    }
                }
            }
            
            updateLightVeils(currentStageId) {
                // å…‰ã®ãƒ™ãƒ¼ãƒ«ãŒè¡¨ç¤ºã•ã‚Œãªã„ã‚¹ãƒ†ãƒ¼ã‚¸ã®å ´åˆã¯å…¨ãƒ™ãƒ¼ãƒ«ã‚’éè¡¨ç¤º
                if (this.noLightVeilStages.includes(currentStageId)) {
                    this.hideAllLightVeils();
                    return;
                }
                
                // ã‚¹ãƒ†ãƒ¼ã‚¸é€²è¡Œé †åºã«åŸºã¥ã„ã¦ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¾ã§ã®å…‰ã®ãƒ™ãƒ¼ãƒ«ã‚’è¡¨ç¤º
                const currentIndex = this.stageProgressionOrder.indexOf(currentStageId);
                
                if (currentIndex === -1) {
                    // é€²è¡Œé †åºã«ãªã„ã‚¹ãƒ†ãƒ¼ã‚¸ã®å ´åˆã‚‚å…¨ãƒ™ãƒ¼ãƒ«ã‚’éè¡¨ç¤º
                    this.hideAllLightVeils();
                    return;
                }
                
                // ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¾ã§ã®å…‰ã®ãƒ™ãƒ¼ãƒ«ã‚’æ®µéšçš„ã«è¡¨ç¤º
                this.lightVeils.forEach((veil, index) => {
                    if (index <= currentIndex) {
                        // æ®µéšçš„ã«ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ - ã‚ˆã‚Šæ»‘ã‚‰ã‹ãªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                        setTimeout(() => {
                            veil.visible = true;
                            veil.userData.visible = true;
                            veil.userData.fadingIn = true; // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³çŠ¶æ…‹ãƒ•ãƒ©ã‚°
                            veil.userData.fadeStartTime = Date.now(); // ãƒ•ã‚§ãƒ¼ãƒ‰é–‹å§‹æ™‚åˆ»
                            veil.userData.fadeDuration = 2000; // 2ç§’é–“ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
                            
                            // åˆæœŸçŠ¶æ…‹ã‚’å®Œå…¨é€æ˜ã«è¨­å®š
                            if (veil.material.uniforms) {
                                veil.material.uniforms.opacity.value = 0;
                                veil.material.uniforms.emissiveIntensity.value = 0;
                            } else {
                                veil.material.opacity = 0;
                                if (veil.material.emissiveIntensity !== undefined) {
                                    veil.material.emissiveIntensity = 0;
                                }
                            }
                            
                        }, index * 500); // å„ãƒ™ãƒ¼ãƒ«ã‚’500msé–“éš”ã§æ®µéšçš„ã«è¡¨ç¤ºï¼ˆå°‘ã—é•·ã‚ã«ï¼‰
                    } else {
                        // ã¾ã åˆ°é”ã—ã¦ã„ãªã„ã‚¹ãƒ†ãƒ¼ã‚¸ã®ãƒ™ãƒ¼ãƒ«ã¯éè¡¨ç¤º
                        veil.visible = false;
                        veil.userData.visible = false;
                        veil.userData.fadingIn = false;
                    }
                });
                
                // ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ›´æ–°
                this.currentStageIndex = currentIndex;
            }
            
            hideAllLightVeils() {
                // å…¨ã¦ã®å…‰ã®ãƒ™ãƒ¼ãƒ«ã‚’éè¡¨ç¤ºã«ã™ã‚‹ï¼ˆãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆåŠ¹æœä»˜ãï¼‰
                this.lightVeils.forEach((veil, index) => {
                    if (veil.visible) {
                        // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                        veil.userData.fadingOut = true;
                        veil.userData.fadeOutStartTime = Date.now();
                        veil.userData.fadeOutDuration = 1000; // 1ç§’é–“ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
                        
                        // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«å¯¾å¿œã®åˆæœŸå€¤è¨˜éŒ²
                        if (veil.material.uniforms) {
                            veil.userData.fadeOutStartOpacity = veil.material.uniforms.opacity.value;
                            veil.userData.fadeOutStartEmissive = veil.material.uniforms.emissiveIntensity.value;
                        } else {
                            veil.userData.fadeOutStartOpacity = veil.material.opacity;
                            veil.userData.fadeOutStartEmissive = veil.material.emissiveIntensity || 0;
                        }
                        
                        veil.userData.fadingIn = false; // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚’åœæ­¢
                    }
                });
                this.currentStageIndex = -1; // ãƒ™ãƒ¼ãƒ«ãªã—çŠ¶æ…‹
            }
            
            addSingleParticle(color) {
                // çµŒé¨“ã®ãƒ¡ã‚¿ãƒ•ã‚¡ãƒ¼ã¨ã—ã¦ãƒ©ãƒ³ãƒ€ãƒ ãªã‚µã‚¤ã‚ºã‚’ç”Ÿæˆ
                const baseSize = 0.04;
                const sizeVariation = 0.5 + Math.random() * 1.3; // 0.5 - 1.8å€
                const particleSize = baseSize * sizeVariation;
                
                // æ®µéšã«å¿œã˜ãŸã‚µã‚¤ã‚ºèª¿æ•´
                const stageNumber = this.getStageNumber(this.currentStage);
                let stageSizeMultiplier = 1.0;
                
                if (stageNumber >= 8) { // Ia, Ib, Icæ®µéš
                    stageSizeMultiplier = 1.0 + (stageNumber - 7) * 0.15;
                } else if (stageNumber >= 5) { // E-I, I-E, IEæ®µéš
                    stageSizeMultiplier = 1.0 + (stageNumber - 4) * 0.08;
                }
                
                const finalSize = particleSize * stageSizeMultiplier;
                const geometry = new THREE.SphereGeometry(finalSize, 12, 12); // ãƒ©ãƒ³ãƒ€ãƒ ã‚µã‚¤ã‚ºé©ç”¨ã€å“è³ªã‚‚å‘ä¸Š
                
                // ã‚«ãƒ©ãƒ•ãƒ«ã‚¹ãƒ†ãƒ¼ã‚¸ã®å ´åˆã¯åˆæœŸè‰²ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«è¨­å®š
                const initialColor = this.isColorfulStage(this.currentStage) ? 
                    this.colorfulParticlePalette[Math.floor(Math.random() * this.colorfulParticlePalette.length)] : 
                    color;
                
                // ã‚µã‚¤ã‚ºã«å¿œã˜ãŸè¦–è¦šçš„åŠ¹æœã®èª¿æ•´
                const sizeRatio = finalSize / baseSize; // ã‚µã‚¤ã‚ºæ¯”ã‚’è¨ˆç®—
                const baseOpacity = 0.0; // addSingleParticleã¯0ã‹ã‚‰é–‹å§‹
                const sizeAdjustedEmissive = Math.floor(0x111111 * (0.8 + sizeRatio * 0.4)); // å¤§ãã„ã»ã©å°‘ã—æ˜ã‚‹ãç™ºå…‰
                const sizeAdjustedShininess = 80 + (sizeRatio - 1) * 40; // ã‚µã‚¤ã‚ºã«å¿œã˜ã¦å…‰æ²¢åº¦èª¿æ•´
                
                const material = new THREE.MeshPhongMaterial({ 
                    color: initialColor,
                    transparent: true,
                    opacity: baseOpacity,  // åˆæœŸã¯0
                    emissive: sizeAdjustedEmissive,  // ã‚µã‚¤ã‚ºèª¿æ•´ã•ã‚ŒãŸç™ºå…‰
                    shininess: Math.max(50, Math.min(150, sizeAdjustedShininess))  // å…‰æ²¢ç¯„å›²åˆ¶é™
                });
                const particle = new THREE.Mesh(geometry, material);
                
                // ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã«é…ç½®
                const radius = 1 + Math.random() * 5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                particle.position.x = radius * Math.sin(phi) * Math.cos(theta);
                particle.position.y = radius * Math.sin(phi) * Math.sin(theta);
                particle.position.z = radius * Math.cos(phi);
                
                // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’è¨­å®š
                const stageData = this.getStageData(this.currentStage);
                particle.userData = {
                    originalPosition: particle.position.clone(),
                    baseRadius: radius,
                    baseTheta: theta,
                    basePhi: phi,
                    personalityFactor: Math.random(),
                    phaseOffset: Math.random() * Math.PI * 2,
                    speed: stageData.speed * (0.8 + Math.random() * 0.4),
                    cohesion: stageData.cohesion,
                    behavior: stageData.behavior,
                    pattern: stageData.pattern,
                    age: 0,
                    targetPosition: new THREE.Vector3(),
                    // ã‚µã‚¤ã‚ºé–¢é€£æƒ…å ±ã‚’è¿½åŠ 
                    originalSize: finalSize,
                    sizeRatio: sizeRatio,
                    baseSize: baseSize,
                    sizeVariation: sizeVariation
                };
                
                // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³åŠ¹æœ
                let opacity = 0;
                const fadeIn = () => {
                    opacity += 0.02;
                    if (opacity >= 0.8) {
                        particle.material.opacity = 0.8;
                        return;
                    }
                    particle.material.opacity = opacity;
                    requestAnimationFrame(fadeIn);
                };
                fadeIn();
                
                this.scene.add(particle);
                this.particles.push(particle);
            }
            
            removeSingleParticle() {
                if (this.particles.length === 0) return;
                
                const particle = this.particles.pop();
                
                // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆåŠ¹æœ
                let opacity = particle.material.opacity;
                const fadeOut = () => {
                    opacity -= 0.05;
                    if (opacity <= 0) {
                        this.scene.remove(particle);
                        particle.geometry.dispose();
                        particle.material.dispose();
                        return;
                    }
                    particle.material.opacity = opacity;
                    requestAnimationFrame(fadeOut);
                };
                fadeOut();
            }
            
            updateActiveButton(stageId) {
                const buttons = document.querySelectorAll('.stage-btn');
                buttons.forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.stage === stageId) {
                        btn.classList.add('active');
                    }
                });
                
                // æ®µéšæƒ…å ±è¡¨ç¤ºã‚’æ›´æ–°
                this.updateStageInfo(stageId);
            }
            
            updateStageInfo(stageId) {
                const stageData = this.getStageData(stageId);
                const titleElement = document.getElementById('current-stage-title');
                const descElement = document.getElementById('current-stage-description');
                
                if (titleElement && descElement) {
                    titleElement.textContent = `${stageId}: ${stageData.description}`;
                    
                    // æ®µéšã«å¿œã˜ãŸè©³ç´°èª¬æ˜
                    const behaviorDescriptions = {
                        'chaotic': 'æ··æ²Œã¨ã—ãŸçŠ¶æ…‹ã‹ã‚‰æˆé•·ãŒå§‹ã¾ã‚Šã¾ã™',
                        'conflicted': 'å†…é¢ã«å¯¾ç«‹ã™ã‚‹åŠ›ãŒåƒã„ã¦ã„ã¾ã™',
                        'questioning': 'ç–‘å•ã¨æ°—ã¥ããŒç”Ÿã¾ã‚Œã¦ã„ã¾ã™',
                        'questioning_emergence': 'ç–‘å•ã«ã‚ˆã‚Šæ§˜ã€…ãªçµŒé¨“ãŒæ€ã„æµ®ã‹ã³ã€å¤§åˆ‡ãªã‚‚ã®ã¯å¿ƒã«æ®‹ã‚Šç¶šã‘ã¾ã™',
                        'searching': 'æ–°ã—ã„å¯èƒ½æ€§ã‚’æ¢ç´¢ã—ã¦ã„ã¾ã™',
                        'building': 'å†…ãªã‚‹åŸºç›¤ã‚’æ§‹ç¯‰ã—ã¦ã„ã¾ã™',
                        'listening': 'å†…ãªã‚‹å£°ã«è€³ã‚’å‚¾ã‘ã¦ã„ã¾ã™',
                        'nurturing': 'è‡ªå·±ã®æˆé•·ã‚’è‚²ã‚“ã§ã„ã¾ã™',
                        'trusting': 'å†…ãªã‚‹å£°ã‚’ä¿¡é ¼ã—å§‹ã‚ã¦ã„ã¾ã™',
                        'foundation': 'ç¢ºå›ºã¨ã—ãŸåŸºç›¤ã‚’ç¯‰ã„ã¦ã„ã¾ã™',
                        'committed': 'åŸºç›¤ã®ä¸Šã§æ³¢ã®ã‚ˆã†ã«èºå‹•ã—ãªãŒã‚‰å®Œå…¨ãªã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒ³ãƒˆã‚’å®Ÿç¾ã—ã¦ã„ã¾ã™'
                    };
                    
                    descElement.textContent = behaviorDescriptions[stageData.behavior] || stageData.description;
                }
            }
            
            resetView() {
                this.camera.position.set(0, 0, this.defaultCameraZ);
                this.camera.lookAt(0, 0, 0);
            }
            
            handleZoom(deltaY) {
                if (!this.camera) return;
                
                // Zoom direction: positive deltaY = zoom out, negative deltaY = zoom in
                const zoomDirection = deltaY > 0 ? 1 : -1;
                const zoomAmount = zoomDirection * this.zoomSpeed;
                
                // Calculate new camera position
                const currentZ = this.camera.position.z;
                const newZ = currentZ + zoomAmount;
                
                // Clamp zoom within bounds
                const clampedZ = Math.max(this.minZoom, Math.min(this.maxZoom, newZ));
                
                // Apply smooth zoom
                this.camera.position.z = clampedZ;
                
                // Optionally update field of view for more dramatic zoom effect
                // this.camera.fov = Math.max(30, Math.min(75, 75 - (clampedZ - this.defaultCameraZ) * 2));
                // this.camera.updateProjectionMatrix();
            }
            
            handleResize() {
                const width = this.container.offsetWidth;
                const height = this.container.offsetHeight;
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }
            
            startAnimation() {
                const animate = () => {
                    this.animationFrameId = requestAnimationFrame(animate);
                    
                    const time = Date.now() * 0.001;
                    
                    // Core rotation
                    if (this.core) {
                        this.core.rotation.y += 0.005; // ã‚†ã£ãã‚Šã¨ã—ãŸå›è»¢
                        this.core.rotation.x += 0.002;
                    }
                    
                    // æ®µéšçš„é€²åŒ–ã™ã‚‹æ¬¡å…ƒãƒªãƒ³ã‚°ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    this.animateDimensionRingsEvolution(time);
                    
                    // I-E ã‚¹ãƒ†ãƒ¼ã‚¸: ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†
                    if (this.isEmergingIE) {
                        this.updateIEEmergence();
                    }
                    
                    // Advanced particle animation based on stage behavior
                    this.particles.forEach((particle, index) => {
                        const userData = particle.userData;
                        if (!userData) return;
                        
                        userData.age += 0.016; // Approximate 60fps
                        
                        // Update colorful particles for I(E) stages and beyond
                        this.updateParticleColorDynamic(particle, index, time);
                        
                        this.updateParticleBehavior(particle, index, time);
                    });
                    
                    // Update particle connections for I(E) stages and beyond
                    if (this.shouldShowConnections(this.currentStage)) {
                        this.updateConnections();
                        this.updateConnectionPositions();
                    }
                    
                    // å…‰ã®ãƒ™ãƒ¼ãƒ«ã®å‘¼å¸ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    this.animateLightVeils(time);
                    
                    // å¤šé¢ä½“ã‚³ã‚¢ã®å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    this.animatePolyhedronCore(time);
                    
                    this.renderer.render(this.scene, this.camera);
                };
                animate();
            }

            animatePolyhedronCore(time) {
                if (!this.core || this.isTransitioning) return;
                
                // æ®µéšã«å¿œã˜ãŸå›è»¢ãƒ‘ã‚¿ãƒ¼ãƒ³
                const stageData = this.getStageData(this.currentStage);
                
                switch(this.currentStage) {
                    case 'Ea': case 'Eb': case 'Ec':
                        // æ­£å››é¢ä½“: ä¸å®‰å®šãªæŒ¯å‹•çš„å›è»¢
                        this.core.rotation.x = Math.sin(time * 0.003) * 0.3;
                        this.core.rotation.y += 0.01 + Math.sin(time * 0.002) * 0.005;
                        this.core.rotation.z = Math.cos(time * 0.0025) * 0.2;
                        break;
                        
                    case 'EI': case 'E-I': case 'I-E':
                        // æ­£å…«é¢ä½“: äºŒé‡è»¸å›è»¢ï¼ˆè‘›è—¤è¡¨ç¾ï¼‰
                        this.core.rotation.x += 0.008;
                        this.core.rotation.y += 0.012;
                        this.core.rotation.z = Math.sin(time * 0.001) * 0.1;
                        break;
                        
                    case 'IE': case 'Ia':
                        // æ­£åäºŒé¢ä½“: èª¿å’Œçš„ãªå®‰å®šå›è»¢
                        this.core.rotation.x += 0.005;
                        this.core.rotation.y += 0.008;
                        this.core.rotation.z += 0.003;
                        break;
                        
                    case 'Ib': case 'Ic':
                        // æ­£äºŒåé¢ä½“: è¤‡é›‘ã§ç¾ã—ã„çµ±åˆå›è»¢
                        this.core.rotation.x += 0.004;
                        this.core.rotation.y += 0.006;
                        this.core.rotation.z += 0.002;
                        // å¾®ç´°ãªå‘¨æœŸçš„å¤‰å‹•
                        const fine = Math.sin(time * 0.001) * 0.05;
                        this.core.rotation.x += fine;
                        this.core.rotation.y += fine * 0.8;
                        this.core.rotation.z += fine * 0.6;
                        break;
                }
                
                // æ®µéšå…±é€š: ç™ºå…‰åŠ¹æœã®å‘¼å¸
                if (this.coreLight) {
                    const baseIntensity = this.baseCoreIntensity;
                    const breathe = Math.sin(time * 0.002) * 0.2 + 1;
                    this.coreLight.intensity = baseIntensity * breathe;
                }
            }
            
            animateLightVeils(time) {
                // å…‰ã®ãƒ™ãƒ¼ãƒ«ã®å‘¼å¸ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ - ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—ã®æˆé•·ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’è¡¨ç¾
                this.lightVeils.forEach((veil, index) => {
                    const userData = veil.userData;
                    const now = Date.now();
                    
                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆå‡¦ç†
                    if (userData.fadingOut) {
                        const elapsed = now - userData.fadeOutStartTime;
                        const progress = Math.min(elapsed / userData.fadeOutDuration, 1);
                        
                        // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ï¼ˆease-inï¼‰ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
                        const easedProgress = Math.pow(progress, 2);
                        
                        // MeshBasicMaterialç”¨ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
                        veil.material.opacity = userData.fadeOutStartOpacity * (1 - easedProgress);
                        const colorFade = 1.0 * (1 - easedProgress);
                        veil.material.color.setRGB(colorFade, colorFade * 0.98, colorFade * 0.95); // æš–ã‹ã¿ã‚’ä¿ã¤
                        
                        // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆå®Œäº†ãƒã‚§ãƒƒã‚¯
                        if (progress >= 1) {
                            veil.visible = false;
                            veil.userData.visible = false;
                            veil.userData.fadingOut = false;
                        }
                        return; // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆä¸­ã¯ä»–ã®å‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—
                    }
                    
                    if (!veil.visible || !veil.userData.visible) return;
                    
                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®å‡¦ç†
                    if (userData.fadingIn) {
                        const elapsed = now - userData.fadeStartTime;
                        const progress = Math.min(elapsed / userData.fadeDuration, 1);
                        
                        // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ï¼ˆease-outï¼‰ã§ã‚ˆã‚Šè‡ªç„¶ãªãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
                        const easedProgress = 1 - Math.pow(1 - progress, 3);
                        
                        // ç›®æ¨™å€¤ã®è¨ˆç®— - ã‚ˆã‚Šé€æ˜æ„Ÿã®ã‚ã‚‹è¨­å®š
                        const targetOpacity = 0.005 + userData.stageIndex * 0.002; // æ¥µã‚ã¦é€æ˜ã«è¨­å®š
                        const targetEmissive = 0.15 + userData.stageIndex * 0.03;
                        
                        // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ç”¨ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
                        if (veil.material.uniforms) {
                            veil.material.uniforms.opacity.value = targetOpacity * easedProgress;
                            veil.material.uniforms.emissiveIntensity.value = targetEmissive * easedProgress;
                            veil.material.uniforms.time.value = time; // æ™‚é–“æ›´æ–°
                        } else {
                            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šé€šå¸¸ã®ãƒãƒ†ãƒªã‚¢ãƒ«
                            veil.material.opacity = targetOpacity * easedProgress;
                            if (veil.material.emissiveIntensity !== undefined) {
                                veil.material.emissiveIntensity = targetEmissive * easedProgress;
                            }
                        }
                        
                        // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³å®Œäº†ãƒã‚§ãƒƒã‚¯
                        if (progress >= 1) {
                            userData.fadingIn = false;
                        }
                        
                        // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ä¸­ã¯ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ§ãˆã‚ã«
                        const breatheIntensity = easedProgress * 0.08; // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é€²è¡Œã«å¿œã˜ã¦å¼·åŒ–
                        const breathe = Math.sin(time * userData.breatheSpeed + userData.breathePhase) * breatheIntensity + 1;
                        veil.scale.setScalar(breathe);
                        
                    } else {
                        // é€šå¸¸ã®å‘¼å¸ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³å®Œäº†å¾Œï¼‰
                        const breathe = Math.sin(time * userData.breatheSpeed + userData.breathePhase) * 0.08 + 1;
                        veil.scale.setScalar(breathe);
                        
                        // ã‚³ã‚¢ã¨ã®åŒæœŸåŠ¹æœï¼ˆMeshBasicMaterialç”¨ï¼‰
                        const coreSync = Math.sin(time * 0.5) * 0.02 + 1; // ã‚³ã‚¢ã¨ã®åŒæœŸãƒ‘ãƒ«ã‚¹
                        const opacityVariation = Math.sin(time * userData.breatheSpeed * 0.7 + userData.breathePhase) * 0.03;
                        
                        // åŸºæº–å€¤ã«ã‚³ã‚¢åŒæœŸã¨å‘¼å¸ã‚’é©ç”¨
                        const materialData = veil.material.userData;
                        const baseOpacity = materialData.baseOpacity;
                        
                        // è‡ªç„¶ãªå…‰ã®å¤‰å‹• - ã‚³ã‚¢ã‹ã‚‰ã®æ”¾å°„å…‰ã¨ã—ã¦
                        veil.material.opacity = Math.max(0.002, (baseOpacity + opacityVariation) * breathe * coreSync);
                        
                        // å…‰ã®è‰²ã®å¼·åº¦ã‚‚å¤‰å‹•ã•ã›ã¦å…‰ã‚‰ã—ã•ã‚’æ¼”å‡º
                        const colorIntensity = 0.85 + (materialData.emissiveStrength * 0.15 * breathe * coreSync);
                        veil.material.color.setRGB(colorIntensity, colorIntensity * 0.98, colorIntensity * 0.95); // æš–ã‹ã¿ã®ã‚ã‚‹è‰²èª¿
                    }
                });
            }
            
            // I-E ã‚¹ãƒ†ãƒ¼ã‚¸: ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
            updateIEEmergence() {
                const currentTime = Date.now();
                let allEmerged = true;
                
                this.emergingParticles.forEach(emergenceData => {
                    if (emergenceData.hasEmerged) return;
                    
                    // ã¾ã å‡ºç¾æ™‚åˆ»ã«é”ã—ã¦ã„ãªã„
                    if (currentTime < emergenceData.emergenceTime) {
                        allEmerged = false;
                        return;
                    }
                    
                    const particle = this.particles[emergenceData.particleIndex];
                    if (!particle || !particle.userData) {
                        emergenceData.hasEmerged = true;
                        return;
                    }
                    
                    // å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
                    if (!emergenceData.hasEmerged) {
                        const elapsedTime = currentTime - emergenceData.emergenceTime;
                        const emergenceDuration = 1200; // å„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å‡ºç¾æœŸé–“ã‚’1.2ç§’ã«å»¶é•·
                        emergenceData.emergenceProgress = Math.min(elapsedTime / emergenceDuration, 1);
                        
                        // ã‚ˆã‚Šè‡ªç„¶ãªã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ï¼ˆease-out cubicï¼‰
                        const easedProgress = 1 - Math.pow(1 - emergenceData.emergenceProgress, 2.5);
                        
                        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è¡¨ç¤º
                        particle.visible = true;
                        
                        // ä½ç½®: ã‚ˆã‚Šæ»‘ã‚‰ã‹ãªæ”¾å°„çŠ¶ç§»å‹•
                        const startPos = particle.userData.emergenceStartPosition;
                        const targetPos = particle.userData.emergenceTargetPosition;
                        
                        // æ”¾å°„æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
                        const direction = targetPos.clone().normalize();
                        const maxDistance = targetPos.length();
                        
                        // åŠ é€Ÿåº¦çš„ãªç§»å‹•ï¼ˆæœ€åˆã¯ã‚†ã£ãã‚Šã€å¾Œã§åŠ é€Ÿï¼‰
                        const currentDistance = maxDistance * easedProgress;
                        particle.position.copy(direction.multiplyScalar(currentDistance));
                        
                        // é€æ˜åº¦: ã‚ˆã‚Šæ»‘ã‚‰ã‹ãªãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
                        const opacityProgress = Math.min(emergenceData.emergenceProgress * 1.5, 1);
                        particle.material.opacity = 0.9 * opacityProgress;
                        
                        // ã‚¹ã‚±ãƒ¼ãƒ«: ã‚ˆã‚Šæ»‘ã‚‰ã‹ãªã‚µã‚¤ã‚ºå¤‰åŒ–
                        const scaleProgress = Math.min(emergenceData.emergenceProgress * 1.2, 1);
                        const scale = 0.2 + (0.8 * scaleProgress);
                        particle.scale.setScalar(scale);
                        
                        // è»½å¾®ãªå›è»¢åŠ¹æœï¼ˆç”Ÿå‘½æ„Ÿã‚’è¡¨ç¾ï¼‰
                        particle.rotation.z = emergenceData.emergenceProgress * Math.PI * 0.5;
                        
                        // å‡ºç¾å®Œäº†ãƒã‚§ãƒƒã‚¯
                        if (emergenceData.emergenceProgress >= 1) {
                            emergenceData.hasEmerged = true;
                            
                            // ãƒ‘ãƒ«ã‚¹å‹•ä½œã®åˆæœŸçŠ¶æ…‹ã«åˆã‚ã›ã¦ä½ç½®ã‚’è¨­å®š
                            const basePos = particle.userData.originalPosition;
                            const distance = basePos.length();
                            
                            // ç¾åœ¨ã®ä½ç½®ã‹ã‚‰ãƒ‘ãƒ«ã‚¹å€¤ã‚’é€†ç®—ã—ã¦æ™‚é–“ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨­å®š
                            const currentDistance = particle.position.length();
                            const currentPulse = currentDistance / distance;
                            
                            // ç¾åœ¨ã®ãƒ‘ãƒ«ã‚¹å€¤ã«å¯¾å¿œã™ã‚‹æ™‚é–“ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—
                            let targetPulse = Math.max(0.85, Math.min(1.0, currentPulse)); // 0.85-1.0ã®ç¯„å›²ã«åˆ¶é™
                            let normalizedPulse = (targetPulse - 0.925) / 0.075; // -1ã‹ã‚‰1ã®ç¯„å›²ã«æ­£è¦åŒ–
                            normalizedPulse = Math.max(-1, Math.min(1, normalizedPulse)); // ç¯„å›²ã‚’ç¢ºå®Ÿã«åˆ¶é™
                            
                            const currentPhase = Math.asin(normalizedPulse);
                            particle.userData.pulseTimeOffset = currentPhase - (Date.now() * 0.001) * 1.2;
                            
                            // ãƒ‘ãƒ«ã‚¹å‹•ä½œã¨åŒã˜è¨ˆç®—å¼ã‚’ä½¿ç”¨ã—ã¦ä½ç½®ã‚’å¾®èª¿æ•´
                            const initialPulse = Math.sin((Date.now() * 0.001) * 1.2 + particle.userData.pulseTimeOffset) * 0.075 + 0.925;
                            const direction = basePos.clone().normalize();
                            const pulsedDistance = distance * initialPulse;
                            
                            particle.position.copy(direction);
                            particle.position.multiplyScalar(pulsedDistance);
                            
                            // é€šå¸¸ã®å‹•ä½œã«ç§»è¡Œã™ã‚‹ãŸã‚ã€åˆæœŸè¨­å®šã‚’ãƒªã‚»ãƒƒãƒˆ
                            particle.material.opacity = 0.9;
                            particle.scale.setScalar(1);
                            particle.rotation.z = 0;
                        } else {
                            allEmerged = false;
                        }
                    }
                });
                
                // å…¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å‡ºç¾å®Œäº†
                if (allEmerged) {
                    this.isEmergingIE = false;
                    console.log('I-E Emergence animation completed - transitioning to pulse behavior');
                    
                    // å…¨ã¦ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç¢ºå®Ÿã«pulseã«è¨­å®š
                    this.particles.children.forEach(particle => {
                        particle.userData.pattern = 'pulse';
                        particle.userData.cohesion = 0.2;
                        particle.userData.behavior = 'contemplative';
                    });
                    
                    console.log('I-E particles reset to pulse pattern - total particles:', this.particles.children.length);
                    
                    // é€šå¸¸ã®pulseãƒ‘ã‚¿ãƒ¼ãƒ³ã«ç§»è¡Œã™ã‚‹ãŸã‚ã€å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ä¸€æ™‚çš„åŠ¹æœã®ã¿ãƒªã‚»ãƒƒãƒˆ
                    this.particles.forEach(particle => {
                        if (particle.userData) {
                            // originalPositionã¯æ—¢ã«é©åˆ‡ã«è¨­å®šæ¸ˆã¿ãªã®ã§æ›´æ–°ã—ãªã„
                            
                            // å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ä¸€æ™‚çš„ãªåŠ¹æœã‚’ãƒªã‚»ãƒƒãƒˆ
                            particle.material.opacity = 0.9;
                            particle.scale.setScalar(1);
                            particle.rotation.z = 0;
                            particle.visible = true;
                            
                            // I-Eã‚¹ãƒ†ãƒ¼ã‚¸ã®è¨­å®šã‚’ç¢ºå®Ÿã«é©ç”¨
                            const stageData = this.getStageData('I-E');
                            particle.material.color.setHex(stageData.color);
                            particle.userData.pattern = 'pulse'; // æ˜ç¤ºçš„ã«pulseãƒ‘ã‚¿ãƒ¼ãƒ³ã«è¨­å®š
                            particle.userData.behavior = 'listening';
                            particle.userData.cohesion = 0.1; // ä½ã„å‡é›†åŠ›
                        }
                    });
                }
            }
            
            updateParticleBehavior(particle, index, time) {
                try {
                    const userData = particle.userData;
                    const stageData = this.getStageData(this.currentStage);
                    
                    // ã‚µã‚¤ã‚ºã«åŸºã¥ãå‹•çš„åŠ¹æœã®é©ç”¨
                    if (userData.originalSize && userData.sizeRatio) {
                        // å¤§ããªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã¯å°‘ã—ã‚†ã£ãã‚Šå‹•ãï¼ˆé‡ã„çµŒé¨“ã®ãƒ¡ã‚¿ãƒ•ã‚¡ãƒ¼ï¼‰
                        const sizeSpeedModifier = 1.0 / (1.0 + (userData.sizeRatio - 1.0) * 0.3);
                        
                        // å°ã•ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã¯å°‘ã—æ´»ç™ºã«å‹•ãï¼ˆæ–°ã—ã„çµŒé¨“ã®ãƒ¡ã‚¿ãƒ•ã‚¡ãƒ¼ï¼‰
                        const sizePulseModifier = userData.sizeRatio < 1.0 ? 
                            1.0 + (1.0 - userData.sizeRatio) * 0.5 : 1.0;
                        
                        // å¾®ç´°ãªè„ˆå‹•åŠ¹æœï¼ˆçµŒé¨“ã® "ç”Ÿãã¦ã„ã‚‹" æ„Ÿè¦šã‚’è¡¨ç¾ï¼‰
                        const pulse = 1.0 + Math.sin(time * 2.0 + userData.phaseOffset) * 0.05 * sizePulseModifier;
                        particle.scale.setScalar(pulse);
                        
                        // ã‚µã‚¤ã‚ºæƒ…å ±ã‚’userDataã«ä¿å­˜ï¼ˆä»–ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§ä½¿ç”¨ï¼‰
                        userData.currentSpeedModifier = sizeSpeedModifier;
                        userData.currentPulseModifier = sizePulseModifier;
                    }
                    
                    switch (userData.pattern) {
                        case 'random':
                            this.animateRandomBehavior(particle, index, time);
                            break;
                        case 'opposing':
                            this.animateOpposingBehavior(particle, index, time);
                            break;
                        case 'hesitant':
                            this.animateHesitantBehavior(particle, index, time);
                            break;
                        case 'spiral_out':
                            this.animateSpiralOutBehavior(particle, index, time);
                            break;
                        case 'dynamic_emergence':
                            this.animateDynamicEmergenceBehavior(particle, index, time);
                            break;
                        case 'convergent':
                            this.animateConvergentBehavior(particle, index, time);
                            break;
                        case 'pulse':
                            this.animatePulseBehavior(particle, index, time);
                            break;
                        case 'growth':
                            this.animateGrowthBehavior(particle, index, time);
                            break;
                        case 'stable_orbit':
                            this.animateStableOrbitBehavior(particle, index, time);
                            break;
                        case 'structured':
                            this.animateStructuredBehavior(particle, index, time);
                            break;
                        case 'harmonious':
                            this.animateHarmoniousBehavior(particle, index, time);
                            break;
                        case 'wave_rotation':
                            this.animateHarmoniousBehavior(particle, index, time);
                            break;
                        default:
                            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: åŸºæœ¬çš„ãªå‹•ã
                            this.animateRandomBehavior(particle, index, time);
                            break;
                    }
                } catch (error) {
                    console.error('Particle animation error:', error, 'Pattern:', userData?.pattern);
                    // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã¯ãƒ©ãƒ³ãƒ€ãƒ å‹•ä½œã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                    this.animateRandomBehavior(particle, index, time);
                }
            }
            
            // æ®µéšåˆ¥ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°ç¾¤
            animateRandomBehavior(particle, index, time) {
                // Ea: æ··æ²Œã¨ã—ãŸä¸è¦å‰‡ãªå‹•ã
                const userData = particle.userData;
                const speedModifier = userData.currentSpeedModifier || 1.0;
                const baseSpeed = 0.02 * speedModifier; // ã‚µã‚¤ã‚ºã«å¿œã˜ãŸé€Ÿåº¦èª¿æ•´
                
                const noise = Math.sin(time * 2 + index) * 0.5;
                particle.position.x += (Math.random() - 0.5) * baseSpeed;
                particle.position.y += (Math.random() - 0.5) * baseSpeed;
                particle.position.z += (Math.random() - 0.5) * baseSpeed;
                
                // å¢ƒç•Œå†…ã«ä¿æŒ
                const distance = particle.position.length();
                if (distance > 6) {
                    particle.position.multiplyScalar(0.9);
                }
            }
            
            animateOpposingBehavior(particle, index, time) {
                // Eb: å¯¾ç«‹ã™ã‚‹åŠ›ã«ã‚ˆã‚‹ç·Šå¼µçŠ¶æ…‹
                const userData = particle.userData;
                const speedModifier = userData.currentSpeedModifier || 1.0;
                const baseIntensity = 0.03 * speedModifier; // ã‚µã‚¤ã‚ºã«å¿œã˜ãŸå‹•ãã®å¼·åº¦èª¿æ•´
                
                const conflictDirection = index % 2 === 0 ? 1 : -1;
                const intensity = Math.sin(time * 3 + index) * conflictDirection;
                
                particle.position.x += Math.cos(time + index) * intensity * baseIntensity;
                particle.position.y += Math.sin(time * 1.5 + index) * intensity * baseIntensity;
                particle.rotation.z += intensity * 0.1 * speedModifier;
            }
            
            animateHesitantBehavior(particle, index, time) {
                // Ec: ãŸã‚ã‚‰ã„ã¨æ°—ã¥ãã®å‹•ã
                const hesitation = Math.sin(time * 0.5 + index) * 0.5 + 0.5;
                const awareness = Math.cos(time * 0.3 + index * 0.1);
                
                particle.position.y += awareness * hesitation * 0.01;
                particle.material.opacity = 0.5 + hesitation * 0.3;
            }
            
            animateSpiralOutBehavior(particle, index, time) {
                // E(I): å¤–å‘ãã‚¹ãƒ‘ã‚¤ãƒ©ãƒ« - ç–‘å•ãŒå¤–ã«å‘ã‹ã†
                const userData = particle.userData;
                const spiralRadius = userData.baseRadius + time * 0.1;
                const spiralAngle = userData.baseTheta + time * userData.speed;
                
                particle.position.x = spiralRadius * Math.cos(spiralAngle);
                particle.position.z = spiralRadius * Math.sin(spiralAngle);
                particle.position.y += Math.sin(time + index) * 0.01;
            }
            
            animateConvergentBehavior(particle, index, time) {
                // E-I: åæŸ - å†…ãªã‚‹å£°ã®æ§‹ç¯‰
                const userData = particle.userData;
                
                // I-Eã‚¹ãƒ†ãƒ¼ã‚¸ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãŒã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«æ¥ã¦ã„ãªã„ã‹ç¢ºèª
                if (this.currentStage === 'I-E' && index === 0 && Math.random() < 0.05) {
                    console.warn('I-E stage particle in convergent behavior - pattern:', userData.pattern, 'should be pulse');
                }
                
                const centerPull = userData.cohesion * 0.03; // å°‘ã—å¼·åŒ–
                const direction = new THREE.Vector3().subVectors(new THREE.Vector3(0, 0, 0), particle.position).normalize();
                
                // ã‚ˆã‚Šå¼·ã„ä¸­å¿ƒã¸ã®å¸å¼•åŠ›
                particle.position.add(direction.multiplyScalar(centerPull));
                
                // å‚ç›´æ–¹å‘ã®å¾®ç´°ãªå‹•ãã‚’æŠ‘åˆ¶ï¼ˆã‚ˆã‚ŠåæŸã«é›†ä¸­ï¼‰
                particle.position.y += Math.sin(time * 2 + index) * 0.003;
                
                // ã‚³ã‚¢è¿‘ãã§ã¯é€æ˜åº¦ã‚’ä¸‹ã’ã‚‹ï¼ˆå¸ã„è¾¼ã¾ã‚Œã‚‹æ„Ÿè¦šï¼‰
                const distanceToCore = particle.position.length();
                if (distanceToCore < 0.5) {
                    particle.material.opacity = Math.max(0.3, 0.9 * (distanceToCore / 0.5));
                }
            }
            
            animateDynamicEmergenceBehavior(particle, index, time) {
                // E(I): å‹•çš„å‡ºç¾ãƒ»æ¶ˆå¤± - ç–‘å•ã«ã‚ˆã‚‹çµŒé¨“ã®å†è©•ä¾¡
                const userData = particle.userData;
                
                // ç–‘å•ãƒ•ã‚§ãƒ¼ã‚ºã®ç®¡ç†
                if (!userData.questioningPhase) {
                    // transitionToStageã§æ—¢ã«åˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿åˆæœŸè¨­å®š
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 1 + Math.random() * 2.5;
                    const height = (Math.random() - 0.5) * 3;
                    
                    const fixedPosition = {
                        x: radius * Math.cos(angle),
                        y: height,
                        z: radius * Math.sin(angle)
                    };
                    
                    particle.position.set(fixedPosition.x, fixedPosition.y, fixedPosition.z);
                    
                    userData.questioningPhase = {
                        spawnTime: time,
                        lifespan: 1.5 + Math.random() * 4, // 1.5-5.5ç§’ã®ãƒ©ã‚¤ãƒ•ã‚¹ãƒ‘ãƒ³
                        isPersistent: Math.random() < 0.25, // 25%ã®ç¢ºç‡ã§æ°¸ç¶šåŒ–
                        fadeInDuration: 0.8,
                        fadeOutDuration: 1.2,
                        hasBeenPersistent: false,
                        fixedPosition: fixedPosition
                    };
                }
                
                const phase = userData.questioningPhase;
                const age = time - phase.spawnTime;
                
                // æ°¸ç¶šåŒ–åˆ¤å®šï¼ˆãƒ©ã‚¤ãƒ•ã‚¹ãƒ‘ãƒ³ã®70%çµŒéæ™‚ç‚¹ã§åˆ¤å®šï¼‰
                if (!phase.hasBeenPersistent && age > phase.lifespan * 0.7 && phase.isPersistent) {
                    phase.hasBeenPersistent = true;
                    this.persistentParticleIndices.add(index);
                    phase.lifespan = Infinity; // æ°¸ç¶šåŒ–
                }
                
                // ãƒ•ã‚§ãƒ¼ãƒ‰å‡¦ç†
                let alpha = 1;
                if (age < phase.fadeInDuration) {
                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
                    alpha = age / phase.fadeInDuration;
                } else if (age > phase.lifespan - phase.fadeOutDuration && phase.lifespan !== Infinity) {
                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆï¼ˆæ°¸ç¶šãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ä»¥å¤–ï¼‰
                    alpha = Math.max(0, (phase.lifespan - age) / phase.fadeOutDuration);
                }
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å†ç”Ÿæˆåˆ¤å®š
                if (age > phase.lifespan && phase.lifespan !== Infinity) {
                    // æ–°ã—ã„ä½ç½®ã§å†å‡ºç¾
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 1 + Math.random() * 2.5;
                    const height = (Math.random() - 0.5) * 3;
                    
                    const newFixedPosition = {
                        x: radius * Math.cos(angle),
                        y: height,
                        z: radius * Math.sin(angle)
                    };
                    
                    particle.position.set(newFixedPosition.x, newFixedPosition.y, newFixedPosition.z);
                    
                    // æ–°ã—ã„ãƒ•ã‚§ãƒ¼ã‚ºã‚’é–‹å§‹
                    userData.questioningPhase = {
                        spawnTime: time,
                        lifespan: 1.5 + Math.random() * 4,
                        isPersistent: Math.random() < 0.25,
                        fadeInDuration: 0.8,
                        fadeOutDuration: 1.2,
                        hasBeenPersistent: false,
                        fixedPosition: newFixedPosition
                    };
                    alpha = 0;
                } else {
                    // å›ºå®šä½ç½®ã«ç•™ã¾ã‚‹ï¼ˆã‚ãšã‹ãªæµ®éŠæ„Ÿã®ã¿ï¼‰
                    const basePos = phase.fixedPosition;
                    const gentleFloat = Math.sin(time * 0.5 + index * 0.3) * 0.05; // éå¸¸ã«å¾®ç´°ãªæµ®éŠ
                    
                    particle.position.x = basePos.x;
                    particle.position.y = basePos.y + gentleFloat;
                    particle.position.z = basePos.z;
                }
                
                // é€æ˜åº¦ã¨ã‚¹ã‚±ãƒ¼ãƒ«ã®é©ç”¨
                particle.material.opacity = alpha * 0.95;
                const scale = 0.7 + alpha * 0.5;
                
                // ã‚¹ã‚±ãƒ¼ãƒ«è¨­å®šã®å®‰å…¨ãªå‡¦ç†
                if (particle.scale) {
                    particle.scale.setScalar(scale);
                } else {
                    particle.scale = new THREE.Vector3(scale, scale, scale);
                }
                
                // æ°¸ç¶šãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã¯å°‘ã—æ˜ã‚‹ãã€ã‚ˆã‚Šå¼·ã„ç™ºå…‰
                if (this.persistentParticleIndices.has(index)) {
                    if (particle.material.emissive) {
                        particle.material.emissive.setHex(0x666600); // ã‚ˆã‚Šå¼·ã„é»„è‰²ã®ç™ºå…‰
                    }
                } else {
                    if (particle.material.emissive) {
                        particle.material.emissive.setHex(0x111111);
                    }
                }
            }
            
            animatePulseBehavior(particle, index, time) {
                // I-E: è„ˆå‹• - å†…ãªã‚‹å£°ã‚’è´ãï¼ˆã¤ã‹ãšé›¢ã‚Œãšã®çŠ¶æ…‹ï¼‰
                
                // å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã¯é€šå¸¸ã®pulseå‹•ä½œã‚’ã‚¹ã‚­ãƒƒãƒ—
                if (this.isEmergingIE) {
                    return;
                }
                
                const basePos = particle.userData.originalPosition;
                if (!basePos) return; // originalPositionãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                
                // ãƒ‡ãƒãƒƒã‚°ï¼šãƒ‘ã‚¿ãƒ¼ãƒ³ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªï¼ˆæœ€åˆã®æ•°å›ã®ã¿ï¼‰
                if (index === 0 && Math.random() < 0.01) {
                    console.log('I-E Pulse behavior - pattern:', particle.userData.pattern, 'cohesion:', particle.userData.cohesion);
                }
                
                const distance = basePos.length();
                
                // æ™‚é–“ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’ä½¿ç”¨ã—ãŸæ»‘ã‚‰ã‹ãªãƒ‘ãƒ«ã‚¹ï¼ˆè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯indexåŸºæº–ï¼‰
                const timeOffset = particle.userData.pulseTimeOffset || (index * 0.15);
                
                // ã‚ˆã‚ŠçŸ­ã„è·é›¢ã§ã®è„ˆå‹•ï¼ˆ0.85-1.0ã®ç¯„å›²ã«èª¿æ•´ï¼‰
                const pulse = Math.sin(time * 1.2 + timeOffset) * 0.075 + 0.925;
                
                // å€‹åˆ¥ã®æ€æ¡ˆãƒ—ãƒ­ã‚»ã‚¹ã‚’è¡¨ç¾ã™ã‚‹å¾®ç´°ãªæºã‚‰ã
                const contemplation = Math.sin(time * 2.3 + index * 0.3) * 0.03;
                const finalPulse = pulse + contemplation;
                
                // åŸºæº–ä½ç½®ã‹ã‚‰ã®è„ˆå‹•ï¼ˆã‚³ã‚¢ã«å‘ã‹ã‚ãšã€å…ƒã®ä½ç½®å‘¨è¾ºã§è„ˆå‹•ï¼‰
                const direction = basePos.clone().normalize();
                const pulsedDistance = distance * finalPulse;
                
                // ä½ç½®æ›´æ–°: å…ƒã®æ–¹å‘ã‚’ç¶­æŒã—ãªãŒã‚‰è·é›¢ã ã‘ã‚’è„ˆå‹•
                particle.position.copy(direction);
                particle.position.multiplyScalar(pulsedDistance);
                
                // è»½å¾®ãªå††è»Œé“é‹å‹•ã‚’è¿½åŠ ï¼ˆå†…ãªã‚‹å£°ã‚’ã€Œè´ãã€å‹•ãã‚’è¡¨ç¾ï¼‰
                const orbitAngle = time * 0.3 + index * 0.5;
                const orbitRadius = 0.1;
                const orbitX = Math.cos(orbitAngle) * orbitRadius;
                const orbitZ = Math.sin(orbitAngle) * orbitRadius;
                
                particle.position.x += orbitX;
                particle.position.z += orbitZ;
                
                // é€æ˜åº¦ã‚‚å¾®ç´°ã«å¤‰å‹•ï¼ˆæ€è€ƒã®æ·±ã•ã‚’è¡¨ç¾ï¼‰
                particle.material.opacity = 0.7 + finalPulse * 0.2;
            }
            
            animateGrowthBehavior(particle, index, time) {
                // I(E): æˆé•·ãƒ‘ã‚¿ãƒ¼ãƒ³ - å†…ãªã‚‹å£°ã‚’è‚²ã‚€
                const growth = Math.min(1, particle.userData.age * 0.1);
                const organic = Math.sin(time + index * 0.5) * growth;
                
                particle.position.y += organic * 0.015;
                particle.scale.setScalar(0.8 + growth * 0.4);
            }
            
            animateStableOrbitBehavior(particle, index, time) {
                // Ia: å®‰å®šè»Œé“ - ä¿¡é ¼ã«åŸºã¥ãå®‰å®šã—ãŸå‹•ã
                const userData = particle.userData;
                const orbitRadius = userData.baseRadius;
                const orbitSpeed = userData.speed * 0.5;
                const angle = time * orbitSpeed + userData.phaseOffset;
                
                particle.position.x = orbitRadius * Math.cos(angle);
                particle.position.z = orbitRadius * Math.sin(angle);
                particle.position.y = userData.originalPosition.y + Math.sin(angle * 2) * 0.2;
            }
            
            animateStructuredBehavior(particle, index, time) {
                // Ib: æ§‹é€ åŒ– - åŸºç›¤å½¢æˆï¼ˆã‚ˆã‚Šã‚ªãƒ¼ã‚¬ãƒ‹ãƒƒã‚¯ãªé…ç½®ï¼‰
                const userData = particle.userData;
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å›ºæœ‰ã®ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ ã‚’åˆæœŸåŒ–ï¼ˆä¸€åº¦ã ã‘ï¼‰
                if (!userData.structuredParams) {
                    userData.structuredParams = {
                        layerGroup: Math.floor(index / 5) + Math.floor(index / 8), // ã‚ˆã‚Šå¤šæ§˜ãªå±¤åˆ†å¸ƒ
                        baseAngleOffset: Math.random() * Math.PI * 2, // å„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å›ºæœ‰ã®è§’åº¦ã‚ªãƒ•ã‚»ãƒƒãƒˆ
                        radiusVariation: 0.7 + Math.random() * 0.6, // åŠå¾„ã®ãƒ©ãƒ³ãƒ€ãƒ å¤‰å‹•
                        heightOffset: (Math.random() - 0.5) * 0.4, // é«˜ã•ã®ãƒ©ãƒ³ãƒ€ãƒ ã‚ªãƒ•ã‚»ãƒƒãƒˆ
                        rotationSpeed: 0.8 + Math.random() * 0.4, // å€‹åˆ¥ã®å›è»¢é€Ÿåº¦
                        phaseShift: Math.random() * Math.PI * 2, // æ³¢ã®ä½ç›¸ã‚·ãƒ•ãƒˆ
                        verticalCenter: (Math.random() - 0.5) * 0.8 // æ°´å¹³é¢ã‚’ä¸­å¿ƒã¨ã—ãŸä¸Šä¸‹åˆ†æ•£
                    };
                }
                
                const params = userData.structuredParams;
                const layer = Math.min(params.layerGroup, 4); // æœ€å¤§5å±¤ã«åˆ¶é™
                const layerRadius = (1 + layer * 0.7) * params.radiusVariation;
                
                // ã‚ˆã‚Šã‚ªãƒ¼ã‚¬ãƒ‹ãƒƒã‚¯ãªè§’åº¦è¨ˆç®—
                const baseAngle = params.baseAngleOffset + time * 0.2 * params.rotationSpeed;
                const angleNoise = Math.sin(time * 0.5 + params.phaseShift) * 0.3; // è§’åº¦ã®ã‚†ã‚‰ã
                const finalAngle = baseAngle + angleNoise;
                
                // åŠå¾„ã«ã‚‚å¾®ç´°ãªå¤‰å‹•ã‚’è¿½åŠ 
                const radiusNoise = Math.sin(time * 0.8 + index * 0.1) * 0.2;
                const finalRadius = layerRadius + radiusNoise;
                
                particle.position.x = finalRadius * Math.cos(finalAngle);
                particle.position.z = finalRadius * Math.sin(finalAngle);
                // æ°´å¹³é¢ï¼ˆy=0ï¼‰ã‚’ä¸­å¿ƒã«ä¸Šä¸‹å‡ç­‰ã«åˆ†æ•£
                particle.position.y = params.verticalCenter + params.heightOffset + Math.sin(time + params.phaseShift) * 0.15;
            }
            
            animateHarmoniousBehavior(particle, index, time) {
                // Ic: æ³¢å‹•å›è»¢ - Ibã®ã‚ªãƒ¼ã‚¬ãƒ‹ãƒƒã‚¯æ§‹é€ ã‚’ãƒ™ãƒ¼ã‚¹ã«æ³¢ã®ã†ã­ã‚Šã¨å›è»¢ã‚’è¿½åŠ 
                // åºƒç¯„å›²ãªçµŒé¨“ã®çµã³ã¤ãã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã€ã‚ˆã‚Šåºƒã„ç©ºé–“åˆ†æ•£ã‚’å®Ÿç¾
                const userData = particle.userData;
                
                // Ibã®ã‚ªãƒ¼ã‚¬ãƒ‹ãƒƒã‚¯æ§‹é€ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å–å¾—/åˆæœŸåŒ–
                if (!userData.structuredParams) {
                    userData.structuredParams = {
                        layerGroup: Math.floor(index / 5) + Math.floor(index / 8),
                        baseAngleOffset: Math.random() * Math.PI * 2,
                        radiusVariation: 0.7 + Math.random() * 0.6,
                        heightOffset: (Math.random() - 0.5) * 1.2, // é«˜ã•ã®åˆ†æ•£ã‚’3å€ã«æ‹¡å¤§
                        rotationSpeed: 0.8 + Math.random() * 0.4,
                        phaseShift: Math.random() * Math.PI * 2,
                        verticalCenter: (Math.random() - 0.5) * 1.0 // æ°´å¹³é¢ã‚’ä¸­å¿ƒã¨ã—ãŸä¸Šä¸‹åˆ†æ•£
                    };
                }
                
                const params = userData.structuredParams;
                const layer = Math.min(params.layerGroup, 4);
                const baseRadius = (1 + layer * 0.7) * params.radiusVariation;
                const baseAngle = params.baseAngleOffset + time * 0.2 * params.rotationSpeed;
                
                // æ³¢ã®ã†ã­ã‚Šæˆåˆ†ã‚’è¿½åŠ 
                const waveFrequency = 0.5;
                const waveAmplitude = 0.4;
                const wavePhase = time * 2 + params.phaseShift;
                const wave = Math.sin(wavePhase * waveFrequency) * waveAmplitude;
                
                // å‹•çš„ãªå›è»¢åŠå¾„ï¼ˆæ³¢ã®å½±éŸ¿ã‚’å—ã‘ã‚‹ï¼‰
                const dynamicRadius = baseRadius + wave;
                
                // åŸºæœ¬å›è»¢ã«å‚ç›´ãªæ³¢å‹•ã‚’è¿½åŠ ï¼ˆé«˜ã•æ–¹å‘ã®å‹•ãã‚’æ‹¡å¤§ï¼‰
                const verticalWave = Math.sin(time * 1.5 + params.phaseShift) * 0.5; // å‚ç›´æ³¢å‹•ã‚’æ‹¡å¤§
                const radialWave = Math.cos(time * 0.8 + index * 0.4) * 0.15;
                const angleNoise = Math.sin(time * 0.7 + params.phaseShift) * 0.2;
                
                particle.position.x = (dynamicRadius + radialWave) * Math.cos(baseAngle + angleNoise);
                particle.position.z = (dynamicRadius + radialWave) * Math.sin(baseAngle + angleNoise);
                // æ°´å¹³é¢ï¼ˆy=0ï¼‰ã‚’ä¸­å¿ƒã«ä¸Šä¸‹å‡ç­‰ã«åˆ†æ•£
                particle.position.y = params.verticalCenter + params.heightOffset + verticalWave + Math.sin(baseAngle * 3 + time) * 0.3;
                
                // ã‚ˆã‚Šæ˜ã‚‹ãæ´»ç™ºãªé€æ˜åº¦å¤‰åŒ–
                const brightness = 0.8 + Math.sin(time * 2 + index) * 0.2;
                particle.material.opacity = Math.max(0.6, brightness);
            }
            
            // EI stage: ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å¸åã¨ã‚³ã‚¢å…‰é‡å¢—åŠ 
            absorbParticleIntoCore(particle, index) {
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å‰Šé™¤
                this.scene.remove(particle);
                particle.geometry.dispose();
                particle.material.dispose();
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é…åˆ—ã‹ã‚‰å‰Šé™¤
                const particleIndex = this.particles.indexOf(particle);
                if (particleIndex > -1) {
                    this.particles.splice(particleIndex, 1);
                }
                
                // å¸åã‚«ã‚¦ãƒ³ãƒˆã‚’å¢—åŠ 
                this.absorptionCount++;
                
                // ã‚³ã‚¢å…‰é‡ã‚’å¢—åŠ ï¼ˆæ®µéšçš„ã«ä¸Šé™ã¾ã§ï¼‰
                const intensityIncrease = 0.05; // 1å›ã®å¸åã§ã®å¢—åŠ é‡
                this.currentCoreIntensity = Math.min(
                    this.maxCoreIntensity, 
                    this.currentCoreIntensity + intensityIncrease
                );
                
                // ã‚³ã‚¢ãƒ©ã‚¤ãƒˆã®å¼·åº¦ã‚’æ›´æ–°
                if (this.coreLight) {
                    this.coreLight.intensity = this.currentCoreIntensity;
                }
                
                // ã‚³ã‚¢è‡ªä½“ã®ç™ºå…‰ã‚‚å¼·åŒ–
                if (this.core && this.core.material) {
                    const emissiveIntensity = Math.min(0.8, 0.2 + (this.absorptionCount * 0.02));
                    this.core.material.emissive.setRGB(emissiveIntensity, emissiveIntensity, emissiveIntensity);
                }
                
                console.log(`ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å¸å: ${this.absorptionCount}å€‹, ã‚³ã‚¢å…‰é‡: ${this.currentCoreIntensity.toFixed(2)}`);
            }
            
            // ã‚³ã‚¢å…‰é‡ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆã‚¹ãƒ†ãƒ¼ã‚¸åˆ‡ã‚Šæ›¿ãˆæ™‚ãªã©ï¼‰
            resetCoreIntensity() {
                this.absorptionCount = 0;
                this.currentCoreIntensity = this.baseCoreIntensity;
                
                if (this.coreLight) {
                    this.coreLight.intensity = this.baseCoreIntensity;
                }
                
                if (this.core && this.core.material) {
                    this.core.material.emissive.setRGB(0.27, 0.27, 0.27); // 0x444444ç›¸å½“
                }
            }
            
            cleanup() {
                console.log('3Dãƒªã‚½ãƒ¼ã‚¹ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ä¸­...');
                
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                
                // Remove particles
                this.particles.forEach(particle => {
                    this.scene.remove(particle);
                    particle.geometry.dispose();
                    particle.material.dispose();
                });
                this.particles = [];
                
                // Clean up connection lines
                this.clearConnections();
                
                // Remove dimension rings
                this.dimensionRings.forEach(ring => {
                    this.scene.remove(ring);
                    ring.geometry.dispose();
                    ring.material.dispose();
                });
                this.dimensionRings = [];
                
                // Clean up renderer
                if (this.renderer) {
                    const sceneElement = document.getElementById('refined-3d-scene');
                    if (sceneElement && this.renderer.domElement.parentNode === sceneElement) {
                        sceneElement.removeChild(this.renderer.domElement);
                    }
                    this.renderer.dispose();
                    this.renderer = null;
                }
                
                // Clean up scene
                if (this.scene) {
                    while(this.scene.children.length > 0) {
                        const object = this.scene.children[0];
                        if (object.geometry) object.geometry.dispose();
                        if (object.material) object.material.dispose();
                        this.scene.remove(object);
                    }
                    this.scene = null;
                }
                
                this.isInitialized = false;
                console.log('3Dãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†');
            }
        }

        // Global instances
        let refinedVisualization = null;
        let journeyVisualization = null;

        // Enhanced toggleSection function with detailed debugging
        function toggleSection(sectionId) {
            console.log('toggleSection called with:', sectionId);
            const section = document.getElementById(sectionId);
            
            if (!section) {
                console.error('Section not found:', sectionId);
                alert('ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ' + sectionId);
                return;
            }
            
            console.log('Section element found:', section);
            section.classList.toggle('active');
            const isActive = section.classList.contains('active');
            console.log('Section', sectionId, 'is now', isActive ? 'active' : 'inactive');
            
            // Handle 3D initialization/cleanup for refined-phases section
            if (sectionId === 'refined-phases') {
                if (isActive) {
                    // Section opened - initialize 3D
                    console.log('ç²¾ç·»åŒ–ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒé–‹ã‹ã‚Œã¾ã—ãŸ - 3DåˆæœŸåŒ–é–‹å§‹');
                    try {
                        if (!refinedVisualization) {
                            console.log('Creating new RefinedSelfAuthorshipVisualization instance');
                            refinedVisualization = new RefinedSelfAuthorshipVisualization();
                        }
                        console.log('Initializing 3D visualization');
                        refinedVisualization.init('refined-3d-container');
                    } catch (error) {
                        console.error('3DåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
                        alert('3DåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ' + error.message);
                    }
                } else {
                    // Section closed - cleanup 3D
                    console.log('ç²¾ç·»åŒ–ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒé–‰ã˜ã‚‰ã‚Œã¾ã—ãŸ - 3Dã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–‹å§‹');
                    try {
                        if (refinedVisualization) {
                            refinedVisualization.cleanup();
                        }
                    } catch (error) {
                        console.error('3Dã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼:', error);
                    }
                }
            }
            
            // Handle Canvas 2D initialization/cleanup for detailed-journey section
            if (sectionId === 'detailed-journey') {
                if (isActive) {
                    // Section opened - initialize Canvas 2D
                    console.log('è©³ç´°ãªæ—…ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒé–‹ã‹ã‚Œã¾ã—ãŸ - Canvas2DåˆæœŸåŒ–é–‹å§‹');
                    try {
                        console.log('Calling initJourneyVisualization');
                        initJourneyVisualization();
                    } catch (error) {
                        console.error('Canvas2DåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
                        alert('Canvas2DåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ' + error.message);
                    }
                } else {
                    // Section closed - cleanup Canvas 2D
                    console.log('è©³ç´°ãªæ—…ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒé–‰ã˜ã‚‰ã‚Œã¾ã—ãŸ - Canvas2Dã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–‹å§‹');
                    try {
                        cleanupJourneyVisualization();
                    } catch (error) {
                        console.error('Canvas2Dã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼:', error);
                    }
                }
            }
        }

        // Make toggleSection globally available
        window.toggleSection = toggleSection;

        // Stage click handling for dynamic linking
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—3Dçµ±åˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
            
            // Add click handlers to stage headings in text for dynamic linking
            setTimeout(() => {
                const stageHeadings = document.querySelectorAll('.sub-phase h4');
                stageHeadings.forEach(heading => {
                    const text = heading.textContent;
                    const stageMatch = text.match(/^(Ea|Eb|Ec|E\(I\)|E-I|I-E|I\(E\)|Ia|Ib|Ic):/);
                    if (stageMatch) {
                        let stageId = stageMatch[1];
                        // Convert special cases
                        if (stageId === 'E(I)') stageId = 'EI';
                        if (stageId === 'I(E)') stageId = 'IE';
                        
                        heading.style.cursor = 'pointer';
                        heading.style.transition = 'all 0.3s';
                        
                        heading.addEventListener('click', () => {
                            if (refinedVisualization && refinedVisualization.isInitialized) {
                                refinedVisualization.switchToStage(stageId);
                                
                                // Scroll to 3D area
                                const container = document.getElementById('refined-3d-container');
                                if (container) {
                                    container.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            }
                        });
                    }
                });
            }, 1000);
        });

        // ===== Canvas 2D ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³çµ±åˆã‚³ãƒ¼ãƒ‰ =====
        
        class EnhancedParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.2;
                this.vy = (Math.random() - 0.5) * 0.2;
                this.baseSize = Math.random() * 3 + 2;
                this.size = this.baseSize;
                this.autonomy = 0.0;
                this.personalDirection = Math.random() * Math.PI * 2;
                this.personalFrequency = 0.01 + Math.random() * 0.02;
                this.vibrationPhase = Math.random() * Math.PI * 2;
                this.shape = 'circle';
                this.connections = [];
                
                // æ¥ç¶šãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³åˆ¶å¾¡ç”¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
                this.connectionFadeOpacity = 0.0;
                this.connectionFadeStartTime = null;
                this.connectionFadeDuration = 1500; // 1.5ç§’ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³å®Œäº†
                this.connectionFadeDelay = 1500;    // 1.5ç§’ã®é…å»¶å¾Œã«ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é–‹å§‹
                
                // è‰²å½©ã‚·ã‚¹ãƒ†ãƒ 
                this.originalHue = Math.random() * 360;
                this.currentHue = this.originalHue;
                this.saturation = 30;
                this.lightness = 50;
                this.glow = 0;
                
                // è»Œè·¡ã‚·ã‚¹ãƒ†ãƒ 
                this.trail = [];
                this.maxTrailLength = 20;
            }

            update(stage, mouseX, mouseY, particles) {
                // è»Œè·¡ã®æ›´æ–°
                this.trail.push({x: this.x, y: this.y, life: 1.0});
                while (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                this.trail.forEach(point => point.life *= 0.95);

                // æ®µéšã«å¿œã˜ãŸæŒ™å‹•
                switch(stage) {
                    case 0: this.updateGravityDominance(mouseX, mouseY); break;
                    case 1: this.updateChaosEdge(mouseX, mouseY); break;
                    case 2: this.updateCreativeScattering(mouseX, mouseY); break;
                    case 3: this.updateCosmicDance(mouseX, mouseY, particles); break;
                }

                // å¢ƒç•Œå‡¦ç†
                this.handleBoundaries();
                
                // ä½ç½®æ›´æ–°
                this.x += this.vx;
                this.y += this.vy;

                // æ‘©æ“¦
                this.vx *= 0.99;
                this.vy *= 0.99;
            }

            updateGravityDominance(mouseX, mouseY) {
                // é‡åŠ›å ´ã®å½±éŸ¿
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    const force = 0.004;
                    this.vx += (dx / distance) * force;
                    this.vy += (dy / distance) * force;
                }

                // åŒèª¿è¡Œå‹•
                this.vibrationPhase += this.personalFrequency;
                this.size = this.baseSize + Math.sin(this.vibrationPhase) * 0.5;
                
                // è‰²å½©ã®çµ±ä¸€åŒ–
                this.currentHue = 240;
                this.saturation = 40;
                this.lightness = 60;
                this.glow = 0;
                this.autonomy = 0;
                this.shape = 'ellipse';
            }

            updateChaosEdge(mouseX, mouseY) {
                // å¤–éƒ¨ã¨å†…éƒ¨ã®åŠ›ã®æ··åœ¨
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    const force = 0.002 * (1 - this.autonomy);
                    this.vx += (dx / distance) * force;
                    this.vy += (dy / distance) * force;
                }

                // ä¸è¦å‰‡ãªæŒ¯å‹•
                this.vibrationPhase += this.personalFrequency * (1 + Math.sin(Date.now() * 0.003) * 0.5);
                this.size = this.baseSize + Math.sin(this.vibrationPhase) * 1.5;
                
                // è‡ªå¾‹æ€§ã®èŠ½ç”Ÿãˆ
                if (Math.random() < 0.01) {
                    this.autonomy = Math.min(0.3, this.autonomy + 0.005);
                }
                
                // è‰²å½©ã®åˆ†åŒ–
                this.currentHue = this.originalHue + (Math.sin(this.vibrationPhase) * 30);
                this.saturation = 40 + (this.autonomy * 40);
                this.lightness = 60 + (Math.sin(this.vibrationPhase) * 20);
                this.glow = this.autonomy * 0.3;
                
                // å½¢çŠ¶ã®å®Ÿé¨“
                const shapeRandom = Math.sin(this.vibrationPhase * 3);
                if (shapeRandom > 0.7) this.shape = 'triangle';
                else if (shapeRandom > 0.3) this.shape = 'square';
                else this.shape = 'circle';
                
                // å€‹äººçš„ãªæ–¹å‘æ€§
                const personalForce = 0.001 * this.autonomy;
                this.vx += Math.cos(this.personalDirection) * personalForce;
                this.vy += Math.sin(this.personalDirection) * personalForce;
            }

            updateCreativeScattering(mouseX, mouseY) {
                try {
                    // å…¥åŠ›å€¤ã®æ¤œè¨¼
                    if (!isFinite(mouseX) || !isFinite(mouseY)) {
                        mouseX = this.x || 0;
                        mouseY = this.y || 0;
                    }
                    
                    // åˆæœŸæ‹¡æ•£ãƒ•ã‚§ãƒ¼ã‚º - ã‚¹ãƒ†ãƒ¼ã‚¸ç§»è¡Œç›´å¾Œã«ç©æ¥µçš„ã«æ‹¡æ•£
                    if (!this.hasInitialDispersed) {
                        this.hasInitialDispersed = true;
                        this.initialDispersionTimer = 0;
                        
                        // åˆæœŸæ‹¡æ•£æ–¹å‘ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«è¨­å®š
                        this.dispersalDirection = Math.random() * Math.PI * 2;
                        this.dispersalForce = 0.4 + Math.random() * 0.3; // 0.4-0.7ã®æ‹¡æ•£åŠ›ï¼ˆå¾“æ¥ã®åŠåˆ†ç¨‹åº¦ï¼‰
                    }
                    
                    // åˆæœŸæ‹¡æ•£åŠ›ã®é©ç”¨ï¼ˆæœ€åˆã®4ç§’é–“ã«å»¶é•·ã—ã¦ã‚ˆã‚Šç·©ã‚„ã‹ã«ï¼‰
                    if (this.initialDispersionTimer < 240) { // 60fps * 4ç§’
                        this.initialDispersionTimer++;
                        const dispersionStrength = Math.max(0, 1 - (this.initialDispersionTimer / 240));
                        
                        this.vx += Math.cos(this.dispersalDirection) * this.dispersalForce * dispersionStrength * 0.01; // 0.02ã‹ã‚‰0.01ã«æ¸›å°‘
                        this.vy += Math.sin(this.dispersalDirection) * this.dispersalForce * dispersionStrength * 0.01;
                    }
                    
                    // é‡åŠ›ã‹ã‚‰ã®è§£æ”¾ï¼ˆå¾“æ¥ã‚ˆã‚Šå¼±ãèª¿æ•´ï¼‰
                    const dx = mouseX - this.x;
                    const dy = mouseY - this.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // åˆ†æ¯ã‚¼ãƒ­ãƒã‚§ãƒƒã‚¯
                    if (distance < 0.001) {
                        distance = 0.001;
                    }
                    
                    if (isFinite(distance) && distance > 0) {
                        // é‡åŠ›ã®å½±éŸ¿ã‚’å¤§å¹…ã«æ¸›å°‘ï¼ˆè‡ªå¾‹æ€§é‡è¦–ï¼‰
                        const force = 0.0002 * (1 - this.autonomy) * Math.max(0, 1 - this.autonomy);
                        if (isFinite(force)) {
                            const forceX = (dx / distance) * force;
                            const forceY = (dy / distance) * force;
                            
                            if (isFinite(forceX) && isFinite(forceY)) {
                                this.vx += forceX;
                                this.vy += forceY;
                            }
                        }
                    }

                    // æ€¥é€Ÿãªè‡ªå¾‹æ€§ã®ç™ºé”
                    this.autonomy = Math.min(0.95, this.autonomy + 0.008);
                    
                    // å‰µé€ çš„ãªè»Œé“ï¼ˆå®‰å…¨æ€§ãƒã‚§ãƒƒã‚¯ä»˜ãï¼‰- æ‹¡æ•£åŠ›å¼·åŒ–
                    if (isFinite(this.personalDirection)) {
                        this.personalDirection += 0.012 + (this.autonomy * 0.02); // å›è»¢é€Ÿåº¦ã‚’å°‘ã—ç·©ã‚„ã‹ã«
                        const creativityForce = 0.004 * this.autonomy + 0.001; // åŸºæœ¬å‰µé€ åŠ›ã‚’æ¸›å°‘
                        
                        // æ‹¡æ•£ä¿ƒé€²åŠ› - ä»–ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã¨ã®è·é›¢ã«åŸºã¥ãåç™ºåŠ›
                        const expansionForce = 0.002 * this.autonomy; // æ‹¡æ•£åŠ›ã‚’åŠåˆ†ã«
                        
                        if (isFinite(creativityForce) && isFinite(expansionForce)) {
                            const baseCreativeX = Math.cos(this.personalDirection) * creativityForce;
                            const baseCreativeY = Math.sin(this.personalDirection) * creativityForce;
                            
                            // æ‹¡æ•£æ–¹å‘ã¸ã®è¿½åŠ åŠ›
                            const expansionX = Math.cos(this.personalDirection + Math.PI/4) * expansionForce;
                            const expansionY = Math.sin(this.personalDirection + Math.PI/4) * expansionForce;
                            
                            this.vx += baseCreativeX + expansionX;
                            this.vy += baseCreativeY + expansionY;
                        }
                    } else {
                        this.personalDirection = Math.random() * Math.PI * 2;
                    }

                    // å¢ƒç•Œã§ã®åç™ºåŠ›å¼·åŒ–ï¼ˆç”»é¢ç«¯ã‹ã‚‰ã®è‡ªå¾‹çš„åç™ºï¼‰
                    const canvas = document.getElementById('growth-visualization-canvas');
                    if (canvas) {
                        const margin = 50;
                        if (this.x < margin) this.vx += 0.005 * this.autonomy; // å¢ƒç•Œåç™ºåŠ›ã‚‚åŠæ¸›
                        if (this.x > canvas.width - margin) this.vx -= 0.005 * this.autonomy;
                        if (this.y < margin) this.vy += 0.005 * this.autonomy;
                        if (this.y > canvas.height - margin) this.vy -= 0.005 * this.autonomy;
                    }

                    // ç”Ÿãç”Ÿãã¨ã—ãŸæŒ¯å‹•ï¼ˆå®‰å…¨æ€§ãƒã‚§ãƒƒã‚¯ä»˜ãï¼‰- æ´»ç™ºæ€§å‘ä¸Š
                    if (isFinite(this.vibrationPhase) && isFinite(this.personalFrequency)) {
                        this.vibrationPhase += this.personalFrequency * (2.5 + this.autonomy * 1.5);
                        const sizeModifier = Math.sin(this.vibrationPhase * 2) * (1.2 + this.autonomy * 2.5);
                        if (isFinite(sizeModifier)) {
                            this.size = this.baseSize + sizeModifier;
                        } else {
                            this.size = this.baseSize;
                        }
                    } else {
                        this.vibrationPhase = Math.random() * Math.PI * 2;
                        this.personalFrequency = 0.015 + Math.random() * 0.025; // æŒ¯å‹•é »åº¦å‘ä¸Š
                        this.size = this.baseSize;
                    }
                    
                    // ç‹¬è‡ªè‰²å½©ã®ç¢ºç«‹ï¼ˆå®‰å…¨æ€§ãƒã‚§ãƒƒã‚¯ä»˜ãï¼‰- ã‚ˆã‚Šé®®ã‚„ã‹ã«
                    if (isFinite(this.originalHue) && isFinite(this.personalDirection)) {
                        this.currentHue = this.originalHue + (Math.sin(this.personalDirection) * 90); // è‰²ç›¸å¤‰åŒ–æ‹¡å¤§
                        this.saturation = 70 + (this.autonomy * 25); // å½©åº¦å‘ä¸Š
                        this.lightness = 65 + (Math.sin(this.vibrationPhase) * 30); // æ˜åº¦å¤‰åŒ–æ‹¡å¤§
                        this.glow = this.autonomy * 1.2; // ã‚°ãƒ­ãƒ¼åŠ¹æœå¼·åŒ–
                    } else {
                        this.currentHue = this.originalHue || Math.random() * 360;
                        this.saturation = 75;
                        this.lightness = 70;
                        this.glow = 0.7;
                    }
                    
                    // å¤šæ§˜ãªå½¢çŠ¶ï¼ˆå®‰å…¨æ€§ãƒã‚§ãƒƒã‚¯ä»˜ãï¼‰
                    if (isFinite(this.personalDirection) && isFinite(this.vibrationPhase)) {
                        const uniqueShape = Math.sin(this.personalDirection * 2 + this.vibrationPhase);
                        if (uniqueShape > 0.6) this.shape = 'triangle';
                        else if (uniqueShape > 0.2) this.shape = 'square';
                        else if (uniqueShape > -0.2) this.shape = 'circle';
                        else this.shape = 'ellipse';
                    } else {
                        this.shape = 'circle';
                    }

                    // æ‘©æ“¦ã®è»½æ¸›ï¼ˆè‡ªå¾‹æ€§ãŒé«˜ã„ã»ã©æ…£æ€§ã‚’ä¿æŒï¼‰
                    const frictionReduction = 1 - (this.autonomy * 0.3);
                    this.vx *= (0.985 + (this.autonomy * 0.01)); // æ‘©æ“¦è»½æ¸›
                    this.vy *= (0.985 + (this.autonomy * 0.01)); // æ‘©æ“¦è»½æ¸›

                    // é€Ÿåº¦åˆ¶é™ï¼ˆç™ºæ•£é˜²æ­¢ï¼‰- ä¸Šé™ç·©å’Œ
                    const maxVelocity = 2.5 + (this.autonomy * 2.5); // è‡ªå¾‹æ€§ã«å¿œã˜ã¦æœ€å¤§é€Ÿåº¦å‘ä¸Šï¼ˆ2.5-5.0ã®ç¯„å›²ï¼‰
                    this.vx = Math.max(-maxVelocity, Math.min(maxVelocity, this.vx || 0));
                    this.vy = Math.max(-maxVelocity, Math.min(maxVelocity, this.vy || 0));
                    
                } catch (error) {
                    console.error('updateCreativeScattering error:', error);
                    // ã‚¨ãƒ©ãƒ¼æ™‚ã¯å®‰å…¨ãªå€¤ã«ãƒªã‚»ãƒƒãƒˆ
                    this.autonomy = 0.3;
                    this.size = this.baseSize;
                    this.shape = 'circle';
                    this.vx = (this.vx || 0) * 0.5;
                    this.vy = (this.vy || 0) * 0.5;
                    this.hasInitialDispersed = false;
                    this.personalDirection = Math.random() * Math.PI * 2;
                }
            }

            updateCosmicDance(mouseX, mouseY, particles) {
                // æ¥ç¶šãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³åˆ¶å¾¡ã®åˆæœŸåŒ–
                if (this.connectionFadeStartTime === null) {
                    this.connectionFadeStartTime = Date.now();
                    this.connectionFadeOpacity = 0.0;
                }
                
                // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é€²è¡Œåº¦ã®è¨ˆç®—
                const currentTime = Date.now();
                const timeSinceStageStart = currentTime - this.connectionFadeStartTime;
                
                if (timeSinceStageStart >= this.connectionFadeDelay) {
                    // é…å»¶æœŸé–“çµŒéå¾Œã€ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é–‹å§‹
                    const fadeProgress = Math.min(1.0, (timeSinceStageStart - this.connectionFadeDelay) / this.connectionFadeDuration);
                    this.connectionFadeOpacity = fadeProgress;
                } else {
                    // ã¾ã é…å»¶æœŸé–“ä¸­
                    this.connectionFadeOpacity = 0.0;
                }
                
                // ç›¸äº’ä½œç”¨ã®æº–å‚™
                this.connections = [];
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é–“ç›¸äº’ä½œç”¨ï¼ˆå‹•çš„ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å½¢æˆï¼‰
                particles.forEach(other => {
                    if (other === this) return;
                    
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // é©åº¦ãªè·é›¢ã‚’ä¿ã¤ãŸã‚ã®åç™ºåŠ›ï¼ˆè‡ªå¾‹æ€§ã®ç¶­æŒï¼‰
                    const minDistance = 40; // æœ€å°è·é›¢ï¼ˆå€‹äººç©ºé–“ã®ç¢ºä¿ï¼‰
                    if (distance < minDistance && distance > 0) {
                        const repulsionForce = 0.002 * (1 - distance / minDistance);
                        this.vx -= (dx / distance) * repulsionForce;
                        this.vy -= (dy / distance) * repulsionForce;
                    }
                    
                    // ä¸­è·é›¢ã§ã®å‹•çš„ãªæ¥ç¶šï¼ˆèª¿å’Œçš„ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼‰
                    const optimalDistance = 80; // æœ€é©ãªæ¥ç¶šè·é›¢
                    const maxConnectionDistance = 120; // æœ€å¤§æ¥ç¶šè·é›¢
                    
                    if (distance < maxConnectionDistance && distance > minDistance) {
                        // æ¥ç¶šã®è¨˜éŒ²ï¼ˆæç”»ç”¨ï¼‰
                        this.connections.push({
                            particle: other,
                            strength: Math.max(0, 1 - distance / maxConnectionDistance)
                        });
                        
                        // æœ€é©è·é›¢ã¸ã®ç©ã‚„ã‹ãªèª¿æ•´åŠ›
                        if (distance < optimalDistance) {
                            // å°‘ã—é›¢ã‚Œã‚‹æ–¹å‘ã¸
                            const adjustForce = 0.0003 * (1 - distance / optimalDistance);
                            this.vx -= (dx / distance) * adjustForce;
                            this.vy -= (dy / distance) * adjustForce;
                        } else {
                            // å°‘ã—è¿‘ã¥ãæ–¹å‘ã¸ï¼ˆå¼±ã„å¼•åŠ›ï¼‰
                            const harmonyForce = 0.0004 * (1 - distance / maxConnectionDistance);
                            this.vx += (dx / distance) * harmonyForce;
                            this.vy += (dy / distance) * harmonyForce;
                        }
                    }
                });

                // æœ€å¤§è‡ªå¾‹æ€§
                this.autonomy = Math.min(1.0, this.autonomy + 0.002);
                
                // ç‹¬è‡ªè»Œé“ã®ç¶­æŒï¼ˆå€‹æ€§ã®è¡¨ç¾ï¼‰
                this.personalDirection += 0.008 + (Math.sin(Date.now() * 0.001 + this.originalHue) * 0.008);
                const selfForce = 0.003; // è‡ªå¾‹æ€§ã‚’å¼·åŒ–
                this.vx += Math.cos(this.personalDirection) * selfForce;
                this.vy += Math.sin(this.personalDirection) * selfForce;
                
                // å€‹äººçš„ãªæŒ¯å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆç‹¬è‡ªæ€§ã®ç¶­æŒï¼‰ - æ–¹å‘æ€§ã‚’å‡ç­‰ã«åˆ†æ•£
                const personalOscillationX = 0.001 * Math.sin(Date.now() * 0.002 + this.originalHue * 0.1);
                const personalOscillationY = 0.001 * Math.sin(Date.now() * 0.002 + this.originalHue * 0.1 + Math.PI * 0.5);
                this.vx += personalOscillationX;
                this.vy += personalOscillationY;
                
                // ä¸­å¿ƒã¸ã®å¾©å¸°åŠ›ï¼ˆç”»é¢å…¨ä½“ã®å‡ç­‰ãªåˆ†å¸ƒã‚’ä¿ƒé€²ï¼‰
                const canvas = document.getElementById('journey-canvas');
                if (canvas) {
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const toCenterX = centerX - this.x;
                    const toCenterY = centerY - this.y;
                    const distanceToCenter = Math.sqrt(toCenterX * toCenterX + toCenterY * toCenterY);
                    
                    // ä¸­å¿ƒã‹ã‚‰é ã™ãã‚‹å ´åˆã€éå¸¸ã«å¼±ã„å¾©å¸°åŠ›ã‚’é©ç”¨
                    const maxRadius = Math.min(canvas.width, canvas.height) * 0.4;
                    if (distanceToCenter > maxRadius) {
                        const returnForce = 0.0002 * (distanceToCenter - maxRadius) / maxRadius;
                        this.vx += (toCenterX / distanceToCenter) * returnForce;
                        this.vy += (toCenterY / distanceToCenter) * returnForce;
                    }
                }

                // èª¿å’Œçš„ãªè„ˆå‹•
                this.vibrationPhase += this.personalFrequency * 1.5;
                this.size = this.baseSize + Math.sin(this.vibrationPhase) * 0.8;
                
                // æˆç†Ÿã—ãŸå€‹æ€§çš„ãªè‰²å½©ï¼ˆå¤šæ§˜æ€§ã®è¡¨ç¾ï¼‰
                const individualityFactor = Math.sin(this.vibrationPhase * 0.3 + this.originalHue * 0.05);
                this.currentHue = this.originalHue + (individualityFactor * 40); // ã‚ˆã‚Šåºƒã„è‰²å½©ç¯„å›²
                this.saturation = 75 + (Math.sin(this.vibrationPhase * 0.7) * 15); // å½©åº¦ã®å¤‰å‹•
                this.lightness = 75 + (Math.sin(this.vibrationPhase * 0.5) * 15); // æ˜åº¦ã®å¤‰å‹•
                this.glow = 0.4 + (Math.sin(this.vibrationPhase * 0.3) * 0.4); // ã‚ˆã‚Šå‹•çš„ãªè¼ã
                
                // å‰µé€ çš„ãªå½¢çŠ¶å¤‰åŒ–ï¼ˆå‰µé€ çš„æ•£ä¹±ã¨åŒæ§˜ã®ã‚­ãƒ©ã‚­ãƒ©åŠ¹æœï¼‰
                if (isFinite(this.personalDirection) && isFinite(this.vibrationPhase)) {
                    const harmonicShape = Math.sin(this.personalDirection * 1.5 + this.vibrationPhase * 0.8);
                    const dynamicShape = Math.cos(this.vibrationPhase * 1.2 + this.originalHue * 0.1);
                    
                    // ã‚ˆã‚Šæ´—ç·´ã•ã‚ŒãŸå½¢çŠ¶å¤‰åŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³
                    if (harmonicShape > 0.7) {
                        this.shape = 'triangle';
                    } else if (harmonicShape > 0.3) {
                        this.shape = 'square';
                    } else if (dynamicShape > 0.4) {
                        this.shape = 'ellipse';
                    } else {
                        this.shape = 'circle';
                    }
                } else {
                    this.shape = 'circle';
                }
            }

            handleBoundaries() {
                const canvas = document.getElementById('journey-canvas');
                if (!canvas) return;
                
                const margin = this.size + 10;
                
                // å¢ƒç•Œã§ã®åç™ºã‚’å¼·åŒ–ã—ã€åã‚Šã‚’é˜²ã
                if (this.x < margin) {
                    this.x = margin;
                    this.vx = Math.abs(this.vx) * 0.9; // åç™ºåŠ›ã‚’å¼·åŒ–
                    // è»½å¾®ãªä¸Šä¸‹ã®ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ ã‚’è¿½åŠ 
                    this.vy += (Math.random() - 0.5) * 0.1;
                }
                if (this.x > canvas.width - margin) {
                    this.x = canvas.width - margin;
                    this.vx = -Math.abs(this.vx) * 0.9; // åç™ºåŠ›ã‚’å¼·åŒ–
                    // è»½å¾®ãªä¸Šä¸‹ã®ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ ã‚’è¿½åŠ 
                    this.vy += (Math.random() - 0.5) * 0.1;
                }
                if (this.y < margin) {
                    this.y = margin;
                    this.vy = Math.abs(this.vy) * 0.9; // åç™ºåŠ›ã‚’å¼·åŒ–
                    // è»½å¾®ãªå·¦å³ã®ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ ã‚’è¿½åŠ 
                    this.vx += (Math.random() - 0.5) * 0.1;
                }
                if (this.y > canvas.height - margin) {
                    this.y = canvas.height - margin;
                    this.vy = -Math.abs(this.vy) * 0.9; // åç™ºåŠ›ã‚’å¼·åŒ–
                    // è»½å¾®ãªå·¦å³ã®ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ ã‚’è¿½åŠ 
                    this.vx += (Math.random() - 0.5) * 0.1;
                }
            }

            draw(ctx, stage) {
                // è»Œè·¡æç”»
                if (stage >= 1) {
                    this.drawTrail(ctx, stage);
                }
                
                // ã‚°ãƒ­ãƒ¼åŠ¹æœ
                if (this.glow > 0 && stage >= 2) {
                    this.drawGlow(ctx);
                }
                
                // ãƒ¡ã‚¤ãƒ³ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
                this.drawParticle(ctx);
                
                // æ¥ç¶šç·šï¼ˆæœ€çµ‚æ®µéšã®ã¿ï¼‰
                if (stage === 3) {
                    this.drawConnections(ctx);
                }
            }

            drawTrail(ctx, stage) {
                if (this.trail.length < 2) return;
                
                ctx.save();
                
                switch(stage) {
                    case 0:
                        ctx.strokeStyle = `hsla(${this.currentHue}, 30%, 50%, 0.2)`;
                        ctx.lineWidth = 1;
                        break;
                    case 1:
                        ctx.strokeStyle = `hsla(${this.currentHue}, 50%, 60%, 0.3)`;
                        ctx.lineWidth = 1.5;
                        break;
                    case 2:
                        ctx.strokeStyle = `hsla(${this.currentHue}, 70%, 70%, 0.5)`;
                        ctx.lineWidth = 2;
                        break;
                    case 3:
                        const gradient = ctx.createLinearGradient(
                            this.trail[0].x, this.trail[0].y,
                            this.x, this.y
                        );
                        gradient.addColorStop(0, `hsla(${this.currentHue}, 80%, 80%, 0)`);
                        gradient.addColorStop(1, `hsla(${this.currentHue}, 80%, 80%, 0.6)`);
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 3;
                        break;
                }
                
                ctx.beginPath();
                for (let i = 1; i < this.trail.length; i++) {
                    const point = this.trail[i];
                    ctx.globalAlpha = point.life * 0.5;
                    
                    if (i === 1) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                }
                ctx.stroke();
                ctx.restore();
            }

            drawGlow(ctx) {
                ctx.save();
                
                // Stage 3ã§ã¯ç‰¹ã«å¼·ã„ã‚°ãƒ­ãƒ¼åŠ¹æœã‚’é©ç”¨
                const stage = journeyCurrentStage;
                const glowIntensity = stage === 3 ? this.glow * 0.4 : this.glow * 0.2;
                const glowMultiplier = stage === 3 ? 2.5 : 1.5;
                
                ctx.globalAlpha = glowIntensity;
                const glowSize = this.size * (1.5 + this.glow * glowMultiplier);
                
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, glowSize
                );
                
                // Stage 3ã§ã¯å¤šå±¤ã‚°ãƒ­ãƒ¼åŠ¹æœ
                if (stage === 3) {
                    gradient.addColorStop(0, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 20}%, 0.6)`);
                    gradient.addColorStop(0.3, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 15}%, 0.3)`);
                    gradient.addColorStop(0.7, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 10}%, 0.1)`);
                    gradient.addColorStop(1, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 15}%, 0)`);
                } else {
                    gradient.addColorStop(0, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 15}%, 0.4)`);
                    gradient.addColorStop(1, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 15}%, 0)`);
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            drawParticle(ctx) {
                try {
                    ctx.save();
                    ctx.globalAlpha = 1.0;
                    
                    // å€¤ã®å®‰å…¨æ€§ãƒã‚§ãƒƒã‚¯
                    const hue = isFinite(this.currentHue) ? this.currentHue % 360 : 0;
                    const sat = Math.max(0, Math.min(100, this.saturation || 50));
                    const light = Math.max(0, Math.min(100, this.lightness || 50));
                    const size = Math.max(0.5, Math.min(20, this.size || 2));
                    const rotationAngle = isFinite(this.vibrationPhase) ? this.vibrationPhase : 0;
                    
                    // ä½ç½®ã®å®‰å…¨æ€§ãƒã‚§ãƒƒã‚¯
                    const x = isFinite(this.x) ? this.x : 0;
                    const y = isFinite(this.y) ? this.y : 0;
                    
                    // Stage 3ã§ã¯ç‰¹åˆ¥ãªã‚­ãƒ©ã‚­ãƒ©åŠ¹æœã‚’è¿½åŠ 
                    const stage = journeyCurrentStage;
                    const sparkleIntensity = stage === 3 ? this.glow * 0.8 : 0;
                    
                    ctx.fillStyle = `hsl(${hue}, ${sat}%, ${light}%)`;
                    ctx.strokeStyle = `hsl(${hue}, ${sat}%, ${Math.max(20, light - 20)}%)`;
                    ctx.lineWidth = stage === 3 ? 1.0 : 0.5; // Stage 3ã§ã¯è¼ªéƒ­ã‚’å¼·åŒ–
                    
                    ctx.translate(x, y);
                    ctx.rotate(rotationAngle);
                    
                    // Stage 3ã§ã¯è¿½åŠ ã®ã‚­ãƒ©ã‚­ãƒ©ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    if (stage === 3 && sparkleIntensity > 0.3) {
                        this.drawSparkles(ctx, size, hue, sat, light);
                    }
                    
                    ctx.beginPath();
                    switch(this.shape) {
                        case 'circle':
                            ctx.arc(0, 0, size, 0, Math.PI * 2);
                            break;
                        case 'ellipse':
                            ctx.scale(1, 0.6);
                            ctx.arc(0, 0, size, 0, Math.PI * 2);
                            break;
                        case 'triangle':
                            ctx.moveTo(0, -size);
                            ctx.lineTo(-size * 0.866, size * 0.5);
                            ctx.lineTo(size * 0.866, size * 0.5);
                            ctx.closePath();
                            break;
                        case 'square':
                            ctx.rect(-size * 0.7, -size * 0.7, size * 1.4, size * 1.4);
                            break;
                        default:
                            // ä¸æ˜ãªå½¢çŠ¶ã®å ´åˆã¯å††ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                            ctx.arc(0, 0, size, 0, Math.PI * 2);
                            break;
                    }
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.restore();
                } catch (error) {
                    console.error('drawParticle error:', error);
                    // ã‚¨ãƒ©ãƒ¼æ™‚ã¯æœ€å°é™ã®æç”»
                    try {
                        ctx.save();
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(this.x || 0, this.y || 0, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    } catch (fallbackError) {
                        console.error('Fallback drawing also failed:', fallbackError);
                    }
                }
            }

            drawConnections(ctx) {
                if (this.connections.length === 0 || this.connectionFadeOpacity <= 0) return;
                
                ctx.save();
                this.connections.forEach((connection, index) => {
                    if (Date.now() % 2 === 0 && index % 2 === 1) return;
                    
                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é€æ˜åº¦ã‚’é©ç”¨
                    const baseOpacity = Math.min(0.6, connection.strength * 0.5);
                    ctx.globalAlpha = baseOpacity * this.connectionFadeOpacity;
                    
                    const avgHue = (this.currentHue + connection.particle.currentHue) / 2;
                    ctx.strokeStyle = `hsl(${avgHue % 360}, 60%, 70%)`;
                    ctx.lineWidth = Math.max(0.5, connection.strength * 2);
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(connection.particle.x, connection.particle.y);
                    ctx.stroke();
                });
                ctx.restore();
            }
            
            drawSparkles(ctx, size, hue, sat, light) {
                // ã‚­ãƒ©ã‚­ãƒ©ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨ã®å°ã•ãªæ˜ŸçŠ¶ã®å›³å½¢ã‚’æç”»
                ctx.save();
                
                const sparkleCount = 4 + Math.floor(this.glow * 4); // è¼ãã«å¿œã˜ã¦ã‚¹ãƒ‘ãƒ¼ã‚¯ãƒ«æ•°ã‚’èª¿æ•´
                const sparkleRadius = size * 0.3;
                
                for (let i = 0; i < sparkleCount; i++) {
                    const angle = (i / sparkleCount) * Math.PI * 2 + this.vibrationPhase * 0.5;
                    const distance = sparkleRadius + Math.sin(this.vibrationPhase * 2 + i) * sparkleRadius * 0.3;
                    
                    const sparkleX = Math.cos(angle) * distance;
                    const sparkleY = Math.sin(angle) * distance;
                    
                    // ã‚¹ãƒ‘ãƒ¼ã‚¯ãƒ«ã®è‰²ã¯åŸºæœ¬è‰²ã‚ˆã‚Šæ˜ã‚‹ã
                    const sparkleHue = (hue + Math.sin(this.vibrationPhase + i) * 30) % 360;
                    const sparkleBrightness = Math.min(95, light + 20);
                    
                    ctx.globalAlpha = 0.3 + Math.sin(this.vibrationPhase * 3 + i) * 0.3;
                    ctx.fillStyle = `hsl(${sparkleHue}, ${sat}%, ${sparkleBrightness}%)`;
                    
                    // å°ã•ãªæ˜Ÿå½¢ã‚’æç”»
                    const sparkleSize = size * 0.15 * (0.5 + Math.sin(this.vibrationPhase * 2 + i) * 0.5);
                    ctx.beginPath();
                    for (let j = 0; j < 4; j++) {
                        const starAngle = (j / 4) * Math.PI * 2;
                        const x = sparkleX + Math.cos(starAngle) * sparkleSize;
                        const y = sparkleY + Math.sin(starAngle) * sparkleSize;
                        
                        if (j === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // Canvas 2D ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ç®¡ç†
        let journeyCanvas = null;
        let journeyCtx = null;
        let journeyParticles = [];
        let journeyMouseX = 0;
        let journeyMouseY = 0;
        let journeyCurrentStage = 0;
        let journeyAnimationId = null;

        const journeyStageDescriptions = [
            {
                title: "é‡åŠ›ã®æ”¯é…",
                description: "å¤–éƒ¨ã®æ¨©å¨ã«å¾“å±ã—ã¦ã„ã‚‹çŠ¶æ…‹"
            },
            {
                title: "æºã‚‰ãã¨å¢ƒç•ŒçŠ¶æ…‹", 
                description: "å†…ãªã‚‹å£°ã«è€³ã‚’å‚¾ã‘ã€æºã‚‰ããŒç”Ÿã¾ã‚Œã‚‹"
            },
            {
                title: "å‰µé€ çš„ãªæ•£ä¹±",
                description: "å€‹æ€§ãŒèŠ½å¹ãã€è‡ªå¾‹çš„ãªå‹•ãã‚’å§‹ã‚ã‚‹"
            },
            {
                title: "å‰µç™ºçš„ç›¸äº’ä½œç”¨",
                description: "è‡ªå¾‹çš„ãªä¸»ä½“ã®ç›¸äº’ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®å‰µç™º"
            }
        ];

        function initJourneyVisualization() {
            console.log('Canvas 2D ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–é–‹å§‹');
            
            try {
                journeyCanvas = document.getElementById('journey-canvas');
                if (!journeyCanvas) {
                    console.error('Canvasè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    return;
                }
                
                journeyCtx = journeyCanvas.getContext('2d');
                if (!journeyCtx) {
                    console.error('Canvas 2Dã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®å–å¾—ã«å¤±æ•—');
                    return;
                }
                
                initJourneyCanvas();
                createJourneyParticles();
                updateJourneyStageUI();
                updateJourneyButtonStates();
                addJourneyEventListeners();
                startJourneyAnimation();
                
                console.log('Canvas 2D ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–å®Œäº†');
            } catch (error) {
                console.error('Canvas 2D ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
            }
        }

        function cleanupJourneyVisualization() {
            console.log('Canvas 2D ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–‹å§‹');
            
            if (journeyAnimationId) {
                cancelAnimationFrame(journeyAnimationId);
                journeyAnimationId = null;
            }
            
            journeyParticles = [];
            journeyCurrentStage = 0;
            
            removeJourneyEventListeners();
            
            console.log('Canvas 2D ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†');
        }

        function initJourneyCanvas() {
            if (!journeyCanvas) return;
            
            const container = journeyCanvas.parentElement;
            journeyCanvas.width = container.clientWidth;
            journeyCanvas.height = container.clientHeight;
            
            journeyMouseX = journeyCanvas.width / 2;
            journeyMouseY = journeyCanvas.height / 2;
        }

        function createJourneyParticles() {
            journeyParticles = [];
            if (!journeyCanvas) return;
            
            const numParticles = Math.min(100, Math.floor(journeyCanvas.width * journeyCanvas.height / 10000));
            
            for (let i = 0; i < numParticles; i++) {
                journeyParticles.push(new EnhancedParticle(
                    Math.random() * journeyCanvas.width,
                    Math.random() * journeyCanvas.height
                ));
            }
        }

        function updateJourneyPhysicsInfo() {
            const avgAutonomy = journeyParticles.reduce((sum, p) => sum + p.autonomy, 0) / journeyParticles.length;
            const gravityStrength = journeyCurrentStage === 0 ? "å¼·" : journeyCurrentStage === 1 ? "ä¸­" : journeyCurrentStage === 2 ? "å¼±" : "ç„¡";
            
            let harmony = 0;
            if (journeyCurrentStage === 3) {
                // é©åº¦ãªè·é›¢ã‚’ä¿ã£ãŸè³ªã®é«˜ã„æ¥ç¶šã‚’è©•ä¾¡
                let qualityConnections = 0;
                let totalParticles = journeyParticles.length;
                
                journeyParticles.forEach(particle => {
                    particle.connections.forEach(connection => {
                        const dx = connection.particle.x - particle.x;
                        const dy = connection.particle.y - particle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // é©åº¦ãªè·é›¢ï¼ˆ60-100ãƒ”ã‚¯ã‚»ãƒ«ï¼‰ã®æ¥ç¶šã«ã‚ˆã‚Šé«˜ã„ã‚¹ã‚³ã‚¢ã‚’ä¸ãˆã‚‹
                        if (distance >= 60 && distance <= 100) {
                            qualityConnections += connection.strength * 1.5; // è³ªã®é«˜ã„æ¥ç¶šã«é«˜ã„ã‚¹ã‚³ã‚¢
                        } else if (distance >= 40 && distance <= 120) {
                            qualityConnections += connection.strength; // é€šå¸¸ã®ã‚¹ã‚³ã‚¢
                        } else {
                            qualityConnections += connection.strength * 0.5; // è¿‘ã™ãã‚‹/é ã™ãã‚‹æ¥ç¶šã¯ä½ã„ã‚¹ã‚³ã‚¢
                        }
                    });
                });
                
                harmony = Math.min(100, (qualityConnections / totalParticles) * 8);
            }
            
            const physicsInfo = document.getElementById('journey-physicsInfo');
            if (physicsInfo) {
                physicsInfo.innerHTML = 
                    `é‡åŠ›å¼·åº¦: ${gravityStrength}<br>` +
                    `è‡ªå¾‹æ€§: ${Math.round(avgAutonomy * 100)}%<br>` +
                    `èª¿å’Œåº¦: ${Math.round(harmony)}%`;
            }
        }

        function updateJourneyStageUI() {
            const stageInfo = document.getElementById('journey-stageInfo');
            if (stageInfo) {
                const stage = journeyStageDescriptions[journeyCurrentStage];
                stageInfo.innerHTML = `${stage.title}<br><small>${stage.description}</small>`;
            }
            
            // ãƒ‰ãƒƒãƒˆæ›´æ–°
            for (let i = 0; i < 4; i++) {
                const dot = document.getElementById(`journey-dot${i}`);
                if (dot) {
                    dot.classList.toggle('active', i === journeyCurrentStage);
                }
            }
        }

        function updateJourneyButtonStates() {
            const prevButton = document.getElementById('journey-prevButton');
            const nextButton = document.getElementById('journey-nextButton');
            
            if (prevButton) {
                prevButton.disabled = journeyCurrentStage === 0;
                prevButton.style.opacity = journeyCurrentStage === 0 ? '0.5' : '1';
            }
            
            if (nextButton) {
                nextButton.disabled = journeyCurrentStage === 3;
                nextButton.style.opacity = journeyCurrentStage === 3 ? '0.5' : '1';
            }
        }

        function nextJourneyStage() {
            if (journeyCurrentStage < 3) {
                console.log(`Switching from stage ${journeyCurrentStage} to ${journeyCurrentStage + 1}`);
                journeyCurrentStage++;
                updateJourneyStageUI();
                adjustJourneyParticlesForStage();
                updateJourneyButtonStates();
                console.log(`Stage switch completed. Current stage: ${journeyCurrentStage}`);
            }
        }

        function previousJourneyStage() {
            if (journeyCurrentStage > 0) {
                console.log(`Switching from stage ${journeyCurrentStage} to ${journeyCurrentStage - 1}`);
                journeyCurrentStage--;
                updateJourneyStageUI();
                adjustJourneyParticlesForStage();
                updateJourneyButtonStates();
                console.log(`Stage switch completed. Current stage: ${journeyCurrentStage}`);
            }
        }

        function resetJourney() {
            console.log('Resetting journey to stage 0');
            journeyCurrentStage = 0;
            createJourneyParticles();
            updateJourneyStageUI();
            updateJourneyButtonStates();
            console.log('Journey reset completed');
        }

        function toggleInstructions() {
            const instructionsElement = document.getElementById('journey-instructions');
            const detailElement = document.getElementById('instructions-detail');
            const arrowElement = document.getElementById('instructions-arrow');
            
            if (detailElement.classList.contains('show')) {
                // é–‰ã˜ã‚‹
                detailElement.classList.remove('show');
                arrowElement.textContent = 'â–¼';
                console.log('Instructions collapsed');
            } else {
                // é–‹ã
                detailElement.classList.add('show');
                arrowElement.textContent = 'â–²';
                console.log('Instructions expanded');
            }
        }

        function adjustJourneyParticlesForStage() {
            try {
                console.log(`Adjusting particles for stage ${journeyCurrentStage}`);
                if (journeyParticles.length > 0) {
                    journeyParticles.forEach((particle, index) => {
                        const maxVelocity = journeyCurrentStage === 3 ? 2.5 : 2; // Stage 3ã®é€Ÿåº¦åˆ¶é™ã‚’ç·©å’Œ
                        particle.vx = Math.max(-maxVelocity, Math.min(maxVelocity, particle.vx));
                        particle.vy = Math.max(-maxVelocity, Math.min(maxVelocity, particle.vy));
                        
                        particle.size = particle.baseSize;
                        particle.connections = [];
                        
                        if (journeyCurrentStage === 0) {
                            particle.autonomy = 0;
                            // æ¥ç¶šãƒ•ã‚§ãƒ¼ãƒ‰çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
                            particle.connectionFadeStartTime = null;
                            particle.connectionFadeOpacity = 0.0;
                        } else if (journeyCurrentStage === 1) {
                            particle.autonomy = Math.max(0, particle.autonomy);
                            // æ¥ç¶šãƒ•ã‚§ãƒ¼ãƒ‰çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
                            particle.connectionFadeStartTime = null;
                            particle.connectionFadeOpacity = 0.0;
                        } else if (journeyCurrentStage === 2) {
                            particle.autonomy = Math.max(0.1, particle.autonomy);
                            // å‰µé€ çš„æ•£ä¹±ã‚¹ãƒ†ãƒ¼ã‚¸ç§»è¡Œæ™‚ã®åˆæœŸåŒ–
                            particle.hasInitialDispersed = false;
                            particle.initialDispersionTimer = 0;
                            particle.dispersalDirection = Math.random() * Math.PI * 2;
                            particle.dispersalForce = 0.4 + Math.random() * 0.3; // ç©ã‚„ã‹ãªæ‹¡æ•£åŠ›ã«èª¿æ•´
                            // æ¥ç¶šãƒ•ã‚§ãƒ¼ãƒ‰çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
                            particle.connectionFadeStartTime = null;
                            particle.connectionFadeOpacity = 0.0;
                        } else if (journeyCurrentStage === 3) {
                            particle.autonomy = Math.max(0.8, particle.autonomy);
                            
                            // å‰µç™ºçš„ç›¸äº’ä½œç”¨ã‚¹ãƒ†ãƒ¼ã‚¸ç§»è¡Œæ™‚ã®æ¥ç¶šãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³åˆæœŸåŒ–
                            particle.connectionFadeStartTime = null;
                            particle.connectionFadeOpacity = 0.0;
                            
                            // Stage 3ç§»è¡Œæ™‚ã®åˆ†æ•£ä¿ƒé€²
                            const canvas = document.getElementById('journey-canvas');
                            if (canvas) {
                                const centerX = canvas.width / 2;
                                const centerY = canvas.height / 2;
                                const distanceToCenter = Math.sqrt((particle.x - centerX) ** 2 + (particle.y - centerY) ** 2);
                                
                                // ä¸­å¿ƒã«é›†ã¾ã‚Šã™ãã¦ã„ã‚‹å ´åˆã€å¤–å‘ãã®åˆæœŸé€Ÿåº¦ã‚’ä¸ãˆã‚‹
                                if (distanceToCenter < Math.min(canvas.width, canvas.height) * 0.15) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const disperseForce = 0.5 + Math.random() * 1.0;
                                    particle.vx += Math.cos(angle) * disperseForce;
                                    particle.vy += Math.sin(angle) * disperseForce;
                                }
                                
                                // å€‹äººçš„ãªæ–¹å‘æ€§ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«å†è¨­å®šï¼ˆå¤šæ§˜æ€§ã®ç¢ºä¿ï¼‰
                                particle.personalDirection = Math.random() * Math.PI * 2;
                            }
                        }
                        
                        console.log(`Particle ${index} stage set to ${journeyCurrentStage}`);
                    });
                    console.log(`Particle adjustment completed for stage ${journeyCurrentStage}`);
                } else {
                    console.warn('No particles available for stage adjustment');
                }
                
                if (journeyCurrentStage === 0) {
                    createJourneyParticles();
                }
            } catch (error) {
                console.error('Error adjusting particles for stage:', error);
            }
        }

        function startJourneyAnimation() {
            function animate() {
                try {
                    if (!journeyCanvas || !journeyCtx) {
                        console.warn('Canvas or context not available, stopping animation');
                        return;
                    }
                    
                    // èƒŒæ™¯ã‚¯ãƒªã‚¢
                    journeyCtx.clearRect(0, 0, journeyCanvas.width, journeyCanvas.height);
                    journeyCtx.fillStyle = '#0a0a0a';
                    journeyCtx.fillRect(0, 0, journeyCanvas.width, journeyCanvas.height);

                    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°ã¨æç”»ï¼ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä»˜ãï¼‰
                    journeyParticles.forEach((particle, index) => {
                        try {
                            particle.update(journeyCurrentStage, journeyMouseX, journeyMouseY, journeyParticles);
                            particle.draw(journeyCtx, journeyCurrentStage);
                        } catch (error) {
                            console.error(`Particle ${index} error in stage ${journeyCurrentStage}:`, error);
                            // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å€¤ã‚’ãƒªã‚»ãƒƒãƒˆ
                            particle.vx = particle.vx || 0;
                            particle.vy = particle.vy || 0;
                            particle.x = particle.x || journeyCanvas.width / 2;
                            particle.y = particle.y || journeyCanvas.height / 2;
                        }
                    });

                    // ç‰©ç†æƒ…å ±æ›´æ–°
                    updateJourneyPhysicsInfo();

                    journeyAnimationId = requestAnimationFrame(animate);
                } catch (error) {
                    console.error('Animation loop error:', error);
                    console.error('Error occurred at stage:', journeyCurrentStage);
                    console.error('Animation frame ID:', journeyAnimationId);
                    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åœæ­¢
                    if (journeyAnimationId) {
                        cancelAnimationFrame(journeyAnimationId);
                        journeyAnimationId = null;
                        console.log('Animation stopped due to error');
                    }
                }
            }
            
            animate();
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ç®¡ç†
        let journeyEventListeners = [];

        function addJourneyEventListeners() {
            if (!journeyCanvas) return;
            
            const mouseMoveHandler = (e) => {
                const rect = journeyCanvas.getBoundingClientRect();
                journeyMouseX = e.clientX - rect.left;
                journeyMouseY = e.clientY - rect.top;
            };
            
            const touchMoveHandler = (e) => {
                e.preventDefault();
                const rect = journeyCanvas.getBoundingClientRect();
                journeyMouseX = e.touches[0].clientX - rect.left;
                journeyMouseY = e.touches[0].clientY - rect.top;
            };
            
            const resizeHandler = () => {
                initJourneyCanvas();
                createJourneyParticles();
            };
            
            journeyCanvas.addEventListener('mousemove', mouseMoveHandler);
            journeyCanvas.addEventListener('touchmove', touchMoveHandler);
            window.addEventListener('resize', resizeHandler);
            
            journeyEventListeners.push(
                { element: journeyCanvas, event: 'mousemove', handler: mouseMoveHandler },
                { element: journeyCanvas, event: 'touchmove', handler: touchMoveHandler },
                { element: window, event: 'resize', handler: resizeHandler }
            );
        }

        function removeJourneyEventListeners() {
            journeyEventListeners.forEach(({ element, event, handler }) => {
                element.removeEventListener(event, handler);
            });
            journeyEventListeners = [];
        }

        // Stage click handling for dynamic linking
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ã‚»ãƒ«ãƒ•ã‚ªãƒ¼ã‚µãƒ¼ã‚·ãƒƒãƒ—3Dçµ±åˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
            
            // Test toggleSection function availability
            if (typeof toggleSection === 'function') {
                console.log('toggleSection function is available');
                
                // Test with buttons
                const toggleButtons = document.querySelectorAll('button[onclick*="toggleSection"]');
                console.log('Found toggle buttons:', toggleButtons.length);
                
                toggleButtons.forEach((button, index) => {
                    console.log(`Button ${index}:`, button.textContent.trim());
                    button.addEventListener('click', (e) => {
                        console.log('Button clicked:', button.textContent.trim());
                    });
                });
            } else {
                console.error('toggleSection function is NOT available');
            }
            
            // Test DOM elements
            const detailedJourney = document.getElementById('detailed-journey');
            const refinedPhases = document.getElementById('refined-phases');
            
            console.log('detailed-journey element:', detailedJourney);
            console.log('refined-phases element:', refinedPhases);
            
            // Add click handlers to stage headings in text for dynamic linking
            setTimeout(() => {
                const stageHeadings = document.querySelectorAll('.sub-phase h4');
                stageHeadings.forEach(heading => {
                    const text = heading.textContent;
                    const stageMatch = text.match(/^(Ea|Eb|Ec|E\(I\)|E-I|I-E|I\(E\)|Ia|Ib|Ic):/);
                    if (stageMatch) {
                        let stageId = stageMatch[1];
                        // Convert special cases
                        if (stageId === 'E(I)') stageId = 'EI';
                        if (stageId === 'I(E)') stageId = 'IE';
                        
                        heading.style.cursor = 'pointer';
                        heading.style.transition = 'color 0.3s';
                        heading.style.color = '#667eea';
                        
                        heading.addEventListener('click', () => {
                            if (refinedVisualization && refinedVisualization.isInitialized) {
                                refinedVisualization.switchToStage(stageId);
                                
                                // Scroll to 3D area
                                const container = document.getElementById('refined-3d-container');
                                if (container) {
                                    container.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            }
                        });
                        
                        heading.addEventListener('mouseenter', () => {
                            heading.style.color = '#764ba2';
                        });
                        
                        heading.addEventListener('mouseleave', () => {
                            heading.style.color = '#667eea';
                        });
                    }
                });
            }, 1000);
        });
        
        // ã‚¸ãƒ£ãƒ¼ãƒ‹ãƒ¼ãƒãƒƒãƒ—é–‹é–‰æ©Ÿèƒ½
        function toggleJourneyMap() {
            const container = document.getElementById('journey-map-container');
            const icon = document.getElementById('journey-toggle-icon');
            
            if (container.style.display === 'none') {
                // é–‹ã
                container.style.display = 'block';
                icon.classList.add('rotated');
                icon.textContent = 'â–²';
                
                // iframe ã®ã‚µã‚¤ã‚ºèª¿æ•´
                adjustIframeHeight();
            } else {
                // é–‰ã˜ã‚‹
                container.style.display = 'none';
                icon.classList.remove('rotated');
                icon.textContent = 'â–¼';
            }
        }
        
        // iframe ã®å‹•çš„é«˜ã•èª¿æ•´ï¼ˆUXæœ€é©åŒ–ç‰ˆï¼‰
        let lastIframeHeight = 800; // åˆæœŸå€¤ã‚’ã‚°ãƒ©ãƒ•ãŒè¦‹ãˆã‚‹é«˜ã•ã«
        let heightAdjustmentSetup = false;
        
        function adjustIframeHeight() {
            if (heightAdjustmentSetup) return; // é‡è¤‡ãƒªã‚¹ãƒŠãƒ¼é˜²æ­¢
            heightAdjustmentSetup = true;
            
            const iframe = document.getElementById('journey-map-iframe');
            
            // PostMessage ã§iframeå†…ã®é«˜ã•ã‚’å—ä¿¡
            window.addEventListener('message', function(event) {
                if (event.data.type === 'IFRAME_HEIGHT_CHANGE' && iframe) {
                    let newHeight = event.data.height + 20; // ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’æœ€å°é™ã«
                    
                    // ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œï¼šç”»é¢ã‚µã‚¤ã‚ºã«å¿œã˜ãŸåˆ¶é™
                    const viewportHeight = window.innerHeight;
                    const maxAllowedHeight = Math.min(viewportHeight * 0.85, 1600);
                    
                    // æœ€å°é«˜ã•ã‚’800pxã€æœ€å¤§é«˜ã•ã‚’åˆ¶é™
                    newHeight = Math.max(800, Math.min(newHeight, maxAllowedHeight));
                    
                    // é«˜ã•ã®å¤‰åŒ–ãŒæœ€å°é™ã®å ´åˆã¯èª¿æ•´ã—ãªã„
                    if (Math.abs(newHeight - lastIframeHeight) < 5) {
                        return;
                    }
                    
                    lastIframeHeight = newHeight;
                    
                    // ã‚¹ãƒ ãƒ¼ã‚ºãªãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³
                    iframe.style.transition = 'height 0.3s ease-out';
                    iframe.style.height = newHeight + 'px';
                    
                    console.log('iframeé«˜ã•æœ€é©åŒ–:', {
                        received: event.data.height,
                        applied: newHeight,
                        viewport: viewportHeight
                    });
                    
                    // ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³çµ‚äº†å¾Œã«transitionã‚’å‰Šé™¤
                    setTimeout(() => {
                        iframe.style.transition = '';
                    }, 300);
                }
            });
        }
    </script>
</body>
</html>
