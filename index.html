<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>セルフ・オーサーシップ理論フレームワーク勉強ノート（暫定版）</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans JP", sans-serif;
            line-height: 1.8;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background: 
                linear-gradient(135deg, rgba(201, 234, 102, 0) 0%, rgba(126, 206, 255, 0) 100%),
                url('./header_image01_orchard.png') center 75%/cover no-repeat;
            color: white;
            padding: 60px 40px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .header h1,
        .header .subtitle {
            background: rgba(0, 0, 0, 0.2);
            padding: 0px 8px;
            border-radius: 0px;
            margin: 0;
            display: inline-block;
        }
        .header .subtitle {
            margin-top: 4px;
        }
        h1 {
            font-size: 2.5em;
        }
        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }
        .section {
            background: white;
            padding: 30px;
            margin-bottom: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        h2 {
            color: #666;
            border-bottom: 3px solid #666;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        h3 {
            color: #444;
            margin-top: 25px;
        }
        .dimension-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .dimension-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 5px solid #667eea;
        }
        .phase-container {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .phase-card {
            flex: 1;
            min-width: 250px;
            background: #fff;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .phase-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .phase-1 { border-color: #ff6b6b; }
        .phase-2 { border-color: #ffd43b; }
        .phase-3 { border-color: #51cf66; }
        .principle {
            background: #e3f2fd;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border-left: 5px solid #2196f3;
        }
        .checklist {
            background: #f0f4ff;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .checklist h4 {
            color: #666;
            margin-bottom: 15px;
        }
        .checklist ul {
            list-style: none;
            padding: 0;
        }
        .checklist li {
            padding: 8px 0;
            padding-left: 30px;
            position: relative;
        }
        .checklist li:before {
            content: "□";
            position: absolute;
            left: 0;
            color: #667eea;
            font-weight: bold;
        }
        .highlight {
            background: #ffeb3b;
            padding: 2px 6px;
            border-radius: 3px;
        }
        .example {
            background: #e8f5e9;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 4px solid #4caf50;
            font-style: italic;
        }
        .arrow {
            text-align: center;
            font-size: 2em;
            color: #667eea;
            margin: 20px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background: #667eea;
            color: white;
        }
        tr:nth-child(even) {
            background: #f9f9f9;
        }
        .practical-tips {
            background: #fff3cd;
            padding: 20px;
            border-radius: 8px;
            border-left: 5px solid #ffc107;
            margin: 20px 0;
        }
        .advanced-section {
            background: #f0f7ff;
            padding: 30px;
            margin: 20px 0;
            border-radius: 10px;
            border: 2px solid #667eea;
        }
        .sub-phase {
            background: #fafbfc;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }
        .sub-phase h4 {
            margin: 0 0 10px 0;
            color: #667eea;
        }
        .lpm-step {
            background: #f8f9fa;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 4px solid #2196f3;
        }
        .lpm-step h5 {
            margin: 0 0 10px 0;
            color: #2196f3;
        }
        .toggle-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px 0;
            transition: background 0.3s;
        }
        .toggle-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            text-decoration: none;
            color: white;
        }
        .collapsible {
            display: none;
            margin-top: 20px;
        }
        .collapsible.active {
            display: block;
        }
        .journey-table {
            overflow-x: auto;
        }
        .journey-table table {
            font-size: 0.9em;
        }
        .journey-table td {
            vertical-align: top;
        }
        @media (max-width: 768px) {
            .phase-container {
                flex-direction: column;
            }
            .dimension-grid {
                grid-template-columns: 1fr;
            }
            .journey-table {
                overflow-x: scroll;
            }
        }
        
        /* 3D Integration Styles */
        .sa-3d-integration {
            margin: 30px 0;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0);
        }
        
        .sa-3d-integration h4 {
            color: #667eea;
            margin: 0 0 15px 0;
            font-size: 1.3em;
        }
        
        .sa-3d-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .sa-3d-loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            z-index: 10;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(102, 126, 234, 0.3);
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Canvas 2D ビジュアライゼーション統合スタイル */
        .canvas-2d-integration {
            margin: 25px 0;
            padding: 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            border: 2px solid #dee2e6;
        }
        
        .canvas-2d-integration h4 {
            color: #667eea;
            margin: 0 0 15px 0;
            font-size: 1.3em;
        }
        
        .journey-canvas-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        #journey-canvas {
            display: block;
            cursor: crosshair;
            background: transparent;
            width: 100%;
            height: 100%;
        }
        
        .journey-controls {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 10;
            background: rgba(26, 26, 46, 0.95);
            padding: 12px;
            border-radius: 12px;
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 240px;
            color: white;
            font-size: 0.9em;
        }
        
        .journey-controls h5 {
            color: #ffffff;
            margin: 0 0 8px 0;
            font-size: 1em;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            text-align: center;
        }
        
        .journey-stage-info {
            margin-bottom: 10px;
            padding: 8px 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            font-size: 0.8em;
            line-height: 1.3;
            box-shadow: 0 3px 12px rgba(102, 126, 234, 0.3);
            text-align: center;
        }
        
        .journey-stage-info small {
            display: block;
            opacity: 0.9;
            font-size: 0.85em;
            margin-top: 2px;
        }
        
        .journey-button-group {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
        }
        
        .journey-controls button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
            font-weight: 500;
            transition: all 0.3s ease;
            flex: 1;
            box-shadow: 0 3px 12px rgba(102, 126, 234, 0.2);
        }
        
        .journey-controls button.reset-btn {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            padding: 6px 10px;
            font-size: 0.75em;
        }
        
        .journey-controls button:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .journey-controls button.reset-btn:hover {
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }
        
        .journey-controls button:disabled {
            cursor: not-allowed;
            opacity: 0.4;
            transform: none !important;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1) !important;
        }
        
        .journey-stage-indicator {
            display: flex;
            gap: 6px;
            margin-top: 8px;
            justify-content: center;
        }
        
        .journey-stage-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .journey-stage-dot.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transform: scale(1.3);
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.6);
        }
        
        .journey-instructions {
            position: absolute;
            top: 185px;
            left: 15px;
            background: rgba(26, 26, 46, 0.95);
            padding: 12px;
            border-radius: 12px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            width: 240px;
            font-size: 0.75em;
            line-height: 1.2;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            z-index: 10;
        }
        
        .journey-instructions:hover {
            background: rgba(102, 126, 234, 0.2);
            border-color: rgba(102, 126, 234, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.3);
        }
        
        .journey-instructions-detail {
            display: none;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.9em;
            line-height: 1.3;
            opacity: 0;
            animation: fadeIn 0.3s ease forwards;
        }
        
        .journey-instructions-detail.show {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .journey-physics-info {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(26, 26, 46, 0.95);
            padding: 10px 12px;
            border-radius: 8px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 0.8em;
            line-height: 1.3;
        }
        
        .sa-3d-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        .stage-info-display {
            color: white;
            text-align: center;
            margin-bottom: 10px;
            min-height: 40px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .stage-info-display h5 {
            margin: 0 0 5px 0;
            color: #667eea;
            font-size: 1em;
        }
        
        .stage-info-display p {
            margin: 0;
            font-size: 0.85em;
            opacity: 0.9;
        }
        
        .stage-controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .stage-btn {
            background: #334155;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s;
            min-width: 40px;
        }
        
        .stage-btn:hover {
            background: #475569;
            transform: translateY(-2px);
        }
        
        .stage-btn.active {
            background: #667eea;
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
        }
        
        .tool-link {
            display: inline-block;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            text-decoration: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: 500;
            text-align: center;
            margin-top: 15px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
        }
        
        .tool-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            text-decoration: none;
            color: white;
        }
        
        .view-controls {
            display: flex;
            gap: 10px;
        }
        
        .view-controls button {
            background: #1e293b;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background 0.3s;
        }
        
        .view-controls button:hover {
            background: #475569;
        }
        
        /* 浮遊視点リセットボタン */
        .floating-view-control {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 100;
            background: rgba(30, 41, 59, 0.9);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.2);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .floating-view-control:hover {
            background: rgba(59, 130, 246, 0.9);
            border-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
        }
        
        .floating-view-control:active {
            transform: scale(0.95);
        }
        
        .floating-view-control .tooltip {
            position: absolute;
            bottom: -35px;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .floating-view-control:hover .tooltip {
            opacity: 1;
        }

        .sa-3d-description {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .sub-phase h4 {
            transition: all 0.3s;
        }
        
        .sub-phase h4:hover {
            color: #764ba2;
            cursor: pointer;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            .sa-3d-container {
                height: 350px;
            }
            
            .sa-3d-controls {
                padding: 12px 15px;
                bottom: 10px;
            }
            
            .stage-controls {
                gap: 6px;
            }
            
            .stage-btn {
                padding: 6px 8px;
                font-size: 0.75em;
                min-width: 35px;
            }
            
            /* Canvas 2D レスポンシブ対応 */
            .journey-canvas-container {
                height: 400px;
            }
            
            .journey-controls {
                padding: 10px;
                width: 200px;
                font-size: 0.85em;
            }
            
            .journey-controls button {
                padding: 6px 8px;
                font-size: 0.75em;
            }
            
            .journey-controls button.reset-btn {
                padding: 5px 8px;
                font-size: 0.7em;
            }
            
            .journey-instructions {
                top: 155px;
                left: 10px;
                right: auto;
                bottom: auto;
                width: 200px;
                padding: 10px;
                font-size: 0.65em;
            }
            
            .journey-physics-info {
                right: 10px;
                bottom: 70px;
                padding: 8px 10px;
                font-size: 0.75em;
            }
        }
        
        /* ジャーニーマップセクション用スタイル */
        .journey-map-section {
            background: #f8f9fa;
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
            border: 1px solid #e9ecef;
        }
        
        
        .toggle-icon {
            font-size: 1em;
            margin-left: 8px;
            transition: transform 0.3s ease;
        }
        
        .toggle-icon.rotated {
            transform: rotate(180deg);
        }
        
        .journey-map-container {
            padding: 0;
            transition: max-height 0.5s ease;
            overflow: hidden;
        }
        
        .journey-iframe-wrapper {
            padding: 20px;
            background: white;
        }
        
        .journey-map-description {
            padding: 20px 30px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
        }
        
        .journey-map-description h4 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .journey-map-description ul {
            margin-left: 20px;
        }
        
        .journey-map-description li {
            margin-bottom: 8px;
        }
        
        /* フレーズクラウドセクション用スタイル */
        .phrases-cloud-section {
            background: #f8f9fa;
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
            border: 1px solid #e9ecef;
        }
        
        .phrases-cloud-container {
            padding: 0;
            transition: max-height 0.5s ease;
            overflow: hidden;
        }
        
        .phrases-iframe-wrapper {
            padding: 20px;
            background: white;
        }
        
        .phrases-cloud-description {
            padding: 20px 30px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
        }
        
        .phrases-cloud-description h4 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .phrases-cloud-description ul {
            margin-left: 20px;
        }
        
        .phrases-cloud-description li {
            margin-bottom: 8px;
        }
        
        /* レスポンシブ対応 */
        @media (max-width: 768px) {
            .journey-iframe-wrapper {
                padding: 10px;
            }
            
            #journey-map-iframe {
                height: 550px; /* モバイルでもグラフが見える高さ */
            }
        }
        
        @media (max-width: 480px) {
            .journey-iframe-wrapper {
                padding: 8px;
            }
            
            #journey-map-iframe {
                height: 500px; /* 小画面でもできるだけグラフを表示 */
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>セルフ・オーサーシップ理論フレームワーク勉強ノート<br>（暫定版）</h1>
        <p class="subtitle">大学における学生の成長支援の取り組み検討用（随時更新中）</p>
    </div>

    <div class="section">
        <h2>📚 参考情報</h2>
        <p>下記の内容は、Baxter Magoldaによるセルフ・オーサーシップ理論、および河井亨（2022）「<a href="https://ritsumei.repo.nii.ac.jp/records/16164" target="_blank">大学生におけるセルフ・オーサーシップの成長理論 : 成長理論のなかの位置づけおよび成長経路と影響要因の析出</a>」を参照しながら作成しています。</p>
        <p>論文の内容から発想を広げて追加している内容もあり、必ずしも忠実に論文の内容を紹介しているものではありません。</p>
        <p>より詳細な理論的背景や実践事例については、原著論文をご参照ください。</p>
    </div>

    <div class="section">
        <h2>🎯 セルフ・オーサーシップとは？</h2>
        <p><strong>セルフ・オーサーシップ</strong>とは、<span class="highlight">「自己の信念、アイデンティティ、社会関係を定義する内的能力」</span>のことです。</p>
        <p>人が外部の権威や期待に依存するのではなく、自分自身の内なる声に基づいて人生を切り開いていく力を指します。これは21世紀の高等教育における重要な学習成果として位置づけられています。</p>
        
        <div class="practical-tips">
            <strong>💡 なぜ重要？</strong>
            <ul>
                <li>批判的思考力と主体的な学習態度の育成</li>
                <li>複雑な社会で自律的に生きる力の獲得</li>
                <li>多様な価値観の中で自分の軸を持つ力の形成</li>
            </ul>
        </div>
        
        <!-- 新規追加：フレーズクラウドセクション -->
        <button class="toggle-button" onclick="togglePhrasesCloud()">💭 多様な声・問いを表示する <span class="toggle-icon" id="phrases-toggle-icon">▼</span></button>
        
        <div class="phrases-cloud-section">
            
            <div class="phrases-cloud-container" id="phrases-cloud-container" style="display: none;">
                <div class="phrases-iframe-wrapper">
                    <iframe id="phrases-cloud-iframe"
                            src="./3d_phrases_cloud_embed.html"
                            width="100%"
                            height="800px"
                            frameborder="0"
                            style="border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    </iframe>
                </div>
                
                <div class="phrases-cloud-description">
                    <h4>上の画面について</h4>
                    <p>このビューアは、設定したフレーズを3D空間に表示させるものです。（※最初に表示されるテキストはサンプルとして作成したものです）</p>
                    <ul>
                        <li><strong>インタラクティブ表示：</strong>マウスで視点を自由に変更可能</li>
                        <li><strong>カテゴリ分類：</strong>色分けによる関心領域の可視化</li>
                        <li><strong>詳細確認：</strong>各フレーズをクリックして詳細を確認</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>📊 3つの成長次元</h2>
        <p>セルフ・オーサーシップの成長は、以下の3つの次元で捉えることができます：</p>
        
        <div class="dimension-grid">
            <div class="dimension-card">
                <h3>🧠 認識論的次元</h3>
                <p><strong>問い：「私はどのように知るのか？」</strong></p>
                <p>知識や真実をどのように捉え、理解するかに関する成長</p>
                <div class="example">
                    例：「教科書に書いてあるから正しい」から「複数の視点を比較検討して自分の考えを形成する」へ
                </div>
            </div>
            
            <div class="dimension-card">
                <h3>🪞 対自関係次元</h3>
                <p><strong>問い：「私は何者か？」</strong></p>
                <p>自己アイデンティティや価値観の形成に関する成長</p>
                <div class="example">
                    例：「親や周囲が期待する自分」から「自分自身で選択した価値観に基づく自分」へ
                </div>
            </div>
            
            <div class="dimension-card">
                <h3>🤝 対人関係次元</h3>
                <p><strong>問い：「他者とどのように関わるか？」</strong></p>
                <p>他者との関係性をいかに構築するかに関する成長</p>
                <div class="example">
                    例：「承認をしてもらうための関係」から「相互に自立した対等な関係性での協働」へ
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>🚀 成長の3局面（基本）</h2>
        <p>学生は以下の3つの局面を通じて成長していきます：</p>
        
        <div class="phase-container">
            <div class="phase-card phase-1">
                <h3>1️⃣ 外的公式に従う局面</h3>
                <p><strong>特徴：</strong></p>
                <ul>
                    <li>権威者の言うことを鵜呑みにする</li>
                    <li>他者からの承認を求める</li>
                    <li>外的な期待に自己を合わせる</li>
                </ul>
                <p><strong>学生の状態：</strong><br>
                「先生が言ったから」「みんながそうしているから」という理由で行動</p>
            </div>
            
            <div class="phase-card phase-2">
                <h3>2️⃣ 岐路の局面</h3>
                <p><strong>特徴：</strong></p>
                <ul>
                    <li>外的権威への疑問が生じる</li>
                    <li>内なる声の必要性を認識</li>
                    <li>葛藤や不協和を経験</li>
                </ul>
                <p><strong>学生の状態：</strong><br>
                「本当にそれでいいのか？」「自分の考えは？」という問いが生まれる</p>
            </div>
            
            <div class="phase-card phase-3">
                <h3>3️⃣ セルフ・オーサーシップ局面</h3>
                <p><strong>特徴：</strong></p>
                <ul>
                    <li>内なる声を信頼する</li>
                    <li>自己決定に基づく行動</li>
                    <li>内なる基盤の構築</li>
                </ul>
                <p><strong>学生の状態：</strong><br>
                「私はこう考える」「私の価値観に基づいて行動する」</p>
            </div>
        </div>
        
        <button class="toggle-button" onclick="toggleSection('detailed-journey')">🔍 より詳細な成長の旅を見る</button>
        
        <div id="detailed-journey" class="collapsible">
            <div class="advanced-section">
                <h3>🗺️ セルフ・オーサーシップの成長の旅</h3>
                <p>各次元における成長の詳細な様相を以下の表に示します：</p>
                
                <!-- Canvas 2Dビジュアライゼーション統合エリア -->
                <div class="canvas-2d-integration">
                    <h4>🗺️ 成長の旅のビジュアライゼーション</h4>
                    <p>以下のインタラクティブなアニメーションは、セルフ・オーサーシップの成長イメージの表現です。マウスで操作してみてください。<br>🎨：これはセルフ・オーサーシップの成長を集団・集合的な視点から比喩的に表現した例です。</p>

                    <div id="journey-canvas-container" class="journey-canvas-container">
                        <canvas id="journey-canvas"></canvas>
                        <div class="journey-controls">
                            <h5>🗺️ 成長の旅</h5>
                            <div class="journey-stage-info" id="journey-stageInfo">
                                重力の支配<br><small>外部の権威に従属している状態</small>
                            </div>
                            
                            <div class="journey-button-group">
                                <button onclick="previousJourneyStage()" id="journey-prevButton" title="前のステージ">←</button>
                                <button onclick="nextJourneyStage()" id="journey-nextButton" title="次のステージ">→</button>
                                <button onclick="resetJourney()" class="reset-btn" title="リセット">🔄</button>
                            </div>
                            
                            <div class="journey-stage-indicator">
                                <div class="journey-stage-dot active" id="journey-dot0"></div>
                                <div class="journey-stage-dot" id="journey-dot1"></div>
                                <div class="journey-stage-dot" id="journey-dot2"></div>
                                <div class="journey-stage-dot" id="journey-dot3"></div>
                            </div>
                        </div>
                        
                        <div class="journey-instructions" onclick="toggleInstructions()" id="journey-instructions">
                            <p><small>💡 操作ガイド <span id="instructions-arrow">▼</span></small></p>
                            <div class="journey-instructions-detail" id="instructions-detail">
                                <p><small>
                                    🖱️ <strong>マウス/タッチ</strong><br>
                                    パーティクルに影響を与える<br><br>
                                    🎯 <strong>ステージ操作</strong><br>
                                    ←→ボタンで段階切り替え<br><br>
                                    🔄 <strong>リセット</strong><br>
                                    初期状態に戻す
                                </small></p>
                            </div>
                        </div>
                        
                        <!-- 物理情報表示セクションを非表示化
                        <div class="journey-physics-info" id="journey-physicsInfo">
                            重力強度: 強<br>
                            自律性: 0%<br>
                            調和度: 0%
                        </div>
                        -->
                    </div>
                </div>
                
                <div class="journey-table">
                    <table>
                        <thead>
                            <tr>
                                <th>次元</th>
                                <th>外的公式</th>
                                <th>岐路</th>
                                <th>セルフ・オーサーシップ</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>認識論的</strong></td>
                                <td>
                                    • 知識の源泉として権威に信頼を譲る<br>
                                    • 知識を確実（または部分的に確実）と見る<br>
                                    • 外的に規定される信念となるような知識命題を評価するための内なる基盤を欠く
                                </td>
                                <td>
                                    • 不確実性と多元的視点の自覚と受容を進める<br>
                                    • 権威者の知識を受容することから知識命題を採用するパーソナルなプロセスへ移る<br>
                                    • 信念を選択するために責任を持つ必要性を認める
                                </td>
                                <td>
                                    • 知識を文脈的なものと見る<br>
                                    • 利用可能なエビデンスや参照枠組みの観点で判断を構築・評価・解釈する<br>
                                    • 内的信念システムを発達させる
                                </td>
                            </tr>
                            <tr>
                                <td><strong>対自関係</strong></td>
                                <td>
                                    • 自分の価値観や社会的アイデンティティの自覚を欠く<br>
                                    • アイデンティティの諸要素の調整を欠く<br>
                                    • 他者からの肯定を要する
                                </td>
                                <td>
                                    • 外的な他者の物の見方から区別される、自身の価値観とアイデンティティの感覚の自覚を進める<br>
                                    • 生じつつある内的価値観と外的圧力との間に緊張がある<br>
                                    • 自らのアイデンティティを作り出すために責任を持つ必要性を認める
                                </td>
                                <td>
                                    • 内的に生成し、経験と選択の解釈を調整する<br>
                                    • 自己の感覚をつくる際に自身の価値観とアイデンティティを選択する<br>
                                    • 一貫した内的な自己の感覚に根ざす
                                </td>
                            </tr>
                            <tr>
                                <td><strong>対人関係</strong></td>
                                <td>
                                    • 同じような他者たちとの依存関係がアイデンティティと必要な肯定の源泉となる<br>
                                    • 他者の肯定を得ていくこととしての関係への参加
                                </td>
                                <td>
                                    • 依存関係の限界への自覚を進める<br>
                                    • 自身のアイデンティティを自立的な諸関係を構築することへ持っていく必要性を認める<br>
                                    • 自己を再構築する、または依存関係から脱出させるために闘う
                                </td>
                                <td>
                                    • 多様な他者たちと真正な相互依存関係に取り組むことができる<br>
                                    • 関係性の必要性を相互的に交渉する<br>
                                    • 他者の視点を本当の意味で考慮に入れる
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>🔬 成長局面の精緻化</h2>
        <p>ウォバシュ全国調査研究により、セルフ・オーサーシップの成長の各局面にはさらに詳細な下位局面があることが明らかになりました。外的な権威に従う局面から、葛藤や不協和の経験を経て内なる声の必要性を認識し、内なる基盤を構築するまでの詳しい変容過程や移行の契機が示されています。</p>
        
        <button class="toggle-button" onclick="toggleSection('refined-phases')">🔬 精緻化された成長局面を見る</button>
        
        <div id="refined-phases" class="collapsible">
            <div class="advanced-section">
                <!-- 3D可視化統合エリア -->
                <div class="sa-3d-integration">
                    <h4>🔬 成長局面の変容のイメージ</h4>
                    <p>以下の3Dアニメーションで、各成長段階を視覚的に体験できます。下のテキストの段階名をクリックして切り替えてください。<br>🎨：これは個人内のセルフ・オーサーシップの成長を比喩的に表現した一例です。</p>

                    <div id="refined-3d-container" class="sa-3d-container">
                        <div id="refined-3d-scene">
                            <!-- 3Dシーン内浮遊ボタン -->
                            <button id="reset-view-btn" class="floating-view-control">
                                <span>↺</span>
                                <span class="tooltip">視点リセット</span>
                            </button>
                            <button id="reinit-3d-btn" class="floating-view-control" style="right: 60px;">
                                <span>⟲</span>
                                <span class="tooltip">3D環境初期化</span>
                            </button>
                            <button id="explanation-toggle-btn" class="floating-view-control" style="right: 120px;">
                                <span>❓</span>
                                <span class="tooltip">要素説明表示</span>
                            </button>
                        </div>
                        <div class="sa-3d-loading" id="refined-3d-loading">
                            <div class="loading-spinner"></div>
                            <p>3D環境を初期化中...</p>
                        </div>
                        <div class="sa-3d-controls" id="refined-3d-controls" style="display: none;">
                            <div class="stage-info-display" id="stage-info-display">
                                <!-- titleElement を一時的に非表示化（重複表示回避のため） -->
                                <!-- <h5 id="current-stage-title">Ea: 外的権威を信頼する</h5> -->
                                <p id="current-stage-description">外的権威を信頼</p>
                            </div>
                            <div class="stage-controls">
                                <button data-stage="Ea" class="stage-btn active">Ea</button>
                                <button data-stage="Eb" class="stage-btn">Eb</button>
                                <button data-stage="Ec" class="stage-btn">Ec</button>
                                <button data-stage="EI" class="stage-btn">E(I)</button>
                                <button data-stage="E-I" class="stage-btn">E-I</button>
                                <button data-stage="I-E" class="stage-btn">I-E</button>
                                <button data-stage="IE" class="stage-btn">I(E)</button>
                                <button data-stage="Ia" class="stage-btn">Ia</button>
                                <button data-stage="Ib" class="stage-btn">Ib</button>
                                <button data-stage="Ic" class="stage-btn">Ic</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="sa-3d-description">
                        <p><small>💡 3D空間をドラッグして視点を変更、マウスホイールでズームイン・アウト、下のテキストの段階名をクリックして成長段階を切り替えられます。</small></p>
                    </div>
                </div>
                
                <h3>外的な意味形成局面の詳細</h3>
                
                <div class="sub-phase">
                    <h4>Ea: 外的権威を信頼する</h4>
                    <p>一貫して盲目的に外的資源を信頼し、そのことの欠点の可能性を認識することもない。</p>
                </div>
                
                <div class="sub-phase">
                    <h4>Eb: 外的権威を信頼することとの緊張</h4>
                    <p>一貫して外的資源を信頼するが、そうすることの緊張を経験する（とくに外的資源の間に葛藤がある場合）。葛藤を解消しようとして複数の権威の方を見る。</p>
                </div>
                
                <div class="sub-phase">
                    <h4>Ec: 外的権威を信頼することの欠点を認識する</h4>
                    <p>外的権威への信頼を継続するが、そのことの欠点を認識している。</p>
                </div>
                
                <h3>岐路局面の詳細</h3>
                
                <div class="sub-phase">
                    <h4>E(I): 外的権威に疑問を持つ（岐路に入る）</h4>
                    <p>内なる声の必要性を自覚するも、外的資源への信頼を継続する。外的意味形成のジレンマを自覚するが、どう進めばいいかわからない。</p>
                </div>
                
                <div class="sub-phase">
                    <h4>E-I: 内なる声を構築する</h4>
                    <p>意味形成の新しい仕方を構築するよう能動的に動き始めるが、以前の外的位置に「後退する」こともある。</p>
                </div>
                
                <div class="sub-phase">
                    <h4>I-E: 内なる声を聴く（岐路から出る）</h4>
                    <p>内なる声を注意深く聞き取り始め、外的資源を押しのけつつある。外的資源がまだ強く、内なる声を一貫して維持することを難しくしている。</p>
                </div>
                
                <div class="sub-phase">
                    <h4>I(E): 内なる声を育む</h4>
                    <p>内なる声を能動的に育み始め、内なる声が多くの外的資源を媒介する。他者の視点が自身の視点を包摂してしまうそれまでの傾性に戻らないように意識する。</p>
                </div>
                
                <h3>内的な意味形成（セルフ・オーサーシップ）局面の詳細</h3>
                
                <div class="sub-phase">
                    <h4>Ia: 内なる声を信頼する</h4>
                    <p>信念、価値、アイデンティティ、関係を洗練するのに十分なほど内なる声を信頼する。反応を形作り、外的資源を管理するのに内なる声を活用する。</p>
                </div>
                
                <div class="sub-phase">
                    <h4>Ib: 内なる基盤を築く</h4>
                    <p>外的資源にどう反応するかを導く人生哲学へのコミットメントを形成するのに十分なほど内なる声を信頼する。</p>
                </div>
                
                <div class="sub-phase">
                    <h4>Ic: 内なるコミットメントを確保する</h4>
                    <p>人生哲学を自分の存在の核として固め、それを第二の性質として生きる。</p>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>🛠️ 実践原則：ラーニング・パートナーシップ・モデル（LPM）</h2>
        <p>学生のセルフ・オーサーシップ成長を支援する3つの実践原則：</p>
        
        <div class="principle">
            <h3>1. 学習者の知る能力を確かめる</h3>
            <p>学生がどのように知識を捉えているかを理解し、その段階に応じたサポートを提供する</p>
            <p><strong>実践例：</strong>「なぜそう思うの？」「どうやってその結論に至った？」という問いかけ</p>
        </div>
        
        <div class="principle">
            <h3>2. 学生の学びをその学生の経験の中に位置づける</h3>
            <p>抽象的な学びではなく、学生自身の経験と結びつけて理解を深める</p>
            <p><strong>実践例：</strong>「この理論はあなたの経験とどう関連する？」という振り返り</p>
        </div>
        
        <div class="principle">
            <h3>3. 学びを相互的な意味構成と定義する</h3>
            <p>教員と学生、学生同士が対等な立場で意味を構築していく</p>
            <p><strong>実践例：</strong>ディスカッションやグループワークでの協働的な知識構築</p>
        </div>
        
        <button class="toggle-button" onclick="toggleSection('lpm-steps')">📋 LPM実践の10ステップを見る</button>
        
        <div id="lpm-steps" class="collapsible">
            <div class="advanced-section">
                <h3>ラーニング・パートナーシップ・モデル（LPM）実践の10ステップ</h3>
                
                <h4>フェーズ1：学習目標と学習者のセルフ・オーサーシップ能力をアセスメントする</h4>
                
                <div class="lpm-step">
                    <h5>ステップ1：文脈の選定</h5>
                    <p>学生や同僚との関わりから、LPMを用いてセルフ・オーサーシップを向上するのに適した実践は何か？</p>
                    <p><em>例：卒業論文、ピア・サポート、キャリア相談</em></p>
                </div>
                
                <div class="lpm-step">
                    <h5>ステップ2：その文脈での学習目標の設定</h5>
                    <ul>
                        <li>その文脈で現在、達成しようとしている学習成果は何か？</li>
                        <li>セルフ・オーサーシップをより包括的な目標と考えると、現在設定している学習成果＝目標をどのように設定することになるか？</li>
                        <li>参加者に何をよりよく理解してもらいたいか？何をよりうまく取り組めるようになってもらいたいか？</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ステップ3：セルフ・オーサーシップの視点から学習目標の検討</h5>
                    <ul>
                        <li><strong>認知能力：</strong>それらの学習目標を達成するのに、どのような仕方で知識を構築するか？</li>
                        <li><strong>対自関係能力：</strong>自分自身をどのような仕方で見て理解することが求められるか？</li>
                        <li><strong>対人関係能力：</strong>他者との関係の中の自分自身をどのような仕方で理解することが求められるか？</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ステップ4：その文脈での学習者のセルフ・オーサーシップ特徴の考慮</h5>
                    <ul>
                        <li>学習者が共通して用いる知識構築の仕方は？</li>
                        <li>学習者によって示される自分自身の見方は？</li>
                        <li>学習者が示す他者との関係の中の自分自身の見方は？</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ステップ5：学習目標と学習者能力の間の整合性と不整合の特定</h5>
                    <ul>
                        <li>学習目標と学習者のセルフ・オーサーシップ能力はどのように結びつくか？</li>
                        <li>それらの間にある不整合はどこか？</li>
                        <li>どんな成長目標が、必要な能力と狙いとする学習成果の間を橋渡しするのに役立つか？</li>
                    </ul>
                </div>
                
                <h4>フェーズ2：「成長の架け橋」をデザインする</h4>
                
                <div class="lpm-step">
                    <h5>ステップ6：成長する「カリキュラム」の素描</h5>
                    <ul>
                        <li>学習目標と成長目標は、どのように時間をかけてステップに変換されるか？</li>
                        <li>学習者への関与の長さにともなって、最初の時点で、学習目標と成長目標はどのような形態となるか？</li>
                        <li>ステップのどれがこれまでに通過し、どれがこれから向かう必要のあるものか？</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ステップ7：3つの想定に取り組む</h5>
                    <p><strong>知識は複雑で社会的に構築される / 自己が知識構築の中心である / 熟練と権威は相互に共有される</strong></p>
                    <ul>
                        <li>あなたの実践領域において、これらの想定は現在どのような仕方で示されているか？</li>
                        <li>どうすればより効果的にこれらの想定を学習者に伝えられるか？</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ステップ8：3つの原則に取り組む</h5>
                    <p>学習者の知る能力を確かめる / 学習を学習者の経験に位置づける / 学習者と意味を相互構築する</p>
                    <ul>
                        <li>これらの原則は現在どのような仕方で示されているか？</li>
                        <li>どうすればより効果的にこれらの原則を学習者に伝えられるか？</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ステップ9：整合性と不整合を再吟味する</h5>
                    <ul>
                        <li>新しい計画は、整合しているところを揺るがさないか？</li>
                        <li>この計画は、どの不整合に取り組むのか？</li>
                        <li>取り組むべき不整合のうち、残るものはどれか？</li>
                    </ul>
                </div>
                
                <div class="lpm-step">
                    <h5>ステップ10：効果を評価するための計画を素描する</h5>
                    <ul>
                        <li>参加者のセルフ・オーサーシップ能力を促進するのにどれほど効果があったかを決めるエビデンスとして使えるものは何か？</li>
                        <li>そのエビデンスはどのように集められるだろうか？</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>📋 実践チェックリストの例</h2>
        
        <div class="checklist">
            <h4>取り組み検討時の活用</h4>
            <ul>
                <li>学生に「自分の考え」を求める機会を設けているか</li>
                <li>多様な視点に触れる機会を提供しているか</li>
                <li>失敗を恐れず挑戦できる環境を作っているか</li>
                <li>振り返りと省察の時間を確保しているか</li>
                <li>学生の成長段階に応じた課題設定をしているか</li>
            </ul>
        </div>
        
        <div class="checklist">
            <h4>学生支援・アドバイジングでの活用</h4>
            <ul>
                <li>学生の現在の成長局面を把握しているか</li>
                <li>答えを与えるのではなく、問いを投げかけているか</li>
                <li>学生の内なる声に耳を傾けているか</li>
                <li>適切なチャレンジとサポートのバランスを取っているか</li>
                <li>学生の自己決定を尊重しているか</li>
            </ul>
        </div>
    </div>

    <div class="section">
        <h2>📈 成長を促す具体的な取り組み例</h2>
        
        <table>
            <thead>
                <tr>
                    <th>取り組み</th>
                    <th>期待される効果</th>
                    <th>対応する次元</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>ポートフォリオ作成</td>
                    <td>自己の成長過程の可視化と省察</td>
                    <td>対自関係</td>
                </tr>
                <tr>
                    <td>ディベート・討論</td>
                    <td>多様な視点の理解と自己の立場の明確化</td>
                    <td>認識論的</td>
                </tr>
                <tr>
                    <td>協働プロジェクト</td>
                    <td>相互依存的な関係構築の経験</td>
                    <td>対人関係</td>
                </tr>
                <tr>
                    <td>リフレクション・ジャーナル</td>
                    <td>内なる声の発見と育成</td>
                    <td>全次元</td>
                </tr>
                <tr>
                    <td>メンタリング・プログラム</td>
                    <td>対話を通じた自己理解の深化</td>
                    <td>全次元</td>
                </tr>
                <tr>
                    <td>サービス・ラーニング</td>
                    <td>社会的文脈での自己の位置づけの理解</td>
                    <td>全次元</td>
                </tr>
                <tr>
                    <td>ライティング・カリキュラム</td>
                    <td>段階的な知的成長と自己表現力の育成</td>
                    <td>認識論的・対自関係</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="section">
        <h2>💡 実践のポイント</h2>
        
        <div class="practical-tips">
            <h3>成長を支援する際の留意点</h3>
            <ul>
                <li><strong>非線形な成長を理解する：</strong>学生は3つの局面を行きつ戻りつしながら成長します</li>
                <li><strong>次元間の連動を意識する：</strong>3つの次元は相互に影響し合います</li>
                <li><strong>文脈の重要性：</strong>学生の背景や環境を考慮したサポートが必要です</li>
                <li><strong>不協和の活用：</strong>葛藤や矛盾は成長の契機となります</li>
                <li><strong>長期的視点：</strong>セルフ・オーサーシップの成長は時間がかかるプロセスです</li>
                <li><strong>対自関係次元が中心：</strong>セルフ・オーサーシップは対自関係次元を軸とする成長です</li>
            </ul>
        </div>
        
        <div class="practical-tips">
            <h3>成長の契機となるもの</h3>
            <ul>
                <li><strong>外的意味形成段階：</strong>外的権威や期待の間の衝突・葛藤（不協和）</li>
                <li><strong>岐路段階：</strong>内なる声の発見と活用経験</li>
                <li><strong>セルフ・オーサーシップ段階：</strong>内なる基盤に基づく自己決定と行動の積み重ね</li>
            </ul>
        </div>
        
        <!-- 新規追加：ジャーニーマップセクション -->
        <button class="toggle-button" onclick="toggleJourneyMap()">📊 成長の道のり（例）を見る <span class="toggle-icon" id="journey-toggle-icon">▼</span></button>
        
        <div class="journey-map-section">
            
            <div class="journey-map-container" id="journey-map-container" style="display: none;">
                <div class="journey-iframe-wrapper">
                    <iframe id="journey-map-iframe"
                            src="./journey-map-embed.html"
                            width="100%"
                            height="800px"
                            frameborder="0"
                            style="border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    </iframe>
                </div>
                
                <div class="journey-map-description">
                    <h4>ジャーニーマップについて</h4>
                    <p>このビューアは、セルフ・オーサーシップ理論に基づいた学生の成長過程を視覚化したものです。シナリオは生成AIを用いて作成した仮想のものです。</p>
                    <ul>
                        <li><strong>ペルソナ比較：</strong>異なる学習パターンの比較分析</li>
                        <li><strong>成長/停滞分析：</strong>成長・停滞パターンの可視化</li>
                        <li><strong>分岐点特定：</strong>重要な転換点の詳細分析</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>🤖 付録：セルフ・オーサーシップの成長支援のための生成AI活用ツール（随時追加予定）</h2>
        <p>セルフ・オーサーシップの各段階における成長支援の検討にあたり、以下のツールも活用いただけます。</p>
        
        <div class="dimension-grid">
            <div class="dimension-card">
                <h3>💭 アイデア独り言ツール</h3>
                <p>現在検討中のアイデアや企画について、セルフ・オーサーシップを大切にする観点から生成AIにフィードバックをしてもらうためのプロンプト生成ツールです。</p>
                <a href="javascript:void(0)" onclick="openIdeaFeedbackTool()" class="tool-link">
                    ツールを開く →
                </a>
            </div>
            
            <div class="dimension-card">
                <h3>📋 学生ペルソナ作成ツール</h3>
                <p>多様な学生ペルソナを作成し、個々人の様々な成長シナリオの理解や学習・成長支援の検討を効果的に進められるよう設計されたツールです。</p>
                <a href="https://hirokioshiro.github.io/persona_selection_tool/" target="_blank" class="tool-link">
                    ツールを開く →
                </a>
            </div>
            
            <div class="dimension-card">
                <h3>🛠️ 学生ペルソナ活用ツール</h3>
                <p>作成した学生ペルソナを活用し、セルフ・オーサーシップを重視した取り組みを様々なフレームワークも参考にしながら検討を進めるためのツールです。</p>
                <a href="https://hirokioshiro.github.io/support_design_prompt_generator/" target="_blank" class="tool-link">
                    ツールを開く →
                </a>
            </div>

            <div class="dimension-card">
                <h3>🎯 概念可視化プロンプト生成</h3>
                <p>複雑な概念や理論を視覚的に理解しやすい形で表現するためのプロンプトを自動生成し、リフレクションや対話を促進する素材として活用することができます。</p>
                <a href="https://hirokioshiro.github.io/concept_visualization_prompt_generator/" target="_blank" class="tool-link">
                    ツールを開く →
                </a>
            </div>
            
            <div class="dimension-card">
                <h3>🃏 パターン・カード作成</h3>
                <p>セルフ・オーサーシップの成長を後押しするようなパターンをカードとして作成し、学習者が各自の状況に応じて自分自身へ問いかけを行う機会を提供できます。</p>
                <a href="https://hirokioshiro.github.io/pattern_card_generator/" target="_blank" class="tool-link">
                    ツールを開く →
                </a>
            </div>

            <div class="dimension-card">
                <h3>🃏 問いかけカード作成</h3>
                <p>ふと立ち止まって自分に問いかけてみたくなるような様々な問いをカードとして作成し、学習者が各自の状況に応じて自分自身へ問いかけを行う機会を提供できます。</p>
                <a href="https://hirokioshiro.github.io/question_card_generator/" target="_blank" class="tool-link">
                    ツールを開く →
                </a>
            </div>
        </div>
    </div>

    <script>
        // Self-Authorship 3D Integration Module
        
        // 地面移動システム - セルフ・オーサーシップの人生の旅路を地面の流れで表現
        class GroundMovementSystem {
            constructor(scene, camera) {
                this.scene = scene;
                this.camera = camera;
                this.groundDots = [];
                this.currentDirection = { x: 0, z: 1 }; // デフォルト：前進
                this.speed = 0.1;
                this.gridSize = 50;
                this.spacing = 4;
                this.depth = 200;
                this.isActive = false;
                this.currentStage = 'Ea'; // 現在のステージを追跡
                this.behaviorState = null; // 行動状態管理
                this.stageConfig = null; // 段階固有の設定
                this.originalSpeed = 0.1; // 元の速度を保存
                
                // セルフ・オーサーシップ段階別の動作パターン（地面は前後のみ流れる）
                this.movementPatterns = {
                    // EA段階: 外部権威依存期 - 制限的で慎重な動き
                    'Ea': { type: 'guided', speed: 0.06, direction: { x: 0, z: 0.8 }, pause: true },
                    'Eb': { type: 'guided', speed: 0.05, direction: { x: 0, z: 0.9 }, pause: true },
                    'Ec': { type: 'guided', speed: 0.04, direction: { x: 0, z: 1.0 }, pause: false },
                    
                    // 岐路段階: 探索と迷いの期 - 前後の動きのみで表現
                    'EI': { type: 'exploring', speed: 0.03, direction: { x: 0, z: 0.7 }, pause: true },
                    'E-I': { type: 'wandering', speed: 0.02, direction: { x: 0, z: 0.5 }, pause: true },
                    'I-E': { type: 'questioning', speed: 0.02, direction: { x: 0, z: 0.2 }, pause: true },
                    
                    // IA段階: 内的権威確立期 - 自律的で確信に満ちた動き
                    'IE': { type: 'emerging', speed: 0.025, direction: { x: 0, z: 1.2 }, pause: false },
                    'Ia': { type: 'confident', speed: 0.03, direction: { x: 0, z: 1.3 }, pause: false },
                    'Ib': { type: 'integrating', speed: 0.04, direction: { x: 0, z: 1.1 }, pause: false },
                    'Ic': { type: 'authoring', speed: 0.05, direction: { x: 0, z: 1.4 }, pause: false }
                };
            }
            
            // 地面ドット配列の初期化
            initializeGroundDots() {
                // 既存のドットをクリア
                this.clearGroundDots();
                
                const dotGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const dotMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.6
                });
                
                // 格子状にドットを配置（波打つ地形）
                const extraMargin = 20; // ループ処理用の余裕範囲
                for (let x = -this.gridSize - extraMargin; x <= this.gridSize + extraMargin; x += this.spacing) {
                    for (let z = -this.depth; z <= this.depth; z += this.spacing) {
                        const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                        
                        // 波打つ地形の計算（人生の起伏を表現）
                        const waveHeight = this.calculateTerrainHeight(x, z);
                        
                        dot.position.set(x, -5 + waveHeight, z); // 地面レベル + 波の高さ
                        
                        // 波の高さに応じて透明度を調整（高いところは少し明るく）
                        const heightOpacity = 0.4 + (waveHeight + 1) * 0.1; // 0.4〜0.6の範囲
                        dot.material = dotMaterial.clone();
                        dot.material.opacity = Math.min(heightOpacity, 0.7);
                        
                        this.groundDots.push(dot);
                        this.scene.add(dot);
                    }
                }
                
                console.log(`[GroundSystem] Initialized ${this.groundDots.length} ground dots`);
            }
            
            // 波打つ地形の高さを計算（人生の道のりの起伏を表現）
            calculateTerrainHeight(x, z) {
                // 複数の波を重ね合わせて自然な起伏を作成
                const time = Date.now() * 0.0001; // ゆっくりとした時間変化
                
                // 段階に応じた波の強度調整
                const stageIntensity = this.getWaveIntensityForStage();
                
                // 大きな波（人生の大きな起伏）
                const largeWave = Math.sin(x * 0.05 + time) * Math.cos(z * 0.03 + time * 0.5) * 0.8 * stageIntensity.large;
                
                // 中程度の波（日常の変化）
                const mediumWave = Math.sin(x * 0.15 + z * 0.1 + time * 2) * 0.4 * stageIntensity.medium;
                
                // 小さな波（細かい変動）
                const smallWave = Math.sin(x * 0.3 + z * 0.4 + time * 3) * 0.2 * stageIntensity.small;
                
                // 距離に基づく減衰（中央から離れるほど平坦に）
                const distanceFromCenter = Math.sqrt(x * x + z * z);
                const dampingFactor = Math.max(0.1, Math.exp(-distanceFromCenter * 0.02));
                
                // 波を合成し、適度な起伏に調整
                const combinedHeight = (largeWave + mediumWave + smallWave) * dampingFactor;
                
                // 最終的な高さ（-1〜1の範囲に制限）
                return Math.max(-1, Math.min(1, combinedHeight));
            }
            
            // 段階に応じた波の強度を取得
            getWaveIntensityForStage() {
                const stage = this.currentStage || 'Ea';
                
                // 各段階の特徴に応じた波の強度設定
                const intensityMap = {
                    // Ea段階: 穏やかな波（安定した環境）
                    'Ea': { large: 0.6, medium: 0.8, small: 1.0 },
                    // Ec段階: 激しい波（葛藤と混乱）
                    'Ec': { large: 1.2, medium: 1.4, small: 1.6 },
                    // EI段階: やや不安定な波（自分らしさの模索）
                    'EI': { large: 0.9, medium: 1.1, small: 1.3 },
                    // E-I段階: 変動の大きい波（価値観の衝突）
                    'E-I': { large: 1.1, medium: 1.3, small: 1.1 },
                    // I-E段階: 徐々に安定する波（内なる声の確立）
                    'I-E': { large: 0.8, medium: 1.0, small: 0.9 },
                    // Ia段階: 複雑な波（複数の価値観の統合）
                    'Ia': { large: 1.0, medium: 1.2, small: 1.0 },
                    // デフォルト
                    'default': { large: 0.8, medium: 1.0, small: 1.0 }
                };
                
                return intensityMap[stage] || intensityMap['default'];
            }
            
            // 段階に応じた動作パターンの設定
            setMovementPattern(stage) {
                if (!this.movementPatterns[stage]) {
                    console.warn(`[GroundSystem] Unknown stage: ${stage}`);
                    return;
                }
                
                const pattern = this.movementPatterns[stage];
                this.speed = pattern.speed;
                this.currentDirection = { ...pattern.direction };
                this.currentStage = stage; // 現在のステージを更新
                
                // 段階固有の行動パターンを初期化
                this.initializeStageSpecificBehaviors(stage, pattern);
                
                console.log(`[GroundSystem] Set pattern for stage ${stage}:`, pattern);
            }
            
            // 段階固有の行動パターンを初期化
            initializeStageSpecificBehaviors(stage, pattern) {
                // 段階別の特殊行動頻度設定を先に設定
                this.stageConfig = this.getStageSpecificConfig(stage);
                
                // 行動状態の初期化
                this.behaviorState = {
                    currentBehavior: 'normal', // normal, pausing, wandering
                    behaviorStartTime: Date.now(),
                    behaviorDuration: 0,
                    pauseCounter: 0,
                    wanderDirection: { x: 0, z: 1 },
                    // 振り返り関連のプロパティ
                    shouldReflect: false,           // 立ち止まり中に振り返るかどうか
                    reflectionAngle: 0,             // 振り返り角度
                    reflectionStartTime: null,      // 振り返り開始時刻
                    nextBehaviorTime: Date.now() + this.calculateNextBehaviorDelay()
                };
            }
            
            // 段階別の詳細設定を取得
            getStageSpecificConfig(stage) {
                const configs = {
                    // EA段階: 慎重で規則的な動き
                    'Ea': {
                        pauseFrequency: 0.1, // 高い立ち止まり頻度
                        pauseDuration: [800, 1000], // 1-2.5秒の立ち止まり
                        wanderFrequency: 0.1, // 少ない迷い
                        wanderIntensity: 0.2, // 軽い迷い
                        reflectionFrequency: 0.4, // 高い振り返り頻度
                        reflectionAngle: Math.PI / 4, // 45度の振り返り
                        behaviorTransition: 3000 // 3秒間隔での行動変化
                    },
                    'Eb': {
                        pauseFrequency: 0.5, // より高い立ち止まり頻度（複数権威確認のため）
                        pauseDuration: [1200, 2500], // 長めの停止（複数方向確認時間）
                        wanderFrequency: 0.1, // 迷いは控えめ（振り返りを重視）
                        wanderIntensity: 0.25,
                        reflectionFrequency: 0.8, // 非常に高い振り返り頻度
                        reflectionAngle: Math.PI, // 180度を基本とし、複数段階で実装
                        behaviorTransition: 2200, // やや短めの間隔で頻繁な権威確認
                        // Eb専用: 複数権威確認パターン
                        isMultiAuthorityScanning: true,
                        authorityDirections: [
                            Math.PI / 6,      // 右30度
                            -Math.PI / 6,     // 左30度  
                            Math.PI / 3,      // 右60度
                            -Math.PI / 3,     // 左60度
                            Math.PI * 0.75,   // 右135度
                            -Math.PI * 0.75,  // 左135度
                            Math.PI           // 後方180度
                        ]
                    },
                    'Ec': {
                        pauseFrequency: 0.25,
                        pauseDuration: [600, 1500],
                        wanderFrequency: 0.2,
                        wanderIntensity: 0.4,
                        reflectionFrequency: 0.3,
                        reflectionAngle: Math.PI / 1,
                        behaviorTransition: 2500
                    },
                    
                    // 岐路段階: 最も複雑で変化に富んだ動き
                    'EI': {
                        pauseFrequency: 0.4, // 非常に高い立ち止まり頻度
                        pauseDuration: [1500, 3000], // 長い思考時間
                        wanderFrequency: 0.6, // 高い迷い頻度
                        wanderIntensity: 0.8, // 強い迷い
                        reflectionFrequency: 0.5,
                        reflectionAngle: Math.PI * 1, // 180度の振り返り
                        behaviorTransition: 1500 // 頻繁な行動変化
                    },
                    'E-I': {
                        pauseFrequency: 0.5, // 最高の立ち止まり頻度
                        pauseDuration: [2000, 4000], // 最も長い思考時間
                        wanderFrequency: 0.7, // 最高の迷い頻度
                        wanderIntensity: 1.0, // 最強の迷い
                        reflectionFrequency: 0.6,
                        reflectionAngle: Math.PI * 1.5, // 270度の振り返り
                        behaviorTransition: 1200, // 最も頻繁な行動変化
                        isMultiAuthorityScanning: true, // E-Iステージでもスキャニング機能を有効
                        authorityDirections: [
                            { angle: Math.PI * 2/3, weight: 0.2 },   // 右前120度
                            { angle: -Math.PI * 2/3, weight: 0.2 },  // 左前120度
                            { angle: Math.PI/2, weight: 0.2 },       // 右横90度
                            { angle: -Math.PI/2, weight: 0.2 },      // 左横90度
                            { angle: Math.PI/3, weight: 0.1 },       // 右前60度
                            { angle: -Math.PI/3, weight: 0.1 },      // 左前60度
                            { angle: Math.PI * 5/6, weight: 0.1 },   // 右後150度
                            { angle: -Math.PI * 5/6, weight: 0.1 }   // 左後150度
                        ]
                    },
                    'I-E': {
                        pauseFrequency: 0.4,
                        pauseDuration: [1500, 3500],
                        wanderFrequency: 0.5,
                        wanderIntensity: 0.9,
                        reflectionFrequency: 0.7, // 最高の振り返り頻度
                        reflectionAngle: Math.PI * 0.75, // 135度の振り返り
                        behaviorTransition: 1800
                    },
                    
                    // IA段階: 確信を持った動きだが時折の熟考
                    'IE': {
                        pauseFrequency: 0.15, // 低い立ち止まり頻度
                        pauseDuration: [500, 1200], // 短い思考時間
                        wanderFrequency: 0.1, // 少ない迷い
                        wanderIntensity: 0.3, // 軽い迷い
                        reflectionFrequency: 0.2, // 少ない振り返り
                        reflectionAngle: Math.PI / 6, // 30度の軽い振り返り
                        behaviorTransition: 4000 // ゆっくりとした行動変化
                    },
                    'Ia': {
                        pauseFrequency: 0.1,
                        pauseDuration: [300, 800],
                        wanderFrequency: 0.05,
                        wanderIntensity: 0.2,
                        reflectionFrequency: 0.15,
                        reflectionAngle: Math.PI / 8,
                        behaviorTransition: 5000
                    },
                    'Ib': {
                        pauseFrequency: 0.12,
                        pauseDuration: [400, 1000],
                        wanderFrequency: 0.08,
                        wanderIntensity: 0.25,
                        reflectionFrequency: 0.18,
                        reflectionAngle: Math.PI / 6,
                        behaviorTransition: 4500
                    },
                    'Ic': {
                        pauseFrequency: 0.08, // 最も低い立ち止まり頻度
                        pauseDuration: [200, 600], // 最も短い思考時間
                        wanderFrequency: 0.03, // 最も少ない迷い
                        wanderIntensity: 0.15, // 最も軽い迷い
                        reflectionFrequency: 0.1, // 最も少ない振り返り
                        reflectionAngle: Math.PI / 12, // 15度の非常に軽い振り返り
                        behaviorTransition: 6000 // 最もゆっくりとした行動変化
                    }
                };
                
                return configs[stage] || configs['Ea']; // デフォルトはEa段階
            }
            
            // 地面ドットのアニメーション更新
            updateGroundMovement() {
                if (!this.isActive || this.groundDots.length === 0) return;
                
                const currentTime = Date.now();
                
                // 段階固有の行動パターンを更新
                this.updateStageSpecificBehaviors(currentTime);
                
                // 現在の行動に基づいて移動方向と速度を決定
                const adjustedMovement = this.calculateAdjustedMovement();
                
                // ドットを現在の方向に移動（地面は前後のみ、左右には動かない）
                this.groundDots.forEach(dot => {
                    // X方向（左右）の移動は無効化し、Z方向（前後）のみ適用
                    // dot.position.x += adjustedMovement.speed * adjustedMovement.direction.x; // 左右移動を無効化
                    dot.position.z += adjustedMovement.speed * adjustedMovement.direction.z; // 前後移動のみ
                    
                    // 波打つ地形の動的更新（時間とともに変化する起伏）
                    const waveHeight = this.calculateTerrainHeight(dot.position.x, dot.position.z);
                    dot.position.y = -5 + waveHeight; // 基準レベル + 波の高さ
                    
                    // 波の高さに応じて透明度を動的に調整
                    const heightOpacity = 0.4 + (waveHeight + 1) * 0.1; // 0.4〜0.6の範囲
                    dot.material.opacity = Math.min(heightOpacity, 0.7);
                    
                    // ドットが範囲外に出たら反対側に戻す（無限ループ効果）
                    const extraMargin = 20;
                    if (dot.position.z > 50) {
                        dot.position.z = -this.depth;
                    }
                    if (dot.position.z < -this.depth) {
                        dot.position.z = 50;
                    }
                    // X方向のループは維持（初期配置のため）
                    if (dot.position.x > this.gridSize + extraMargin) {
                        dot.position.x = -this.gridSize - extraMargin;
                    }
                    if (dot.position.x < -this.gridSize - extraMargin) {
                        dot.position.x = this.gridSize + extraMargin;
                    }
                });
            }
            
            // 段階固有の行動パターンを更新
            updateStageSpecificBehaviors(currentTime) {
                if (!this.behaviorState || !this.stageConfig) return;
                
                const timeSinceLastBehavior = currentTime - this.behaviorState.behaviorStartTime;
                
                // 次の行動切り替えタイミングかチェック
                if (currentTime >= this.behaviorState.nextBehaviorTime) {
                    this.selectNextBehavior(currentTime);
                }
                
                // 現在の行動を実行
                this.executeBehavior(timeSinceLastBehavior);
            }
            
            // 次の行動パターンを選択
            selectNextBehavior(currentTime) {
                const config = this.stageConfig;
                const random = Math.random();
                
                let selectedBehavior = 'normal';
                
                // 確率に基づいて行動を選択（reflectingは除外し、pausingに統合）
                if (random < config.pauseFrequency) {
                    selectedBehavior = 'pausing';
                    this.behaviorState.behaviorDuration = this.randomBetween(
                        config.pauseDuration[0], 
                        config.pauseDuration[1]
                    );
                    // 立ち止まり中に振り返りが発生するかを決定
                    this.behaviorState.shouldReflect = Math.random() < config.reflectionFrequency;
                    if (this.behaviorState.shouldReflect) {
                        this.behaviorState.reflectionAngle = config.reflectionAngle;
                        this.behaviorState.reflectionStartTime = null; // 後で設定
                        console.log(`[GroundSystem] Pausing with reflection (angle: ${config.reflectionAngle})`);
                    }
                } else if (random < config.pauseFrequency + config.wanderFrequency) {
                    selectedBehavior = 'wandering';
                    this.behaviorState.behaviorDuration = this.randomBetween(1000, 3000);
                    // 迷い方向を前後のみに制限（左右の迷いは除外）
                    const wanderIntensity = (Math.random() - 0.5) * config.wanderIntensity; // -0.5〜0.5の範囲
                    this.behaviorState.wanderDirection = {
                        x: 0, // 左右の迷いを無効化
                        z: 1 + wanderIntensity // 前後のみの変動
                    };
                } else {
                    selectedBehavior = 'normal';
                    this.behaviorState.behaviorDuration = this.randomBetween(2000, 5000);
                }
                
                // 行動状態を更新
                this.behaviorState.currentBehavior = selectedBehavior;
                this.behaviorState.behaviorStartTime = currentTime;
                this.behaviorState.nextBehaviorTime = currentTime + 
                    this.behaviorState.behaviorDuration + 
                    this.calculateNextBehaviorDelay();
                
                console.log(`[GroundSystem] Behavior changed to: ${selectedBehavior} for ${this.behaviorState.behaviorDuration}ms`);
            }
            
            // 現在の行動を実行
            executeBehavior(timeSinceStart) {
                const behavior = this.behaviorState.currentBehavior;
                const progress = Math.min(timeSinceStart / this.behaviorState.behaviorDuration, 1.0);
                
                switch (behavior) {
                    case 'pausing':
                        this.executePausingBehavior(progress);
                        break;
                    case 'wandering':
                        this.executeWanderingBehavior(progress);
                        break;
                    case 'normal':
                    default:
                        this.executeNormalBehavior();
                        break;
                }
            }
            
            // 立ち止まり行動：自然な減速・加速と微細な揺らぎを含む
            executePausingBehavior(progress) {
                // 元の速度を保存
                if (!this.originalSpeed) {
                    this.originalSpeed = this.movementPatterns[this.currentStage]?.speed || 0.1;
                }
                
                // 立ち止まりフェーズの時間配分（よりなめらかに）
                const decelPhase = 0.35;      // 減速フェーズ
                const pausedPhase = 0.3;      // 停止フェーズ（揺らぎあり）
                const accelPhase = 0.35;      // 加速フェーズ
                
                let speedMultiplier = 0;
                let reflectionAngle = 0;
                let microMovement = { x: 0, z: 0 };
                
                // 現在時刻（揺らぎ計算用）
                const currentTime = Date.now();
                const timeOffset = this.behaviorState.behaviorStartTime || currentTime;
                
                if (progress <= decelPhase) {
                    // フェーズ1: 自然な減速（イージングアウト）
                    const decelProgress = progress / decelPhase;
                    // スムーズな減速カーブ (ease-out)
                    speedMultiplier = 1 - Math.pow(decelProgress, 2.5);
                    
                } else if (progress <= decelPhase + pausedPhase) {
                    // フェーズ2: 微細な揺らぎのある停止状態
                    const pausedProgress = (progress - decelPhase) / pausedPhase;
                    
                    // 基本速度は非常に低速（完全停止ではない）
                    speedMultiplier = 0.05;
                    
                    // 微細な揺らぎ（呼吸のような動き）
                    const breathingCycle = (currentTime - timeOffset) * 0.002; // ゆっくりとした呼吸
                    const nervousTremor = (currentTime - timeOffset) * 0.008;   // 細かい震え
                    
                    microMovement.x = Math.sin(breathingCycle) * 0.01 + Math.sin(nervousTremor) * 0.005;
                    microMovement.z = Math.cos(breathingCycle * 0.7) * 0.008 + Math.cos(nervousTremor * 1.3) * 0.003;
                    
                    // 振り返りが予定されている場合
                    if (this.behaviorState.shouldReflect) {
                        if (!this.behaviorState.reflectionStartTime) {
                            this.behaviorState.reflectionStartTime = currentTime;
                        }
                        
                        // Eb段階の特別な複数権威スキャニング動作
                        if (this.currentStage === 'Eb' && this.stageConfig.isMultiAuthorityScanning) {
                            reflectionAngle = this.executeMultiAuthorityScanning(pausedProgress);
                        } else {
                            // 他の段階：通常の振り返り動作
                            const reflectionCycle = pausedProgress * Math.PI * 1.5; // 1.5往復
                            const reflectionIntensity = Math.sin(pausedProgress * Math.PI); // 中央で最大
                            reflectionAngle = this.behaviorState.reflectionAngle * 
                                            Math.sin(reflectionCycle) * 
                                            reflectionIntensity * 0.6;
                        }
                    }
                    
                } else {
                    // フェーズ3: 自然な加速（イージングイン）
                    const accelProgress = (progress - decelPhase - pausedPhase) / accelPhase;
                    // スムーズな加速カーブ (ease-in)
                    speedMultiplier = Math.pow(accelProgress, 1.8);
                    
                    // 振り返り動作を徐々に停止
                    const fadeOutReflection = 1 - accelProgress;
                    reflectionAngle *= fadeOutReflection;
                }
                
                // 方向の調整（振り返り角度 + 微細な揺らぎを適用）
                const originalDirection = this.movementPatterns[this.currentStage]?.direction || { x: 0, z: 1 };
                
                if (Math.abs(reflectionAngle) > 0.001) {
                    // 振り返り中: 元の方向を回転
                    const cos = Math.cos(reflectionAngle);
                    const sin = Math.sin(reflectionAngle);
                    
                    // スキャニング動作の場合は、速度を維持して方向のみ変更
                    const isScanning = this.currentStage === 'Eb' && 
                                     this.stageConfig.isMultiAuthorityScanning && 
                                     this.behaviorState.shouldReflect;
                    
                    if (isScanning && speedMultiplier < 0.1) {
                        // スキャニング時は最低限の動きを保証
                        const scanningSpeed = 0.08; // 視認可能な速度
                        this.currentDirection.x = (originalDirection.x * cos - originalDirection.z * sin) * scanningSpeed + microMovement.x;
                        this.currentDirection.z = (originalDirection.x * sin + originalDirection.z * cos) * scanningSpeed + microMovement.z;
                    } else {
                        // 通常の振り返り
                        this.currentDirection.x = (originalDirection.x * cos - originalDirection.z * sin) * speedMultiplier + microMovement.x;
                        this.currentDirection.z = (originalDirection.x * sin + originalDirection.z * cos) * speedMultiplier + microMovement.z;
                    }
                } else {
                    // 通常時: 元の方向 + 微細な揺らぎ
                    this.currentDirection.x = originalDirection.x * speedMultiplier + microMovement.x;
                    this.currentDirection.z = originalDirection.z * speedMultiplier + microMovement.z;
                }
                
                // 速度の設定（最小値を保証して完全停止を避ける）
                this.speed = Math.max(this.originalSpeed * speedMultiplier, 0.002);
            }
            
            // 迷い行動：より自然な方向転換と速度変化
            executeWanderingBehavior(progress) {
                // 元の速度を保存
                if (!this.originalSpeed) {
                    this.originalSpeed = this.movementPatterns[this.currentStage]?.speed || 0.1;
                }
                
                // 迷い行動を3つのフェーズに分割
                const transitionIn = 0.2;    // 迷い始め
                const wanderCore = 0.6;      // 迷いのメイン
                const transitionOut = 0.2;   // 迷いからの復帰
                
                let directionBlend = 0;
                let speedMultiplier = 1;
                
                if (progress <= transitionIn) {
                    // フェーズ1: 通常方向から迷い方向への漸進的変化
                    const easeIn = progress / transitionIn;
                    directionBlend = Math.pow(easeIn, 2); // ease-in
                    speedMultiplier = 1 - easeIn * 0.4; // 徐々に減速
                    
                } else if (progress <= transitionIn + wanderCore) {
                    // フェーズ2: メインの迷い動作（複雑な波状動き）
                    const coreProgress = (progress - transitionIn) / wanderCore;
                    directionBlend = 1;
                    
                    // 複数の波を重ねたより複雑な迷い
                    const wave1 = Math.sin(coreProgress * Math.PI * 3) * 0.6;
                    const wave2 = Math.sin(coreProgress * Math.PI * 5 + Math.PI/3) * 0.3;
                    const wave3 = Math.sin(coreProgress * Math.PI * 2 + Math.PI/6) * 0.1;
                    const combinedWave = (wave1 + wave2 + wave3) * 0.5 + 0.5;
                    
                    speedMultiplier = 0.4 + combinedWave * 0.4; // 0.4-0.8の範囲で変動
                    
                } else {
                    // フェーズ3: 迷いから通常方向への復帰
                    const easeOut = (progress - transitionIn - wanderCore) / transitionOut;
                    directionBlend = 1 - Math.pow(easeOut, 1.5); // ease-out
                    speedMultiplier = 0.6 + easeOut * 0.4; // 通常速度に復帰
                }
                
                // 基本方向と迷い方向をブレンド
                const originalDirection = this.movementPatterns[this.currentStage]?.direction || { x: 0, z: 1 };
                this.currentDirection.x = originalDirection.x * (1 - directionBlend) + 
                    this.behaviorState.wanderDirection.x * directionBlend;
                this.currentDirection.z = originalDirection.z * (1 - directionBlend) + 
                    this.behaviorState.wanderDirection.z * directionBlend;
                
                // スムーズな速度変化
                this.speed = this.originalSpeed * speedMultiplier;
            }
            
            // 通常行動：基本的な前進（微細な揺らぎ付き）
            executeNormalBehavior() {
                // 元の方向性と速度を復元
                if (this.movementPatterns[this.currentStage]) {
                    const original = this.movementPatterns[this.currentStage];
                    
                    // 基本方向を設定
                    let baseX = original.direction.x;
                    let baseZ = original.direction.z;
                    
                    // 歩行の自然な揺らぎを追加
                    const currentTime = Date.now();
                    const walkingRhythm = currentTime * 0.006; // 歩行リズム
                    const breathingRhythm = currentTime * 0.001; // 呼吸リズム
                    
                    // 左右の微細な揺れ（歩行による自然な動き）
                    const lateralSway = Math.sin(walkingRhythm) * 0.015;
                    const forwardVariation = Math.sin(breathingRhythm) * 0.008;
                    
                    // 段階別の揺らぎ強度調整
                    const stageMultiplier = this.getStageAgitationLevel();
                    
                    this.currentDirection.x = baseX + lateralSway * stageMultiplier;
                    this.currentDirection.z = baseZ + forwardVariation * stageMultiplier;
                    
                    // 速度にも微細な変動を追加
                    const speedVariation = 1 + Math.sin(walkingRhythm * 0.7) * 0.05 * stageMultiplier;
                    this.speed = original.speed * speedVariation;
                    this.originalSpeed = original.speed;
                }
            }
            
            // 段階別の動揺レベルを取得
            getStageAgitationLevel() {
                const agitationLevels = {
                    'Ea': 0.8,   // 外部権威期：やや緊張
                    'Eb': 0.9,   
                    'Ec': 1.0,   
                    'EI': 1.5,   // 岐路期：高い動揺
                    'E-I': 1.8,  // 最高の迷い
                    'I-E': 1.6,  
                    'IE': 1.2,   // 統合期：減少
                    'Ia': 0.7,   // 内的権威期：安定
                    'Ib': 0.5,   
                    'Ic': 0.3    // 最も安定
                };
                return agitationLevels[this.currentStage] || 1.0;
            }
            
            // Eb段階専用: 複数権威をスキャニングする動作（非常にゆっくりした人間的な動き）
            executeMultiAuthorityScanning(pausedProgress) {
                const config = this.stageConfig;
                const directions = config.authorityDirections;
                
                if (!directions || directions.length === 0) {
                    return 0; // フォールバック
                }
                
                // より人間的なスキャニング設定
                const totalScans = Math.min(directions.length, 6); // より多くの方向スキャン
                const scanningCycles = 0.3; // さらに少ないサイクル（よりゆっくり）
                const totalProgress = pausedProgress * scanningCycles;
                
                // 現在のスキャン対象を決定
                const currentScanIndex = Math.floor(totalProgress * totalScans) % totalScans;
                const scanPhaseProgress = (totalProgress * totalScans) % 1;
                
                // ランダムな角度設定（左右均等に分散）
                const randomSeed = Math.floor(Date.now() / 8000); // 8秒ごとに新しいランダム設定
                const rng = this.createSeededRandom(randomSeed + currentScanIndex);
                
                // より自然なランダム左右選択（シードベース）
                const directionSeed = this.createSeededRandom(randomSeed * 7 + currentScanIndex * 3);
                const isLeft = directionSeed() < 0.5; // 真のランダム左右選択
                const baseAngle = isLeft ? -1 : 1; // 左は負、右は正
                
                // E-Iステージはより大きな回転角度範囲を使用
                let randomAngleRange;
                if (this.currentStage === 'E-I') {
                    randomAngleRange = (Math.PI / 4) + (rng() * Math.PI / 2.5); // 45度〜117度の範囲（より大きく）
                } else {
                    randomAngleRange = (Math.PI / 8) + (rng() * Math.PI / 6); // 22.5度〜52.5度の範囲（デフォルト）
                }
                
                const targetAngle = baseAngle * randomAngleRange;
                
                // 非常にゆっくりとしたスムーズな移行
                let easedProgress;
                if (scanPhaseProgress < 0.9) {
                    // 前の角度から目標角度への移行（非常にゆっくり）
                    const transitionProgress = scanPhaseProgress / 0.9;
                    easedProgress = Math.pow(transitionProgress, 6); // 非常に緩やかなease-in
                } else {
                    // 目標角度での滞在
                    easedProgress = 1;
                }
                
                // 前回の角度から現在の角度への非常に滑らかな補間
                const prevAngle = currentScanIndex > 0 ? 
                    this.getPreviousRandomAngle(randomSeed + currentScanIndex - 1) : 0;
                
                const interpolatedAngle = prevAngle + (targetAngle - prevAngle) * easedProgress;
                
                // 非常に控えめな不安定さ
                const nervousness = Math.sin(Date.now() * 0.002) * 0.005; // さらに穏やかな動き
                
                return interpolatedAngle + nervousness;
            }
            
            // シード付きランダム関数（一貫した疑似ランダム）
            createSeededRandom(seed) {
                let x = Math.sin(seed) * 10000;
                return function() {
                    x = Math.sin(x) * 10000;
                    return x - Math.floor(x);
                };
            }
            
            // 前の角度を再計算（一貫性のため）
            getPreviousRandomAngle(seed) {
                const rng = this.createSeededRandom(seed);
                // より自然なランダム左右選択（シードベース）
                const directionSeed = this.createSeededRandom(seed * 7);
                const isLeft = directionSeed() < 0.5; // 真のランダム左右選択
                const baseAngle = isLeft ? -1 : 1;
                
                // E-Iステージはより大きな回転角度範囲を使用
                let randomAngleRange;
                if (this.currentStage === 'E-I') {
                    randomAngleRange = (Math.PI / 4) + (rng() * Math.PI / 2.5); // 45度〜117度の範囲（より大きく）
                } else {
                    randomAngleRange = (Math.PI / 8) + (rng() * Math.PI / 6); // 22.5度〜52.5度の範囲（デフォルト）
                }
                
                return baseAngle * randomAngleRange;
            }
            
            // 調整された移動を計算
            calculateAdjustedMovement() {
                return {
                    direction: { ...this.currentDirection },
                    speed: this.speed
                };
            }
            
            // 次の行動までの遅延時間を計算
            calculateNextBehaviorDelay() {
                if (!this.stageConfig) {
                    return 3000; // デフォルト値
                }
                const baseDelay = this.stageConfig.behaviorTransition || 3000;
                const variation = baseDelay * 0.3; // 30%の変動
                return baseDelay + (Math.random() - 0.5) * variation;
            }
            
            // 範囲内のランダム数値を生成
            randomBetween(min, max) {
                return min + Math.random() * (max - min);
            }
            
            // 地面システムの有効化/無効化
            setActive(active) {
                this.isActive = active;
                this.groundDots.forEach(dot => {
                    dot.visible = active;
                });
                console.log(`[GroundSystem] ${active ? 'Activated' : 'Deactivated'}`);
            }
            
            // 地面ドットのクリーンアップ
            clearGroundDots() {
                this.groundDots.forEach(dot => {
                    this.scene.remove(dot);
                    if (dot.geometry) dot.geometry.dispose();
                    if (dot.material) dot.material.dispose();
                });
                this.groundDots = [];
            }
            
            // システム全体のクリーンアップ
            cleanup() {
                this.clearGroundDots();
                this.isActive = false;
                console.log('[GroundSystem] Cleanup completed');
            }
        }
        
        // 説明表示システム - 各要素の意味を簡潔に表示
        class ExplanationDisplaySystem {
            constructor(container) {
                this.container = container;
                this.explanationPanel = null;
                this.isVisible = false;
                this.currentExplanations = new Map();
            }
            
            createExplanationPanel() {
                // 説明パネルのHTML要素を作成
                this.explanationPanel = document.createElement('div');
                this.explanationPanel.id = 'explanation-panel';
                this.explanationPanel.style.cssText = `
                    position: absolute;
                    top: 20px;
                    right: 20px;
                    width: 280px;
                    background: rgba(0, 0, 0, 0.85);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 12px;
                    padding: 16px;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                    font-size: 13px;
                    line-height: 1.4;
                    color: rgba(255, 255, 255, 0.9);
                    backdrop-filter: blur(10px);
                    -webkit-backdrop-filter: blur(10px);
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                    opacity: 0;
                    transform: translateY(-10px);
                    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                    pointer-events: none;
                    z-index: 1000;
                `;
                
                // ヘッダー部分（タイトル + 閉じるボタン）
                const headerDiv = document.createElement('div');
                headerDiv.style.cssText = `
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 12px;
                    padding-bottom: 8px;
                    border-bottom: 1px solid rgba(135, 206, 235, 0.3);
                `;
                
                // タイトル部分
                const titleDiv = document.createElement('div');
                titleDiv.style.cssText = `
                    font-size: 14px;
                    font-weight: 600;
                    color: #87ceeb;
                `;
                titleDiv.textContent = '視覚要素の説明';
                
                // 閉じるボタン
                const closeButton = document.createElement('button');
                closeButton.style.cssText = `
                    background: none;
                    border: none;
                    color: rgba(255, 255, 255, 0.7);
                    font-size: 16px;
                    cursor: pointer;
                    padding: 2px 6px;
                    border-radius: 4px;
                    transition: all 0.2s ease;
                    line-height: 1;
                `;
                closeButton.innerHTML = '×';
                closeButton.title = '説明を閉じる';
                
                // 閉じるボタンのホバー効果
                closeButton.addEventListener('mouseenter', () => {
                    closeButton.style.background = 'rgba(255, 255, 255, 0.1)';
                    closeButton.style.color = 'rgba(255, 255, 255, 1)';
                });
                closeButton.addEventListener('mouseleave', () => {
                    closeButton.style.background = 'none';
                    closeButton.style.color = 'rgba(255, 255, 255, 0.7)';
                });
                
                // 閉じるボタンのクリックイベント
                closeButton.addEventListener('click', () => {
                    this.hidePanel();
                });
                
                headerDiv.appendChild(titleDiv);
                headerDiv.appendChild(closeButton);
                
                // 説明リスト部分
                const explanationList = document.createElement('div');
                explanationList.id = 'explanation-list';
                explanationList.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                `;
                
                this.explanationPanel.appendChild(headerDiv);
                this.explanationPanel.appendChild(explanationList);
                this.container.appendChild(this.explanationPanel);
            }
            
            // ステージに応じた説明を更新（手動制御のみ）
            updateStageExplanations(stage) {
                if (!this.explanationPanel) {
                    this.createExplanationPanel();
                }
                
                this.clearExplanations();
                
                // ステージに応じた説明を取得
                const explanations = this.getStageExplanations(stage);
                
                // 説明アイテムを追加
                const explanationList = this.explanationPanel.querySelector('#explanation-list');
                explanations.forEach(item => {
                    const explanationItem = this.createExplanationItem(item);
                    explanationList.appendChild(explanationItem);
                    this.currentExplanations.set(item.id, explanationItem);
                });
                
                // パネルが表示されている場合のみ更新（自動表示はしない）
            }
            
            // ステージ別の説明内容を定義
            getStageExplanations(stage) {
                const stageNum = this.getStageNumber(stage);
                const baseExplanations = [
                    { id: 'core', icon: '●', text: '中心コア: セルフ', color: '#87ceeb' }
                ];
                
                if (stageNum <= 3) {
                    // EA段階: 基本的な要素のみ
                    return [
                        ...baseExplanations,
                        { id: 'particles', icon: '✦', text: 'パーティクル: 内面の経験・気づき', color: '#98fb98' },
                        { id: 'lightning', icon: '⚡', text: '光の線: 自己の内面を見つめる動き', color: '#ffd700' },
                        { id: 'radar', icon: '📡', text: 'レーダー: 新しい視点・知識の探索', color: '#ff69b4' },
                        { id: 'connections', icon: '💬', text: '伝達信号: 他者との関係・対話', color: '#40e0d0' }
                    ];
                } else if (stageNum <= 7) {
                    // 岐路段階: 探索要素を追加
                    return [
                        ...baseExplanations,
                        { id: 'particles', icon: '✦', text: 'パーティクル: 内面の経験・気づき', color: '#98fb98' },
                        { id: 'lightning', icon: '⚡', text: '光の線: 自己の内面を見つめる動き', color: '#ffd700' },
                        { id: 'radar', icon: '📡', text: 'レーダー: 新しい視点・知識の探索', color: '#ff69b4' },
                        { id: 'connections', icon: '💬', text: '伝達信号: 他者との関係・対話', color: '#40e0d0' }
                    ];
                } else {
                    // IA段階: 関係性要素も含む
                    return [
                        ...baseExplanations,
                        { id: 'particles', icon: '✦', text: 'パーティクル: 内面の経験・気づき', color: '#98fb98' },
                        { id: 'lightning', icon: '⚡', text: '光の線: 自己の内面を見つめる動き', color: '#ffd700' },
                        { id: 'radar', icon: '📡', text: 'レーダー: 新しい視点・知識の探索', color: '#ff69b4' },
                        { id: 'connections', icon: '💬', text: '伝達信号: 他者との関係・対話', color: '#40e0d0' }
                    ];
                }
            }
            
            // 説明アイテムのHTML要素を作成
            createExplanationItem(item) {
                const itemDiv = document.createElement('div');
                itemDiv.style.cssText = `
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    padding: 6px 0;
                    border-radius: 6px;
                    transition: all 0.2s ease;
                `;
                
                const iconSpan = document.createElement('span');
                iconSpan.style.cssText = `
                    font-size: 14px;
                    width: 16px;
                    text-align: center;
                    color: ${item.color};
                `;
                iconSpan.textContent = item.icon;
                
                const textSpan = document.createElement('span');
                textSpan.style.cssText = `
                    flex: 1;
                    font-size: 13px;
                    color: rgba(255, 255, 255, 0.85);
                `;
                textSpan.textContent = item.text;
                
                itemDiv.appendChild(iconSpan);
                itemDiv.appendChild(textSpan);
                
                return itemDiv;
            }
            
            // パネルを表示
            showPanel() {
                if (!this.explanationPanel) return;
                
                this.isVisible = true;
                this.explanationPanel.style.opacity = '1';
                this.explanationPanel.style.transform = 'translateY(0)';
                this.explanationPanel.style.pointerEvents = 'auto';
            }
            
            // パネルを非表示
            hidePanel() {
                if (!this.explanationPanel) return;
                
                this.isVisible = false;
                this.explanationPanel.style.opacity = '0';
                this.explanationPanel.style.transform = 'translateY(-10px)';
                this.explanationPanel.style.pointerEvents = 'none';
            }
            
            // 説明をクリア
            clearExplanations() {
                this.currentExplanations.clear();
                if (this.explanationPanel) {
                    const explanationList = this.explanationPanel.querySelector('#explanation-list');
                    if (explanationList) {
                        explanationList.innerHTML = '';
                    }
                }
            }
            
            // ステージ文字列を数値に変換
            getStageNumber(stage) {
                const stageMap = {
                    'Ea': 1, 'Eb': 2, 'Ec': 3,
                    'EI': 4, 'E-I': 5,
                    'I-E': 6, 'IE': 7,
                    'Ia': 8, 'Ib': 9, 'Ic': 10
                };
                return stageMap[stage] || 1;
            }
            
            // パネルの表示/非表示を切り替え（手動制御のみ）
            toggle(currentStage = null) {
                if (this.isVisible) {
                    this.hidePanel();
                } else {
                    // パネルを表示前に現在のステージの説明を更新
                    if (currentStage) {
                        this.updateStageExplanations(currentStage);
                    }
                    this.showPanel();
                }
            }
            
            // クリーンアップ
            cleanup() {
                if (this.explanationPanel && this.explanationPanel.parentNode) {
                    this.explanationPanel.parentNode.removeChild(this.explanationPanel);
                }
                this.explanationPanel = null;
                this.currentExplanations.clear();
            }
        }
        
        // 次元1: 対自関係次元 - 流れ星イメージ光線システム
        class LightningDimensionSystem {
            constructor(particles, scene) {
                this.particles = particles;
                this.scene = scene;
                this.activeShootingStars = []; // アクティブな流れ星
                this.trailSegments = []; // 残像セグメント
                this.lastUpdate = 0;
                this.maxConcurrentStars = 2; // 同時流れ星数
                this.tailLength = 0.8; // 流れ星の尻尾の長さ
                this.trailFadeTime = 1500; // 残像のフェード時間（ms）
                this.maxTrailLifetime = 2500; // 残像の最大寿命（強制削除用）
            }
            
            // 直線パス生成（ギザギザなし）
            createStraightPath(startParticle, endParticle) {
                const start = startParticle.position.clone();
                const end = endParticle.position.clone();
                return [start, end];
            }
            
            // waypoints（経由点）の有効性を検証
            validateWaypoints(star) {
                try {
                    if (!star.waypoints || star.waypoints.length < 2) {
                        console.warn('[LightningSystem] Invalid waypoints: insufficient points');
                        return false;
                    }
                    
                    return star.waypoints.every((particle, index) => {
                        // パーティクルの基本的な存在チェック
                        if (!particle || !particle.position) {
                            console.warn(`[LightningSystem] Invalid particle at waypoint ${index}: missing position`);
                            return false;
                        }
                        
                        // 可視性チェック
                        if (!particle.visible) {
                            console.warn(`[LightningSystem] Particle at waypoint ${index} became invisible`);
                            return false;
                        }
                        
                        // シーンから除去されていないかチェック
                        if (!particle.parent) {
                            console.warn(`[LightningSystem] Particle at waypoint ${index} was removed from scene`);
                            return false;
                        }
                        
                        // 異常な位置変更をチェック（原点付近への強制移動）
                        const distanceFromOrigin = particle.position.length();
                        if (distanceFromOrigin < 0.1) {
                            console.warn(`[LightningSystem] Particle at waypoint ${index} moved to origin (distance: ${distanceFromOrigin})`);
                            return false;
                        }
                        
                        return true;
                    });
                } catch (error) {
                    console.error('[LightningSystem] Error validating waypoints:', error);
                    return false;
                }
            }
            
            // 流れ星クラス（イーズイン/アウトと残像効果付き）
            createShootingStar(waypoints, stageIntensity) {
                const star = {
                    waypoints: waypoints,
                    currentSegment: 0, // 現在のセグメント（A→B, B→C, etc.）
                    progress: 0, // 現在セグメント内の進行度 (0-1)
                    globalProgress: 0, // 全体の進行度 (0-1)
                    baseSpeed: stageIntensity.speed, // 基本移動速度
                    currentSpeed: 0, // 現在の速度（イーズ用）
                    tailLength: this.tailLength, // 流れ星の尻尾の長さ
                    color: stageIntensity.colors[Math.floor(Math.random() * stageIntensity.colors.length)],
                    opacity: stageIntensity.opacity,
                    creationTime: Date.now(),
                    duration: stageIntensity.duration,
                    mainLine: null, // メインの流れ星ライン
                    totalDistance: 0, // 総距離
                    easingType: stageIntensity.easingType || 'easeInOut' // イージングタイプ
                };
                
                // 総距離を計算
                star.totalDistance = this.getTotalRouteLength(waypoints);
                
                return star;
            }
            
            // 経由点を選択（TSP最適化版）
            selectWaypoints(availableParticles, count) {
                const waypoints = [];
                const usedIndices = new Set();
                
                // ランダムに経由点を選択
                while (waypoints.length < count && waypoints.length < availableParticles.length) {
                    const randomIndex = Math.floor(Math.random() * availableParticles.length);
                    if (!usedIndices.has(randomIndex)) {
                        waypoints.push(availableParticles[randomIndex]);
                        usedIndices.add(randomIndex);
                    }
                }
                
                // 距離最適化
                if (waypoints.length > 1) {
                    const optimized = [waypoints[0]];
                    const remaining = waypoints.slice(1);
                    
                    while (remaining.length > 0) {
                        const current = optimized[optimized.length - 1];
                        let nearestIndex = 0;
                        let nearestDistance = current.position.distanceTo(remaining[0].position);
                        
                        for (let i = 1; i < remaining.length; i++) {
                            const distance = current.position.distanceTo(remaining[i].position);
                            if (distance < nearestDistance) {
                                nearestDistance = distance;
                                nearestIndex = i;
                            }
                        }
                        
                        optimized.push(remaining[nearestIndex]);
                        remaining.splice(nearestIndex, 1);
                    }
                    
                    return optimized;
                }
                
                return waypoints;
            }
            
            createShootingStars(stage) {
                const stageIntensity = this.getLightningIntensity(stage);
                const availableParticles = this.particles.filter(p => p.visible);
                
                // デバッグ出力
                console.log(`[ShootingStar] Stage: ${stage}, Particles: ${availableParticles.length}, Frequency: ${stageIntensity.frequency}ms`);
                
                if (availableParticles.length < 2) {
                    console.log('[ShootingStar] Not enough visible particles for shooting stars');
                    return;
                }
                
                // 新しい流れ星を生成
                const starCount = Math.min(stageIntensity.maxCount, this.maxConcurrentStars);
                
                for (let i = 0; i < starCount; i++) {
                    const waypoints = this.selectWaypoints(availableParticles, stageIntensity.waypointCount);
                    if (waypoints.length >= 2) {
                        const star = this.createShootingStar(waypoints, stageIntensity);
                        this.activeShootingStars.push(star);
                    }
                }
            }
            
            getLightningIntensity(stageNumber) {
                if (stageNumber <= 3) {
                    // EA段階: 穏やかな流れ星（パステル調の単色）
                    return {
                        maxCount: 1,
                        colors: [0x87ceeb, 0x98fb98, 0xffd1dc], // スカイブルー、ペールグリーン、ピンク
                        opacity: 0.8,
                        duration: 3000, // 流れ星の寿命
                        frequency: 2000, // 生成頻度
                        waypointCount: 2, // 2点間移動（シンプルな流れ星）
                        speed: 0.6, // 基本移動速度（緩やかに変更）
                        easingType: 'easeInOut' // スムーズなイージング
                    };
                } else if (stageNumber <= 7) {
                    // 岐路段階: 活発な流れ星（明るい多色）
                    return {
                        maxCount: 2,
                        colors: [0x87ceeb, 0x98fb98, 0xffd700, 0xff69b4, 0x40e0d0], // スカイブルー、ライトグリーン、ゴールド、ホットピンク、ターコイズ
                        opacity: 0.85,
                        duration: 2500,
                        frequency: 1200,
                        waypointCount: 3, // 3点経由
                        speed: 0.6, // やや高速（緩やかに変更）
                        easingType: 'easeInOut'
                    };
                } else {
                    // IA段階: 統合的な流れ星（虹色スペクトラム）
                    return {
                        maxCount: 2,
                        colors: [0xff69b4, 0x40e0d0, 0x98fb98, 0xffd700, 0xff7f50, 0xda70d6, 0x87ceeb], // 虹色パレット
                        opacity: 0.9,
                        duration: 2000,
                        frequency: 800,
                        waypointCount: 4, // 4点経由
                        speed: 0.6, // 高速（緩やかに変更）
                        easingType: 'easeInOut'
                    };
                }
            }
            
            // 流れ星の移動アニメーション更新
            updateShootingStars(deltaTime) {
                this.activeShootingStars = this.activeShootingStars.filter(star => {
                    // Phase 2: waypoint検証による早期終了
                    if (!this.validateWaypoints(star)) {
                        console.log('[LightningSystem] Terminating shooting star due to invalid waypoints');
                        this.cleanupShootingStar(star);
                        return false;
                    }
                    
                    const age = Date.now() - star.creationTime;
                    const normalizedAge = age / star.duration;
                    
                    // イージング関数を適用
                    const easedProgress = this.applyEasing(normalizedAge, star.easingType);
                    star.globalProgress = Math.min(easedProgress, 1.0);
                    
                    // 現在の速度をイージングに基づいて計算
                    star.currentSpeed = this.calculateSpeedFromEasing(normalizedAge, star.easingType, star.baseSpeed);
                    
                    // セグメントとローカル進行度の更新
                    this.updateSegmentProgress(star);
                    
                    // 寿命チェック
                    if (normalizedAge >= 1.0) {
                        // 残像を作成してから流れ星を除去
                        this.createTrailSegment(star);
                        this.cleanupShootingStar(star);
                        return false;
                    }
                    
                    // 流れ星を描画
                    this.renderShootingStar(star);
                    
                    return true;
                });
                
                // 残像セグメントの更新
                this.updateTrailSegments();
            }
            
            // 流れ星の光線描画（イージングと残像効果付き）
            renderShootingStar(star) {
                // 既存のラインを確実に削除
                if (star.mainLine) {
                    if (star.mainLine.parent) {
                        star.mainLine.parent.remove(star.mainLine);
                    } else {
                        this.scene.remove(star.mainLine);
                    }
                    
                    // リソースを破棄
                    if (star.mainLine.geometry) {
                        star.mainLine.geometry.dispose();
                    }
                    if (star.mainLine.material) {
                        if (star.mainLine.material.uniforms) {
                            Object.values(star.mainLine.material.uniforms).forEach(uniform => {
                                if (uniform.value && uniform.value.dispose) {
                                    uniform.value.dispose();
                                }
                            });
                        }
                        star.mainLine.material.dispose();
                    }
                    star.mainLine = null;
                }
                
                const currentWaypoint = star.waypoints[star.currentSegment];
                const nextWaypoint = star.waypoints[star.currentSegment + 1];
                
                if (!currentWaypoint || !nextWaypoint) return;
                
                // 現在位置の計算
                const currentPos = currentWaypoint.position.clone().lerp(
                    nextWaypoint.position, 
                    star.progress
                );
                
                // 流れ星の尻尾位置の計算（グローバル進行度ベース）
                const tailGlobalProgress = Math.max(0, star.globalProgress - (star.tailLength / star.totalDistance));
                const tailPos = this.getPositionAtGlobalProgress(star.waypoints, tailGlobalProgress);
                
                if (!tailPos) return;
                
                // 流れ星のグラデーション材質を作成
                const points = [tailPos, currentPos];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                
                // アルファ属性を追加（尻尾=0.0, 先頭=1.0）
                const alphas = new Float32Array([0.0, 1.0]);
                geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
                
                // シェーダーマテリアルでグラデーション効果
                const material = this.createShootingStarMaterial(star);
                
                star.mainLine = new THREE.Line(geometry, material);
                this.scene.add(star.mainLine);
            }
            
            // 進行度から座標を取得
            getPositionAtProgress(waypoints, totalProgress) {
                if (totalProgress <= 0) return waypoints[0].position.clone();
                
                const segmentIndex = Math.floor(totalProgress);
                const segmentProgress = totalProgress - segmentIndex;
                
                if (segmentIndex >= waypoints.length - 1) {
                    return waypoints[waypoints.length - 1].position.clone();
                }
                
                return waypoints[segmentIndex].position.clone().lerp(
                    waypoints[segmentIndex + 1].position,
                    segmentProgress
                );
            }
            
            // ルートの総長を計算
            getTotalRouteLength(waypoints) {
                let totalLength = 0;
                for (let i = 0; i < waypoints.length - 1; i++) {
                    totalLength += waypoints[i].position.distanceTo(waypoints[i + 1].position);
                }
                return totalLength;
            }
            
            // 流れ星用グラデーションマテリアル作成
            createShootingStarMaterial(star) {
                const vertexShader = `
                    attribute float alpha;
                    varying float vAlpha;
                    varying vec3 vPosition;
                    
                    void main() {
                        vAlpha = alpha;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;
                
                const fragmentShader = `
                    uniform vec3 color;
                    uniform float opacity;
                    uniform float time;
                    varying float vAlpha;
                    varying vec3 vPosition;
                    
                    void main() {
                        // 先頭から尻尾へのグラデーション
                        float gradient = 1.0 - vAlpha; // 0=尻尾, 1=先頭
                        
                        // 輝き効果
                        float glow = pow(gradient, 0.5) * (0.8 + 0.2 * sin(time * 0.01));
                        
                        gl_FragColor = vec4(color, opacity * glow);
                    }
                `;
                
                const material = new THREE.ShaderMaterial({
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    uniforms: {
                        color: { value: new THREE.Color(star.color) },
                        opacity: { value: star.opacity },
                        time: { value: Date.now() }
                    },
                    transparent: true,
                    blending: THREE.AdditiveBlending // 美しい発光効果
                });
                
                return material;
            }
            
            // イージング関数
            applyEasing(t, type) {
                switch (type) {
                    case 'easeIn':
                        return t * t * t; // スロースタート
                    case 'easeOut':
                        return 1 - Math.pow(1 - t, 3); // スローエンド
                    case 'easeInOut':
                    default:
                        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; // 流れ星らしい動き
                }
            }
            
            // イージングから現在の速度を計算
            calculateSpeedFromEasing(t, type, baseSpeed) {
                const dt = 0.001; // 微小変化
                const current = this.applyEasing(t, type);
                const next = this.applyEasing(Math.min(t + dt, 1.0), type);
                return (next - current) / dt * baseSpeed;
            }
            
            // グローバル進行度からセグメント進行度を更新
            updateSegmentProgress(star) {
                const totalSegments = star.waypoints.length - 1;
                const globalSegmentProgress = star.globalProgress * totalSegments;
                
                star.currentSegment = Math.min(Math.floor(globalSegmentProgress), totalSegments - 1);
                star.progress = globalSegmentProgress - star.currentSegment;
                
                // 最終セグメントでの調整
                if (star.currentSegment >= totalSegments - 1) {
                    star.currentSegment = totalSegments - 1;
                    star.progress = Math.min(star.progress, 1.0);
                }
            }
            
            // グローバル進行度から位置を取得
            getPositionAtGlobalProgress(waypoints, globalProgress) {
                if (globalProgress <= 0) return waypoints[0].position.clone();
                if (globalProgress >= 1) return waypoints[waypoints.length - 1].position.clone();
                
                const totalSegments = waypoints.length - 1;
                const segmentProgress = globalProgress * totalSegments;
                const segmentIndex = Math.floor(segmentProgress);
                const localProgress = segmentProgress - segmentIndex;
                
                if (segmentIndex >= totalSegments - 1) {
                    return waypoints[waypoints.length - 1].position.clone();
                }
                
                return waypoints[segmentIndex].position.clone().lerp(
                    waypoints[segmentIndex + 1].position,
                    localProgress
                );
            }
            
            // 残像セグメントを作成
            createTrailSegment(star) {
                if (!star.mainLine) return;
                
                const trailSegment = {
                    line: star.mainLine.clone(),
                    creationTime: Date.now(),
                    originalOpacity: star.opacity,
                    color: star.color
                };
                
                // クローンしたラインのマテリアルを深くコピー
                const originalMaterial = star.mainLine.material;
                if (originalMaterial.isShaderMaterial) {
                    // ShaderMaterialの場合は完全にクローン
                    trailSegment.line.material = originalMaterial.clone();
                    // uniformsも個別にコピー
                    if (originalMaterial.uniforms) {
                        Object.keys(originalMaterial.uniforms).forEach(key => {
                            if (originalMaterial.uniforms[key].value !== undefined) {
                                trailSegment.line.material.uniforms[key] = {
                                    value: originalMaterial.uniforms[key].value
                                };
                            }
                        });
                    }
                } else {
                    // 通常のマテリアルの場合
                    trailSegment.line.material = originalMaterial.clone();
                }
                
                this.scene.add(trailSegment.line);
                this.trailSegments.push(trailSegment);
                
                // 元のラインはシーンから除去しない（クローンしたので別物）
                star.mainLine = null;
            }
            
            // 残像セグメントの更新（フェードアウト）
            updateTrailSegments() {
                const currentTime = Date.now();
                
                this.trailSegments = this.trailSegments.filter(segment => {
                    try {
                        const age = currentTime - segment.creationTime;
                        const fadeProgress = age / this.trailFadeTime;
                        
                        // Phase 3: 最大寿命による強制削除
                        if (age >= this.maxTrailLifetime) {
                            console.log('[LightningSystem] Force removing trail segment due to max lifetime exceeded');
                            this.forceRemoveTrailSegment(segment);
                            return false;
                        }
                        
                        if (fadeProgress >= 1.0) {
                            // フェード完了、確実に除去
                            this.forceRemoveTrailSegment(segment);
                            return false;
                        }
                        
                        // フェードアウト効果（両方のマテリアルタイプに対応）
                        const fadedOpacity = segment.originalOpacity * (1 - fadeProgress);
                        const material = segment.line.material;
                        
                        if (material && material.uniforms && material.uniforms.opacity) {
                            // ShaderMaterialの場合
                            material.uniforms.opacity.value = fadedOpacity;
                        } else if (material && material.opacity !== undefined) {
                            // BasicMaterialなどの場合
                            material.opacity = fadedOpacity;
                        }
                        
                        return true;
                    } catch (error) {
                        console.error('[LightningSystem] Error updating trail segment:', error);
                        this.forceRemoveTrailSegment(segment);
                        return false;
                    }
                });
            }
            
            // Phase 3: 残像セグメントの強制削除（エラーハンドリング付き）
            forceRemoveTrailSegment(segment) {
                try {
                    if (segment.line) {
                        // シーンから確実に除去
                        if (segment.line.parent) {
                            segment.line.parent.remove(segment.line);
                        } else {
                            this.scene.remove(segment.line);
                        }
                        
                        // ジオメトリとマテリアルを確実に破棄
                        if (segment.line.geometry) {
                            segment.line.geometry.dispose();
                        }
                        if (segment.line.material) {
                            // ShaderMaterialの場合、uniformsのテクスチャも破棄
                            if (segment.line.material.uniforms) {
                                Object.values(segment.line.material.uniforms).forEach(uniform => {
                                    if (uniform.value && uniform.value.dispose) {
                                        uniform.value.dispose();
                                    }
                                });
                            }
                            segment.line.material.dispose();
                        }
                        segment.line = null;
                    }
                } catch (error) {
                    console.error('[LightningSystem] Error in forceRemoveTrailSegment:', error);
                    // エラーが発生してもnullに設定して参照を切る
                    segment.line = null;
                }
            }
            
            // 流れ星のクリーンアップ
            cleanupShootingStar(star) {
                if (star.mainLine) {
                    // シーンから確実に除去
                    if (star.mainLine.parent) {
                        star.mainLine.parent.remove(star.mainLine);
                    } else {
                        this.scene.remove(star.mainLine);
                    }
                    
                    // ジオメトリとマテリアルを破棄
                    if (star.mainLine.geometry) {
                        star.mainLine.geometry.dispose();
                    }
                    if (star.mainLine.material) {
                        // ShaderMaterialの場合、uniformsのテクスチャも破棄
                        if (star.mainLine.material.uniforms) {
                            Object.values(star.mainLine.material.uniforms).forEach(uniform => {
                                if (uniform.value && uniform.value.dispose) {
                                    uniform.value.dispose();
                                }
                            });
                        }
                        star.mainLine.material.dispose();
                    }
                    star.mainLine = null;
                }
            }
            
            // 全体のクリーンアップ
            clearActiveLightning() {
                // アクティブな流れ星をクリーンアップ
                this.activeShootingStars.forEach(star => {
                    if (star.mainLine) {
                        // シーンから確実に除去
                        if (star.mainLine.parent) {
                            star.mainLine.parent.remove(star.mainLine);
                        } else {
                            this.scene.remove(star.mainLine);
                        }
                        
                        // リソースを破棄
                        if (star.mainLine.geometry) {
                            star.mainLine.geometry.dispose();
                        }
                        if (star.mainLine.material) {
                            if (star.mainLine.material.uniforms) {
                                Object.values(star.mainLine.material.uniforms).forEach(uniform => {
                                    if (uniform.value && uniform.value.dispose) {
                                        uniform.value.dispose();
                                    }
                                });
                            }
                            star.mainLine.material.dispose();
                        }
                        star.mainLine = null;
                    }
                });
                this.activeShootingStars = [];
                
                // 残像セグメントもクリーンアップ
                this.trailSegments.forEach(segment => {
                    if (segment.line) {
                        // シーンから確実に除去
                        if (segment.line.parent) {
                            segment.line.parent.remove(segment.line);
                        } else {
                            this.scene.remove(segment.line);
                        }
                        
                        // リソースを破棄
                        if (segment.line.geometry) {
                            segment.line.geometry.dispose();
                        }
                        if (segment.line.material) {
                            if (segment.line.material.uniforms) {
                                Object.values(segment.line.material.uniforms).forEach(uniform => {
                                    if (uniform.value && uniform.value.dispose) {
                                        uniform.value.dispose();
                                    }
                                });
                            }
                            segment.line.material.dispose();
                        }
                        segment.line = null;
                    }
                });
                this.trailSegments = [];
            }
            
            update(stageNumber) {
                try {
                    const now = Date.now();
                    const intensity = this.getLightningIntensity(stageNumber);
                    
                    // Phase 4: 状態の健全性チェック
                    if (this.activeShootingStars.length > this.maxConcurrentStars * 2) {
                        console.warn(`[LightningSystem] Too many active shooting stars (${this.activeShootingStars.length}), clearing excess`);
                        // 古い流れ星から優先的に削除
                        this.activeShootingStars.sort((a, b) => a.creationTime - b.creationTime);
                        const excess = this.activeShootingStars.splice(this.maxConcurrentStars);
                        excess.forEach(star => this.cleanupShootingStar(star));
                    }
                    
                    if (this.trailSegments.length > 20) {
                        console.warn(`[LightningSystem] Too many trail segments (${this.trailSegments.length}), forcing cleanup`);
                        // 古い残像から優先的に削除
                        this.trailSegments.sort((a, b) => a.creationTime - b.creationTime);
                        const excess = this.trailSegments.splice(10);
                        excess.forEach(segment => this.forceRemoveTrailSegment(segment));
                    }
                    
                    // 新しい流れ星の生成タイミング制御
                    if (now - this.lastUpdate > intensity.frequency) {
                        this.createShootingStars(stageNumber);
                        this.lastUpdate = now;
                    }
                    
                    // 流れ星のアニメーション更新
                    const deltaTime = 0.016; // 約60FPS想定
                    this.updateShootingStars(deltaTime);
                    
                } catch (error) {
                    console.error('[LightningSystem] Critical error in update:', error);
                    // 緊急時のクリーンアップ
                    try {
                        this.clearActiveLightning();
                    } catch (cleanupError) {
                        console.error('[LightningSystem] Error during emergency cleanup:', cleanupError);
                    }
                }
            }
            
            cleanup() {
                this.clearActiveLightning();
            }
        }
        
        // 次元2: 認識論的次元 - レーダー探知システム
        class RadarDimensionSystem {
            constructor(scene) {
                this.scene = scene;
                this.radarBeam = null;
                this.detectionRings = [];
                this.rotationSpeed = 0.005; // より穏やかな基本速度に変更
                this.sweepAngle = Math.PI / 3; // 60度の扇形
                this.maxRange = 4.0;
                this.currentAngle = 0;
                this.axisVariation = 0; // 回転軸の変化用
            }
            
            createRadarBeam(stageNumber) {
                this.cleanup();
                const intensity = this.getRadarIntensity(stageNumber);
                
                // メインレーダービーム（扇形）- グラデーション用の複数セグメントで構成
                const beamGeometry = new THREE.ConeGeometry(
                    intensity.range, 
                    0.05, 
                    32, // セグメント数を増やしてグラデーション効果向上
                    1, 
                    true, 
                    0, 
                    this.sweepAngle
                );
                
                // カラフルグラデーションマテリアル作成
                const gradientMaterial = this.createGradientMaterial(intensity.colors, intensity.opacity);
                
                this.radarBeam = new THREE.Mesh(beamGeometry, gradientMaterial);
                this.radarBeam.rotation.x = -Math.PI / 2; // 水平に配置
                this.radarBeam.position.y = 0.05; // わずかに上に配置
                
                // 探知リング効果
                this.createDetectionRings(intensity);
                
                this.scene.add(this.radarBeam);
                this.rotationSpeed = intensity.rotationSpeed;
            }
            
            createGradientMaterial(colors, opacity) {
                // カラフルグラデーション用のシェーダーマテリアル
                const vertexShader = `
                    varying vec2 vUv;
                    varying float vDistance;
                    void main() {
                        vUv = uv;
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vDistance = length(worldPosition.xz);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;
                
                const fragmentShader = `
                    uniform vec3 colors[${colors.length}];
                    uniform float opacity;
                    uniform float time;
                    varying vec2 vUv;
                    varying float vDistance;
                    
                    void main() {
                        // 距離とUVに基づくグラデーション
                        float t = vDistance * 0.3 + sin(time * 2.0) * 0.1;
                        t = fract(t); // 0-1の範囲にループ
                        
                        // 複数色の補間
                        float colorIndex = t * float(${colors.length - 1});
                        int index1 = int(floor(colorIndex));
                        int index2 = min(index1 + 1, ${colors.length - 1});
                        float mix_factor = fract(colorIndex);
                        
                        vec3 color1 = colors[index1];
                        vec3 color2 = colors[index2];
                        vec3 finalColor = mix(color1, color2, mix_factor);
                        
                        // UV座標に基づく透明度の変化でよりダイナミックに
                        float alpha = opacity * (0.8 + 0.2 * sin(vUv.x * 3.14159));
                        
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `;
                
                return new THREE.ShaderMaterial({
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    uniforms: {
                        colors: { value: colors.map(c => new THREE.Color(c)) },
                        opacity: { value: opacity },
                        time: { value: 0.0 }
                    },
                    transparent: true,
                    side: THREE.DoubleSide
                });
            }
            
            createDetectionRings(intensity) {
                const ringCount = intensity.ringCount;
                
                for (let i = 0; i < ringCount; i++) {
                    const ringRadius = (i + 1) * (intensity.range / ringCount);
                    const ringGeometry = new THREE.RingGeometry(
                        ringRadius - 0.02, 
                        ringRadius, 
                        64 // セグメント数を増やしてより滑らかに
                    );
                    
                    // 各リングも異なる色のグラデーションを適用
                    const colorIndex = i % intensity.colors.length;
                    const ringGradientMaterial = this.createRingGradientMaterial(
                        intensity.colors[colorIndex],
                        intensity.ringOpacity,
                        i
                    );
                    
                    const ring = new THREE.Mesh(ringGeometry, ringGradientMaterial);
                    ring.rotation.x = -Math.PI / 2;
                    ring.position.y = 0.01;
                    
                    ring.userData = {
                        baseOpacity: intensity.ringOpacity,
                        pulsePhase: i * Math.PI / 2, // 位相をずらしてリップル効果
                        pulseSpeed: 0.05,
                        material: ringGradientMaterial // マテリアル参照を保存
                    };
                    
                    this.detectionRings.push(ring);
                    this.scene.add(ring);
                }
            }
            
            createRingGradientMaterial(baseColor, opacity, ringIndex) {
                const vertexShader = `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;
                
                const fragmentShader = `
                    uniform vec3 baseColor;
                    uniform float opacity;
                    uniform float time;
                    uniform float ringIndex;
                    varying vec2 vUv;
                    
                    void main() {
                        // 円形グラデーション効果
                        float angle = atan(vUv.y - 0.5, vUv.x - 0.5);
                        float normalizedAngle = (angle + 3.14159) / (2.0 * 3.14159);
                        
                        // 時間とリングインデックスに基づく色の変化
                        float hueShift = normalizedAngle + time * 0.5 + ringIndex * 0.2;
                        
                        // HSVライクな色変換で虹色効果
                        vec3 color = baseColor;
                        color.r = baseColor.r + sin(hueShift * 2.0) * 0.3;
                        color.g = baseColor.g + sin(hueShift * 2.0 + 2.0) * 0.3;
                        color.b = baseColor.b + sin(hueShift * 2.0 + 4.0) * 0.3;
                        color = clamp(color, 0.0, 1.0);
                        
                        gl_FragColor = vec4(color, opacity);
                    }
                `;
                
                return new THREE.ShaderMaterial({
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    uniforms: {
                        baseColor: { value: new THREE.Color(baseColor) },
                        opacity: { value: opacity },
                        time: { value: 0.0 },
                        ringIndex: { value: ringIndex }
                    },
                    transparent: true,
                    side: THREE.DoubleSide
                });
            }
            
            getRadarIntensity(stageNumber) {
                if (stageNumber <= 3) {
                    // EA段階: 遅い回転、狭い範囲 - パステルブルー系グラデーション
                    return {
                        range: 2.0,
                        colors: [0x87ceeb, 0xb0e0e6, 0xe0f6ff], // スカイブルー → パウダーブルー → アリスブルー
                        opacity: 0.15,
                        rotationSpeed: 0.008, // さらに遅く
                        ringCount: 2,
                        ringOpacity: 0.1,
                        detectionSensitivity: 0.3
                    };
                } else if (stageNumber <= 7) {
                    // 岐路段階: 多彩な色合い - グリーン・イエロー・ピンク系グラデーション
                    return {
                        range: 3.0,
                        colors: [0x98fb98, 0xffffe0, 0xffc0cb, 0x87ceeb, 0xdda0dd], // ペールグリーン → ライトイエロー → ピンク → スカイブルー → プラム
                        opacity: 0.25,
                        rotationSpeed: 0.015, // 遅めに調整
                        ringCount: 3,
                        ringOpacity: 0.15,
                        detectionSensitivity: 0.5
                    };
                } else {
                    // IA段階: カラフルな虹色 - 豊富な色彩のグラデーション
                    return {
                        range: 4.0,
                        colors: [0xffa07a, 0xffb6c1, 0x98fb98, 0x87ceeb, 0xdda0dd, 0xf0e68c, 0xffa500], // ライトサーモン → ライトピンク → ペールグリーン → スカイブルー → プラム → カーキ → オレンジ
                        opacity: 0.35,
                        rotationSpeed: 0.02, // 高速から中速に変更
                        ringCount: 4,
                        ringOpacity: 0.2,
                        detectionSensitivity: 0.8
                    };
                }
            }
            
            update(time, particles) {
                if (!this.radarBeam) return;
                
                // レーダービームの動的軸変化回転システム
                this.currentAngle += this.rotationSpeed;
                this.axisVariation += 0.003; // 軸変化の速度を少し上げる
                
                // 回転軸自体を動的に変化させる
                const axisX = Math.sin(this.axisVariation * 0.7) * 0.3; // X軸方向の軸変化
                const axisY = 1.0; // Y軸の基本成分
                const axisZ = Math.cos(this.axisVariation * 0.5) * 0.3; // Z軸方向の軸変化
                
                // 正規化して回転軸ベクトルを作成
                const axisLength = Math.sqrt(axisX * axisX + axisY * axisY + axisZ * axisZ);
                const normalizedAxisX = axisX / axisLength;
                const normalizedAxisY = axisY / axisLength;
                const normalizedAxisZ = axisZ / axisLength;
                
                // 動的回転軸での回転を適用
                const quaternion = new THREE.Quaternion();
                quaternion.setFromAxisAngle(
                    new THREE.Vector3(normalizedAxisX, normalizedAxisY, normalizedAxisZ), 
                    this.currentAngle
                );
                
                // 基本姿勢（水平配置）からの回転を適用
                const baseQuaternion = new THREE.Quaternion();
                baseQuaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2);
                
                // 最終的な回転を設定
                this.radarBeam.quaternion.copy(baseQuaternion.multiply(quaternion));
                
                // 探知リングのパルス効果とグラデーション更新
                this.detectionRings.forEach(ring => {
                    if (ring.userData) {
                        const pulseValue = Math.sin(time * ring.userData.pulseSpeed + ring.userData.pulsePhase);
                        
                        // シェーダーマテリアルの時間更新
                        if (ring.userData.material && ring.userData.material.uniforms) {
                            ring.userData.material.uniforms.time.value = time * 0.001;
                            ring.userData.material.uniforms.opacity.value = ring.userData.baseOpacity + pulseValue * 0.1;
                        }
                    }
                });
                
                // メインレーダービームのシェーダー時間更新
                if (this.radarBeam && this.radarBeam.material && this.radarBeam.material.uniforms) {
                    this.radarBeam.material.uniforms.time.value = time * 0.001;
                }
                
                // パーティクル探知効果（未来の拡張ポイント）
                this.detectParticles(particles);
            }
            
            detectParticles(particles) {
                // パーティクルがレーダー範囲内にある場合の視覚効果
                // （現在は基本実装、将来的にはより高度な探知効果を追加可能）
                if (!particles || !this.radarBeam) return;
                
                particles.forEach(particle => {
                    if (!particle.position) return;
                    
                    const distance = particle.position.length();
                    const intensity = this.getRadarIntensity(this.getCurrentStage());
                    
                    if (distance <= intensity.range) {
                        // 探知されたパーティクルの微細な効果
                        // （現在は控えめな実装）
                    }
                });
            }
            
            getCurrentStage() {
                // 現在のステージを取得するヘルパー（メインクラスから参照）
                return 5; // デフォルト値
            }
            
            cleanup() {
                if (this.radarBeam) {
                    this.scene.remove(this.radarBeam);
                    this.radarBeam.geometry.dispose();
                    this.radarBeam.material.dispose();
                    this.radarBeam = null;
                }
                
                this.detectionRings.forEach(ring => {
                    this.scene.remove(ring);
                    ring.geometry.dispose();
                    ring.material.dispose();
                });
                this.detectionRings = [];
            }
        }
        
        // TargetCore用ミニレーダーシステム - 他者の認識論的探知を表現
        class MiniRadarSystem {
            constructor(scene, parentCore) {
                this.scene = scene;
                this.parentCore = parentCore;
                this.radarBeam = null;
                this.detectionRings = [];
                this.rotationSpeed = 0.003 + Math.random() * 0.002; // 各他者固有の速度
                this.sweepAngle = Math.PI / 6; // 30度の小さな扇形
                this.maxRange = 0.8; // 小さな探知範囲
                this.currentAngle = Math.random() * Math.PI * 2; // ランダム開始角度
                this.axisVariation = Math.random() * Math.PI * 2; // 各他者固有の軸変化
                this.colorPhase = Math.random() * Math.PI * 2; // カラー位相
            }
            
            createMiniRadarBeam(coreColor) {
                this.cleanup();
                
                // メインレーダービーム（小さな扇形）
                const beamGeometry = new THREE.ConeGeometry(
                    this.maxRange, 
                    0.02, // 非常に薄く
                    16, 
                    1, 
                    true, 
                    0, 
                    this.sweepAngle
                );
                
                // コアと調和するグラデーションマテリアル
                const gradientMaterial = this.createMiniGradientMaterial(coreColor);
                
                this.radarBeam = new THREE.Mesh(beamGeometry, gradientMaterial);
                this.radarBeam.rotation.x = -Math.PI / 2; // 水平に配置
                this.radarBeam.position.copy(this.parentCore.position);
                this.radarBeam.position.y += 0.02; // わずかに上に配置
                
                // 小さな探知リング効果
                this.createMiniDetectionRings(coreColor);
                
                this.scene.add(this.radarBeam);
            }
            
            createMiniGradientMaterial(coreColor) {
                const baseColor = new THREE.Color(coreColor);
                
                const vertexShader = `
                    varying vec2 vUv;
                    varying float vDistance;
                    void main() {
                        vUv = uv;
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vDistance = length(worldPosition.xz);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;
                
                const fragmentShader = `
                    uniform vec3 baseColor;
                    uniform float opacity;
                    uniform float time;
                    uniform float colorPhase;
                    varying vec2 vUv;
                    varying float vDistance;
                    
                    void main() {
                        // 距離とUVに基づくグラデーション
                        float t = vDistance * 0.5 + sin(time * 3.0 + colorPhase) * 0.2;
                        t = fract(t);
                        
                        // ベースカラーから派生した美しいグラデーション
                        vec3 color1 = baseColor;
                        vec3 color2 = baseColor * 1.3; // 明るく
                        vec3 color3 = baseColor * 0.7; // 暗く
                        
                        vec3 finalColor;
                        if (t < 0.5) {
                            finalColor = mix(color1, color2, t * 2.0);
                        } else {
                            finalColor = mix(color2, color3, (t - 0.5) * 2.0);
                        }
                        
                        float alpha = opacity * (0.6 + 0.4 * sin(vUv.x * 3.14159));
                        
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `;
                
                return new THREE.ShaderMaterial({
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    uniforms: {
                        baseColor: { value: baseColor },
                        opacity: { value: 0.15 }, // 控えめな透明度
                        time: { value: 0.0 },
                        colorPhase: { value: this.colorPhase }
                    },
                    transparent: true,
                    side: THREE.DoubleSide
                });
            }
            
            createMiniDetectionRings(coreColor) {
                const ringCount = 2; // 小さなリング2つ
                const baseColor = new THREE.Color(coreColor);
                
                for (let i = 0; i < ringCount; i++) {
                    const ringRadius = (i + 1) * (this.maxRange / ringCount);
                    const ringGeometry = new THREE.RingGeometry(
                        ringRadius - 0.01, 
                        ringRadius, 
                        32 
                    );
                    
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: baseColor,
                        transparent: true,
                        opacity: 0.1,
                        side: THREE.DoubleSide
                    });
                    
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = -Math.PI / 2;
                    ring.position.copy(this.parentCore.position);
                    ring.position.y += 0.01;
                    
                    ring.userData = {
                        baseOpacity: 0.1,
                        pulsePhase: i * Math.PI / 2 + this.colorPhase,
                        pulseSpeed: 0.03,
                        baseColor: baseColor.clone()
                    };
                    
                    this.detectionRings.push(ring);
                    this.scene.add(ring);
                }
            }
            
            update(time) {
                if (!this.radarBeam) return;
                
                // ミニレーダービームの回転
                this.currentAngle += this.rotationSpeed;
                this.axisVariation += 0.001;
                
                // 親コアの位置に追従
                this.radarBeam.position.copy(this.parentCore.position);
                this.radarBeam.position.y += 0.02;
                
                // 動的回転軸での回転
                const axisX = Math.sin(this.axisVariation * 0.5) * 0.2;
                const axisY = 1.0;
                const axisZ = Math.cos(this.axisVariation * 0.3) * 0.2;
                
                const axisLength = Math.sqrt(axisX * axisX + axisY * axisY + axisZ * axisZ);
                const normalizedAxisX = axisX / axisLength;
                const normalizedAxisY = axisY / axisLength;
                const normalizedAxisZ = axisZ / axisLength;
                
                const quaternion = new THREE.Quaternion();
                quaternion.setFromAxisAngle(
                    new THREE.Vector3(normalizedAxisX, normalizedAxisY, normalizedAxisZ), 
                    this.currentAngle
                );
                
                const baseQuaternion = new THREE.Quaternion();
                baseQuaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2);
                
                this.radarBeam.quaternion.copy(baseQuaternion.multiply(quaternion));
                
                // シェーダーマテリアルの時間更新
                if (this.radarBeam && this.radarBeam.material && this.radarBeam.material.uniforms) {
                    this.radarBeam.material.uniforms.time.value = time * 0.001;
                }
                
                // 探知リングの更新
                this.detectionRings.forEach(ring => {
                    // 親コアの位置に追従
                    ring.position.copy(this.parentCore.position);
                    ring.position.y += 0.01;
                    
                    if (ring.userData) {
                        const pulseValue = Math.sin(time * ring.userData.pulseSpeed + ring.userData.pulsePhase);
                        ring.material.opacity = ring.userData.baseOpacity + pulseValue * 0.05;
                    }
                });
            }
            
            cleanup() {
                if (this.radarBeam) {
                    this.scene.remove(this.radarBeam);
                    this.radarBeam.geometry.dispose();
                    this.radarBeam.material.dispose();
                    this.radarBeam = null;
                }
                
                this.detectionRings.forEach(ring => {
                    this.scene.remove(ring);
                    ring.geometry.dispose();
                    ring.material.dispose();
                });
                this.detectionRings = [];
            }
        }
        
        // 次元3: 対人関係次元 - ニューロンシナプス伝達システム
        class BeamDimensionSystem {
            constructor(scene) {
                this.scene = scene;
                this.particleStreams = []; // 伝達物質のパーティクルストリーム
                this.targetCores = []; // 他のコア（目標地点）
                this.connectionPaths = []; // 接続パス
                this.transmissionActive = {}; // 伝達状態管理
                this.maxConnections = 8;
                this.particleCount = 15; // 各ストリームのパーティクル数
                this.miniRadars = []; // 各TargetCore用のミニレーダーシステム
            }
            
            createNeuralConnections(stageNumber) {
                this.cleanup();
                const intensity = this.getSynapseIntensity(stageNumber);
                
                // 段階に応じた接続数と目標コアの配置
                const connectionCount = intensity.connectionCount;
                this.createTargetCores(connectionCount, intensity);
                
                // 各接続に対してパーティクルストリームを作成
                for (let i = 0; i < connectionCount; i++) {
                    const targetCore = this.targetCores[i];
                    const particleStream = this.createParticleStream(targetCore, intensity, i);
                    this.particleStreams.push(particleStream);
                    this.scene.add(particleStream.group);
                    
                    // 伝達状態を初期化
                    this.transmissionActive[i] = {
                        active: true,
                        lastTransmission: Math.random() * 3000, // より広いランダム開始時刻（0-3秒）
                        interval: 600 + Math.random() * 2400, // 0.6-3秒の多様な間隔
                        baseInterval: 1200 + Math.random() * 1800, // 基準間隔（個体差）
                        intervalVariation: 0.3 + Math.random() * 0.7, // 間隔変動係数
                        particles: []
                    };
                }
            }
            
            createTargetCores(count, intensity) {
                this.targetCores = [];
                const radius = intensity.connectionDistance;
                
                // 7種類の3D形状定義（パーティクルより大きく）
                const geometryTypes = [
                    { name: 'sphere', create: () => new THREE.SphereGeometry(0.15, 8, 6) },
                    { name: 'box', create: () => new THREE.BoxGeometry(0.24, 0.24, 0.24) },
                    { name: 'cone', create: () => new THREE.ConeGeometry(0.15, 0.30, 6) },
                    { name: 'cylinder', create: () => new THREE.CylinderGeometry(0.12, 0.12, 0.24, 6) },
                    { name: 'octahedron', create: () => new THREE.OctahedronGeometry(0.15) },
                    { name: 'icosahedron', create: () => new THREE.IcosahedronGeometry(0.15) },
                    { name: 'tetrahedron', create: () => new THREE.TetrahedronGeometry(0.18) }
                ];
                
                for (let i = 0; i < count; i++) {
                    // 均等な角度配置に少しのランダム性を加える
                    const baseAngle = (i / count) * Math.PI * 2;
                    const angle = baseAngle + (Math.random() - 0.5) * 0.3;
                    const elevation = (Math.random() - 0.5) * 0.4; // Y軸の変化
                    
                    const position = new THREE.Vector3(
                        Math.cos(angle) * radius,
                        elevation,
                        Math.sin(angle) * radius
                    );
                    
                    // ランダムな形状を選択
                    const randomGeometryType = geometryTypes[Math.floor(Math.random() * geometryTypes.length)];
                    const coreGeometry = randomGeometryType.create();
                    
                    // 様々な他者を表現する多彩な色彩パレット
                    const diverseColors = [
                        0x87ceeb, // スカイブルー - 理性的な他者
                        0xffa07a, // ライトサーモン - 温かい他者
                        0x98fb98, // ペールグリーン - 自然体な他者
                        0xdda0dd, // プラム - 神秘的な他者
                        0xf0e68c, // カーキ - 地に足ついた他者
                        0xffb6c1, // ライトピンク - 感情豊かな他者
                        0xffd700, // ゴールド - 輝く他者
                        0xff6347, // トマト - 情熱的な他者
                        0x40e0d0, // ターコイズ - 清らかな他者
                        0xda70d6, // オーキッド - 個性的な他者
                        0x32cd32, // ライムグリーン - 生命力ある他者
                        0xff69b4, // ホットピンク - 活発な他者
                        0x00ced1, // ダークターコイズ - 深い他者
                        0xffa500, // オレンジ - エネルギッシュな他者
                        0x9370db  // ミディアムパープル - 創造的な他者
                    ];
                    
                    const randomColor = diverseColors[Math.floor(Math.random() * diverseColors.length)];
                    const coreMaterial = new THREE.MeshBasicMaterial({
                        color: randomColor,
                        transparent: true,
                        opacity: 0.4 // 存在感を抑えるため半透明に変更
                    });
                    
                    const core = new THREE.Mesh(coreGeometry, coreMaterial);
                    core.position.copy(position);
                    
                    // ワイヤーフレーム効果（エッジ強調）- 中央コアと同様
                    const wireframeGeometry = new THREE.EdgesGeometry(coreGeometry);
                    const wireframeMaterial = new THREE.LineBasicMaterial({ 
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.6,
                        linewidth: 1
                    });
                    
                    const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
                    core.add(wireframe); // コアの子として追加
                    
                    // グロー効果も同じ形状で少し大きく、同じ色調で
                    const glowScale = 1.5;
                    const glowGeometry = randomGeometryType.create();
                    glowGeometry.scale(glowScale, glowScale, glowScale);
                    
                    // グローは同じ色の淡いバージョンを使用
                    const glowColor = new THREE.Color(randomColor);
                    glowColor.multiplyScalar(0.8); // 少し暗くして統一感を保つ
                    
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: glowColor,
                        transparent: true,
                        opacity: 0.15 // グローも控えめに変更
                    });
                    
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    glow.position.copy(position);
                    
                    this.scene.add(core);
                    this.scene.add(glow);
                    
                    // 回転アニメーション用のプロパティを追加
                    core.userData = {
                        rotationSpeed: {
                            x: (Math.random() - 0.5) * 0.02,
                            y: (Math.random() - 0.5) * 0.02,
                            z: (Math.random() - 0.5) * 0.02
                        },
                        baseScale: 1.0,
                        pulseSpeed: 0.5 + Math.random() * 1.0,
                        pulsePhase: Math.random() * Math.PI * 2,
                        // 位置移動のパラメータ（より活発な動き）
                        basePosition: position.clone(),
                        movementSpeed: {
                            x: (Math.random() - 0.5) * 0.003, // 3倍に増加
                            y: (Math.random() - 0.5) * 0.002, // 2.5倍に増加
                            z: (Math.random() - 0.5) * 0.003  // 3倍に増加
                        },
                        movementPhase: {
                            x: Math.random() * Math.PI * 2,
                            y: Math.random() * Math.PI * 2,
                            z: Math.random() * Math.PI * 2
                        },
                        movementRadius: {
                            x: 0.5 + Math.random() * 0.6, // X軸の移動範囲拡大
                            y: 0.3 + Math.random() * 0.5, // Y軸の移動範囲拡大
                            z: 0.5 + Math.random() * 0.6  // Z軸の移動範囲拡大
                        },
                        distanceVariation: 0.7 + Math.random() * 0.6 // 0.7-1.3倍の距離変動拡大
                    };
                    
                    glow.userData = {
                        rotationSpeed: core.userData.rotationSpeed,
                        baseScale: glowScale,
                        pulseSpeed: core.userData.pulseSpeed,
                        pulsePhase: core.userData.pulsePhase,
                        // 位置移動パラメータをグローも共有
                        basePosition: position.clone(),
                        movementSpeed: core.userData.movementSpeed,
                        movementPhase: core.userData.movementPhase,
                        movementRadius: core.userData.movementRadius,
                        distanceVariation: core.userData.distanceVariation
                    };
                    
                    this.targetCores.push({
                        position: position.clone(),
                        core: core,
                        glow: glow,
                        index: i,
                        geometryType: randomGeometryType.name
                    });
                    
                    // 各TargetCoreにミニレーダーシステムを追加
                    const miniRadar = new MiniRadarSystem(this.scene, core);
                    miniRadar.createMiniRadarBeam(randomColor);
                    this.miniRadars.push(miniRadar);
                }
            }
            
            createParticleStream(targetCore, intensity, streamIndex) {
                const group = new THREE.Group();
                const particles = [];
                
                // ストリームの方向ベクトル
                const direction = targetCore.position.clone().normalize();
                
                for (let i = 0; i < this.particleCount; i++) {
                    // 各パーティクルは最初非表示
                    const particleGeometry = new THREE.SphereGeometry(0.02, 6, 4);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: intensity.particleColors[Math.floor(Math.random() * intensity.particleColors.length)],
                        transparent: true,
                        opacity: 0
                    });
                    
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    
                    // パーティクルのメタデータ
                    particle.userData = {
                        originalOpacity: 0.8,
                        progress: 0, // 0-1の進行度
                        speed: 0.4 + Math.random() * 0.4, // 0.4-0.8 の速度（緩やかに変更）
                        startDelay: i * 100, // パーティクル間の遅延
                        targetPosition: targetCore.position.clone(),
                        direction: direction.clone(),
                        active: false,
                        pulsePhase: Math.random() * Math.PI * 2
                    };
                    
                    group.add(particle);
                    particles.push(particle);
                }
                
                return {
                    group: group,
                    particles: particles,
                    targetCore: targetCore,
                    direction: direction.clone(),
                    streamIndex: streamIndex
                };
            }
            
            getSynapseIntensity(stageNumber) {
                if (stageNumber <= 3) {
                    // EA段階: 少ない接続、短距離、穏やかな色彩
                    return {
                        connectionCount: Math.max(1, Math.min(2, stageNumber)),
                        connectionDistance: 8.0,
                        particleColors: [0x87ceeb, 0xb0e0e6, 0xe6f3ff], // パステルブルー系
                        coreColor: 0xb0e0e6,
                        glowColor: 0x87ceeb,
                        transmissionFrequency: 0.3, // 低頻度
                        particleSpeed: 0.6,
                        connectionOpacity: 0.4
                    };
                } else if (stageNumber <= 7) {
                    // 岐路段階: 中程度の接続、多彩な色彩
                    const progressInPhase = (stageNumber - 3) / 4;
                    return {
                        connectionCount: Math.floor(3 + progressInPhase * 3), // 3-6接続
                        connectionDistance: 7.5,
                        particleColors: [
                            0x98fb98, 0xffffe0, 0xffc0cb, // ペールグリーン、ライトイエロー、ピンク
                            0x87ceeb, 0xdda0dd, 0xf0e68c  // スカイブルー、プラム、カーキ
                        ],
                        coreColor: 0xffc0cb,
                        glowColor: 0x98fb98,
                        transmissionFrequency: 0.6, // 中頻度
                        particleSpeed: 0.8,
                        connectionOpacity: 0.6
                    };
                } else {
                    // IA段階: 豊富な接続、虹色の美しい色彩
                    const progressInPhase = (stageNumber - 7) / 3;
                    return {
                        connectionCount: Math.floor(6 + progressInPhase * 2), // 6-8接続
                        connectionDistance: 7.5,
                        particleColors: [
                            0xffa07a, 0xffb6c1, 0x98fb98, 0x87ceeb, // ライトサーモン、ライトピンク、ペールグリーン、スカイブルー
                            0xdda0dd, 0xf0e68c, 0xffa500, 0xff6347  // プラム、カーキ、オレンジ、トマト
                        ],
                        coreColor: 0xffa07a,
                        glowColor: 0xffb6c1,
                        transmissionFrequency: 1.0, // 高頻度
                        particleSpeed: 1.0,
                        connectionOpacity: 0.8
                    };
                }
            }
            
            update(time, stageNumber) {
                const intensity = this.getSynapseIntensity(stageNumber);
                const currentTime = Date.now();
                
                this.particleStreams.forEach((stream, streamIndex) => {
                    if (!this.transmissionActive[streamIndex]) return;
                    
                    const transmissionState = this.transmissionActive[streamIndex];
                    
                    // 伝達開始のタイミングをチェック
                    if (currentTime - transmissionState.lastTransmission > transmissionState.interval) {
                        this.startTransmission(stream, intensity);
                        transmissionState.lastTransmission = currentTime;
                        // より自然なランダム間隔（個体差と変動を考慮）
                        const baseInterval = transmissionState.baseInterval;
                        const variation = transmissionState.intervalVariation;
                        transmissionState.interval = baseInterval * (1 - variation + Math.random() * variation * 2);
                    }
                    
                    // アクティブなパーティクルの更新
                    stream.particles.forEach(particle => {
                        if (!particle.userData.active) return;
                        
                        // パーティクルの進行
                        particle.userData.progress += particle.userData.speed * 0.008;
                        
                        if (particle.userData.progress <= 1.0) {
                            // パーティクルの位置更新（ベジェ曲線で自然な軌道）
                            const startPos = new THREE.Vector3(0, 0, 0);
                            // リアルタイムのターゲット座標を使用（動的追跡）
                            const endPos = stream.targetCore.position.clone();
                            const t = particle.userData.progress;
                            
                            // ベジェ曲線の中間制御点を作成（弧を描く）
                            const midPoint = startPos.clone().lerp(endPos, 0.5);
                            midPoint.y += 0.3 * Math.sin(Math.PI * t); // 上向きの弧
                            
                            // 二次ベジェ曲線
                            const pos1 = startPos.clone().lerp(midPoint, t);
                            const pos2 = midPoint.clone().lerp(endPos, t);
                            const finalPos = pos1.lerp(pos2, t);
                            
                            particle.position.copy(finalPos);
                            
                            // 透明度とサイズのアニメーション
                            const fadeIn = Math.min(1.0, t * 4); // 開始時のフェードイン
                            const fadeOut = Math.max(0, 1 - (t - 0.8) * 5); // 終了時のフェードアウト
                            const opacity = fadeIn * fadeOut * particle.userData.originalOpacity;
                            
                            // パルス効果
                            const pulse = Math.sin(time * 0.01 + particle.userData.pulsePhase) * 0.2 + 0.8;
                            particle.material.opacity = opacity * pulse;
                            
                            // サイズ変化（美しい輝き）
                            const scale = 1 + Math.sin(time * 0.02 + particle.userData.pulsePhase) * 0.3;
                            particle.scale.setScalar(scale);
                            
                        } else {
                            // パーティクルが目標に到達、接続効果を表示
                            this.showConnectionEffect(stream.targetCore, intensity);
                            this.resetParticle(particle);
                        }
                    });
                    
                    // 目標コアの回転・呼吸・位置移動アニメーション更新
                    const targetCore = stream.targetCore;
                    if (targetCore && targetCore.core && targetCore.glow) {
                        // 各コアの独立した回転
                        targetCore.core.rotation.x += targetCore.core.userData.rotationSpeed.x;
                        targetCore.core.rotation.y += targetCore.core.userData.rotationSpeed.y;
                        targetCore.core.rotation.z += targetCore.core.userData.rotationSpeed.z;
                        
                        targetCore.glow.rotation.x += targetCore.glow.userData.rotationSpeed.x;
                        targetCore.glow.rotation.y += targetCore.glow.userData.rotationSpeed.y;
                        targetCore.glow.rotation.z += targetCore.glow.userData.rotationSpeed.z;
                        
                        // 自律的位置移動（他者の動き）
                        const movementTime = time * 0.001;
                        const coreData = targetCore.core.userData;
                        
                        // 各軸で独立した三角関数による滑らかな移動
                        const offsetX = Math.sin(movementTime * coreData.movementSpeed.x * 10 + coreData.movementPhase.x) * coreData.movementRadius.x;
                        const offsetY = Math.sin(movementTime * coreData.movementSpeed.y * 10 + coreData.movementPhase.y) * coreData.movementRadius.y;
                        const offsetZ = Math.cos(movementTime * coreData.movementSpeed.z * 10 + coreData.movementPhase.z) * coreData.movementRadius.z;
                        
                        // 距離変動（近くなったり遠くなったり）- より顕著な変化
                        const distanceModulation = Math.sin(movementTime * 0.5 + coreData.pulsePhase) * 0.3 + 1;
                        const finalDistanceMultiplier = coreData.distanceVariation * distanceModulation;
                        
                        // 新しい位置を計算
                        const newPosition = coreData.basePosition.clone();
                        newPosition.multiplyScalar(finalDistanceMultiplier);
                        newPosition.add(new THREE.Vector3(offsetX, offsetY, offsetZ));
                        
                        // コアとグローの位置を更新
                        targetCore.core.position.copy(newPosition);
                        targetCore.glow.position.copy(newPosition);
                        
                        // targetCoreオブジェクトの位置情報も更新（パーティクル軌道計算用）
                        targetCore.position.copy(newPosition);
                        
                        // 呼吸のような脈動効果（自律的生命感）
                        const pulse = Math.sin(time * 0.001 * targetCore.core.userData.pulseSpeed + targetCore.core.userData.pulsePhase);
                        const breathingScale = targetCore.core.userData.baseScale + pulse * 0.15;
                        const breathingGlowScale = targetCore.glow.userData.baseScale + pulse * 0.2;
                        
                        targetCore.core.scale.setScalar(breathingScale);
                        targetCore.glow.scale.setScalar(breathingGlowScale);
                        
                        // 色の微妙な変化（活動感を表現）- 各コアの個別色を維持
                        const colorVariation = (Math.sin(time * 0.002 + targetCore.core.userData.pulsePhase) + 1) * 0.1;
                        const originalColor = targetCore.core.userData.originalColor || targetCore.core.material.color.clone();
                        
                        // 初回時に元の色を保存
                        if (!targetCore.core.userData.originalColor) {
                            targetCore.core.userData.originalColor = targetCore.core.material.color.clone();
                        }
                        
                        const enhancedColor = originalColor.clone();
                        enhancedColor.multiplyScalar(1 + colorVariation);
                        targetCore.core.material.color.copy(enhancedColor);
                    }
                    
                    // 目標コアのグロー効果更新
                    if (stream.targetCore && stream.targetCore.glow) {
                        const glowPulse = Math.sin(time * 0.005 + streamIndex) * 0.3 + 0.7;
                        stream.targetCore.glow.material.opacity = 0.2 * glowPulse;
                        stream.targetCore.glow.scale.setScalar(1 + glowPulse * 0.2);
                    }
                });
                
                // ミニレーダーシステムの更新
                this.miniRadars.forEach(miniRadar => {
                    miniRadar.update(time);
                });
            }
            
            startTransmission(stream, intensity) {
                // 非アクティブなパーティクルを選んでアクティブ化
                const inactiveParticles = stream.particles.filter(p => !p.userData.active);
                if (inactiveParticles.length === 0) return;
                
                // 同時に発射するパーティクル数（3-7個）
                const burstCount = Math.floor(3 + Math.random() * 5);
                
                for (let i = 0; i < Math.min(burstCount, inactiveParticles.length); i++) {
                    const particle = inactiveParticles[i];
                    particle.userData.active = true;
                    particle.userData.progress = 0;
                    particle.position.set(0, 0, 0); // コアの中央から開始
                    
                    // ランダムな色を割り当て
                    const randomColor = intensity.particleColors[Math.floor(Math.random() * intensity.particleColors.length)];
                    particle.material.color.setHex(randomColor);
                }
            }
            
            showConnectionEffect(targetCore, intensity) {
                if (!targetCore || !targetCore.core) return;
                
                // 接続成功の瞬間的フラッシュ効果
                const originalOpacity = targetCore.core.material.opacity;
                targetCore.core.material.opacity = 1.0;
                
                setTimeout(() => {
                    if (targetCore.core && targetCore.core.material) {
                        targetCore.core.material.opacity = originalOpacity;
                    }
                }, 200);
                
                // グローの一時的強化
                if (targetCore.glow) {
                    const originalGlowOpacity = targetCore.glow.material.opacity;
                    targetCore.glow.material.opacity = 0.8;
                    targetCore.glow.scale.setScalar(1.5);
                    
                    setTimeout(() => {
                        if (targetCore.glow && targetCore.glow.material) {
                            targetCore.glow.material.opacity = originalGlowOpacity;
                            targetCore.glow.scale.setScalar(1.0);
                        }
                    }, 400);
                }
            }
            
            resetParticle(particle) {
                particle.userData.active = false;
                particle.userData.progress = 0;
                particle.material.opacity = 0;
                particle.scale.setScalar(1);
                particle.position.set(0, 0, 0);
            }
            
            cleanup() {
                // パーティクルストリームのクリーンアップ
                this.particleStreams.forEach(stream => {
                    if (stream.group) {
                        stream.particles.forEach(particle => {
                            particle.geometry.dispose();
                            particle.material.dispose();
                        });
                        this.scene.remove(stream.group);
                    }
                });
                
                // 目標コアのクリーンアップ
                this.targetCores.forEach(targetCore => {
                    if (targetCore.core) {
                        this.scene.remove(targetCore.core);
                        targetCore.core.geometry.dispose();
                        targetCore.core.material.dispose();
                    }
                    if (targetCore.glow) {
                        this.scene.remove(targetCore.glow);
                        targetCore.glow.geometry.dispose();
                        targetCore.glow.material.dispose();
                    }
                });
                
                this.particleStreams = [];
                this.targetCores = [];
                this.connectionPaths = [];
                this.transmissionActive = {};
                
                // ミニレーダーシステムのクリーンアップ
                this.miniRadars.forEach(miniRadar => {
                    miniRadar.cleanup();
                });
                this.miniRadars = [];
            }
        }
        
        class CoreGeometryManager {
            constructor() {
                this.currentGeometry = null;
                this.transitionDuration = 2000; // 2秒のトランジション
            }

            createPolyhedronGeometry(stage) {
                // 段階に応じたサイズの決定
                const baseSize = this.getStageSize(stage);
                
                switch(stage) {
                    case 'Ea':
                    case 'Eb': 
                    case 'Ec':
                        // 正四面体 (Tetrahedron) - External Authority期
                        return new THREE.TetrahedronGeometry(baseSize);
                        
                    case 'EI':
                    case 'E-I':
                    case 'I-E':
                        // 正八面体 (Octahedron) - Transition期
                        return new THREE.OctahedronGeometry(baseSize);
                        
                    case 'IE':
                    case 'Ia':
                        // 正十二面体 (Dodecahedron) - Internal Foundation期
                        return new THREE.DodecahedronGeometry(baseSize);
                        
                    case 'Ib':
                    case 'Ic':
                        // 正二十面体 (Icosahedron) - Self-Authorship期
                        return new THREE.IcosahedronGeometry(baseSize);
                        
                    default:
                        // デフォルトは正四面体
                        return new THREE.TetrahedronGeometry(baseSize);
                }
            }

            getStageSize(stage) {
                // 成長に応じたサイズマッピング
                const sizeMap = {
                    // External Authority期 - 小さく、未発達
                    'Ea': 0.35,  // 最小サイズ
                    'Eb': 0.4,   // 少し成長
                    'Ec': 0.45,  // 疑問の兆し
                    
                    // Transition期 - 中程度、探求期
                    'EI': 0.5,   // 内的探求の始まり
                    'E-I': 0.55, // 内なる声の構築
                    'I-E': 0.6,  // 内なる声を聴く
                    
                    // Internal Foundation期 - 大きく、確立期
                    'IE': 0.65,  // 内なる声を育む
                    'Ia': 0.7,   // 内なる声を信頼
                    
                    // Self-Authorship期 - 最大、統合期
                    'Ib': 0.75,  // 内なる基盤確立
                    'Ic': 0.8    // 最大サイズ、完全な統合
                };
                
                return sizeMap[stage] || 0.35; // デフォルトは最小サイズ
            }

            getSizeDescription(stage) {
                const size = this.getStageSize(stage);
                const percentage = Math.round((size / 0.8) * 100); // 最大サイズを100%として
                return `サイズ: ${percentage}% (${size.toFixed(2)})`;
            }

            getPolyhedronName(stage) {
                const shapeName = this.getShapeName(stage);
                const sizeInfo = this.getSizeDescription(stage);
                return `${shapeName} - ${sizeInfo}`;
            }

            getShapeName(stage) {
                switch(stage) {
                    case 'Ea': case 'Eb': case 'Ec':
                        return 'Tetrahedron (正四面体)';
                    case 'EI': case 'E-I': case 'I-E':
                        return 'Octahedron (正八面体)';
                    case 'IE': case 'Ia':
                        return 'Dodecahedron (正十二面体)';
                    case 'Ib': case 'Ic':
                        return 'Icosahedron (正二十面体)';
                    default:
                        return 'Tetrahedron (正四面体)';
                }
            }

            createWireframeGeometry(geometry) {
                // エッジのみを表示（面の内部の対角線を除去）
                // thresholdAngleを設定して、隣接する面の角度が一定以上の場合のみエッジとして認識
                const edges = new THREE.EdgesGeometry(geometry, 40); // 40度の角度閾値
                return edges;
            }
        }

        class RefinedSelfAuthorshipVisualization {
            constructor() {
                this.container = null;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.currentStage = 'Ea';
                this.isInitialized = false;
                this.isInitializing = false;
                this.animationFrameId = null;
                this.particles = [];
                this.core = null;
                this.coreLight = null;                // コア発光ライト
                this.baseCoreIntensity = 0.3;         // コアの基本光量
                this.currentCoreIntensity = 0.3;      // 現在のコア光量
                this.maxCoreIntensity = 1.5;          // 最大コア光量
                this.absorptionCount = 0;             // 吸収されたパーティクル数
                // 新しい次元効果システム
                this.lightningDimension = null;      // 次元1: 稲光システム
                this.radarDimension = null;          // 次元2: レーダーシステム  
                this.beamDimension = null;           // 次元3: 光線システム
                this.controls = null;
                
                // 説明表示システム
                this.explanationSystem = null;      // 説明表示システム
                
                // 多面体システム
                this.coreGeometryManager = new CoreGeometryManager();
                this.isTransitioning = false;        // 形状変更中フラグ
                
                // 段階的光強化システム - セルフ・オーサーシップの成長に応じたコア光の発達
                this.lightVeils = [];                 // 光のベール配列
                this.stageProgressionOrder = ['I-E', 'IE', 'Ia', 'Ib', 'Ic']; // 光のベールが出現するステージ順
                this.currentStageIndex = 0;           // 現在のステージインデックス
                
                // 光のベールが表示されないステージのリスト
                this.noLightVeilStages = ['Ea', 'Eb', 'Ec', 'EI', 'E-I'];
                
                // I(E)ステージ以降の光線接続システム
                this.connectionLines = [];            // パーティクル間の接続線
                this.connectionPairs = new Map();     // 接続ペアの管理
                this.maxConnections = 45;             // 最大接続数（Icステージの極めて豊富な接続に対応）
                this.connectionUpdateInterval = 10000; // 接続更新間隔（ミリ秒）- 経験の結びつきを長時間維持
                this.lastConnectionUpdate = 0;        // 最後の接続更新時刻
                
                // 接続線のフェード効果システム
                this.isConnectionTransitioning = false; // 接続線遷移中フラグ
                this.fadeOutDuration = 1500;           // フェードアウト期間（ミリ秒）
                this.fadeInDuration = 1500;            // フェードイン期間（ミリ秒）
                this.transitionStartTime = 0;          // 遷移開始時刻
                this.pendingConnections = [];          // 次の接続パターン（待機中）
                this.transitionPhase = 'none';         // 遷移フェーズ: 'none', 'fadeOut', 'fadeIn'
                
                // ステージ別接続制限 - セルフ・オーサーシップの成長に応じた経験統合能力の発達
                this.stageConnectionLimits = {
                    'IE': 3,      // IEステージ：内なる声を育む段階 - 少ない接続
                    'Ia': 8,      // Iaステージ：過去の意味づけ段階 - 基礎的な接続
                    'Ib': 18,      // Ibステージ：統合の基盤段階 - 中程度の接続
                    'Ic': 32      // Icステージ：発見と気づき段階 - 極めて豊富な接続（広範囲な経験統合・完全なコミットメント）
                };
                
                // Zoom controls
                this.defaultCameraZ = 10;
                this.minZoom = 3;
                this.maxZoom = 20;
                this.zoomSpeed = 0.1;
                
                // カメラ回転制御（見回し効果用）
                this.cameraRotationAngle = 0; // 現在のカメラ回転角度
                this.baseLookAtTarget = { x: 0, y: 0, z: 0 }; // 基準となる注視点
                this.lookAroundRadius = 8; // 見回し時の視線半径（控えめに）
                this.lastCameraRotationAngle = 0; // 前回の角度（スムーズ補間用）
                
                // Dynamic particle management for questioning stage
                this.dynamicParticles = [];
                this.lastParticleSpawn = 0;
                this.persistentParticleIndices = new Set();
                
                // Colorful particle system for I(E) stages and beyond
                this.colorfulParticlePalette = [
                    0xff6b6b, 0x4ecdc4, 0x45b7d1, 0x96c93d, 0xffeaa7,
                    0xdda0dd, 0x98d8c8, 0xf7dc6f, 0xbb8fce, 0x85c1e9,
                    0xf8c471, 0x82e0aa, 0xf1948a, 0x85c1e9, 0xc39bd3,
                    0x7fb3d3, 0xaed6f1, 0xf9e79f, 0xa3e4d7, 0xd7bde2
                ];
                this.colorTransitionSpeed = 0.05;
                
                // I-E Stage Particle Emergence System
                this.isEmergingIE = false;           // I-E出現アニメーション中フラグ
                this.emergenceStartTime = 0;         // 出現開始時刻
                this.emergenceDelay = 500;           // 切り替え後の遅延（ms）
                this.emergenceDuration = 2500;       // 全パーティクル出現期間（ms）
                this.particleEmergenceInterval = 100; // パーティクル間出現間隔（ms）
                this.emergingParticles = [];         // 出現中パーティクルのリスト
                this.emergenceTransitionStarted = false; // 出現アニメーション遷移開始フラグ
                this.emergenceTransitionTime = 0;    // 遷移開始時刻
                
                // 地面移動システム - セルフ・オーサーシップの人生の旅路表現
                this.groundMovementSystem = null;   // 地面移動システム
                this.isGroundActive = false;        // 地面システムの有効状態
            }
            
            async init(containerId) {
                if (this.isInitialized || this.isInitializing) return;
                this.isInitializing = true;
                
                console.log('🚀 3D環境初期化開始');
                console.log('📋 システム情報:', {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    hardwareConcurrency: navigator.hardwareConcurrency,
                    language: navigator.language
                });
                
                this.container = document.getElementById(containerId);
                if (!this.container) {
                    console.error('❌ コンテナが見つかりません:', containerId);
                    this.showError();
                    this.isInitializing = false;
                    return;
                }
                
                console.log('✅ コンテナが見つかりました:', {
                    id: containerId,
                    width: this.container.offsetWidth,
                    height: this.container.offsetHeight
                });
                
                // WebGLサポートの確認
                console.log('🔍 WebGL対応をチェック中...');
                if (!this.checkWebGLSupport()) {
                    console.error('❌ WebGLがサポートされていません');
                    this.showError();
                    this.isInitializing = false;
                    return;
                }
                console.log('✅ WebGL対応を確認しました');
                
                this.showLoading();
                
                try {
                    console.log('🎬 3Dシーン作成中...');
                    await this.createScene();
                    console.log('✅ 3Dシーン作成完了');
                    
                    console.log('🎮 コントロール作成中...');
                    this.createControls();
                    console.log('✅ コントロール作成完了');
                    
                    console.log('🔗 イベントバインド中...');
                    this.bindEvents();
                    console.log('✅ イベントバインド完了');
                    
                    console.log('▶️ アニメーション開始...');
                    this.startAnimation();
                    console.log('✅ アニメーション開始完了');
                    
                    this.hideLoading();
                    this.isInitialized = true;
                    console.log('🎉 3D環境の初期化が完了しました');
                } catch (error) {
                    console.error('3D初期化エラー:', error);
                    console.error('エラー詳細:', error.message);
                    console.error('スタックトレース:', error.stack);
                    this.showError();
                } finally {
                    this.isInitializing = false;
                }
            }
            
            // WebGLサポートの確認（改良版）
            isWebGLSupported() {
                try {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('webgl2') || 
                                   canvas.getContext('webgl') || 
                                   canvas.getContext('experimental-webgl');
                    
                    if (!context) {
                        console.warn('WebGLコンテキストの作成に失敗');
                        return false;
                    }
                    
                    // 基本的なWebGL機能をテスト
                    const renderer = context.getParameter(context.RENDERER);
                    const vendor = context.getParameter(context.VENDOR);
                    
                    console.log('WebGL情報:', { renderer, vendor });
                    
                    // ソフトウェアレンダリングの検出
                    if (renderer && (
                        renderer.toLowerCase().includes('software') ||
                        renderer.toLowerCase().includes('llvmpipe') ||
                        renderer.toLowerCase().includes('mesa')
                    )) {
                        console.warn('ソフトウェアレンダリングが検出されました');
                    }
                    
                    return true;
                } catch (e) {
                    console.error('WebGL対応チェックエラー:', e);
                    return false;
                }
            }
            
            // WebGLレンダラーの作成（フォールバック対応）
            createWebGLRenderer() {
                const rendererOptions = [
                    // 最高品質設定
                    { 
                        antialias: true, 
                        alpha: false, 
                        powerPreference: 'high-performance',
                        precision: 'highp'
                    },
                    // 中品質設定
                    { 
                        antialias: true, 
                        alpha: false, 
                        powerPreference: 'default'
                    },
                    // 低品質設定
                    { 
                        antialias: false, 
                        alpha: false, 
                        powerPreference: 'low-power'
                    },
                    // 最小設定
                    { 
                        antialias: false
                    }
                ];
                
                for (let i = 0; i < rendererOptions.length; i++) {
                    try {
                        console.log(`WebGLレンダラー作成試行 ${i + 1}/${rendererOptions.length}`, rendererOptions[i]);
                        const renderer = new THREE.WebGLRenderer(rendererOptions[i]);
                        
                        // レンダラーのテスト
                        const context = renderer.getContext();
                        if (context) {
                            console.log('WebGLレンダラーが正常に作成されました');
                            return renderer;
                        }
                    } catch (e) {
                        console.warn(`レンダラー作成失敗 (試行 ${i + 1}):`, e);
                        continue;
                    }
                }
                
                console.error('すべてのWebGLレンダラー作成オプションが失敗しました');
                return null;
            }

            // WebGLサポートの確認（旧版 - 互換性のため残す）
            checkWebGLSupport() {
                return this.isWebGLSupported();
            }

            showLoading() {
                const loading = document.getElementById('refined-3d-loading');
                if (loading) loading.style.display = 'flex';
            }
            
            hideLoading() {
                const loading = document.getElementById('refined-3d-loading');
                const controls = document.getElementById('refined-3d-controls');
                if (loading) loading.style.display = 'none';
                if (controls) controls.style.display = 'block';
            }
            
            showError() {
                const loading = document.getElementById('refined-3d-loading');
                if (loading) {
                    // WebGL診断情報を取得
                    const diagnostics = this.getWebGLDiagnostics();
                    
                    loading.innerHTML = `
                        <div style="text-align: center; color: #ff6b6b; max-width: 700px; margin: 0 auto;">
                            <h4>🚫 3D表示エラー</h4>
                            <p>3D表示の初期化に失敗しました。</p>
                            
                            <div style="background: #1a1a1a; padding: 15px; border-radius: 8px; margin: 15px 0; text-align: left;">
                                <h5 style="color: #ffd700; margin-top: 0;">🔍 診断情報</h5>
                                <ul style="color: #ccc; line-height: 1.6; font-size: 13px;">
                                    <li><strong>WebGL対応:</strong> ${diagnostics.webglSupported ? '✅ 対応' : '❌ 非対応'}</li>
                                    ${diagnostics.webglVersion ? `<li><strong>WebGLバージョン:</strong> ${diagnostics.webglVersion}</li>` : ''}
                                    <li><strong>ハードウェアアクセラレーション:</strong> ${diagnostics.hardwareAccelerated ? '✅ 有効' : '⚠️ 無効の可能性'}</li>
                                    <li><strong>レンダラー:</strong> ${diagnostics.renderer || '不明'}</li>
                                    <li><strong>ベンダー:</strong> ${diagnostics.vendor || '不明'}</li>
                                    ${diagnostics.maxTextureSize ? `<li><strong>最大テクスチャサイズ:</strong> ${diagnostics.maxTextureSize}px</li>` : ''}
                                    <li><strong>対応拡張機能:</strong> ${diagnostics.extensions.length}個</li>
                                    <li><strong>ブラウザ:</strong> ${this.getBrowserInfo()}</li>
                                    ${diagnostics.errors.length > 0 ? `<li style="color: #ff6b6b;"><strong>エラー:</strong><br>${diagnostics.errors.join('<br>')}</li>` : ''}
                                </ul>
                            </div>
                            
                            <div style="background: #2a1a1a; padding: 15px; border-radius: 8px; margin: 15px 0; text-align: left;">
                                <h5 style="color: #ffd700; margin-top: 0;">💡 よくある原因と解決方法</h5>
                                <div style="color: #ccc; line-height: 1.6; font-size: 13px;">
                                    <h6 style="color: #4ecdc4; margin: 10px 0 5px 0;">🔄 すぐに試せる方法:</h6>
                                    <ol>
                                        <li><strong>ブラウザの完全再起動</strong> (全てのタブを閉じて再起動)</li>
                                        <li><strong>シークレット/プライベートモード</strong>で試行</li>
                                        <li><strong>他のGPU集約的アプリ</strong>を終了</li>
                                        <li><strong>ブラウザのキャッシュをクリア</strong></li>
                                    </ol>
                                    
                                    <h6 style="color: #4ecdc4; margin: 15px 0 5px 0;">⚙️ 設定の確認:</h6>
                                    <ol start="5">
                                        <li><strong>Chrome:</strong> chrome://settings/system → ハードウェアアクセラレーション有効</li>
                                        <li><strong>Firefox:</strong> about:config → webgl.disabled = false</li>
                                        <li><strong>Safari:</strong> 開発メニュー → WebGLを有効にする</li>
                                    </ol>
                                    
                                    <h6 style="color: #4ecdc4; margin: 15px 0 5px 0;">🛠️ システム関連:</h6>
                                    <ol start="8">
                                        <li><strong>グラフィックドライバー</strong>を最新版に更新</li>
                                        <li><strong>OS の更新</strong>を確認</li>
                                        <li><strong>別のブラウザ</strong>で試行 (Chrome推奨)</li>
                                    </ol>
                                </div>
                            </div>
                            
                            <div style="margin-top: 20px;">
                                <button onclick="location.reload()" style="padding: 12px 24px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; margin-right: 10px; font-size: 14px;">
                                    🔄 再読み込み
                                </button>
                                <button onclick="window.open('https://get.webgl.org/', '_blank')" style="padding: 12px 24px; background: #6b7280; color: white; border: none; border-radius: 6px; cursor: pointer; margin-right: 10px; font-size: 14px;">
                                    🔗 WebGLテスト
                                </button>
                                <button onclick="navigator.clipboard?.writeText(JSON.stringify(${JSON.stringify(diagnostics)}, null, 2))" style="padding: 12px 24px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px;">
                                    📋 診断情報コピー
                                </button>
                            </div>
                            
                            <div style="margin-top: 15px; font-size: 12px; color: #888;">
                                💡 問題が解決しない場合は、診断情報をコピーして技術サポートにお問い合わせください
                            </div>
                        </div>
                    `;
                }
            }
            
            // ブラウザ情報を取得
            getBrowserInfo() {
                const ua = navigator.userAgent;
                if (ua.includes('Chrome') && !ua.includes('Edg')) {
                    return 'Chrome';
                } else if (ua.includes('Firefox')) {
                    return 'Firefox';
                } else if (ua.includes('Safari') && !ua.includes('Chrome')) {
                    return 'Safari';
                } else if (ua.includes('Edg')) {
                    return 'Edge';
                } else {
                    return 'その他';
                }
            }
            
            // WebGL診断情報を取得（拡張版）
            getWebGLDiagnostics() {
                const diagnostics = {
                    webglSupported: false,
                    hardwareAccelerated: false,
                    renderer: null,
                    vendor: null,
                    userAgent: navigator.userAgent,
                    webglVersion: null,
                    maxTextureSize: null,
                    maxRenderBufferSize: null,
                    extensions: [],
                    errors: []
                };
                
                try {
                    const canvas = document.createElement('canvas');
                    let gl = null;
                    
                    // WebGL2を試行
                    try {
                        gl = canvas.getContext('webgl2');
                        if (gl) {
                            diagnostics.webglVersion = 'WebGL 2.0';
                            diagnostics.webglSupported = true;
                        }
                    } catch (e) {
                        diagnostics.errors.push('WebGL2作成エラー: ' + e.message);
                    }
                    
                    // WebGL2が失敗した場合、WebGL1を試行
                    if (!gl) {
                        try {
                            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                            if (gl) {
                                diagnostics.webglVersion = 'WebGL 1.0';
                                diagnostics.webglSupported = true;
                            }
                        } catch (e) {
                            diagnostics.errors.push('WebGL1作成エラー: ' + e.message);
                        }
                    }
                    
                    if (gl) {
                        try {
                            // 基本情報を取得
                            diagnostics.renderer = gl.getParameter(gl.RENDERER);
                            diagnostics.vendor = gl.getParameter(gl.VENDOR);
                            diagnostics.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                            diagnostics.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
                            
                            // 拡張機能一覧を取得
                            const extensions = gl.getSupportedExtensions();
                            diagnostics.extensions = extensions || [];
                            
                            // ハードウェアアクセラレーションの推定
                            const renderer = diagnostics.renderer?.toLowerCase() || '';
                            diagnostics.hardwareAccelerated = !(
                                renderer.includes('software') ||
                                renderer.includes('llvmpipe') ||
                                renderer.includes('mesa') ||
                                renderer.includes('swiftshader') ||
                                renderer.includes('microsoft basic render driver')
                            );
                            
                            // デバッグ情報をコンソールに出力
                            console.log('🔍 詳細WebGL診断情報:', {
                                version: diagnostics.webglVersion,
                                renderer: diagnostics.renderer,
                                vendor: diagnostics.vendor,
                                maxTextureSize: diagnostics.maxTextureSize,
                                maxRenderBufferSize: diagnostics.maxRenderBufferSize,
                                extensionsCount: diagnostics.extensions.length,
                                hardwareAccelerated: diagnostics.hardwareAccelerated
                            });
                            
                        } catch (e) {
                            diagnostics.errors.push('WebGL情報取得エラー: ' + e.message);
                        }
                    } else {
                        diagnostics.errors.push('WebGLコンテキストの作成に失敗');
                    }
                    
                } catch (e) {
                    diagnostics.errors.push('WebGL診断エラー: ' + e.message);
                    console.error('WebGL診断エラー:', e);
                }
                
                return diagnostics;
            }
            
            async createScene() {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        try {
                            // WebGL対応チェック
                            if (!this.isWebGLSupported()) {
                                throw new Error('WebGL is not supported');
                            }
                            
                            // Create Three.js scene
                            this.scene = new THREE.Scene();
                            this.scene.background = new THREE.Color(0x0a0a0a);
                            
                            // Create camera
                            const aspect = this.container.offsetWidth / this.container.offsetHeight;
                            this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
                            this.camera.position.set(0, 0, this.defaultCameraZ);
                            
                            // Create renderer with fallback options
                            this.renderer = this.createWebGLRenderer();
                            if (!this.renderer) {
                                throw new Error('Failed to create WebGL renderer');
                            }
                            
                            this.renderer.setSize(this.container.offsetWidth, this.container.offsetHeight);
                            this.renderer.setClearColor(0x0a0a0a);
                            
                            // Add renderer to container
                            const sceneElement = document.getElementById('refined-3d-scene');
                            if (sceneElement) {
                                sceneElement.appendChild(this.renderer.domElement);
                            } else {
                                throw new Error('Scene container not found');
                            }
                            
                            // Create basic 3D content
                            this.createInitialContent();
                        
                        // Add lighting
                        const ambientLight = new THREE.AmbientLight(0x606060, 0.5); // より明るい環境光
                        this.scene.add(ambientLight);
                        
                        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // より強い指向性ライト
                        directionalLight.position.set(10, 10, 5);
                        this.scene.add(directionalLight);
                        
                        // 追加のポイントライトで立体感を強化
                        const pointLight1 = new THREE.PointLight(0xffffff, 0.5, 100);
                        pointLight1.position.set(-10, -10, 10);
                        this.scene.add(pointLight1);
                            
                            const pointLight2 = new THREE.PointLight(0xffffff, 0.3, 100);
                            pointLight2.position.set(5, -5, -10);
                            this.scene.add(pointLight2);
                            
                            resolve();
                        } catch (error) {
                            console.error('createScene内でエラー:', error);
                            reject(error);
                        }
                    }, 2000); // 2秒の初期化時間
                });
            }
            
            createInitialContent() {
                // Create core (self) with polyhedron geometry
                this.createPolyhedronCore(this.currentStage);
                
                // Create core light for enhanced introspection effect
                this.coreLight = new THREE.PointLight(0xffffcc, this.baseCoreIntensity, 10);
                this.coreLight.position.set(0, 0, 0);
                this.scene.add(this.coreLight);
                
                // Initialize progressive light enhancement system
                this.initializeLightVeils();
                
                // Initialize new dimension effect systems
                this.initializeDimensionEffects();
                
                // Initialize ground movement system
                this.initializeGroundSystem();
                
                // 説明表示システムの初期化
                this.initializeExplanationSystem();
                
                // Create stage-specific particles
                this.createStageParticles();
            }
            
            // 説明表示システムの初期化
            initializeExplanationSystem() {
                if (!this.explanationSystem) {
                    this.explanationSystem = new ExplanationDisplaySystem(this.container);
                }
            }
            
            // 新しい次元効果システムの初期化
            initializeDimensionEffects() {
                // 既存のシステムをクリーンアップ
                this.cleanupDimensionEffects();
                
                // 3つの次元システムを初期化（パーティクル参照は動的に渡す）
                this.lightningDimension = new LightningDimensionSystem([], this.scene);
                this.radarDimension = new RadarDimensionSystem(this.scene);
                this.beamDimension = new BeamDimensionSystem(this.scene);
                
                // 現在の段階に応じてシステムを更新
                const stageNumber = this.getStageNumber(this.currentStage);
                this.updateDimensionEffects(stageNumber);
            }
            
            // 次元効果の段階別更新
            updateDimensionEffects(stageNumber) {
                if (!this.lightningDimension || !this.radarDimension || !this.beamDimension) return;
                
                // レーダーシステムの更新
                this.radarDimension.createRadarBeam(stageNumber);
                
                // 光線システムの更新
                this.beamDimension.createNeuralConnections(stageNumber);
                
                // 稲光システムは動的に更新されるため、ここでは設定のみ
            }
            
            // 次元効果のクリーンアップ
            cleanupDimensionEffects() {
                if (this.lightningDimension) {
                    this.lightningDimension.cleanup();
                    this.lightningDimension = null;
                }
                if (this.radarDimension) {
                    this.radarDimension.cleanup();
                    this.radarDimension = null;
                }
                if (this.beamDimension) {
                    this.beamDimension.cleanup();
                    this.beamDimension = null;
                }
            }
            
            // 地面システムの初期化
            initializeGroundSystem() {
                if (this.groundMovementSystem) {
                    this.groundMovementSystem.cleanup();
                }
                
                // 地面移動システムを作成
                this.groundMovementSystem = new GroundMovementSystem(this.scene, this.camera);
                
                // 地面ドットを初期化
                this.groundMovementSystem.initializeGroundDots();
                
                // 現在の段階に応じた動作パターンを設定
                this.groundMovementSystem.setMovementPattern(this.currentStage);
                
                // 地面システムを有効化（デフォルトで表示）
                this.groundMovementSystem.setActive(true);
                this.isGroundActive = true;
                
                console.log('[3D] Ground movement system initialized for stage:', this.currentStage);
            }
            
            // 次元効果アニメーションの更新
            updateDimensionAnimations(time) {
                const stageNumber = this.getStageNumber(this.currentStage);
                
                // 次元1: 稲光システムの更新（動的にパーティクル配列を更新）
                if (this.lightningDimension) {
                    this.lightningDimension.particles = this.particles; // パーティクル配列を動的に更新
                    this.lightningDimension.update(stageNumber);
                }
                
                // 次元2: レーダーシステムの更新
                if (this.radarDimension) {
                    this.radarDimension.update(time, this.particles);
                }
                
                // 次元3: 光線システムの更新
                if (this.beamDimension) {
                    this.beamDimension.update(time, stageNumber);
                }
                
                // 地面移動システムの更新
                if (this.groundMovementSystem && this.isGroundActive) {
                    this.groundMovementSystem.updateGroundMovement();
                }
                
                // カメラの見回し効果を更新
                this.updateCameraLookAround();
            }
            
            createDimensionRings() {
                // 既存のリングをクリア
                this.dimensionRings.forEach(ring => this.scene.remove(ring));
                this.dimensionRings = [];
                
                // 現在の段階番号を取得（初期化時はEa=1）
                const currentStageNumber = this.getStageNumber(this.currentStage || 'Ea');
                
                for (let i = 0; i < 3; i++) {
                    // 段階に応じた半径を取得
                    const radius = this.getDimensionRingRadius(i, currentStageNumber);
                    const geometry = new THREE.TorusGeometry(radius, 0.05, 8, 32);
                    
                    // 多面体コアと統一した材質システム
                    const material = new THREE.MeshPhongMaterial({ 
                        color: this.getDimensionRingColor(i, currentStageNumber),
                        transparent: true,
                        opacity: this.getDimensionRingOpacity(currentStageNumber),
                        shininess: this.getDimensionRingShininess(currentStageNumber),
                        emissive: this.getDimensionRingEmissive(i, currentStageNumber),
                        emissiveIntensity: this.getDimensionRingEmissiveIntensity(currentStageNumber),
                        specular: 0x888888 // 統一された反射光
                    });
                    
                    const ring = new THREE.Mesh(geometry, material);
                    ring.rotation.x = Math.PI / 2 + (i * Math.PI / 6);
                    
                    // 段階的進化のためのプロパティを追加
                    ring.userData = {
                        ringIndex: i,
                        baseRotationX: Math.PI / 2 + (i * Math.PI / 6),
                        baseRotationSpeed: 0.1 + i * 0.05, // 基本回転速度
                        rotationDirection: i % 2 === 0 ? 1 : -1,
                        interactionPhase: 0, // 相互作用の位相
                        synchronizationFactor: 0, // 同期度合い
                        materialEvolution: 0 // 材質進化度
                    };
                    
                    this.scene.add(ring);
                    this.dimensionRings.push(ring);
                }
            }
            
            // 段階に応じた次元リングの半径を決定
            getDimensionRingRadius(ringIndex, stage) {
                // 基本半径（初期サイズ）
                const baseRadii = [1.8, 2.5, 3.2]; // 内側、中間、外側リング
                const baseRadius = baseRadii[ringIndex];
                
                // 段階に応じたサイズ倍率
                let sizeMultiplier;
                
                if (stage <= 3) {
                    // Ea, Eb, Ec: 小さめから開始
                    sizeMultiplier = 0.7 + stage * 0.1; // 0.8-1.0倍
                } else if (stage <= 7) {
                    // EI, E-I, I-E, IE: 徐々に拡大
                    sizeMultiplier = 1.0 + (stage - 3) * 0.12; // 1.0-1.48倍
                } else {
                    // Ia, Ib, Ic: 最も大きく
                    sizeMultiplier = 1.48 + (stage - 7) * 0.08; // 1.48-1.72倍
                }
                
                return baseRadius * sizeMultiplier;
            }

            // 段階に応じた次元リングの色を決定（多面体コアと統一化）
            getDimensionRingColor(ringIndex, stage) {
                // 多面体コアの色システムと統一した色相配置
                const baseHues = [240, 300, 60]; // 青紫系, 紫系, 黄緑系
                const hue = baseHues[ringIndex];
                
                // 多面体コアのサイズ進化に合わせた色彩発展
                const coreProgress = this.getCoreProgress(stage);
                
                // 段階に応じた色彩パラメータ（コアシステムと統一）
                let saturation, lightness;
                
                if (stage <= 3) {
                    // EA段階: 落ち着いた基調色
                    saturation = 45 + coreProgress * 15;     // 45-60%
                    lightness = 25 + coreProgress * 15;      // 25-40%
                } else if (stage <= 7) {
                    // 岐路段階: 活発な変化を表現
                    const transitionFactor = (stage - 3) / 4;
                    saturation = 60 + transitionFactor * 20; // 60-80%
                    lightness = 40 + transitionFactor * 25;  // 40-65%
                } else {
                    // IA段階: 輝く完成形
                    const masterFactor = (stage - 7) / 3;
                    saturation = 80 + masterFactor * 15;     // 80-95%
                    lightness = 65 + masterFactor * 20;      // 65-85%
                }
                
                // リング間の微妙な色彩変化（統一感を保ちながら区別）
                const ringVariation = ringIndex * 0.05;
                saturation = Math.min(95, saturation + ringVariation * 10);
                lightness = Math.max(15, lightness - ringVariation * 5);
                
                return new THREE.Color().setHSL(hue / 360, saturation / 100, lightness / 100).getHex();
            }
            
            // 段階に応じた透明度を決定
            getDimensionRingOpacity(stage) {
                if (stage <= 3) {
                    // EA段階: 0.35-0.50
                    return 0.35 + stage * 0.05;
                } else if (stage <= 7) {
                    // 岐路段階: 0.50-0.82
                    return 0.50 + (stage - 3) * 0.08;
                } else {
                    // IA段階: 0.82-0.94 (最も明るく)
                    return 0.82 + (stage - 7) * 0.04;
                }
            }
            
            // 段階に応じた光沢度を決定（多面体コアと統一化）
            getDimensionRingShininess(stage) {
                // 多面体コアの光沢進化システムと統一
                const coreProgress = this.getCoreProgress(stage);
                
                if (stage <= 3) {
                    // EA段階: 低光沢から始まる（コアの控えめな輝き）
                    return 10 + coreProgress * 20; // 10-30
                } else if (stage <= 7) {
                    // 岐路段階: 変化的な光沢（コアの変容と同期）
                    const transitionIntensity = (stage - 3) / 4;
                    return 30 + transitionIntensity * 50; // 30-80
                } else {
                    // IA段階: 高光沢・輝く完成形（コアの洗練された輝き）
                    const masterIntensity = (stage - 7) / 3;
                    return 80 + masterIntensity * 60; // 80-140
                }
            }

            // 次元リングのエミッシブ（発光）色を決定
            getDimensionRingEmissive(ringIndex, stage) {
                // コアシステムと統一したエミッシブ効果
                const baseHues = [240, 300, 60]; // 各リングの基本色相
                const hue = baseHues[ringIndex];
                const coreProgress = this.getCoreProgress(stage);
                
                // 段階に応じたエミッシブ強度
                let emissiveSaturation, emissiveLightness;
                
                if (stage <= 3) {
                    // EA段階: 微細な内部光
                    emissiveSaturation = 20 + coreProgress * 10; // 20-30%
                    emissiveLightness = 5 + coreProgress * 5;    // 5-10%
                } else if (stage <= 7) {
                    // 岐路段階: 動的な発光
                    const transitionFactor = (stage - 3) / 4;
                    emissiveSaturation = 30 + transitionFactor * 25; // 30-55%
                    emissiveLightness = 10 + transitionFactor * 10;  // 10-20%
                } else {
                    // IA段階: 強い内部光
                    const masterFactor = (stage - 7) / 3;
                    emissiveSaturation = 55 + masterFactor * 20; // 55-75%
                    emissiveLightness = 20 + masterFactor * 15;  // 20-35%
                }
                
                return new THREE.Color().setHSL(hue / 360, emissiveSaturation / 100, emissiveLightness / 100).getHex();
            }

            // 次元リングのエミッシブ強度を決定
            getDimensionRingEmissiveIntensity(stage) {
                const coreProgress = this.getCoreProgress(stage);
                
                if (stage <= 3) {
                    // EA段階: 弱い発光
                    return 0.1 + coreProgress * 0.1; // 0.1-0.2
                } else if (stage <= 7) {
                    // 岐路段階: 中程度の発光
                    const transitionFactor = (stage - 3) / 4;
                    return 0.2 + transitionFactor * 0.3; // 0.2-0.5
                } else {
                    // IA段階: 強い発光
                    const masterFactor = (stage - 7) / 3;
                    return 0.5 + masterFactor * 0.3; // 0.5-0.8
                }
            }

            // 多面体コアの進化度合いを計算（統一化のためのベースメトリック）
            getCoreProgress(stage) {
                // 10段階の進化を0.0-1.0の範囲で正規化
                if (stage <= 1) return 0.0;
                if (stage >= 10) return 1.0;
                
                // 各段階グループ内での進行度を計算
                if (stage <= 3) {
                    // EA段階 (1-3): 基礎形成期
                    return (stage - 1) / 9; // 0.0-0.22
                } else if (stage <= 7) {
                    // 岐路段階 (4-7): 変容期
                    return (stage - 1) / 9; // 0.33-0.67
                } else {
                    // IA段階 (8-10): 完成期
                    return (stage - 1) / 9; // 0.78-1.0
                }
            }

            createPolyhedronCore(stage) {
                // 既存のコアを削除
                if (this.core) {
                    this.scene.remove(this.core);
                    if (this.core.geometry) this.core.geometry.dispose();
                    if (this.core.material) this.core.material.dispose();
                }

                // 段階に応じた多面体ジオメトリを作成
                const coreGeometry = this.coreGeometryManager.createPolyhedronGeometry(stage);
                
                // 段階データから色彩を取得
                const stageData = this.getStageData(stage);
                const stageColor = stageData.color;
                
                // diverseColors配列を定義
                const diverseColors = [
                    0x87ceeb, // スカイブルー - 理性的な他者
                    0xffa07a, // ライトサーモン - 温かい他者
                    0x98fb98, // ペールグリーン - 自然体な他者
                    0xdda0dd, // プラム - 神秘的な他者
                    0xf0e68c, // カーキ - 地に足ついた他者
                    0xffb6c1, // ライトピンク - 感情豊かな他者
                    0xffd700, // ゴールド - 輝く他者
                    0xff6347, // トマト - 情熱的な他者
                    0x40e0d0, // ターコイズ - 清らかな他者
                    0xda70d6, // オーキッド - 個性的な他者
                    0x32cd32, // ライムグリーン - 生命力ある他者
                    0xff69b4, // ホットピンク - 活発な他者
                    0x00ced1, // ダークターコイズ - 深い他者
                    0xffa500, // オレンジ - エネルギッシュな他者
                    0x9370db  // ミディアムパープル - 創造的な他者
                ];
                
                // 段階に応じた色数を決定
                const colorCount = this.getColorCountForStage(stage);
                const selectedColors = this.selectColorsForStage(diverseColors, colorCount);
                
                // 多面体用マテリアル（面ごとに色分け）
                let coreMaterial;
                if (selectedColors.length > 1) {
                    // 複数色の場合、面ごとに異なる色を適用
                    coreMaterial = this.createMultiColorMaterial(coreGeometry, selectedColors);
                } else {
                    // 単色の場合、従来通り
                    coreMaterial = new THREE.MeshPhongMaterial({ 
                        color: selectedColors[0],
                        emissive: 0x333333,
                        transparent: true,
                        opacity: 0.85,
                        shininess: 100,
                        wireframe: false
                    });
                }
                
                // メインの多面体メッシュ
                this.core = new THREE.Mesh(coreGeometry, coreMaterial);
                this.scene.add(this.core);
                
                // ワイヤーフレーム効果（エッジ強調）
                const wireframeGeometry = this.coreGeometryManager.createWireframeGeometry(coreGeometry);
                const wireframeMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.6,
                    linewidth: 2
                });
                
                const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
                this.core.add(wireframe); // コアの子として追加
                
                // 頂点光点効果
                this.createVertexLights(coreGeometry, stageColor);
                
                console.log(`コア形状更新: ${this.coreGeometryManager.getPolyhedronName(stage)}`);
            }

            createVertexLights(geometry, baseColor) {
                // 頂点位置を取得
                const vertices = geometry.attributes.position.array;
                const vertexCount = vertices.length / 3;
                
                // 既存の頂点ライトを削除
                if (this.vertexLights) {
                    this.vertexLights.forEach(light => {
                        this.scene.remove(light);
                    });
                }
                this.vertexLights = [];
                
                // 各頂点に小さな光点を配置
                for (let i = 0; i < vertexCount; i += 3) { // 間引いて配置
                    const x = vertices[i * 3];
                    const y = vertices[i * 3 + 1];
                    const z = vertices[i * 3 + 2];
                    
                    // 小さな球体光点
                    const lightGeometry = new THREE.SphereGeometry(0.02, 8, 8);
                    const lightMaterial = new THREE.MeshBasicMaterial({ 
                        color: baseColor,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const lightSphere = new THREE.Mesh(lightGeometry, lightMaterial);
                    lightSphere.position.set(x, y, z);
                    
                    this.core.add(lightSphere); // コアの子として追加
                }
            }

            // 段階に応じた色数を決定
            getColorCountForStage(stage) {
                switch(stage) {
                    case 'Ea':
                    case 'Eb': 
                    case 'Ec':
                        // Tetrahedron: 1色
                        return 1;
                        
                    case 'EI':
                    case 'E-I':
                    case 'I-E':
                        // Octahedron: 3色
                        return 3;
                        
                    case 'IE':
                    case 'Ia':
                        // Dodecahedron: 5色
                        return 5;
                        
                    case 'Ib':
                    case 'Ic':
                        // Icosahedron: 8色
                        return 8;
                        
                    default:
                        return 1;
                }
            }

            // 段階に応じた色を選択
            selectColorsForStage(diverseColors, colorCount) {
                const shuffled = [...diverseColors].sort(() => 0.5 - Math.random());
                return shuffled.slice(0, colorCount);
            }

            // 複数色マテリアルを作成（面単位での色付け対応）
            createMultiColorMaterial(geometry, colors) {
                // 面の数を取得（三角形面の数）
                const faceCount = geometry.attributes.position.count / 3;
                const faceColors = [];
                
                // 白色（未知なる可能性）の定義
                const whiteColor = new THREE.Color(0xffffff);
                
                // 多面体の種類に応じた面グループ化を判定
                const actualFaceCount = this.getActualFaceCount(geometry);
                const trianglesPerFace = Math.round(faceCount / actualFaceCount);
                
                console.log(`[色付け] 三角形面数: ${faceCount}, 実際の面数: ${actualFaceCount}, 面あたり三角形数: ${trianglesPerFace}`);
                
                // 各三角形に色を割り当て（面単位でグループ化）
                for (let i = 0; i < faceCount; i++) {
                    // どの実際の面に属するかを計算
                    const actualFaceIndex = Math.floor(i / trianglesPerFace);
                    let color;
                    
                    // 指定された色数までは多様な色、残りは白（未知なる可能性）
                    if (actualFaceIndex < colors.length) {
                        color = new THREE.Color(colors[actualFaceIndex]);
                    } else {
                        color = whiteColor; // 未知なる可能性を表現する白い面
                    }
                    
                    // 各頂点（3つ）に同じ色を割り当て
                    faceColors.push(color.r, color.g, color.b);
                    faceColors.push(color.r, color.g, color.b);
                    faceColors.push(color.r, color.g, color.b);
                }
                
                // 色属性を追加
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(faceColors, 3));
                
                // 頂点カラーを使用するマテリアル
                return new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    emissive: 0x222222,
                    transparent: true,
                    opacity: 0.85,
                    shininess: 100,
                    wireframe: false
                });
            }

            // 多面体の実際の面数を取得（三角分割前の面数）
            getActualFaceCount(geometry) {
                // ジオメトリの頂点数から多面体の種類を推定
                const vertexCount = geometry.attributes.position.count;
                const triangleCount = vertexCount / 3;
                
                // 各多面体の理論的な面数（Eulerの多面体公式を参考）
                if (triangleCount <= 8) {
                    return 4;  // 正四面体: 4面
                } else if (triangleCount <= 16) {
                    return 8;  // 正八面体: 8面
                } else if (triangleCount <= 40) {
                    return 12; // 正十二面体: 12面（各五角形面が3-4個の三角形に分割）
                } else {
                    return 20; // 正二十面体: 20面
                }
            }

            initializeLightVeils() {
                // 段階的光強化システム - セルフ・オーサーシップの成長に応じた光のベール
                // 各ステージで大幅にサイズが増加する透明な光のベールを作成
                
                // 既存のベールをクリア
                this.lightVeils.forEach(veil => this.scene.remove(veil));
                this.lightVeils = [];
                
                // 5段階の光のベールを作成（I-E, IE, Ia, Ib, Ic）
                // より大きなサイズ差で視覚的な層の重なりを明確に表現
                const baseRadii = [0.4, 0.6, 0.9, 1.3, 1.8]; // 段階的に大幅増加
                
                for (let i = 0; i < 5; i++) {
                    const radius = baseRadii[i];
                    const geometry = new THREE.SphereGeometry(radius, 32, 32);
                    
                    // シンプルで確実な光のベール - MeshBasicMaterialで自己発光
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xffffee,              // 暖かみのある柔らかな白
                        transparent: true,
                        opacity: 0.005 + i * 0.002,  // 極めて透明度を高くして背景がはっきり見えるように
                        fog: false,                   // フォグの影響を受けない
                        side: THREE.DoubleSide,       // 両面描画で光らしさを強化
                        blending: THREE.AdditiveBlending,  // 加算ブレンディングで光らしさを強化
                        depthWrite: false             // 深度書き込みを無効化して透明感向上
                    });
                    
                    const veil = new THREE.Mesh(geometry, material);
                    veil.position.set(0, 0, 0);
                    
                    // 放射状グラデーション効果をマテリアル自体で実現
                    veil.material.userData = {
                        baseOpacity: 0.005 + i * 0.002,    // 基準透明度を極めて透明に
                        emissiveStrength: 0.15 + i * 0.03,
                        layerIndex: i
                    };
                    
                    // 呼吸のような動きのためのパラメータ
                    veil.userData = {
                        baseRadius: radius,
                        breatheSpeed: 0.8 + i * 0.1,
                        breathePhase: i * Math.PI / 3,
                        stageIndex: i,
                        visible: false  // 初期状態では非表示
                    };
                    
                    veil.visible = false; // 初期状態では非表示
                    this.scene.add(veil);
                    this.lightVeils.push(veil);
                }
            }
            
            createStageParticles() {
                // Clear existing particles
                this.particles.forEach(particle => this.scene.remove(particle));
                this.particles = [];
                
                // Create particles based on current stage
                const stageData = this.getStageData(this.currentStage);
                const particleCount = stageData.particleCount;
                const color = stageData.color;
                
                for (let i = 0; i < particleCount; i++) {
                    // 経験のメタファーとしてランダムなサイズを生成
                    // 基本サイズ0.04に対して、0.5倍〜1.8倍の範囲でランダム化
                    const baseSize = 0.04;
                    const sizeVariation = 0.5 + Math.random() * 1.3; // 0.5 - 1.8倍
                    const particleSize = baseSize * sizeVariation;
                    
                    // 段階に応じたサイズ調整：後期段階ほど大きく、多様になる
                    const stageNumber = this.getStageNumber(this.currentStage);
                    let stageSizeMultiplier = 1.0;
                    
                    if (stageNumber >= 8) { // Ia, Ib, Ic段階
                        stageSizeMultiplier = 1.0 + (stageNumber - 7) * 0.15; // 最大1.45倍
                    } else if (stageNumber >= 5) { // E-I, I-E, IE段階
                        stageSizeMultiplier = 1.0 + (stageNumber - 4) * 0.08; // 最大1.24倍
                    }
                    
                    const finalSize = particleSize * stageSizeMultiplier;
                    const geometry = new THREE.SphereGeometry(finalSize, 12, 12); // ランダムサイズ適用、品質も向上
                    
                    // サイズに応じた視覚的効果の調整
                    const sizeRatio = finalSize / baseSize; // サイズ比を計算
                    const baseOpacity = 0.9;
                    const sizeAdjustedOpacity = Math.min(baseOpacity * (0.7 + sizeRatio * 0.3), 1.0); // 大きいほど少し透明に
                    const sizeAdjustedEmissive = Math.floor(0x111111 * (0.8 + sizeRatio * 0.4)); // 大きいほど少し明るく発光
                    const sizeAdjustedShininess = 80 + (sizeRatio - 1) * 40; // サイズに応じて光沢度調整
                    
                    const material = new THREE.MeshPhongMaterial({ 
                        color: color,
                        transparent: true,
                        opacity: sizeAdjustedOpacity,  // サイズ調整された透明度
                        emissive: sizeAdjustedEmissive,  // サイズ調整された発光
                        shininess: Math.max(50, Math.min(150, sizeAdjustedShininess))  // 光沢範囲制限（50-150）
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    
                    // Position particles based on stage characteristics
                    const radius = 1 + Math.random() * 5;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    particle.position.x = radius * Math.sin(phi) * Math.cos(theta);
                    particle.position.y = radius * Math.sin(phi) * Math.sin(theta);
                    particle.position.z = radius * Math.cos(phi);
                    
                    // Add dynamic properties based on stage behavior
                    particle.userData = {
                        originalPosition: particle.position.clone(),
                        baseRadius: radius,
                        baseTheta: theta,
                        basePhi: phi,
                        personalityFactor: Math.random(),
                        phaseOffset: Math.random() * Math.PI * 2,
                        speed: stageData.speed * (0.8 + Math.random() * 0.4),
                        cohesion: stageData.cohesion,
                        behavior: stageData.behavior,
                        pattern: stageData.pattern,
                        age: 0,
                        targetPosition: new THREE.Vector3(),
                        // サイズ関連情報を追加
                        originalSize: finalSize,
                        sizeRatio: sizeRatio,
                        baseSize: baseSize,
                        sizeVariation: sizeVariation
                    };
                    
                    this.scene.add(particle);
                    this.particles.push(particle);
                }
                
                // I(E)ステージ以降の場合、初期接続を即座に生成
                if (this.shouldShowConnections(this.currentStage)) {
                    setTimeout(() => {
                        this.updateConnections(true); // 強制更新で即座に接続表示
                    }, 200); // パーティクル配置完了を待つ
                }
            }
            
            // I(E)ステージ以降かどうかを判定
            isColorfulStage(stageId) {
                const colorfulStages = ['IE', 'Ia', 'Ib', 'Ic'];
                return colorfulStages.includes(stageId);
            }
            
            // I(E)ステージ以降で接続線を表示するかを判定
            shouldShowConnections(stageId) {
                const connectionStages = ['IE', 'Ia', 'Ib', 'Ic'];
                return connectionStages.includes(stageId);
            }
            
            // ステージに応じた最大接続数を取得
            getMaxConnectionsForStage(stageId) {
                return this.stageConnectionLimits[stageId] || this.maxConnections;
            }
            
            // パーティクル間の距離を計算
            calculateParticleDistance(particle1, particle2) {
                return particle1.position.distanceTo(particle2.position);
            }
            
            // 適切な接続パターンを選択（ハブ型・連鎖型・相互連結型など）
            selectConnectionPairs() {
                if (!this.shouldShowConnections(this.currentStage) || this.particles.length < 2) {
                    return [];
                }
                
                const connections = [];
                const usedParticles = new Set();
                const maxDistance = 4.5; // 最大接続距離
                const minDistance = 0.5; // 最小接続距離
                
                // 現在のステージに応じた最大接続数を取得
                const stageMaxConnections = this.getMaxConnectionsForStage(this.currentStage);
                
                // ステージ別の接続パターンを設定
                let patterns;
                if (this.currentStage === 'I-E') {
                    // I-Eステージ：内なる声を聴く - 控えめで思慮深い接続
                    patterns = [
                        { type: 'contemplative_pairs', weight: 0.4 },  // 思索的なペア接続
                        { type: 'chain', weight: 0.3 },                // 連鎖型（思考の流れ）
                        { type: 'triangle', weight: 0.2 },             // 小さな三角形（内的対話）
                        { type: 'introspective_hub', weight: 0.1 }     // 内省的ハブ
                    ];
                } else if (this.currentStage === 'IE') {
                    // IEステージ：シンプルな接続パターンのみ
                    patterns = [
                        { type: 'chain', weight: 0.5 },     // 連鎖型（シンプルな繋がり）
                        { type: 'triangle', weight: 0.3 },  // 三角形（基本的な相互連結）
                        { type: 'hub', weight: 0.2 }        // ハブ型（少数）
                    ];
                } else if (this.currentStage === 'Ic') {
                    // Icステージ：極めて豊富で複雑な接続パターン（完全なコミットメント段階）
                    patterns = [
                        { type: 'dense_network', weight: 0.25 },  // 密な全体ネットワーク
                        { type: 'multi_hub', weight: 0.2 },       // 複数ハブ型
                        { type: 'triangle', weight: 0.15 },       // 三角形（相互連結）
                        { type: 'star', weight: 0.15 },           // 星型（中心から放射）
                        { type: 'chain', weight: 0.1 },           // 連鎖型
                        { type: 'hub', weight: 0.1 },             // 単一ハブ型
                        { type: 'cycle', weight: 0.05 }           // 循環型
                    ];
                } else {
                    // その他のステージ：標準的なパターン
                    patterns = [
                        { type: 'hub', weight: 0.3 },        // ハブ型（1つの中心に複数接続）
                        { type: 'chain', weight: 0.25 },     // 連鎖型（A→B→C→D）
                        { type: 'triangle', weight: 0.2 },   // 三角形（相互連結）
                        { type: 'star', weight: 0.15 },      // 星型（中心から放射）
                        { type: 'cycle', weight: 0.1 }       // 循環型（A→B→C→A）
                    ];
                }
                
                // 距離マトリックスを計算
                const distanceMatrix = this.calculateDistanceMatrix();
                
                // パターンを順次生成（ステージ別の制限まで）
                let maxAttempts;
                if (this.currentStage === 'IE') {
                    maxAttempts = 3; // IEステージは少なめ
                } else if (this.currentStage === 'Ic') {
                    maxAttempts = 15; // Icステージは大幅に増加（複雑なネットワーク生成）
                } else {
                    maxAttempts = 6; // その他のステージは標準
                }
                
                for (let attempt = 0; attempt < maxAttempts && connections.length < stageMaxConnections; attempt++) {
                    const pattern = this.selectRandomPattern(patterns);
                    const patternConnections = this.generateConnectionPattern(
                        pattern.type, distanceMatrix, usedParticles, maxDistance, minDistance
                    );
                    
                    if (patternConnections.length > 0) {
                        connections.push(...patternConnections);
                    }
                }
                
                return connections;
            }
            
            // 距離マトリックスを計算
            calculateDistanceMatrix() {
                const matrix = [];
                for (let i = 0; i < this.particles.length; i++) {
                    matrix[i] = [];
                    for (let j = 0; j < this.particles.length; j++) {
                        if (i === j) {
                            matrix[i][j] = 0;
                        } else {
                            matrix[i][j] = this.calculateParticleDistance(this.particles[i], this.particles[j]);
                        }
                    }
                }
                return matrix;
            }
            
            // ランダムなパターンを選択
            selectRandomPattern(patterns) {
                const random = Math.random();
                let cumulative = 0;
                
                for (const pattern of patterns) {
                    cumulative += pattern.weight;
                    if (random <= cumulative) {
                        return pattern;
                    }
                }
                return patterns[patterns.length - 1];
            }
            
            // 指定されたパターンで接続を生成
            generateConnectionPattern(patternType, distanceMatrix, usedParticles, maxDistance, minDistance) {
                switch (patternType) {
                    case 'hub':
                        return this.generateHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'chain':
                        return this.generateChainPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'triangle':
                        return this.generateTrianglePattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'star':
                        return this.generateStarPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'cycle':
                        return this.generateCyclePattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'dense_network':
                        return this.generateDenseNetworkPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'multi_hub':
                        return this.generateMultiHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'contemplative_pairs':
                        return this.generateContemplativePairsPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    case 'introspective_hub':
                        return this.generateIntrospectiveHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                    default:
                        return [];
                }
            }
            
            // ハブ型パターン：1つの中心パーティクルに3-5個が接続
            generateHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 4) return [];
                
                // 中心となるパーティクルを選択
                const hubIndex = availableParticles[Math.floor(Math.random() * availableParticles.length)];
                usedParticles.add(hubIndex);
                
                // ハブからの接続数を決定（IEステージは控えめに）
                let connectionCount;
                if (this.currentStage === 'IE') {
                    connectionCount = 2 + Math.floor(Math.random() * 2); // 2-3個（控えめ）
                } else {
                    connectionCount = 3 + Math.floor(Math.random() * 3); // 3-5個（通常）
                }
                const connections = [];
                
                // ハブに接続する候補を距離順にソート
                const candidates = availableParticles
                    .filter(i => i !== hubIndex && !usedParticles.has(i))
                    .map(i => ({ index: i, distance: distanceMatrix[hubIndex][i] }))
                    .filter(c => c.distance >= minDistance && c.distance <= maxDistance)
                    .sort((a, b) => a.distance - b.distance);
                
                // 上位候補から接続
                for (let i = 0; i < Math.min(connectionCount, candidates.length); i++) {
                    const targetIndex = candidates[i].index;
                    connections.push({ pair: [hubIndex, targetIndex], type: 'hub' });
                    usedParticles.add(targetIndex);
                }
                
                return connections;
            }
            
            // 連鎖型パターン：A→B→C→D の線形接続
            generateChainPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 3) return [];
                
                // 連鎖の長さを決定（IEステージは短めに）
                let chainLength;
                if (this.currentStage === 'IE') {
                    chainLength = 2 + Math.floor(Math.random() * 2); // 2-3個（短い連鎖）
                } else {
                    chainLength = 3 + Math.floor(Math.random() * 3); // 3-5個（通常）
                }
                
                const chain = [availableParticles[Math.floor(Math.random() * availableParticles.length)]];
                usedParticles.add(chain[0]);
                
                // 連鎖を構築
                for (let i = 1; i < chainLength; i++) {
                    const lastIndex = chain[i - 1];
                    const candidates = availableParticles
                        .filter(j => !usedParticles.has(j))
                        .map(j => ({ index: j, distance: distanceMatrix[lastIndex][j] }))
                        .filter(c => c.distance >= minDistance && c.distance <= maxDistance)
                        .sort((a, b) => a.distance - b.distance);
                    
                    if (candidates.length === 0) break;
                    
                    const nextIndex = candidates[0].index;
                    chain.push(nextIndex);
                    usedParticles.add(nextIndex);
                }
                
                // 連鎖の接続を作成
                const connections = [];
                for (let i = 0; i < chain.length - 1; i++) {
                    connections.push({ pair: [chain[i], chain[i + 1]], type: 'chain' });
                }
                
                return connections;
            }
            
            // 三角形パターン：3つのパーティクルが相互に接続
            generateTrianglePattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 3) return [];
                
                // 最初の2つのパーティクルを選択
                const first = availableParticles[Math.floor(Math.random() * availableParticles.length)];
                const secondCandidates = availableParticles
                    .filter(i => i !== first)
                    .map(i => ({ index: i, distance: distanceMatrix[first][i] }))
                    .filter(c => c.distance >= minDistance && c.distance <= maxDistance);
                
                if (secondCandidates.length === 0) return [];
                
                const second = secondCandidates[Math.floor(Math.random() * secondCandidates.length)].index;
                
                // 3つ目のパーティクルを選択（両方に適切な距離）
                const thirdCandidates = availableParticles
                    .filter(i => i !== first && i !== second)
                    .filter(i => {
                        const d1 = distanceMatrix[first][i];
                        const d2 = distanceMatrix[second][i];
                        return d1 >= minDistance && d1 <= maxDistance && 
                               d2 >= minDistance && d2 <= maxDistance;
                    });
                
                if (thirdCandidates.length === 0) return [];
                
                const third = thirdCandidates[Math.floor(Math.random() * thirdCandidates.length)];
                
                // 使用済みとしてマーク
                usedParticles.add(first);
                usedParticles.add(second);
                usedParticles.add(third);
                
                return [
                    { pair: [first, second], type: 'triangle' },
                    { pair: [second, third], type: 'triangle' },
                    { pair: [third, first], type: 'triangle' }
                ];
            }
            
            // 星型パターン：中心から放射状に接続
            generateStarPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                return this.generateHubPattern(distanceMatrix, usedParticles, maxDistance * 1.2, minDistance);
            }
            
            // 循環型パターン：A→B→C→D→A の循環接続
            generateCyclePattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const chainConnections = this.generateChainPattern(distanceMatrix, usedParticles, maxDistance, minDistance);
                if (chainConnections.length < 2) return chainConnections;
                
                // すべてを循環タイプに変更
                chainConnections.forEach(connection => connection.type = 'cycle');
                
                // 最後と最初を接続して循環にする
                const firstParticle = chainConnections[0].pair[0];
                const lastParticle = chainConnections[chainConnections.length - 1].pair[1];
                const distance = distanceMatrix[lastParticle][firstParticle];
                
                if (distance >= minDistance && distance <= maxDistance) {
                    chainConnections.push({ pair: [lastParticle, firstParticle], type: 'cycle' });
                }
                
                return chainConnections;
            }
            
            // 密なネットワークパターン：Icステージ用の豊富な相互接続
            generateDenseNetworkPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 6) return [];
                
                const connections = [];
                const selectedParticles = [];
                
                // 6-8個のパーティクルを選択
                const networkSize = Math.min(6 + Math.floor(Math.random() * 3), availableParticles.length);
                
                for (let i = 0; i < networkSize; i++) {
                    const index = availableParticles[Math.floor(Math.random() * availableParticles.length)];
                    if (!selectedParticles.includes(index)) {
                        selectedParticles.push(index);
                        usedParticles.add(index);
                    }
                }
                
                // 選択されたパーティクル間で密な接続を作成
                for (let i = 0; i < selectedParticles.length; i++) {
                    for (let j = i + 1; j < selectedParticles.length; j++) {
                        const particle1 = selectedParticles[i];
                        const particle2 = selectedParticles[j];
                        const distance = distanceMatrix[particle1][particle2];
                        
                        if (distance >= minDistance && distance <= maxDistance) {
                            // 60%の確率で接続（密だが全てではない）
                            if (Math.random() < 0.6) {
                                connections.push({ pair: [particle1, particle2], type: 'dense_network' });
                            }
                        }
                    }
                }
                
                return connections;
            }
            
            // 複数ハブパターン：Icステージ用の複数の中心点を持つネットワーク
            generateMultiHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 8) return [];
                
                const connections = [];
                const hubCount = 2 + Math.floor(Math.random() * 2); // 2-3個のハブ
                const hubs = [];
                
                // ハブを選択
                for (let h = 0; h < hubCount && availableParticles.length > 0; h++) {
                    const hubIndex = availableParticles.splice(Math.floor(Math.random() * availableParticles.length), 1)[0];
                    hubs.push(hubIndex);
                    usedParticles.add(hubIndex);
                }
                
                // 各ハブから接続を作成
                hubs.forEach(hubIndex => {
                    const remainingParticles = availableParticles.filter(i => !usedParticles.has(i));
                    const connectionsPerHub = 2 + Math.floor(Math.random() * 3); // 2-4個の接続
                    
                    const candidates = remainingParticles
                        .map(i => ({ index: i, distance: distanceMatrix[hubIndex][i] }))
                        .filter(c => c.distance >= minDistance && c.distance <= maxDistance)
                        .sort((a, b) => a.distance - b.distance);
                    
                    for (let i = 0; i < Math.min(connectionsPerHub, candidates.length); i++) {
                        const targetIndex = candidates[i].index;
                        connections.push({ pair: [hubIndex, targetIndex], type: 'multi_hub' });
                        usedParticles.add(targetIndex);
                    }
                });
                
                // ハブ同士も接続する可能性
                for (let i = 0; i < hubs.length; i++) {
                    for (let j = i + 1; j < hubs.length; j++) {
                        const distance = distanceMatrix[hubs[i]][hubs[j]];
                        if (distance >= minDistance && distance <= maxDistance && Math.random() < 0.4) {
                            connections.push({ pair: [hubs[i], hubs[j]], type: 'multi_hub' });
                        }
                    }
                }
                
                return connections;
            }

            // 思索的ペアパターン：I-Eステージ用 - 内なる声を聴く過程での慎重な対話
            generateContemplativePairsPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 2) return [];
                
                const connections = [];
                const maxPairs = Math.min(3, Math.floor(availableParticles.length / 2)); // 最大3ペア
                
                // 適度な距離のペアを選択（近すぎず遠すぎず）
                for (let pairCount = 0; pairCount < maxPairs && availableParticles.length >= 2; pairCount++) {
                    const candidates = [];
                    
                    // 利用可能なペアの組み合わせを評価
                    for (let i = 0; i < availableParticles.length; i++) {
                        for (let j = i + 1; j < availableParticles.length; j++) {
                            const idx1 = availableParticles[i];
                            const idx2 = availableParticles[j];
                            const distance = distanceMatrix[idx1][idx2];
                            
                            // 思索に適した距離（中程度の距離を好む）
                            if (distance >= minDistance * 1.5 && distance <= maxDistance * 0.8) {
                                candidates.push({ 
                                    pair: [idx1, idx2], 
                                    distance: distance,
                                    suitability: 1.0 - Math.abs(distance - (maxDistance * 0.5)) / (maxDistance * 0.5)
                                });
                            }
                        }
                    }
                    
                    if (candidates.length === 0) break;
                    
                    // 最適な距離のペアを選択
                    candidates.sort((a, b) => b.suitability - a.suitability);
                    const selectedPair = candidates[0];
                    
                    connections.push({ pair: selectedPair.pair, type: 'contemplative' });
                    
                    // 使用済みに追加
                    usedParticles.add(selectedPair.pair[0]);
                    usedParticles.add(selectedPair.pair[1]);
                    
                    // availableParticlesからも削除
                    const removeIndices = [
                        availableParticles.indexOf(selectedPair.pair[0]),
                        availableParticles.indexOf(selectedPair.pair[1])
                    ].sort((a, b) => b - a); // 降順でソートして後ろから削除
                    
                    removeIndices.forEach(idx => availableParticles.splice(idx, 1));
                }
                
                return connections;
            }

            // 内省的ハブパターン：I-Eステージ用 - 控えめな中心的思考
            generateIntrospectiveHubPattern(distanceMatrix, usedParticles, maxDistance, minDistance) {
                const availableParticles = this.getAvailableParticles(usedParticles);
                if (availableParticles.length < 3) return [];
                
                const connections = [];
                
                // 中心となるパーティクルを選択（中央に近い位置を好む）
                let hubIndex = availableParticles[0];
                let minCenterDistance = Number.MAX_VALUE;
                
                for (const idx of availableParticles) {
                    const particle = this.particles[idx];
                    const centerDistance = particle.position.length(); // 原点からの距離
                    if (centerDistance < minCenterDistance) {
                        minCenterDistance = centerDistance;
                        hubIndex = idx;
                    }
                }
                
                usedParticles.add(hubIndex);
                
                // 控えめな接続（2-3個のみ）
                const connectionCount = 2 + Math.floor(Math.random() * 2);
                const candidates = availableParticles
                    .filter(i => i !== hubIndex)
                    .map(i => ({ index: i, distance: distanceMatrix[hubIndex][i] }))
                    .filter(c => c.distance >= minDistance && c.distance <= maxDistance * 0.7) // 近めの距離を好む
                    .sort((a, b) => a.distance - b.distance);
                
                for (let i = 0; i < Math.min(connectionCount, candidates.length); i++) {
                    const targetIndex = candidates[i].index;
                    connections.push({ pair: [hubIndex, targetIndex], type: 'introspective' });
                    usedParticles.add(targetIndex);
                }
                
                return connections;
            }

            // 使用可能なパーティクルのインデックスリストを取得
            getAvailableParticles(usedParticles) {
                const available = [];
                for (let i = 0; i < this.particles.length; i++) {
                    if (!usedParticles.has(i)) {
                        available.push(i);
                    }
                }
                return available;
            }
            
            // 接続線を作成（強化版）
            createConnectionLine(particle1, particle2, opacity = 0.4, lineType = 'normal') {
                const points = [particle1.position.clone(), particle2.position.clone()];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                
                // 線の種類に応じた透明度と太さを調整
                let actualOpacity = opacity;
                let lineWidth = 1;
                
                switch (lineType) {
                    case 'hub':        // ハブ接続は少し太く明るく
                        actualOpacity = opacity * 1.3;
                        lineWidth = 2;
                        break;
                    case 'chain':      // 連鎖接続は中程度
                        actualOpacity = opacity * 1.1;
                        lineWidth = 1.5;
                        break;
                    case 'cycle':      // 循環接続は脈動効果
                        actualOpacity = opacity * (0.8 + Math.sin(Date.now() * 0.003) * 0.3);
                        lineWidth = 1.8;
                        break;
                    case 'triangle':   // 相互接続は安定的に明るく
                        actualOpacity = opacity * 1.2;
                        lineWidth = 1.5;
                        break;
                    case 'contemplative': // 思索的接続は控えめで揺らぎあり
                        actualOpacity = opacity * (0.6 + Math.sin(Date.now() * 0.002) * 0.2);
                        lineWidth = 1.2;
                        break;
                    case 'introspective': // 内省的接続はより繊細
                        actualOpacity = opacity * 0.8;
                        lineWidth = 1.0;
                        break;
                        lineWidth = 1.3;
                        break;
                    default:
                        break;
                }
                
                // カラフルステージでは多様な色、それ以外は白〜青のグラデーション
                let color;
                if (this.isColorfulStage(this.currentStage)) {
                    color = this.colorfulParticlePalette[Math.floor(Math.random() * this.colorfulParticlePalette.length)];
                } else {
                    // 接続の種類に応じた色分け
                    const colors = {
                        'hub': 0xffdd44,         // ハブ：金色
                        'chain': 0x44ddff,       // 連鎖：青色
                        'cycle': 0xff44dd,       // 循環：紫色
                        'triangle': 0x44ff88,    // 相互：緑色
                        'dense_network': 0xff8844, // 密なネットワーク：オレンジ色
                        'multi_hub': 0x88ff44,   // 複数ハブ：明るい緑色
                        'normal': 0xcccccc       // 通常：白色
                    };
                    color = colors[lineType] || colors.normal;
                }
                
                const material = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: Math.min(actualOpacity, 0.8),
                    blending: THREE.AdditiveBlending,
                    linewidth: lineWidth  // Note: linewidth は WebGL では制限がある
                });
                
                const line = new THREE.Line(geometry, material);
                line.userData = { lineType: lineType }; // 種類を保存
                return line;
            }
            
            // 接続線を更新（強制更新オプション付き）
            updateConnections(forceUpdate = false) {
                const currentTime = Date.now();
                
                // ステージ別の更新間隔を設定
                let updateInterval;
                if (this.currentStage === 'Ic') {
                    updateInterval = 10000; // Icステージ：10秒間隔（標準的な更新頻度）
                } else if (this.currentStage === 'Ib') {
                    updateInterval = 10000; // Ibステージ：10秒間隔
                } else {
                    updateInterval = this.connectionUpdateInterval; // その他：標準間隔
                }
                
                // 遷移中の場合は更新をスキップ
                if (this.isConnectionTransitioning && !forceUpdate) {
                    return;
                }
                
                // 定期的な更新チェック（強制更新の場合はスキップ）
                if (!forceUpdate && currentTime - this.lastConnectionUpdate < updateInterval) {
                    return;
                }
                
                this.lastConnectionUpdate = currentTime;
                
                // 新しい接続パターンを選択
                const newConnectionPairs = this.selectConnectionPairs();
                
                // フェードイン・フェードアウト効果で切り替え
                if (this.connectionLines.length > 0 && !forceUpdate) {
                    // 既存の接続がある場合はフェード遷移を開始
                    this.startConnectionTransition(newConnectionPairs);
                } else {
                    // 初回または強制更新の場合は直接作成
                    this.clearConnections();
                    this.createConnectionsFromPairs(newConnectionPairs);
                }
            }
            
            // 接続線をクリア
            clearConnections() {
                this.connectionLines.forEach(connection => {
                    this.scene.remove(connection.line);
                    connection.line.geometry.dispose();
                    connection.line.material.dispose();
                });
                this.connectionLines = [];
            }
            
            // フェード遷移を開始
            startConnectionTransition(newConnectionPairs) {
                this.isConnectionTransitioning = true;
                this.transitionStartTime = Date.now();
                this.pendingConnections = newConnectionPairs;
                this.transitionPhase = 'fadeOut';
                
                console.log('接続線フェード遷移開始');
            }
            
            // フェード遷移を更新
            updateConnectionTransition() {
                if (!this.isConnectionTransitioning) return;
                
                const currentTime = Date.now();
                const elapsedTime = currentTime - this.transitionStartTime;
                
                if (this.transitionPhase === 'fadeOut') {
                    // フェードアウト段階
                    const fadeProgress = Math.min(elapsedTime / this.fadeOutDuration, 1.0);
                    const targetOpacity = 1.0 - fadeProgress;
                    
                    // 既存の接続線の透明度を下げる
                    this.connectionLines.forEach(connection => {
                        if (connection.line.material) {
                            connection.line.material.opacity = Math.max(0, targetOpacity * 0.4); // 基本透明度0.4からフェード
                        }
                    });
                    
                    // フェードアウト完了チェック
                    if (fadeProgress >= 1.0) {
                        this.clearConnections();
                        this.createConnectionsFromPairs(this.pendingConnections);
                        this.transitionPhase = 'fadeIn';
                        this.transitionStartTime = currentTime;
                        console.log('フェードアウト完了、フェードイン開始');
                    }
                } else if (this.transitionPhase === 'fadeIn') {
                    // フェードイン段階
                    const fadeProgress = Math.min(elapsedTime / this.fadeInDuration, 1.0);
                    const targetOpacity = fadeProgress;
                    
                    // 新しい接続線の透明度を上げる
                    this.connectionLines.forEach(connection => {
                        if (connection.line.material) {
                            const baseOpacity = this.getBaseOpacityForLineType(connection.lineType);
                            connection.line.material.opacity = targetOpacity * baseOpacity;
                        }
                    });
                    
                    // フェードイン完了チェック
                    if (fadeProgress >= 1.0) {
                        this.isConnectionTransitioning = false;
                        this.transitionPhase = 'none';
                        this.pendingConnections = [];
                        console.log('フェードイン完了、遷移終了');
                    }
                }
            }
            
            // 接続線タイプに応じた基本透明度を取得
            getBaseOpacityForLineType(lineType) {
                switch (lineType) {
                    case 'hub':
                        return 0.52; // 0.4 * 1.3
                    case 'chain':
                        return 0.44; // 0.4 * 1.1
                    case 'triangle':
                        return 0.48; // 0.4 * 1.2
                    case 'contemplative':
                    case 'introspective':
                        return 0.32; // 0.4 * 0.8
                    default:
                        return 0.4;  // 基本透明度
                }
            }
            
            // 接続線をペアから作成
            createConnectionsFromPairs(connectionPairs) {
                connectionPairs.forEach(connection => {
                    const [index1, index2] = connection.pair;
                    const lineType = connection.type;
                    const particle1 = this.particles[index1];
                    const particle2 = this.particles[index2];
                    
                    if (particle1 && particle2) {
                        const line = this.createConnectionLine(particle1, particle2, 0.4, lineType);
                        
                        // 遷移中の場合は初期透明度を0に設定
                        if (this.isConnectionTransitioning && this.transitionPhase === 'fadeIn') {
                            line.material.opacity = 0;
                        }
                        
                        this.scene.add(line);
                        this.connectionLines.push({
                            line: line,
                            particle1Index: index1,
                            particle2Index: index2,
                            lineType: lineType
                        });
                    }
                });
            }
            
            // 既存の接続線の位置を更新（動的効果付き）
            updateConnectionPositions() {
                const time = Date.now() * 0.001;
                
                this.connectionLines.forEach(connection => {
                    const particle1 = this.particles[connection.particle1Index];
                    const particle2 = this.particles[connection.particle2Index];
                    
                    if (particle1 && particle2) {
                        const points = [particle1.position.clone(), particle2.position.clone()];
                        connection.line.geometry.setFromPoints(points);
                        connection.line.geometry.attributes.position.needsUpdate = true;
                        
                        // フェード遷移中でない場合のみ動的効果を適用
                        if (!this.isConnectionTransitioning) {
                            // 接続タイプに応じた動的効果
                            if (connection.lineType === 'cycle') {
                                // 循環接続は脈動効果
                                const pulse = 0.3 + 0.4 * (0.5 + 0.5 * Math.sin(time * 3));
                                connection.line.material.opacity = pulse;
                            } else if (connection.lineType === 'hub') {
                                // ハブ接続は徐々に明るくなる効果
                                const glow = 0.4 + 0.3 * (0.5 + 0.5 * Math.sin(time * 1.5));
                                connection.line.material.opacity = glow;
                            } else if (connection.lineType === 'chain') {
                                // 連鎖接続は流れるような効果
                                const flow = 0.3 + 0.3 * (0.5 + 0.5 * Math.sin(time * 2 + connection.particle1Index));
                                connection.line.material.opacity = flow;
                            }
                        }
                    }
                });
            }
            
            // カラフルパーティクル用の色を取得
            getColorfulParticleColor(index, time) {
                const paletteIndex = (index + Math.floor(time * 2)) % this.colorfulParticlePalette.length;
                return this.colorfulParticlePalette[paletteIndex];
            }
            
            // パーティクルの色を動的に更新
            updateParticleColorDynamic(particle, index, time) {
                if (this.isColorfulStage(this.currentStage)) {
                    const targetColor = this.getColorfulParticleColor(index, time);
                    const currentColor = particle.material.color;
                    const targetColorObj = new THREE.Color(targetColor);
                    
                    // 滑らかな色変更
                    currentColor.lerp(targetColorObj, this.colorTransitionSpeed);
                }
            }
            
            getStageData(stage) {
                const stageMap = {
                    'Ea': { 
                        particleCount: 20, 
                        color: 0xff6b6b, 
                        description: '外的権威を信頼',
                        behavior: 'chaotic',           // 混沌とした動き
                        cohesion: 0.1,                // 結束度：非常に低い
                        speed: 0.8,                   // 速度：比較的低い
                        pattern: 'random'             // パターン：ランダム
                    },
                    'Eb': { 
                        particleCount: 25, 
                        color: 0xff8e53, 
                        description: '外的権威との緊張',
                        behavior: 'conflicted',       // 対立する動き
                        cohesion: 0.2,
                        speed: 1.2,                   // 緊張で速度上昇
                        pattern: 'opposing'           // 対立パターン
                    },
                    'Ec': { 
                        particleCount: 30, 
                        color: 0xffa726, 
                        description: '欠点の認識',
                        behavior: 'questioning',      // 疑問を示す動き
                        cohesion: 0.3,
                        speed: 0.9,
                        pattern: 'hesitant'           // ためらいのパターン
                    },
                    'EI': { 
                        particleCount: 20,  // 35から20に減少
                        color: 0xffeb3b, 
                        description: '疑問を持つ',
                        behavior: 'questioning_emergence',  // 疑問による出現・消失
                        cohesion: 0.4,
                        speed: 1.0,
                        pattern: 'dynamic_emergence'       // 動的出現パターン
                    },
                    'E-I': { 
                        particleCount: 40, 
                        color: 0xcddc39, 
                        description: '内なる声を構築',
                        behavior: 'building',         // 構築する動き
                        cohesion: 0.5,
                        speed: 1.1,
                        pattern: 'convergent'         // 収束パターン
                    },
                    'I-E': { 
                        particleCount: 45, 
                        color: 0x8bc34a, 
                        description: '内なる声を聴く',
                        behavior: 'listening',        // 聴く動き
                        cohesion: 0.1,                // 低い凝集力（自由な浮遊を維持）
                        speed: 0.5,                   // より静かに聴く
                        pattern: 'pulse'              // 脈動パターン
                    },
                    'IE': { 
                        particleCount: 50, 
                        color: 0x4caf50, 
                        description: '内なる声を育む',
                        behavior: 'nurturing',        // 育む動き
                        cohesion: 0.7,
                        speed: 0.9,
                        pattern: 'growth'             // 成長パターン
                    },
                    'Ia': { 
                        particleCount: 55, 
                        color: 0x26a69a, 
                        description: '内なる声を信頼',
                        behavior: 'trusting',         // 信頼する動き
                        cohesion: 0.8,
                        speed: 1.0,
                        pattern: 'stable_orbit'       // 安定軌道
                    },
                    'Ib': { 
                        particleCount: 60, 
                        color: 0x29b6f6, 
                        description: '内なる基盤',
                        behavior: 'foundation',       // 基盤形成
                        cohesion: 0.9,
                        speed: 0.8,
                        pattern: 'structured'         // 構造化パターン
                    },
                    'Ic': { 
                        particleCount: 65, 
                        color: 0x42a5f5,              // Ibの青をベースにした明るい色
                        description: 'コミットメント確保',
                        behavior: 'committed',        // コミット状態
                        cohesion: 1.0,                // 最高の結束
                        speed: 1.0,
                        pattern: 'wave_rotation'      // 波動回転パターン
                    }
                };
                return stageMap[stage] || stageMap['Ea'];
            }
            
            createControls() {
                // Add mouse controls for camera
                let mouseDown = false;
                let mouseX = 0;
                let mouseY = 0;
                
                const canvas = this.renderer.domElement;
                
                canvas.addEventListener('mousedown', (e) => {
                    mouseDown = true;
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!mouseDown) return;
                    
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    
                    this.camera.position.x += deltaX * 0.01;
                    this.camera.position.y -= deltaY * 0.01;
                    this.camera.lookAt(0, 0, 0);
                    
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                canvas.addEventListener('mouseup', () => {
                    mouseDown = false;
                });
                
                // Touch controls for mobile
                let touchStartX = 0;
                let touchStartY = 0;
                
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                });
                
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - touchStartX;
                    const deltaY = touch.clientY - touchStartY;
                    
                    this.camera.position.x += deltaX * 0.01;
                    this.camera.position.y -= deltaY * 0.01;
                    this.camera.lookAt(0, 0, 0);
                    
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                });
            }
            
            bindEvents() {
                // Stage button clicks
                const stageButtons = document.querySelectorAll('.stage-btn');
                stageButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const stage = btn.dataset.stage;
                        this.switchToStage(stage);
                    });
                });
                
                // View control buttons
                const resetBtn = document.getElementById('reset-view-btn');
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => {
                        this.resetView();
                    });
                }
                
                const reinitBtn = document.getElementById('reinit-3d-btn');
                if (reinitBtn) {
                    reinitBtn.addEventListener('click', () => {
                        this.reinitialize3D();
                    });
                }
                
                // 説明表示ボタンのイベントリスナー
                const explanationBtn = document.getElementById('explanation-toggle-btn');
                if (explanationBtn) {
                    explanationBtn.addEventListener('click', () => {
                        if (this.explanationSystem) {
                            // 現在のステージを渡して表示/非表示を切り替え
                            this.explanationSystem.toggle(this.currentStage);
                        }
                    });
                }
                
                // Zoom controls via mouse wheel
                if (this.renderer && this.renderer.domElement) {
                    this.renderer.domElement.addEventListener('wheel', (e) => {
                        e.preventDefault();
                        this.handleZoom(e.deltaY);
                    }, { passive: false });
                }
                
                // Window resize
                window.addEventListener('resize', () => {
                    if (this.isInitialized) {
                        this.handleResize();
                    }
                });
            }
            
            switchToStage(stageId) {
                if (!this.isInitialized || this.isTransitioning) return;
                
                // Reset questioning stage specific data when switching stages
                this.persistentParticleIndices.clear();
                
                this.currentStage = stageId;
                
                // 多面体形状の更新
                this.updatePolyhedronShape(stageId);
                
                this.updateStageVisualization(stageId);
                this.updateActiveButton(stageId);
                console.log('Switched to stage:', stageId);
            }

            updatePolyhedronShape(stageId) {
                if (this.isTransitioning) return;
                
                this.isTransitioning = true;
                
                // 現在の形状から新しい形状へのトランジション
                const currentGeometry = this.core?.geometry;
                const newGeometry = this.coreGeometryManager.createPolyhedronGeometry(stageId);
                
                if (currentGeometry && newGeometry) {
                    // フェードアウト → 形状変更 → フェードイン
                    this.animatePolyhedronTransition(currentGeometry, newGeometry, stageId);
                } else {
                    // 初回または緊急時は直接作成
                    this.createPolyhedronCore(stageId);
                    this.isTransitioning = false;
                }
            }

            animatePolyhedronTransition(oldGeometry, newGeometry, stageId) {
                const transitionDuration = 1500; // 1.5秒のトランジション
                const fadeOutDuration = 500;
                const scaleTransitionDuration = 700; // スケール変更期間
                const fadeInDuration = 500;
                
                // 現在のサイズと新しいサイズを取得
                const oldSize = this.coreGeometryManager.getStageSize(this.currentStage);
                const newSize = this.coreGeometryManager.getStageSize(stageId);
                
                // フェードアウト
                const startOpacity = this.core.material.opacity;
                const startScale = this.core.scale.x;
                const fadeOutStart = Date.now();
                
                const fadeOut = () => {
                    const elapsed = Date.now() - fadeOutStart;
                    const progress = Math.min(elapsed / fadeOutDuration, 1);
                    
                    this.core.material.opacity = startOpacity * (1 - progress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(fadeOut);
                    } else {
                        // 形状変更
                        this.createPolyhedronCore(stageId);
                        
                        // スケールトランジション付きフェードイン
                        const targetOpacity = 0.85;
                        this.core.material.opacity = 0;
                        this.core.scale.set(oldSize / newSize, oldSize / newSize, oldSize / newSize); // 古いサイズから開始
                        
                        const fadeInStart = Date.now();
                        
                        const fadeIn = () => {
                            const elapsed = Date.now() - fadeInStart;
                            const progress = Math.min(elapsed / fadeInDuration, 1);
                            
                            // オパシティのフェードイン
                            this.core.material.opacity = targetOpacity * progress;
                            
                            // スケールの滑らかな変化
                            const scaleProgress = Math.min(elapsed / scaleTransitionDuration, 1);
                            const easeOut = 1 - Math.pow(1 - scaleProgress, 3); // イーズアウト
                            const currentScale = (oldSize / newSize) + (1 - oldSize / newSize) * easeOut;
                            this.core.scale.set(currentScale, currentScale, currentScale);
                            
                            if (progress < 1 || scaleProgress < 1) {
                                requestAnimationFrame(fadeIn);
                            } else {
                                // 最終的に正確なスケールに設定
                                this.core.scale.set(1, 1, 1);
                                this.isTransitioning = false;
                                console.log(`サイズ変更完了: ${oldSize.toFixed(2)} → ${newSize.toFixed(2)}`);
                            }
                        };
                        
                        fadeIn();
                    }
                };
                
                fadeOut();
            }
            
            updateStageVisualization(stageId) {
                // スムーズなトランジション効果
                this.transitionToStage(stageId);
                
                // Update core appearance based on stage
                const stageData = this.getStageData(stageId);
                if (this.core) {
                    // Core色をスムーズに変更
                    this.animateCoreColor(stageData.color);
                }
                
                // 新しい次元効果システムを更新
                const stageNumber = this.getStageNumber(stageId);
                this.updateDimensionEffects(stageNumber);
            }
            
            // 段階に応じて次元リングを更新（統一化されたビジュアルシステム）
            updateDimensionRings(stageId) {
                const stageNumber = this.getStageNumber(stageId);
                
                this.dimensionRings.forEach((ring, index) => {
                    if (!ring.userData) return;
                    
                    // 統一化された色調と質感を段階に応じて更新
                    const newColor = this.getDimensionRingColor(index, stageNumber);
                    const newOpacity = this.getDimensionRingOpacity(stageNumber);
                    const newShininess = this.getDimensionRingShininess(stageNumber);
                    const newEmissive = this.getDimensionRingEmissive(index, stageNumber);
                    const newEmissiveIntensity = this.getDimensionRingEmissiveIntensity(stageNumber);
                    
                    // サイズを段階に応じて更新
                    const newRadius = this.getDimensionRingRadius(index, stageNumber);
                    this.updateRingGeometry(ring, newRadius);
                    
                    // 統一化されたマテリアルシステムでスムーズなトランジション
                    this.animateRingProperties(ring, newColor, newOpacity, newShininess, newEmissive, newEmissiveIntensity);
                    
                    // 相互作用パターンを段階に応じて設定
                    ring.userData.interactionStrength = this.getInteractionStrength(stageNumber);
                    ring.userData.synchronizationFactor = this.getSynchronizationFactor(stageNumber);
                    ring.userData.materialEvolution = this.getCoreProgress(stageNumber); // 材質進化度を同期
                });
            }
            
            // リングのジオメトリを新しい半径で更新
            updateRingGeometry(ring, newRadius) {
                // 現在の半径と新しい半径を比較してログ出力
                const currentRadius = ring.geometry.parameters.radius;
                if (Math.abs(currentRadius - newRadius) > 0.1) {
                    console.log(`リング${ring.userData.ringIndex}のサイズ変更: ${currentRadius.toFixed(2)} → ${newRadius.toFixed(2)}`);
                }
                
                // 新しいジオメトリを作成
                const newGeometry = new THREE.TorusGeometry(newRadius, 0.05, 8, 32);
                
                // 古いジオメトリを破棄
                ring.geometry.dispose();
                
                // 新しいジオメトリを適用
                ring.geometry = newGeometry;
            }

            // 段階番号を取得
            getStageNumber(stageId) {
                const stageMap = {
                    'Ea': 1, 'Eb': 2, 'Ec': 3,    // External Authority 1-3
                    'EI': 4,                          // External-Internal (岐路段階の始まり)
                    'E-I': 5,                         // External to Internal
                    'I-E': 6,                         // Internal to External  
                    'IE': 7,                          // Internal-External
                    'Ia': 8, 'Ib': 9, 'Ic': 10    // Internal Authority 8-10
                };
                return stageMap[stageId] || 1;
            }
            
            // 統一化されたリングプロパティのアニメーション
            animateRingProperties(ring, newColor, newOpacity, newShininess, newEmissive, newEmissiveIntensity) {
                // 色のスムーズな変更
                const currentColor = new THREE.Color(ring.material.color);
                const targetColor = new THREE.Color(newColor);
                const currentEmissive = new THREE.Color(ring.material.emissive);
                const targetEmissive = new THREE.Color(newEmissive);
                
                // 統一化されたトランジション（多面体コアと同期）
                ring.material.color.lerp(targetColor, 0.1);
                ring.material.opacity = THREE.MathUtils.lerp(ring.material.opacity, newOpacity, 0.1);
                ring.material.shininess = THREE.MathUtils.lerp(ring.material.shininess, newShininess, 0.1);
                ring.material.emissive.lerp(targetEmissive, 0.1);
                ring.material.emissiveIntensity = THREE.MathUtils.lerp(ring.material.emissiveIntensity, newEmissiveIntensity, 0.1);
                
                // マテリアルの更新が必要であることを示す
                ring.material.needsUpdate = true;
            }
            
            // 段階に応じた相互作用の強度
            getInteractionStrength(stage) {
                if (stage <= 3) {
                    // EA段階: 0.05-0.20 (独立回転)
                    return 0.05 + stage * 0.05;
                } else if (stage <= 7) {
                    // 岐路段階: 0.20-0.80 (同期の始まり〜発展)
                    return 0.20 + (stage - 3) * 0.15;
                } else {
                    // IA段階: 0.80-0.98 (強い相互作用)
                    return 0.80 + (stage - 7) * 0.06;
                }
            }
            
            // 段階に応じた同期度合い
            getSynchronizationFactor(stage) {
                if (stage <= 3) {
                    // EA段階: 0 (完全に独立)
                    return 0;
                } else if (stage <= 7) {
                    // 岐路段階: 0-0.80 (徐々に同期)
                    return (stage - 3) * 0.20;
                } else {
                    // IA段階: 0.80-0.98 (高度な統合)
                    return 0.80 + (stage - 7) * 0.06;
                }
            }
            
            // 段階的進化する次元リングのアニメーション
            animateDimensionRingsEvolution(time) {
                const stageNumber = this.getStageNumber(this.currentStage);
                
                this.dimensionRings.forEach((ring, index) => {
                    if (!ring.userData) return;
                    
                    const userData = ring.userData;
                    const interactionStrength = userData.interactionStrength || 0;
                    const syncFactor = userData.synchronizationFactor || 0;
                    
                    // 基本回転速度の計算
                    let currentSpeed = userData.baseRotationSpeed;
                    
                    // 段階に応じた回転パターン
                    if (stageNumber <= 3) {
                        // 段階1-3: 独立回転（それぞれ独立）
                        ring.rotation.y += currentSpeed * userData.rotationDirection * 0.01;
                        ring.rotation.x = userData.baseRotationX + Math.sin(time * 0.3 + index) * 0.05;
                        
                    } else if (stageNumber <= 6) {
                        // 段階4-6: 弱い相互作用（同期の始まり）
                        const otherRingsInfluence = this.calculateRingInfluence(index, time);
                        const influenceStrength = interactionStrength * 0.5;
                        
                        ring.rotation.y += (currentSpeed + otherRingsInfluence * influenceStrength) * userData.rotationDirection * 0.01;
                        ring.rotation.x = userData.baseRotationX + 
                                         Math.sin(time * 0.4 + index) * 0.08 + 
                                         Math.sin(time * 0.2 + index * 2) * influenceStrength * 0.03;
                        
                    } else {
                        // 段階7-10: 複雑な相互作用（統合された動き）
                        const complexInteraction = this.calculateComplexInteraction(index, time, syncFactor);
                        
                        ring.rotation.y += (currentSpeed + complexInteraction.yInfluence) * userData.rotationDirection * 0.01;
                        ring.rotation.x = userData.baseRotationX + complexInteraction.xInfluence;
                        
                        // 高次段階では軌道も変化
                        const orbitalMotion = this.calculateOrbitalMotion(index, time, syncFactor);
                        ring.position.x = orbitalMotion.x;
                        ring.position.z = orbitalMotion.z;
                    }
                    
                    // すべての段階で色とプロパティの継続的更新
                    this.updateRingAppearanceContinuous(ring, index, stageNumber, time);
                });
            }
            
            // 他のリングからの影響を計算
            calculateRingInfluence(currentIndex, time) {
                let totalInfluence = 0;
                
                this.dimensionRings.forEach((otherRing, otherIndex) => {
                    if (otherIndex !== currentIndex && otherRing.userData) {
                        const distance = Math.abs(currentIndex - otherIndex);
                        const influence = Math.sin(time * 0.3 + otherIndex) / (distance + 1);
                        totalInfluence += influence;
                    }
                });
                
                return totalInfluence * 0.1;
            }
            
            // 複雑な相互作用の計算（高次段階用）
            calculateComplexInteraction(index, time, syncFactor) {
                const phase1 = time * 0.2 + index * Math.PI * 2 / 3;
                const phase2 = time * 0.15 + (index + 1) * Math.PI * 2 / 3;
                const phase3 = time * 0.25 + (index + 2) * Math.PI * 2 / 3;
                
                const yInfluence = (Math.sin(phase1) + Math.sin(phase2) * syncFactor) * 0.3;
                const xInfluence = (Math.sin(phase1) * 0.1 + 
                                  Math.cos(phase2) * syncFactor * 0.08 + 
                                  Math.sin(phase3) * syncFactor * 0.05);
                
                return { yInfluence, xInfluence };
            }
            
            // 軌道運動の計算（最高次段階用）
            calculateOrbitalMotion(index, time, syncFactor) {
                if (syncFactor < 0.5) {
                    return { x: 0, z: 0 }; // 軌道運動なし
                }
                
                const radius = 0.2 * syncFactor;
                const frequency = 0.1 + index * 0.05;
                const phase = index * Math.PI * 2 / 3;
                
                return {
                    x: Math.cos(time * frequency + phase) * radius,
                    z: Math.sin(time * frequency + phase) * radius
                };
            }
            
            // リングの外観の継続的更新
            updateRingAppearanceContinuous(ring, index, stageNumber, time) {
                // 呼吸のような光の変動
                const breathe = Math.sin(time * 0.5 + index) * 0.1 + 1;
                
                // 段階に応じた発光効果
                if (stageNumber >= 7) {
                    // 輝く質感の段階では発光効果を追加
                    const glow = Math.sin(time * 0.8 + index * 2) * 0.3 + 0.7;
                    ring.material.emissive = ring.material.color.clone().multiplyScalar(0.1 * glow);
                }
                
                // 透明度の微調整
                const baseOpacity = this.getDimensionRingOpacity(stageNumber);
                ring.material.opacity = baseOpacity * breathe;
            }

            transitionToStage(newStageId) {
                const oldStageData = this.getStageData(this.currentStage);
                const newStageData = this.getStageData(newStageId);
                
                // 接続線をクリア（全ステージ切り替え時）
                this.clearConnections();
                
                // ステージ切り替え時のコア光量リセット
                if (this.currentStage === 'EI' || newStageId !== 'EI') {
                    this.resetCoreIntensity();
                }
                
                // EIステージ固有の初期化
                if (newStageId === 'EI') {
                    // 既存の疑問フェーズをリセット
                    this.particles.forEach(particle => {
                        if (particle.userData) {
                            particle.userData.questioningPhase = null;
                        }
                    });
                    this.persistentParticleIndices.clear();
                    
                    // 即座に表示するパーティクルを設定（最初の5個）
                    const currentTime = Date.now() * 0.001;
                    this.particles.slice(0, 5).forEach((particle, index) => {
                        if (particle.userData) {
                            // 即座に表示されるパーティクルの初期設定
                            const angle = Math.random() * Math.PI * 2;
                            const radius = 1 + Math.random() * 2.5;
                            const height = (Math.random() - 0.5) * 3;
                            
                            const fixedPosition = {
                                x: radius * Math.cos(angle),
                                y: height,
                                z: radius * Math.sin(angle)
                            };
                            
                            particle.position.set(fixedPosition.x, fixedPosition.y, fixedPosition.z);
                            
                            // フェーズを初期化して即座に表示
                            particle.userData.questioningPhase = {
                                spawnTime: currentTime - 1, // 1秒前に生成されたことにして即座に表示
                                lifespan: 2 + Math.random() * 4,
                                isPersistent: Math.random() < 0.3,
                                fadeInDuration: 0.8,
                                fadeOutDuration: 1.2,
                                hasBeenPersistent: false,
                                fixedPosition: fixedPosition
                            };
                            
                            // 透明度を即座に設定
                            particle.material.opacity = 0.9;
                        }
                    });
                }
                
                // I(E)ステージ以降（Ia、Ib、Ic等）の接続線即座表示
                if (this.shouldShowConnections(newStageId)) {
                    // 接続更新タイマーをリセットして即座に接続を生成
                    this.lastConnectionUpdate = 0;
                    
                    // 少し遅延して接続を強制生成（パーティクルの初期化完了後）
                    setTimeout(() => {
                        this.updateConnections(true); // 強制更新
                    }, 100);
                }
                
                // I-E ステージ専用: パーティクル出現アニメーション初期化
                if (newStageId === 'I-E') {
                    // まず全パーティクルを完全にコア中心に移動・非表示化
                    this.particles.forEach((particle, index) => {
                        if (particle.userData) {
                            // コア中心に移動
                            particle.position.set(0, 0, 0);
                            // 完全に非表示
                            particle.visible = false;
                            particle.material.opacity = 0;
                            particle.scale.setScalar(0.1);
                            
                            // I-Eステージの動作パターンを設定（重要！）
                            particle.userData.behavior = newStageData.behavior;
                            particle.userData.pattern = newStageData.pattern; // 'pulse'に設定
                            particle.userData.cohesion = newStageData.cohesion;
                            particle.userData.speed = newStageData.speed * (0.8 + Math.random() * 0.4);
                            
                            // 出現先の目標位置を計算（放射状配置）
                            const radius = 1 + Math.random() * 4; // 1-5の範囲
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.random() * Math.PI;
                            
                            const targetX = radius * Math.sin(phi) * Math.cos(theta);
                            const targetY = radius * Math.sin(phi) * Math.sin(theta);
                            const targetZ = radius * Math.cos(phi);
                            
                            // 出現アニメーション用データを設定
                            particle.userData.emergenceStartPosition = new THREE.Vector3(0, 0, 0);
                            particle.userData.emergenceTargetPosition = new THREE.Vector3(targetX, targetY, targetZ);
                            
                            // originalPositionを最終目標位置に設定（パルス動作の基準点）
                            particle.userData.originalPosition = new THREE.Vector3(targetX, targetY, targetZ);
                        }
                    });
                    
                    // 出現アニメーション初期化
                    this.initializeIEEmergence();
                }
                
                // 既存パーティクルを新しい動作パターンに段階的に移行
                this.particles.forEach((particle, index) => {
                    if (particle.userData) {
                        // I-Eステージの場合は既に上で処理済み
                        if (newStageId === 'I-E') {
                            // I-Eステージでは色だけ更新（パターンは既に設定済み）
                            if (!this.isColorfulStage(newStageId)) {
                                particle.material.color.setHex(newStageData.color);
                            }
                            return;
                        }
                        
                        // 新しい動作パターンに更新
                        particle.userData.behavior = newStageData.behavior;
                        particle.userData.pattern = newStageData.pattern;
                        particle.userData.cohesion = newStageData.cohesion;
                        particle.userData.speed = newStageData.speed * (0.8 + Math.random() * 0.4);
                        
                        // カラフルステージでない場合は単色に戻す
                        if (!this.isColorfulStage(newStageId)) {
                            this.animateParticleColor(particle, newStageData.color, index * 50);
                        }
                        // カラフルステージの場合は色のトランジションをスキップ（動的に変化するため）
                    }
                });
                
                // パーティクル数の調整
                this.adjustParticleCount(newStageData.particleCount, newStageData.color);
                
                // 段階的光強化システム - ステージ進行に応じて光のベールを更新
                this.updateLightVeils(newStageId);
                
                // 地面移動システム - ステージ変更時の動作パターン更新
                if (this.groundMovementSystem) {
                    this.groundMovementSystem.setMovementPattern(newStageId);
                    console.log('[Ground] Movement pattern updated for stage:', newStageId);
                }
                
                // 説明表示システム - ステージ変更時は説明内容のみ更新（自動表示はしない）
                if (this.explanationSystem) {
                    this.explanationSystem.updateStageExplanations(newStageId);
                }
            }
            
            animateCoreColor(targetColor) {
                if (!this.core) return;
                
                const currentColor = this.core.material.emissive.getHex();
                const targetColorObj = new THREE.Color(targetColor);
                
                // スムーズな色変更アニメーション
                let progress = 0;
                const animateColor = () => {
                    progress += 0.05;
                    if (progress >= 1) {
                        this.core.material.emissive.setHex(targetColor);
                        return;
                    }
                    
                    const currentColorObj = new THREE.Color(currentColor);
                    currentColorObj.lerp(targetColorObj, progress);
                    this.core.material.emissive.copy(currentColorObj);
                    
                    requestAnimationFrame(animateColor);
                };
                animateColor();
            }
            
            animateParticleColor(particle, targetColor, delay = 0) {
                setTimeout(() => {
                    const currentColor = particle.material.color.getHex();
                    const targetColorObj = new THREE.Color(targetColor);
                    
                    let progress = 0;
                    const animateColor = () => {
                        progress += 0.03;
                        if (progress >= 1) {
                            particle.material.color.setHex(targetColor);
                            return;
                        }
                        
                        const currentColorObj = new THREE.Color(currentColor);
                        currentColorObj.lerp(targetColorObj, progress);
                        particle.material.color.copy(currentColorObj);
                        
                        requestAnimationFrame(animateColor);
                    };
                    animateColor();
                }, delay);
            }
            
            // I-E ステージ専用: パーティクル出現アニメーション初期化
            initializeIEEmergence() {
                this.isEmergingIE = true;
                this.emergenceStartTime = Date.now() + this.emergenceDelay;
                this.emergingParticles = [];
                this.emergenceTransitionStarted = false; // 遷移フラグをリセット
                this.emergenceTransitionTime = 0;        // 遷移時刻をリセット
                
                // 全パーティクルを出現待ちリストに追加（シャッフルして自然な順序に）
                const particleIndices = this.particles.map((_, index) => index);
                this.shuffleArray(particleIndices);
                
                particleIndices.forEach((index, order) => {
                    this.emergingParticles.push({
                        particleIndex: index,
                        emergenceTime: this.emergenceStartTime + (order * this.particleEmergenceInterval),
                        hasEmerged: false,
                        emergenceProgress: 0
                    });
                });
                
                console.log(`I-E Emergence initialized: ${this.emergingParticles.length} particles scheduled`);
            }
            
            // 配列をシャッフルするヘルパー関数
            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }
            
            adjustParticleCount(targetCount, color) {
                const currentCount = this.particles.length;
                
                if (currentCount < targetCount) {
                    // パーティクルを追加
                    const toAdd = targetCount - currentCount;
                    for (let i = 0; i < toAdd; i++) {
                        setTimeout(() => {
                            this.addSingleParticle(color);
                        }, i * 100); // 段階的に追加
                    }
                } else if (currentCount > targetCount) {
                    // パーティクルを削除
                    const toRemove = currentCount - targetCount;
                    for (let i = 0; i < toRemove; i++) {
                        setTimeout(() => {
                            this.removeSingleParticle();
                        }, i * 50); // 段階的に削除
                    }
                }
            }
            
            updateLightVeils(currentStageId) {
                // 光のベールが表示されないステージの場合は全ベールを非表示
                if (this.noLightVeilStages.includes(currentStageId)) {
                    this.hideAllLightVeils();
                    return;
                }
                
                // ステージ進行順序に基づいて現在のステージまでの光のベールを表示
                const currentIndex = this.stageProgressionOrder.indexOf(currentStageId);
                
                if (currentIndex === -1) {
                    // 進行順序にないステージの場合も全ベールを非表示
                    this.hideAllLightVeils();
                    return;
                }
                
                // 現在のステージまでの光のベールを段階的に表示
                this.lightVeils.forEach((veil, index) => {
                    if (index <= currentIndex) {
                        // 段階的にフェードイン - より滑らかなアニメーション
                        setTimeout(() => {
                            veil.visible = true;
                            veil.userData.visible = true;
                            veil.userData.fadingIn = true; // フェードイン状態フラグ
                            veil.userData.fadeStartTime = Date.now(); // フェード開始時刻
                            veil.userData.fadeDuration = 2000; // 2秒間でフェードイン
                            
                            // 初期状態を完全透明に設定
                            if (veil.material.uniforms) {
                                veil.material.uniforms.opacity.value = 0;
                                veil.material.uniforms.emissiveIntensity.value = 0;
                            } else {
                                veil.material.opacity = 0;
                                if (veil.material.emissiveIntensity !== undefined) {
                                    veil.material.emissiveIntensity = 0;
                                }
                            }
                            
                        }, index * 500); // 各ベールを500ms間隔で段階的に表示（少し長めに）
                    } else {
                        // まだ到達していないステージのベールは非表示
                        veil.visible = false;
                        veil.userData.visible = false;
                        veil.userData.fadingIn = false;
                    }
                });
                
                // ステージインデックスを更新
                this.currentStageIndex = currentIndex;
            }
            
            hideAllLightVeils() {
                // 全ての光のベールを非表示にする（フェードアウト効果付き）
                this.lightVeils.forEach((veil, index) => {
                    if (veil.visible) {
                        // フェードアウトアニメーション
                        veil.userData.fadingOut = true;
                        veil.userData.fadeOutStartTime = Date.now();
                        veil.userData.fadeOutDuration = 1000; // 1秒間でフェードアウト
                        
                        // シェーダーマテリアル対応の初期値記録
                        if (veil.material.uniforms) {
                            veil.userData.fadeOutStartOpacity = veil.material.uniforms.opacity.value;
                            veil.userData.fadeOutStartEmissive = veil.material.uniforms.emissiveIntensity.value;
                        } else {
                            veil.userData.fadeOutStartOpacity = veil.material.opacity;
                            veil.userData.fadeOutStartEmissive = veil.material.emissiveIntensity || 0;
                        }
                        
                        veil.userData.fadingIn = false; // フェードインを停止
                    }
                });
                this.currentStageIndex = -1; // ベールなし状態
            }
            
            addSingleParticle(color) {
                // 経験のメタファーとしてランダムなサイズを生成
                const baseSize = 0.04;
                const sizeVariation = 0.5 + Math.random() * 1.3; // 0.5 - 1.8倍
                const particleSize = baseSize * sizeVariation;
                
                // 段階に応じたサイズ調整
                const stageNumber = this.getStageNumber(this.currentStage);
                let stageSizeMultiplier = 1.0;
                
                if (stageNumber >= 8) { // Ia, Ib, Ic段階
                    stageSizeMultiplier = 1.0 + (stageNumber - 7) * 0.15;
                } else if (stageNumber >= 5) { // E-I, I-E, IE段階
                    stageSizeMultiplier = 1.0 + (stageNumber - 4) * 0.08;
                }
                
                const finalSize = particleSize * stageSizeMultiplier;
                const geometry = new THREE.SphereGeometry(finalSize, 12, 12); // ランダムサイズ適用、品質も向上
                
                // カラフルステージの場合は初期色をランダムに設定
                const initialColor = this.isColorfulStage(this.currentStage) ? 
                    this.colorfulParticlePalette[Math.floor(Math.random() * this.colorfulParticlePalette.length)] : 
                    color;
                
                // サイズに応じた視覚的効果の調整
                const sizeRatio = finalSize / baseSize; // サイズ比を計算
                const baseOpacity = 0.0; // addSingleParticleは0から開始
                const sizeAdjustedEmissive = Math.floor(0x111111 * (0.8 + sizeRatio * 0.4)); // 大きいほど少し明るく発光
                const sizeAdjustedShininess = 80 + (sizeRatio - 1) * 40; // サイズに応じて光沢度調整
                
                const material = new THREE.MeshPhongMaterial({ 
                    color: initialColor,
                    transparent: true,
                    opacity: baseOpacity,  // 初期は0
                    emissive: sizeAdjustedEmissive,  // サイズ調整された発光
                    shininess: Math.max(50, Math.min(150, sizeAdjustedShininess))  // 光沢範囲制限
                });
                const particle = new THREE.Mesh(geometry, material);
                
                // ランダムな位置に配置
                const radius = 1 + Math.random() * 5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                particle.position.x = radius * Math.sin(phi) * Math.cos(theta);
                particle.position.y = radius * Math.sin(phi) * Math.sin(theta);
                particle.position.z = radius * Math.cos(phi);
                
                // ユーザーデータを設定
                const stageData = this.getStageData(this.currentStage);
                particle.userData = {
                    originalPosition: particle.position.clone(),
                    baseRadius: radius,
                    baseTheta: theta,
                    basePhi: phi,
                    personalityFactor: Math.random(),
                    phaseOffset: Math.random() * Math.PI * 2,
                    speed: stageData.speed * (0.8 + Math.random() * 0.4),
                    cohesion: stageData.cohesion,
                    behavior: stageData.behavior,
                    pattern: stageData.pattern,
                    age: 0,
                    targetPosition: new THREE.Vector3(),
                    // サイズ関連情報を追加
                    originalSize: finalSize,
                    sizeRatio: sizeRatio,
                    baseSize: baseSize,
                    sizeVariation: sizeVariation
                };
                
                // フェードイン効果
                let opacity = 0;
                const fadeIn = () => {
                    opacity += 0.02;
                    if (opacity >= 0.8) {
                        particle.material.opacity = 0.8;
                        return;
                    }
                    particle.material.opacity = opacity;
                    requestAnimationFrame(fadeIn);
                };
                fadeIn();
                
                this.scene.add(particle);
                this.particles.push(particle);
            }
            
            removeSingleParticle() {
                if (this.particles.length === 0) return;
                
                const particle = this.particles.pop();
                
                // フェードアウト効果
                let opacity = particle.material.opacity;
                const fadeOut = () => {
                    opacity -= 0.05;
                    if (opacity <= 0) {
                        this.scene.remove(particle);
                        particle.geometry.dispose();
                        particle.material.dispose();
                        return;
                    }
                    particle.material.opacity = opacity;
                    requestAnimationFrame(fadeOut);
                };
                fadeOut();
            }
            
            updateActiveButton(stageId) {
                const buttons = document.querySelectorAll('.stage-btn');
                buttons.forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.stage === stageId) {
                        btn.classList.add('active');
                    }
                });
                
                // 段階情報表示を更新
                this.updateStageInfo(stageId);
            }
            
            updateStageInfo(stageId) {
                const stageData = this.getStageData(stageId);
                const titleElement = document.getElementById('current-stage-title');
                const descElement = document.getElementById('current-stage-description');
                
                // titleElementが存在しない場合でも、descElementがあれば処理を続行
                if (descElement) {
                    // titleElement を一時的に非表示化（重複表示回避のため）
                    // if (titleElement) {
                    //     titleElement.textContent = `${stageId}: ${stageData.description}`;
                    // }
                    
                    // behaviorDescriptions を一時的に非表示化（将来的に戻す可能性のため保持）
                    /*
                    // 段階に応じた詳細説明
                    const behaviorDescriptions = {
                        'chaotic': 'あまり疑問に感じたりすることは少ない',
                        'conflicted': '今までの考え方や方法でうまくいかない出来事に遭遇',
                        'questioning': '当たり前と思っていたことに対するふとした疑問',
                        'questioning_emergence': 'このままでいいのか、本当に大丈夫だろうか',
                        'building': '自分の好きなことや心に残っている経験は何か',
                        'listening': '自分の心の動きに落ち着いて耳を傾ける',
                        'nurturing': '自分の気持ちや経験と周囲の状況を意味づける',
                        'trusting': '自分が本当に大切にしたいことの輪郭を掴む',
                        'foundation': '周りの人の声に耳を傾け、自分の考えを自分の言葉で話す',
                        'committed': '進みたい道、貢献したいものごとに向かう'
                    };
                    
                    descElement.textContent = behaviorDescriptions[stageData.behavior] || stageData.description;
                    */
                    
                    // stageData.description のみを表示（重複回避）
                    descElement.textContent = stageData.description;
                }
            }
            
            resetView() {
                this.camera.position.set(0, 0, this.defaultCameraZ);
                this.camera.lookAt(0, 0, 0);
                // カメラ回転も初期化
                this.cameraRotationAngle = 0;
            }
            
            // カメラの見回し効果を更新
            updateCameraLookAround() {
                // 地面移動システムがアクティブで、見回し動作が必要な場合のみ実行
                if (!this.groundMovementSystem || !this.isGroundActive) {
                    // スキャニング中でない場合は中央を向く
                    if (this.cameraRotationAngle !== 0) {
                        const resetSpeed = 0.001; // さらにゆっくりと中央に戻る
                        if (Math.abs(this.cameraRotationAngle) > resetSpeed) {
                            this.cameraRotationAngle -= Math.sign(this.cameraRotationAngle) * resetSpeed;
                        } else {
                            this.cameraRotationAngle = 0;
                        }
                        this.camera.lookAt(0, 0, 0); // 中央に戻す
                    }
                    return;
                }
                
                // 現在の地面移動システムから回転角度を取得
                const targetRotationAngle = this.getCameraRotationFromGroundSystem();
                
                if (targetRotationAngle !== null) {
                    // より遅い角度変化（さらにゆっくり）
                    const maxAngleChangePerFrame = 0.001; // 約0.5度/フレーム（さらに遅く）
                    const angleDiff = targetRotationAngle - this.cameraRotationAngle;
                    
                    // 角度差を -π から π の範囲に正規化
                    let normalizedAngleDiff = angleDiff;
                    while (normalizedAngleDiff > Math.PI) normalizedAngleDiff -= 2 * Math.PI;
                    while (normalizedAngleDiff < -Math.PI) normalizedAngleDiff += 2 * Math.PI;
                    
                    // 非常に滑らかな角度更新
                    if (Math.abs(normalizedAngleDiff) > maxAngleChangePerFrame) {
                        this.cameraRotationAngle += Math.sign(normalizedAngleDiff) * maxAngleChangePerFrame;
                    } else {
                        this.cameraRotationAngle = targetRotationAngle;
                    }
                    
                    // より控えめな視線移動（中央からの小さなオフセット）
                    const lookAtX = Math.sin(this.cameraRotationAngle) * this.lookAroundRadius;
                    const lookAtZ = Math.cos(this.cameraRotationAngle) * this.lookAroundRadius;
                    
                    // 基準注視点からの小さなオフセットを適用
                    this.camera.lookAt(
                        this.baseLookAtTarget.x + lookAtX,
                        this.baseLookAtTarget.y,
                        this.baseLookAtTarget.z + lookAtZ
                    );
                } else {
                    // スキャニング中でない場合は中央を向く
                    if (this.cameraRotationAngle !== 0) {
                        const resetSpeed = 0.001; // さらに遅いリセット速度
                        if (Math.abs(this.cameraRotationAngle) > resetSpeed) {
                            this.cameraRotationAngle -= Math.sign(this.cameraRotationAngle) * resetSpeed;
                            const lookAtX = Math.sin(this.cameraRotationAngle) * this.lookAroundRadius;
                            const lookAtZ = Math.cos(this.cameraRotationAngle) * this.lookAroundRadius;
                            this.camera.lookAt(lookAtX, 0, lookAtZ);
                        } else {
                            this.cameraRotationAngle = 0;
                            this.camera.lookAt(0, 0, 0);
                        }
                    }
                }
            }
            
            // 地面移動システムから現在の回転角度を取得
            getCameraRotationFromGroundSystem() {
                if (!this.groundMovementSystem || !this.groundMovementSystem.behaviorState) {
                    return null;
                }
                
                const behaviorState = this.groundMovementSystem.behaviorState;
                const currentStage = this.groundMovementSystem.currentStage;
                
                // EbステージまたはE-Iステージで複数権威スキャニング中の場合
                if ((currentStage === 'Eb' || currentStage === 'E-I') && 
                    behaviorState.currentBehavior === 'pausing' && 
                    behaviorState.shouldReflect &&
                    this.groundMovementSystem.stageConfig?.isMultiAuthorityScanning) {
                    
                    // 現在のスキャニング進行度を計算
                    const currentTime = Date.now();
                    const timeSinceStart = currentTime - behaviorState.behaviorStartTime;
                    const totalDuration = behaviorState.behaviorDuration;
                    const progress = Math.min(timeSinceStart / totalDuration, 1.0);
                    
                    // デバッグ用：カメラ回転のログ
                    if (progress > 0.35 && progress <= 0.65) { // 停止フェーズ中のみ
                        const pausedProgress = (progress - 0.35) / 0.3;
                        
                        // 複数権威スキャニングの角度を取得
                        const scanningAngle = this.groundMovementSystem.executeMultiAuthorityScanning(pausedProgress);
                        console.log(`[Camera Scanning - ${currentStage}] Progress: ${pausedProgress.toFixed(3)}, Camera Angle: ${(scanningAngle * 180 / Math.PI).toFixed(1)}°`);
                        return scanningAngle;
                    }
                }
                
                return null; // 回転不要
            }
            
            reinitialize3D() {
                // 軽い初期化：現在のオブジェクトをリセットして初期状態に戻す
                
                // 全てのパーティクルをクリア
                if (this.particles) {
                    this.particles.forEach(particle => {
                        if (particle && this.scene) {
                            this.scene.remove(particle);
                        }
                    });
                    this.particles = [];
                }
                
                // 接続をクリア
                this.clearConnections();
                
                // 光のベールを隠す
                this.hideAllLightVeils();
                
                // 説明表示システムをリセット
                if (this.explanationSystem) {
                    this.explanationSystem.hidePanel();
                }
                
                // カメラをリセット
                this.resetView();
                
                // 初期状態（Ea）に戻す
                this.switchToStage('Ea');
            }
            
            cleanup() {
                // アニメーションを停止
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                
                // 説明表示システムのクリーンアップ
                if (this.explanationSystem) {
                    this.explanationSystem.cleanup();
                    this.explanationSystem = null;
                }
                
                // シーンの全てのオブジェクトを削除
                if (this.scene) {
                    while(this.scene.children.length > 0) {
                        const child = this.scene.children[0];
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (child.material.map) child.material.map.dispose();
                            child.material.dispose();
                        }
                        this.scene.remove(child);
                    }
                }
                
                // レンダラーを削除
                if (this.renderer) {
                    this.renderer.dispose();
                    this.renderer = null;
                }
            }
            
            handleZoom(deltaY) {
                if (!this.camera) return;
                
                // Zoom direction: positive deltaY = zoom out, negative deltaY = zoom in
                const zoomDirection = deltaY > 0 ? 1 : -1;
                const zoomAmount = zoomDirection * this.zoomSpeed;
                
                // Calculate new camera position
                const currentZ = this.camera.position.z;
                const newZ = currentZ + zoomAmount;
                
                // Clamp zoom within bounds
                const clampedZ = Math.max(this.minZoom, Math.min(this.maxZoom, newZ));
                
                // Apply smooth zoom
                this.camera.position.z = clampedZ;
                
                // Optionally update field of view for more dramatic zoom effect
                // this.camera.fov = Math.max(30, Math.min(75, 75 - (clampedZ - this.defaultCameraZ) * 2));
                // this.camera.updateProjectionMatrix();
            }
            
            handleResize() {
                const width = this.container.offsetWidth;
                const height = this.container.offsetHeight;
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }
            
            startAnimation() {
                const animate = () => {
                    this.animationFrameId = requestAnimationFrame(animate);
                    
                    const time = Date.now() * 0.001;
                    
                    // Core rotation
                    if (this.core) {
                        this.core.rotation.y += 0.005; // ゆっくりとした回転
                        this.core.rotation.x += 0.002;
                    }
                    
                    // 新しい次元効果システムのアニメーション更新
                    this.updateDimensionAnimations(time);
                    
                    // I-E ステージ: パーティクル出現アニメーション処理
                    if (this.isEmergingIE) {
                        this.updateIEEmergence();
                    }
                    
                    // Advanced particle animation based on stage behavior
                    this.particles.forEach((particle, index) => {
                        const userData = particle.userData;
                        if (!userData) return;
                        
                        userData.age += 0.016; // Approximate 60fps
                        
                        // Update colorful particles for I(E) stages and beyond
                        this.updateParticleColorDynamic(particle, index, time);
                        
                        this.updateParticleBehavior(particle, index, time);
                    });
                    
                    // Update particle connections for I(E) stages and beyond
                    if (this.shouldShowConnections(this.currentStage)) {
                        this.updateConnections();
                        this.updateConnectionTransition(); // フェード遷移の更新
                        this.updateConnectionPositions();
                    }
                    
                    // 光のベールの呼吸アニメーション
                    this.animateLightVeils(time);
                    
                    // 多面体コアの回転アニメーション
                    this.animatePolyhedronCore(time);
                    
                    this.renderer.render(this.scene, this.camera);
                };
                animate();
            }

            animatePolyhedronCore(time) {
                if (!this.core || this.isTransitioning) return;
                
                // 段階に応じた回転パターン
                const stageData = this.getStageData(this.currentStage);
                
                switch(this.currentStage) {
                    case 'Ea': case 'Eb': case 'Ec':
                        // 正四面体: 不安定な振動的回転
                        this.core.rotation.x = Math.sin(time * 0.003) * 0.3;
                        this.core.rotation.y += 0.01 + Math.sin(time * 0.002) * 0.005;
                        this.core.rotation.z = Math.cos(time * 0.0025) * 0.2;
                        break;
                        
                    case 'EI': case 'E-I': case 'I-E':
                        // 正八面体: 二重軸回転（葛藤表現）
                        this.core.rotation.x += 0.008;
                        this.core.rotation.y += 0.012;
                        this.core.rotation.z = Math.sin(time * 0.001) * 0.1;
                        break;
                        
                    case 'IE': case 'Ia':
                        // 正十二面体: 調和的な安定回転
                        this.core.rotation.x += 0.005;
                        this.core.rotation.y += 0.008;
                        this.core.rotation.z += 0.003;
                        break;
                        
                    case 'Ib': case 'Ic':
                        // 正二十面体: 複雑で美しい統合回転（落ち着いた速度）
                        this.core.rotation.x += 0.002;
                        this.core.rotation.y += 0.003;
                        this.core.rotation.z += 0.001;
                        // 微細な周期的変動（より穏やか）
                        const fine = Math.sin(time * 0.001) * 0.02;
                        this.core.rotation.x += fine;
                        this.core.rotation.y += fine * 0.8;
                        this.core.rotation.z += fine * 0.6;
                        break;
                }
                
                // 段階共通: 発光効果の呼吸
                if (this.coreLight) {
                    const baseIntensity = this.baseCoreIntensity;
                    const breathe = Math.sin(time * 0.002) * 0.2 + 1;
                    this.coreLight.intensity = baseIntensity * breathe;
                }
            }
            
            animateLightVeils(time) {
                // 光のベールの呼吸アニメーション - セルフ・オーサーシップの成長エネルギーを表現
                this.lightVeils.forEach((veil, index) => {
                    const userData = veil.userData;
                    const now = Date.now();
                    
                    // フェードアウト処理
                    if (userData.fadingOut) {
                        const elapsed = now - userData.fadeOutStartTime;
                        const progress = Math.min(elapsed / userData.fadeOutDuration, 1);
                        
                        // イージング関数（ease-in）でフェードアウト
                        const easedProgress = Math.pow(progress, 2);
                        
                        // MeshBasicMaterial用のフェードアウト
                        veil.material.opacity = userData.fadeOutStartOpacity * (1 - easedProgress);
                        const colorFade = 1.0 * (1 - easedProgress);
                        veil.material.color.setRGB(colorFade, colorFade * 0.98, colorFade * 0.95); // 暖かみを保つ
                        
                        // フェードアウト完了チェック
                        if (progress >= 1) {
                            veil.visible = false;
                            veil.userData.visible = false;
                            veil.userData.fadingOut = false;
                        }
                        return; // フェードアウト中は他の処理をスキップ
                    }
                    
                    if (!veil.visible || !veil.userData.visible) return;
                    
                    // フェードインアニメーションの処理
                    if (userData.fadingIn) {
                        const elapsed = now - userData.fadeStartTime;
                        const progress = Math.min(elapsed / userData.fadeDuration, 1);
                        
                        // イージング関数（ease-out）でより自然なフェードイン
                        const easedProgress = 1 - Math.pow(1 - progress, 3);
                        
                        // 目標値の計算 - より透明感のある設定
                        const targetOpacity = 0.005 + userData.stageIndex * 0.002; // 極めて透明に設定
                        const targetEmissive = 0.15 + userData.stageIndex * 0.03;
                        
                        // シェーダーマテリアル用のフェードイン
                        if (veil.material.uniforms) {
                            veil.material.uniforms.opacity.value = targetOpacity * easedProgress;
                            veil.material.uniforms.emissiveIntensity.value = targetEmissive * easedProgress;
                            veil.material.uniforms.time.value = time; // 時間更新
                        } else {
                            // フォールバック：通常のマテリアル
                            veil.material.opacity = targetOpacity * easedProgress;
                            if (veil.material.emissiveIntensity !== undefined) {
                                veil.material.emissiveIntensity = targetEmissive * easedProgress;
                            }
                        }
                        
                        // フェードイン完了チェック
                        if (progress >= 1) {
                            userData.fadingIn = false;
                        }
                        
                        // フェードイン中はスケールアニメーションを控えめに
                        const breatheIntensity = easedProgress * 0.08; // フェードイン進行に応じて強化
                        const breathe = Math.sin(time * userData.breatheSpeed + userData.breathePhase) * breatheIntensity + 1;
                        veil.scale.setScalar(breathe);
                        
                    } else {
                        // 通常の呼吸アニメーション（フェードイン完了後）
                        const breathe = Math.sin(time * userData.breatheSpeed + userData.breathePhase) * 0.08 + 1;
                        veil.scale.setScalar(breathe);
                        
                        // コアとの同期効果（MeshBasicMaterial用）
                        const coreSync = Math.sin(time * 0.5) * 0.02 + 1; // コアとの同期パルス
                        const opacityVariation = Math.sin(time * userData.breatheSpeed * 0.7 + userData.breathePhase) * 0.03;
                        
                        // 基準値にコア同期と呼吸を適用
                        const materialData = veil.material.userData;
                        const baseOpacity = materialData.baseOpacity;
                        
                        // 自然な光の変動 - コアからの放射光として
                        veil.material.opacity = Math.max(0.002, (baseOpacity + opacityVariation) * breathe * coreSync);
                        
                        // 光の色の強度も変動させて光らしさを演出
                        const colorIntensity = 0.85 + (materialData.emissiveStrength * 0.15 * breathe * coreSync);
                        veil.material.color.setRGB(colorIntensity, colorIntensity * 0.98, colorIntensity * 0.95); // 暖かみのある色調
                    }
                });
            }
            
            // I-E ステージ: パーティクル出現アニメーション更新
            updateIEEmergence() {
                const currentTime = Date.now();
                let allEmerged = true;
                
                this.emergingParticles.forEach(emergenceData => {
                    if (emergenceData.hasEmerged) return;
                    
                    // まだ出現時刻に達していない
                    if (currentTime < emergenceData.emergenceTime) {
                        allEmerged = false;
                        return;
                    }
                    
                    const particle = this.particles[emergenceData.particleIndex];
                    if (!particle || !particle.userData) {
                        emergenceData.hasEmerged = true;
                        return;
                    }
                    
                    // 出現アニメーション開始
                    if (!emergenceData.hasEmerged) {
                        const elapsedTime = currentTime - emergenceData.emergenceTime;
                        const emergenceDuration = 1200; // 各パーティクルの出現期間を1.2秒に延長
                        emergenceData.emergenceProgress = Math.min(elapsedTime / emergenceDuration, 1);
                        
                        // より自然なイージング関数（ease-out cubic）
                        const easedProgress = 1 - Math.pow(1 - emergenceData.emergenceProgress, 2.5);
                        
                        // パーティクルを表示
                        particle.visible = true;
                        
                        // 位置: より滑らかな放射状移動
                        const startPos = particle.userData.emergenceStartPosition;
                        const targetPos = particle.userData.emergenceTargetPosition;
                        
                        // 放射方向ベクトルを計算
                        const direction = targetPos.clone().normalize();
                        const maxDistance = targetPos.length();
                        
                        // 加速度的な移動（最初はゆっくり、後で加速）
                        const currentDistance = maxDistance * easedProgress;
                        particle.position.copy(direction.multiplyScalar(currentDistance));
                        
                        // 透明度: より滑らかなフェードイン
                        const opacityProgress = Math.min(emergenceData.emergenceProgress * 1.5, 1);
                        particle.material.opacity = 0.9 * opacityProgress;
                        
                        // スケール: より滑らかなサイズ変化
                        const scaleProgress = Math.min(emergenceData.emergenceProgress * 1.2, 1);
                        const scale = 0.2 + (0.8 * scaleProgress);
                        particle.scale.setScalar(scale);
                        
                        // 軽微な回転効果（生命感を表現）
                        particle.rotation.z = emergenceData.emergenceProgress * Math.PI * 0.5;
                        
                        // 出現完了チェック
                        if (emergenceData.emergenceProgress >= 1) {
                            emergenceData.hasEmerged = true;
                            
                            // パルス動作の初期状態に合わせて位置を設定
                            const basePos = particle.userData.originalPosition;
                            const distance = basePos.length();
                            
                            // 現在の位置からより正確な時間オフセットを計算
                            const currentDistance = particle.position.length();
                            const currentPulse = Math.max(0.85, Math.min(1.0, currentDistance / distance));
                            
                            // 正規化（-1から1の範囲）
                            const normalizedPulse = Math.max(-1, Math.min(1, (currentPulse - 0.925) / 0.075));
                            
                            // より安全な位相計算（Math.asinの代わりにMath.atan2を使用）
                            const currentPhase = Math.atan2(normalizedPulse, Math.sqrt(Math.max(0, 1 - normalizedPulse * normalizedPulse)));
                            const currentTime = Date.now() * 0.001;
                            particle.userData.pulseTimeOffset = currentPhase - currentTime * 1.2;
                            
                            // パルス動作と同じ計算式を使用して位置を微調整（滑らかな接続）
                            const initialPulse = Math.sin(currentTime * 1.2 + particle.userData.pulseTimeOffset) * 0.075 + 0.925;
                            const direction = basePos.clone().normalize();
                            const pulsedDistance = distance * initialPulse;
                            
                            // 現在位置から目標位置への滑らかな補間（急激な変化を防ぐ）
                            const targetPosition = direction.multiplyScalar(pulsedDistance);
                            particle.position.lerp(targetPosition, 0.3); // 30%の重みで補間
                            
                            // 通常の動作に移行するため、初期設定をリセット
                            particle.material.opacity = Math.min(0.9, particle.material.opacity + 0.1);
                            particle.scale.setScalar(Math.min(1.0, particle.scale.x + 0.1));
                            particle.rotation.z *= 0.7; // 回転を徐々に減衰
                        } else {
                            allEmerged = false;
                        }
                    }
                });
                
                // 全パーティクルの出現完了
                if (allEmerged) {
                    // 段階的にフラグを切り替える（即座に切り替えない）
                    if (!this.emergenceTransitionStarted) {
                        this.emergenceTransitionStarted = true;
                        this.emergenceTransitionTime = Date.now();
                        console.log('I-E Emergence animation nearing completion - starting transition phase');
                    }
                    
                    // 遷移期間（500ms）経過後にフラグを切り替え
                    const transitionDuration = 500;
                    if (Date.now() - this.emergenceTransitionTime > transitionDuration) {
                        this.isEmergingIE = false;
                        this.emergenceTransitionStarted = false;
                        console.log('I-E Emergence animation completed - fully transitioned to pulse behavior');
                        
                        // 全てのパーティクルのパターンを確実にpulseに設定
                        this.particles.children.forEach(particle => {
                            if (particle.userData) {
                                particle.userData.pattern = 'pulse';
                                particle.userData.cohesion = 0.1;
                                particle.userData.behavior = 'listening';
                            }
                        });
                        
                        console.log('I-E particles reset to pulse pattern - total particles:', this.particles.children.length);
                        
                        // 通常のpulseパターンに移行するため、出現アニメーションの一時的効果のみリセット
                        this.particles.forEach(particle => {
                            if (particle.userData) {
                                // 最終的な属性を確実に設定
                                particle.material.opacity = Math.min(0.9, particle.material.opacity);
                                particle.scale.setScalar(1.0);
                                particle.rotation.z = 0;
                            }
                        });
                    }
                }
            }
            
            updateParticleBehavior(particle, index, time) {
                try {
                    const userData = particle.userData;
                    const stageData = this.getStageData(this.currentStage);
                    
                    // サイズに基づく動的効果の適用
                    if (userData.originalSize && userData.sizeRatio) {
                        // 大きなパーティクルは少しゆっくり動く（重い経験のメタファー）
                        const sizeSpeedModifier = 1.0 / (1.0 + (userData.sizeRatio - 1.0) * 0.3);
                        
                        // 小さなパーティクルは少し活発に動く（新しい経験のメタファー）
                        const sizePulseModifier = userData.sizeRatio < 1.0 ? 
                            1.0 + (1.0 - userData.sizeRatio) * 0.5 : 1.0;
                        
                        // 微細な脈動効果（経験の "生きている" 感覚を表現）
                        const pulse = 1.0 + Math.sin(time * 2.0 + userData.phaseOffset) * 0.05 * sizePulseModifier;
                        particle.scale.setScalar(pulse);
                        
                        // サイズ情報をuserDataに保存（他のアニメーションで使用）
                        userData.currentSpeedModifier = sizeSpeedModifier;
                        userData.currentPulseModifier = sizePulseModifier;
                    }
                    
                    switch (userData.pattern) {
                        case 'random':
                            this.animateRandomBehavior(particle, index, time);
                            break;
                        case 'opposing':
                            this.animateOpposingBehavior(particle, index, time);
                            break;
                        case 'hesitant':
                            this.animateHesitantBehavior(particle, index, time);
                            break;
                        case 'spiral_out':
                            this.animateSpiralOutBehavior(particle, index, time);
                            break;
                        case 'dynamic_emergence':
                            this.animateDynamicEmergenceBehavior(particle, index, time);
                            break;
                        case 'convergent':
                            this.animateConvergentBehavior(particle, index, time);
                            break;
                        case 'pulse':
                            this.animatePulseBehavior(particle, index, time);
                            break;
                        case 'growth':
                            this.animateGrowthBehavior(particle, index, time);
                            break;
                        case 'stable_orbit':
                            this.animateStableOrbitBehavior(particle, index, time);
                            break;
                        case 'structured':
                            this.animateStructuredBehavior(particle, index, time);
                            break;
                        case 'harmonious':
                            this.animateHarmoniousBehavior(particle, index, time);
                            break;
                        case 'wave_rotation':
                            this.animateHarmoniousBehavior(particle, index, time);
                            break;
                        default:
                            // フォールバック: 基本的な動き
                            this.animateRandomBehavior(particle, index, time);
                            break;
                    }
                } catch (error) {
                    console.error('Particle animation error:', error, 'Pattern:', userData?.pattern);
                    // エラーが発生した場合はランダム動作にフォールバック
                    this.animateRandomBehavior(particle, index, time);
                }
            }
            
            // 段階別アニメーション関数群
            animateRandomBehavior(particle, index, time) {
                // Ea: 混沌とした不規則な動き
                const userData = particle.userData;
                const speedModifier = userData.currentSpeedModifier || 1.0;
                const baseSpeed = 0.02 * speedModifier; // サイズに応じた速度調整
                
                const noise = Math.sin(time * 2 + index) * 0.5;
                particle.position.x += (Math.random() - 0.5) * baseSpeed;
                particle.position.y += (Math.random() - 0.5) * baseSpeed;
                particle.position.z += (Math.random() - 0.5) * baseSpeed;
                
                // 境界内に保持
                const distance = particle.position.length();
                if (distance > 6) {
                    particle.position.multiplyScalar(0.9);
                }
            }
            
            animateOpposingBehavior(particle, index, time) {
                // Eb: 対立する力による緊張状態
                const userData = particle.userData;
                const speedModifier = userData.currentSpeedModifier || 1.0;
                const baseIntensity = 0.03 * speedModifier; // サイズに応じた動きの強度調整
                
                const conflictDirection = index % 2 === 0 ? 1 : -1;
                const intensity = Math.sin(time * 3 + index) * conflictDirection;
                
                particle.position.x += Math.cos(time + index) * intensity * baseIntensity;
                particle.position.y += Math.sin(time * 1.5 + index) * intensity * baseIntensity;
                particle.rotation.z += intensity * 0.1 * speedModifier;
            }
            
            animateHesitantBehavior(particle, index, time) {
                // Ec: ためらいと気づきの動き
                const hesitation = Math.sin(time * 0.5 + index) * 0.5 + 0.5;
                const awareness = Math.cos(time * 0.3 + index * 0.1);
                
                particle.position.y += awareness * hesitation * 0.01;
                particle.material.opacity = 0.5 + hesitation * 0.3;
            }
            
            animateSpiralOutBehavior(particle, index, time) {
                // E(I): 外向きスパイラル - 疑問が外に向かう
                const userData = particle.userData;
                const spiralRadius = userData.baseRadius + time * 0.1;
                const spiralAngle = userData.baseTheta + time * userData.speed;
                
                particle.position.x = spiralRadius * Math.cos(spiralAngle);
                particle.position.z = spiralRadius * Math.sin(spiralAngle);
                particle.position.y += Math.sin(time + index) * 0.01;
            }
            
            animateConvergentBehavior(particle, index, time) {
                // E-I: 収束 - 内なる声の構築
                const userData = particle.userData;
                
                // I-Eステージのパーティクルがこのメソッドに来ていないか確認
                if (this.currentStage === 'I-E' && index === 0 && Math.random() < 0.05) {
                    console.warn('I-E stage particle in convergent behavior - pattern:', userData.pattern, 'should be pulse');
                }
                
                const centerPull = userData.cohesion * 0.03; // 少し強化
                const direction = new THREE.Vector3().subVectors(new THREE.Vector3(0, 0, 0), particle.position).normalize();
                
                // より強い中心への吸引力
                particle.position.add(direction.multiplyScalar(centerPull));
                
                // 垂直方向の微細な動きを抑制（より収束に集中）
                particle.position.y += Math.sin(time * 2 + index) * 0.003;
                
                // コア近くでは透明度を下げる（吸い込まれる感覚）
                const distanceToCore = particle.position.length();
                if (distanceToCore < 0.5) {
                    particle.material.opacity = Math.max(0.3, 0.9 * (distanceToCore / 0.5));
                }
            }
            
            animateDynamicEmergenceBehavior(particle, index, time) {
                // E(I): 動的出現・消失 - 疑問による経験の再評価
                const userData = particle.userData;
                
                // 疑問フェーズの管理
                if (!userData.questioningPhase) {
                    // transitionToStageで既に初期化されていない場合のみ初期設定
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 1 + Math.random() * 2.5;
                    const height = (Math.random() - 0.5) * 3;
                    
                    const fixedPosition = {
                        x: radius * Math.cos(angle),
                        y: height,
                        z: radius * Math.sin(angle)
                    };
                    
                    particle.position.set(fixedPosition.x, fixedPosition.y, fixedPosition.z);
                    
                    userData.questioningPhase = {
                        spawnTime: time,
                        lifespan: 1.5 + Math.random() * 4, // 1.5-5.5秒のライフスパン
                        isPersistent: Math.random() < 0.25, // 25%の確率で永続化
                        fadeInDuration: 0.8,
                        fadeOutDuration: 1.2,
                        hasBeenPersistent: false,
                        fixedPosition: fixedPosition
                    };
                }
                
                const phase = userData.questioningPhase;
                const age = time - phase.spawnTime;
                
                // 永続化判定（ライフスパンの70%経過時点で判定）
                if (!phase.hasBeenPersistent && age > phase.lifespan * 0.7 && phase.isPersistent) {
                    phase.hasBeenPersistent = true;
                    this.persistentParticleIndices.add(index);
                    phase.lifespan = Infinity; // 永続化
                }
                
                // フェード処理
                let alpha = 1;
                if (age < phase.fadeInDuration) {
                    // フェードイン
                    alpha = age / phase.fadeInDuration;
                } else if (age > phase.lifespan - phase.fadeOutDuration && phase.lifespan !== Infinity) {
                    // フェードアウト（永続パーティクル以外）
                    alpha = Math.max(0, (phase.lifespan - age) / phase.fadeOutDuration);
                }
                
                // パーティクルの再生成判定
                if (age > phase.lifespan && phase.lifespan !== Infinity) {
                    // 新しい位置で再出現
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 1 + Math.random() * 2.5;
                    const height = (Math.random() - 0.5) * 3;
                    
                    const newFixedPosition = {
                        x: radius * Math.cos(angle),
                        y: height,
                        z: radius * Math.sin(angle)
                    };
                    
                    particle.position.set(newFixedPosition.x, newFixedPosition.y, newFixedPosition.z);
                    
                    // 新しいフェーズを開始
                    userData.questioningPhase = {
                        spawnTime: time,
                        lifespan: 1.5 + Math.random() * 4,
                        isPersistent: Math.random() < 0.25,
                        fadeInDuration: 0.8,
                        fadeOutDuration: 1.2,
                        hasBeenPersistent: false,
                        fixedPosition: newFixedPosition
                    };
                    alpha = 0;
                } else {
                    // 固定位置に留まる（わずかな浮遊感のみ）
                    const basePos = phase.fixedPosition;
                    const gentleFloat = Math.sin(time * 0.5 + index * 0.3) * 0.05; // 非常に微細な浮遊
                    
                    particle.position.x = basePos.x;
                    particle.position.y = basePos.y + gentleFloat;
                    particle.position.z = basePos.z;
                }
                
                // 透明度とスケールの適用
                particle.material.opacity = alpha * 0.95;
                const scale = 0.7 + alpha * 0.5;
                
                // スケール設定の安全な処理
                if (particle.scale) {
                    particle.scale.setScalar(scale);
                } else {
                    particle.scale = new THREE.Vector3(scale, scale, scale);
                }
                
                // 永続パーティクルは少し明るく、より強い発光
                if (this.persistentParticleIndices.has(index)) {
                    if (particle.material.emissive) {
                        particle.material.emissive.setHex(0x666600); // より強い黄色の発光
                    }
                } else {
                    if (particle.material.emissive) {
                        particle.material.emissive.setHex(0x111111);
                    }
                }
            }
            
            animatePulseBehavior(particle, index, time) {
                // I-E: 脈動 - 内なる声を聴く（つかず離れずの状態）
                
                const basePos = particle.userData.originalPosition;
                if (!basePos) return; // originalPositionが設定されていない場合はスキップ
                
                // 出現アニメーション中でも、段階的にパルス動作に移行する
                let transitionFactor = 1.0; // 通常時は完全なパルス動作
                let shouldBlendWithEmergence = false;
                
                if (this.isEmergingIE && this.emergingParticles) {
                    const emergenceData = this.emergingParticles.find(data => data.particleIndex === index);
                    if (emergenceData && emergenceData.emergenceProgress > 0.7) {
                        // 出現アニメーションが70%完了したら段階的にパルス動作を開始
                        transitionFactor = (emergenceData.emergenceProgress - 0.7) / 0.3; // 0.7-1.0を0-1にマップ
                        shouldBlendWithEmergence = true;
                    } else if (emergenceData && emergenceData.emergenceProgress <= 0.7) {
                        // まだ出現アニメーション主導期間
                        return;
                    }
                }
                
                // デバッグ：パターンが正しく設定されているか確認（最初の数回のみ）
                if (index === 0 && Math.random() < 0.01) {
                    console.log('I-E Pulse behavior - pattern:', particle.userData.pattern, 'cohesion:', particle.userData.cohesion, 'transition:', transitionFactor);
                }
                
                const distance = basePos.length();
                
                // 時間オフセットを使用した滑らかなパルス（設定されていない場合はindex基準）
                let timeOffset = particle.userData.pulseTimeOffset;
                if (timeOffset === undefined) {
                    // 初回の場合、現在位置に基づいて自然な時間オフセットを計算
                    const currentDistance = particle.position.length();
                    const currentPulseRatio = Math.max(0.85, Math.min(1.0, currentDistance / distance));
                    const normalizedPulse = Math.max(-1, Math.min(1, (currentPulseRatio - 0.925) / 0.075));
                    
                    // より安全な位相計算（Math.asinの代わりにMath.atan2を使用）
                    const basePhase = Math.atan2(normalizedPulse, Math.sqrt(1 - normalizedPulse * normalizedPulse));
                    timeOffset = basePhase - time * 1.2;
                    particle.userData.pulseTimeOffset = timeOffset;
                }
                
                // より短い距離での脈動（0.85-1.0の範囲に調整）
                const pulse = Math.sin(time * 1.2 + timeOffset) * 0.075 + 0.925;
                
                // 個別の思案プロセスを表現する微細な揺らぎ
                const contemplation = Math.sin(time * 2.3 + index * 0.3) * 0.03;
                const finalPulse = pulse + contemplation;
                
                // 基準位置からの脈動（コアに向かわず、元の位置周辺で脈動）
                const direction = basePos.clone().normalize();
                const pulsedDistance = distance * finalPulse;
                
                // 目標位置を計算
                const targetPosition = direction.clone().multiplyScalar(pulsedDistance);
                
                // 軽微な円軌道運動を追加（内なる声を「聴く」動きを表現）
                const orbitAngle = time * 0.3 + index * 0.5;
                const orbitRadius = 0.1;
                const orbitX = Math.cos(orbitAngle) * orbitRadius;
                const orbitZ = Math.sin(orbitAngle) * orbitRadius;
                
                targetPosition.x += orbitX;
                targetPosition.z += orbitZ;
                
                if (shouldBlendWithEmergence) {
                    // 出現アニメーションとパルス動作をブレンド
                    const currentPos = particle.position.clone();
                    particle.position.lerpVectors(currentPos, targetPosition, transitionFactor * 0.1);
                } else {
                    // 通常のパルス動作
                    particle.position.copy(targetPosition);
                }
                
                // 透明度も微細に変動（思考の深さを表現）
                const targetOpacity = 0.7 + finalPulse * 0.2;
                if (shouldBlendWithEmergence) {
                    particle.material.opacity = THREE.MathUtils.lerp(particle.material.opacity, targetOpacity, transitionFactor * 0.1);
                } else {
                    particle.material.opacity = targetOpacity;
                }
            }
            
            animateGrowthBehavior(particle, index, time) {
                // I(E): 成長パターン - 内なる声を育む
                const growth = Math.min(1, particle.userData.age * 0.1);
                const organic = Math.sin(time + index * 0.5) * growth;
                
                particle.position.y += organic * 0.015;
                particle.scale.setScalar(0.8 + growth * 0.4);
            }
            
            animateStableOrbitBehavior(particle, index, time) {
                // Ia: 安定軌道 - 信頼に基づく安定した動き
                const userData = particle.userData;
                const orbitRadius = userData.baseRadius;
                const orbitSpeed = userData.speed * 0.5;
                const angle = time * orbitSpeed + userData.phaseOffset;
                
                particle.position.x = orbitRadius * Math.cos(angle);
                particle.position.z = orbitRadius * Math.sin(angle);
                particle.position.y = userData.originalPosition.y + Math.sin(angle * 2) * 0.2;
            }
            
            animateStructuredBehavior(particle, index, time) {
                // Ib: 構造化 - 基盤形成（よりオーガニックな配置）
                const userData = particle.userData;
                
                // パーティクル固有のランダム要素を初期化（一度だけ）
                if (!userData.structuredParams) {
                    userData.structuredParams = {
                        layerGroup: Math.floor(index / 5) + Math.floor(index / 8), // より多様な層分布
                        baseAngleOffset: Math.random() * Math.PI * 2, // 各パーティクル固有の角度オフセット
                        radiusVariation: 0.7 + Math.random() * 0.6, // 半径のランダム変動
                        heightOffset: (Math.random() - 0.5) * 0.4, // 高さのランダムオフセット
                        rotationSpeed: 0.8 + Math.random() * 0.4, // 個別の回転速度
                        phaseShift: Math.random() * Math.PI * 2, // 波の位相シフト
                        verticalCenter: (Math.random() - 0.5) * 0.8 // 水平面を中心とした上下分散
                    };
                }
                
                const params = userData.structuredParams;
                const layer = Math.min(params.layerGroup, 4); // 最大5層に制限
                const layerRadius = (1 + layer * 0.7) * params.radiusVariation;
                
                // よりオーガニックな角度計算
                const baseAngle = params.baseAngleOffset + time * 0.2 * params.rotationSpeed;
                const angleNoise = Math.sin(time * 0.5 + params.phaseShift) * 0.3; // 角度のゆらぎ
                const finalAngle = baseAngle + angleNoise;
                
                // 半径にも微細な変動を追加
                const radiusNoise = Math.sin(time * 0.8 + index * 0.1) * 0.2;
                const finalRadius = layerRadius + radiusNoise;
                
                particle.position.x = finalRadius * Math.cos(finalAngle);
                particle.position.z = finalRadius * Math.sin(finalAngle);
                // 水平面（y=0）を中心に上下均等に分散
                particle.position.y = params.verticalCenter + params.heightOffset + Math.sin(time + params.phaseShift) * 0.15;
            }
            
            animateHarmoniousBehavior(particle, index, time) {
                // Ic: 波動回転 - Ibのオーガニック構造をベースに波のうねりと回転を追加
                // 広範囲な経験の結びつきを表現するため、より広い空間分散を実現
                const userData = particle.userData;
                
                // Ibのオーガニック構造パラメータを取得/初期化
                if (!userData.structuredParams) {
                    userData.structuredParams = {
                        layerGroup: Math.floor(index / 5) + Math.floor(index / 8),
                        baseAngleOffset: Math.random() * Math.PI * 2,
                        radiusVariation: 0.7 + Math.random() * 0.6,
                        heightOffset: (Math.random() - 0.5) * 1.2, // 高さの分散を3倍に拡大
                        rotationSpeed: 0.8 + Math.random() * 0.4,
                        phaseShift: Math.random() * Math.PI * 2,
                        verticalCenter: (Math.random() - 0.5) * 1.0 // 水平面を中心とした上下分散
                    };
                }
                
                const params = userData.structuredParams;
                const layer = Math.min(params.layerGroup, 4);
                const baseRadius = (1 + layer * 0.7) * params.radiusVariation;
                const baseAngle = params.baseAngleOffset + time * 0.2 * params.rotationSpeed;
                
                // 波のうねり成分を追加
                const waveFrequency = 0.5;
                const waveAmplitude = 0.4;
                const wavePhase = time * 2 + params.phaseShift;
                const wave = Math.sin(wavePhase * waveFrequency) * waveAmplitude;
                
                // 動的な回転半径（波の影響を受ける）
                const dynamicRadius = baseRadius + wave;
                
                // 基本回転に垂直な波動を追加（高さ方向の動きを拡大）
                const verticalWave = Math.sin(time * 1.5 + params.phaseShift) * 0.5; // 垂直波動を拡大
                const radialWave = Math.cos(time * 0.8 + index * 0.4) * 0.15;
                const angleNoise = Math.sin(time * 0.7 + params.phaseShift) * 0.2;
                
                particle.position.x = (dynamicRadius + radialWave) * Math.cos(baseAngle + angleNoise);
                particle.position.z = (dynamicRadius + radialWave) * Math.sin(baseAngle + angleNoise);
                // 水平面（y=0）を中心に上下均等に分散
                particle.position.y = params.verticalCenter + params.heightOffset + verticalWave + Math.sin(baseAngle * 3 + time) * 0.3;
                
                // より明るく活発な透明度変化
                const brightness = 0.8 + Math.sin(time * 2 + index) * 0.2;
                particle.material.opacity = Math.max(0.6, brightness);
            }
            
            // EI stage: パーティクル吸収とコア光量増加
            absorbParticleIntoCore(particle, index) {
                // パーティクルを削除
                this.scene.remove(particle);
                particle.geometry.dispose();
                particle.material.dispose();
                
                // パーティクル配列から削除
                const particleIndex = this.particles.indexOf(particle);
                if (particleIndex > -1) {
                    this.particles.splice(particleIndex, 1);
                }
                
                // 吸収カウントを増加
                this.absorptionCount++;
                
                // コア光量を増加（段階的に上限まで）
                const intensityIncrease = 0.05; // 1回の吸収での増加量
                this.currentCoreIntensity = Math.min(
                    this.maxCoreIntensity, 
                    this.currentCoreIntensity + intensityIncrease
                );
                
                // コアライトの強度を更新
                if (this.coreLight) {
                    this.coreLight.intensity = this.currentCoreIntensity;
                }
                
                // コア自体の発光も強化
                if (this.core && this.core.material) {
                    const emissiveIntensity = Math.min(0.8, 0.2 + (this.absorptionCount * 0.02));
                    this.core.material.emissive.setRGB(emissiveIntensity, emissiveIntensity, emissiveIntensity);
                }
                
                console.log(`パーティクル吸収: ${this.absorptionCount}個, コア光量: ${this.currentCoreIntensity.toFixed(2)}`);
            }
            
            // コア光量をリセット（ステージ切り替え時など）
            resetCoreIntensity() {
                this.absorptionCount = 0;
                this.currentCoreIntensity = this.baseCoreIntensity;
                
                if (this.coreLight) {
                    this.coreLight.intensity = this.baseCoreIntensity;
                }
                
                if (this.core && this.core.material) {
                    this.core.material.emissive.setRGB(0.27, 0.27, 0.27); // 0x444444相当
                }
            }
            
            cleanup() {
                console.log('3Dリソースをクリーンアップ中...');
                
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                
                // Remove particles
                this.particles.forEach(particle => {
                    this.scene.remove(particle);
                    particle.geometry.dispose();
                    particle.material.dispose();
                });
                this.particles = [];
                
                // Clean up connection lines
                this.clearConnections();
                
                // Remove dimension rings
                this.dimensionRings.forEach(ring => {
                    this.scene.remove(ring);
                    ring.geometry.dispose();
                    ring.material.dispose();
                });
                this.dimensionRings = [];
                
                // Clean up renderer
                if (this.renderer) {
                    const sceneElement = document.getElementById('refined-3d-scene');
                    if (sceneElement && this.renderer.domElement.parentNode === sceneElement) {
                        sceneElement.removeChild(this.renderer.domElement);
                    }
                    this.renderer.dispose();
                    this.renderer = null;
                }
                
                // Clean up scene
                if (this.scene) {
                    while(this.scene.children.length > 0) {
                        const object = this.scene.children[0];
                        if (object.geometry) object.geometry.dispose();
                        if (object.material) object.material.dispose();
                        this.scene.remove(object);
                    }
                    this.scene = null;
                }
                
                this.isInitialized = false;
                console.log('3Dリソースクリーンアップ完了');
            }
        }

        // Global instances
        let refinedVisualization = null;
        let journeyVisualization = null;

        // Enhanced toggleSection function with detailed debugging
        function toggleSection(sectionId) {
            console.log('toggleSection called with:', sectionId);
            const section = document.getElementById(sectionId);
            
            if (!section) {
                console.error('Section not found:', sectionId);
                alert('セクションが見つかりません: ' + sectionId);
                return;
            }
            
            console.log('Section element found:', section);
            section.classList.toggle('active');
            const isActive = section.classList.contains('active');
            console.log('Section', sectionId, 'is now', isActive ? 'active' : 'inactive');
            
            // Handle 3D initialization/cleanup for refined-phases section
            if (sectionId === 'refined-phases') {
                if (isActive) {
                    // Section opened - initialize 3D
                    console.log('精緻化セクションが開かれました - 3D初期化開始');
                    try {
                        if (!refinedVisualization) {
                            console.log('Creating new RefinedSelfAuthorshipVisualization instance');
                            refinedVisualization = new RefinedSelfAuthorshipVisualization();
                            console.log('Initializing 3D visualization');
                            refinedVisualization.init('refined-3d-container');
                        } else {
                            // セクションが再度開かれた時は3D環境を初期化
                            console.log('Re-initializing 3D environment');
                            refinedVisualization.reinitialize3D();
                        }
                    } catch (error) {
                        console.error('3D初期化エラー:', error);
                        alert('3D初期化エラー: ' + error.message);
                    }
                } else {
                    // Section closed - 軽いクリーンアップのみ（レンダラーは保持）
                    console.log('精緻化セクションが閉じられました - 軽いクリーンアップ開始');
                    try {
                        if (refinedVisualization) {
                            // アニメーションのみ停止、レンダラーは保持
                            if (refinedVisualization.animationId) {
                                cancelAnimationFrame(refinedVisualization.animationId);
                                refinedVisualization.animationId = null;
                            }
                            console.log('アニメーション停止完了（レンダラーは保持）');
                        }
                    } catch (error) {
                        console.error('軽いクリーンアップエラー:', error);
                    }
                }
            }
            
            // Handle Canvas 2D initialization/cleanup for detailed-journey section
            if (sectionId === 'detailed-journey') {
                if (isActive) {
                    // Section opened - initialize Canvas 2D
                    console.log('詳細な旅セクションが開かれました - Canvas2D初期化開始');
                    try {
                        console.log('Calling initJourneyVisualization');
                        initJourneyVisualization();
                    } catch (error) {
                        console.error('Canvas2D初期化エラー:', error);
                        alert('Canvas2D初期化エラー: ' + error.message);
                    }
                } else {
                    // Section closed - cleanup Canvas 2D
                    console.log('詳細な旅セクションが閉じられました - Canvas2Dクリーンアップ開始');
                    try {
                        cleanupJourneyVisualization();
                    } catch (error) {
                        console.error('Canvas2Dクリーンアップエラー:', error);
                    }
                }
            }
        }

        // Make toggleSection globally available
        window.toggleSection = toggleSection;

        // Stage click handling for dynamic linking
        document.addEventListener('DOMContentLoaded', function() {
            console.log('セルフ・オーサーシップ3D統合システム準備完了');
            
            // Add click handlers to stage headings in text for dynamic linking
            setTimeout(() => {
                const stageHeadings = document.querySelectorAll('.sub-phase h4');
                stageHeadings.forEach(heading => {
                    const text = heading.textContent;
                    const stageMatch = text.match(/^(Ea|Eb|Ec|E\(I\)|E-I|I-E|I\(E\)|Ia|Ib|Ic):/);
                    if (stageMatch) {
                        let stageId = stageMatch[1];
                        // Convert special cases
                        if (stageId === 'E(I)') stageId = 'EI';
                        if (stageId === 'I(E)') stageId = 'IE';
                        
                        heading.style.cursor = 'pointer';
                        heading.style.transition = 'all 0.3s';
                        
                        heading.addEventListener('click', () => {
                            if (refinedVisualization && refinedVisualization.isInitialized) {
                                refinedVisualization.switchToStage(stageId);
                                
                                // Scroll to 3D area
                                const container = document.getElementById('refined-3d-container');
                                if (container) {
                                    container.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            }
                        });
                    }
                });
            }, 1000);
        });

        // ===== Canvas 2D ビジュアライゼーション統合コード =====
        
        class EnhancedParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.2;
                this.vy = (Math.random() - 0.5) * 0.2;
                this.baseSize = Math.random() * 3 + 2;
                this.size = this.baseSize;
                this.autonomy = 0.0;
                this.personalDirection = Math.random() * Math.PI * 2;
                this.personalFrequency = 0.01 + Math.random() * 0.02;
                this.vibrationPhase = Math.random() * Math.PI * 2;
                this.shape = 'circle';
                this.connections = [];
                
                // 接続フェードイン制御用プロパティ
                this.connectionFadeOpacity = 0.0;
                this.connectionFadeStartTime = null;
                this.connectionFadeDuration = 1500; // 1.5秒でフェードイン完了
                this.connectionFadeDelay = 1500;    // 1.5秒の遅延後にフェードイン開始
                
                // 色彩システム
                this.originalHue = Math.random() * 360;
                this.currentHue = this.originalHue;
                this.saturation = 30;
                this.lightness = 50;
                this.glow = 0;
                
                // 軌跡システム
                this.trail = [];
                this.maxTrailLength = 20;
            }

            update(stage, mouseX, mouseY, particles) {
                // 軌跡の更新
                this.trail.push({x: this.x, y: this.y, life: 1.0});
                while (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                this.trail.forEach(point => point.life *= 0.95);

                // 段階に応じた挙動
                switch(stage) {
                    case 0: this.updateGravityDominance(mouseX, mouseY); break;
                    case 1: this.updateChaosEdge(mouseX, mouseY); break;
                    case 2: this.updateCreativeScattering(mouseX, mouseY); break;
                    case 3: this.updateCosmicDance(mouseX, mouseY, particles); break;
                }

                // 境界処理
                this.handleBoundaries();
                
                // 位置更新
                this.x += this.vx;
                this.y += this.vy;

                // 摩擦
                this.vx *= 0.99;
                this.vy *= 0.99;
            }

            updateGravityDominance(mouseX, mouseY) {
                // 重力場の影響
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    const force = 0.004;
                    this.vx += (dx / distance) * force;
                    this.vy += (dy / distance) * force;
                }

                // 同調行動
                this.vibrationPhase += this.personalFrequency;
                this.size = this.baseSize + Math.sin(this.vibrationPhase) * 0.5;
                
                // 色彩の統一化
                this.currentHue = 240;
                this.saturation = 40;
                this.lightness = 60;
                this.glow = 0;
                this.autonomy = 0;
                this.shape = 'ellipse';
            }

            updateChaosEdge(mouseX, mouseY) {
                // 外部と内部の力の混在
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    const force = 0.002 * (1 - this.autonomy);
                    this.vx += (dx / distance) * force;
                    this.vy += (dy / distance) * force;
                }

                // 不規則な振動
                this.vibrationPhase += this.personalFrequency * (1 + Math.sin(Date.now() * 0.003) * 0.5);
                this.size = this.baseSize + Math.sin(this.vibrationPhase) * 1.5;
                
                // 自律性の芽生え
                if (Math.random() < 0.01) {
                    this.autonomy = Math.min(0.3, this.autonomy + 0.005);
                }
                
                // 色彩の分化
                this.currentHue = this.originalHue + (Math.sin(this.vibrationPhase) * 30);
                this.saturation = 40 + (this.autonomy * 40);
                this.lightness = 60 + (Math.sin(this.vibrationPhase) * 20);
                this.glow = this.autonomy * 0.3;
                
                // 形状の実験
                const shapeRandom = Math.sin(this.vibrationPhase * 3);
                if (shapeRandom > 0.7) this.shape = 'triangle';
                else if (shapeRandom > 0.3) this.shape = 'square';
                else this.shape = 'circle';
                
                // 個人的な方向性
                const personalForce = 0.001 * this.autonomy;
                this.vx += Math.cos(this.personalDirection) * personalForce;
                this.vy += Math.sin(this.personalDirection) * personalForce;
            }

            updateCreativeScattering(mouseX, mouseY) {
                try {
                    // 入力値の検証
                    if (!isFinite(mouseX) || !isFinite(mouseY)) {
                        mouseX = this.x || 0;
                        mouseY = this.y || 0;
                    }
                    
                    // 初期拡散フェーズ - ステージ移行直後に積極的に拡散
                    if (!this.hasInitialDispersed) {
                        this.hasInitialDispersed = true;
                        this.initialDispersionTimer = 0;
                        
                        // 初期拡散方向をランダムに設定
                        this.dispersalDirection = Math.random() * Math.PI * 2;
                        this.dispersalForce = 0.4 + Math.random() * 0.3; // 0.4-0.7の拡散力（従来の半分程度）
                    }
                    
                    // 初期拡散力の適用（最初の4秒間に延長してより緩やかに）
                    if (this.initialDispersionTimer < 240) { // 60fps * 4秒
                        this.initialDispersionTimer++;
                        const dispersionStrength = Math.max(0, 1 - (this.initialDispersionTimer / 240));
                        
                        this.vx += Math.cos(this.dispersalDirection) * this.dispersalForce * dispersionStrength * 0.01; // 0.02から0.01に減少
                        this.vy += Math.sin(this.dispersalDirection) * this.dispersalForce * dispersionStrength * 0.01;
                    }
                    
                    // 重力からの解放（従来より弱く調整）
                    const dx = mouseX - this.x;
                    const dy = mouseY - this.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // 分母ゼロチェック
                    if (distance < 0.001) {
                        distance = 0.001;
                    }
                    
                    if (isFinite(distance) && distance > 0) {
                        // 重力の影響を大幅に減少（自律性重視）
                        const force = 0.0002 * (1 - this.autonomy) * Math.max(0, 1 - this.autonomy);
                        if (isFinite(force)) {
                            const forceX = (dx / distance) * force;
                            const forceY = (dy / distance) * force;
                            
                            if (isFinite(forceX) && isFinite(forceY)) {
                                this.vx += forceX;
                                this.vy += forceY;
                            }
                        }
                    }

                    // 急速な自律性の発達
                    this.autonomy = Math.min(0.95, this.autonomy + 0.008);
                    
                    // 創造的な軌道（安全性チェック付き）- 拡散力強化
                    if (isFinite(this.personalDirection)) {
                        this.personalDirection += 0.012 + (this.autonomy * 0.02); // 回転速度を少し緩やかに
                        const creativityForce = 0.004 * this.autonomy + 0.001; // 基本創造力を減少
                        
                        // 拡散促進力 - 他のパーティクルとの距離に基づく反発力
                        const expansionForce = 0.002 * this.autonomy; // 拡散力を半分に
                        
                        if (isFinite(creativityForce) && isFinite(expansionForce)) {
                            const baseCreativeX = Math.cos(this.personalDirection) * creativityForce;
                            const baseCreativeY = Math.sin(this.personalDirection) * creativityForce;
                            
                            // 拡散方向への追加力
                            const expansionX = Math.cos(this.personalDirection + Math.PI/4) * expansionForce;
                            const expansionY = Math.sin(this.personalDirection + Math.PI/4) * expansionForce;
                            
                            this.vx += baseCreativeX + expansionX;
                            this.vy += baseCreativeY + expansionY;
                        }
                    } else {
                        this.personalDirection = Math.random() * Math.PI * 2;
                    }

                    // 境界での反発力強化（画面端からの自律的反発）
                    const canvas = document.getElementById('growth-visualization-canvas');
                    if (canvas) {
                        const margin = 50;
                        if (this.x < margin) this.vx += 0.005 * this.autonomy; // 境界反発力も半減
                        if (this.x > canvas.width - margin) this.vx -= 0.005 * this.autonomy;
                        if (this.y < margin) this.vy += 0.005 * this.autonomy;
                        if (this.y > canvas.height - margin) this.vy -= 0.005 * this.autonomy;
                    }

                    // 生き生きとした振動（安全性チェック付き）- 活発性向上
                    if (isFinite(this.vibrationPhase) && isFinite(this.personalFrequency)) {
                        this.vibrationPhase += this.personalFrequency * (2.5 + this.autonomy * 1.5);
                        const sizeModifier = Math.sin(this.vibrationPhase * 2) * (1.2 + this.autonomy * 2.5);
                        if (isFinite(sizeModifier)) {
                            this.size = this.baseSize + sizeModifier;
                        } else {
                            this.size = this.baseSize;
                        }
                    } else {
                        this.vibrationPhase = Math.random() * Math.PI * 2;
                        this.personalFrequency = 0.015 + Math.random() * 0.025; // 振動頻度向上
                        this.size = this.baseSize;
                    }
                    
                    // 独自色彩の確立（安全性チェック付き）- より鮮やかに
                    if (isFinite(this.originalHue) && isFinite(this.personalDirection)) {
                        this.currentHue = this.originalHue + (Math.sin(this.personalDirection) * 90); // 色相変化拡大
                        this.saturation = 70 + (this.autonomy * 25); // 彩度向上
                        this.lightness = 65 + (Math.sin(this.vibrationPhase) * 30); // 明度変化拡大
                        this.glow = this.autonomy * 1.2; // グロー効果強化
                    } else {
                        this.currentHue = this.originalHue || Math.random() * 360;
                        this.saturation = 75;
                        this.lightness = 70;
                        this.glow = 0.7;
                    }
                    
                    // 多様な形状（安全性チェック付き）
                    if (isFinite(this.personalDirection) && isFinite(this.vibrationPhase)) {
                        const uniqueShape = Math.sin(this.personalDirection * 2 + this.vibrationPhase);
                        if (uniqueShape > 0.6) this.shape = 'triangle';
                        else if (uniqueShape > 0.2) this.shape = 'square';
                        else if (uniqueShape > -0.2) this.shape = 'circle';
                        else this.shape = 'ellipse';
                    } else {
                        this.shape = 'circle';
                    }

                    // 摩擦の軽減（自律性が高いほど慣性を保持）
                    const frictionReduction = 1 - (this.autonomy * 0.3);
                    this.vx *= (0.985 + (this.autonomy * 0.01)); // 摩擦軽減
                    this.vy *= (0.985 + (this.autonomy * 0.01)); // 摩擦軽減

                    // 速度制限（発散防止）- 上限緩和
                    const maxVelocity = 2.5 + (this.autonomy * 2.5); // 自律性に応じて最大速度向上（2.5-5.0の範囲）
                    this.vx = Math.max(-maxVelocity, Math.min(maxVelocity, this.vx || 0));
                    this.vy = Math.max(-maxVelocity, Math.min(maxVelocity, this.vy || 0));
                    
                } catch (error) {
                    console.error('updateCreativeScattering error:', error);
                    // エラー時は安全な値にリセット
                    this.autonomy = 0.3;
                    this.size = this.baseSize;
                    this.shape = 'circle';
                    this.vx = (this.vx || 0) * 0.5;
                    this.vy = (this.vy || 0) * 0.5;
                    this.hasInitialDispersed = false;
                    this.personalDirection = Math.random() * Math.PI * 2;
                }
            }

            updateCosmicDance(mouseX, mouseY, particles) {
                // 接続フェードイン制御の初期化
                if (this.connectionFadeStartTime === null) {
                    this.connectionFadeStartTime = Date.now();
                    this.connectionFadeOpacity = 0.0;
                }
                
                // フェードイン進行度の計算
                const currentTime = Date.now();
                const timeSinceStageStart = currentTime - this.connectionFadeStartTime;
                
                if (timeSinceStageStart >= this.connectionFadeDelay) {
                    // 遅延期間経過後、フェードイン開始
                    const fadeProgress = Math.min(1.0, (timeSinceStageStart - this.connectionFadeDelay) / this.connectionFadeDuration);
                    this.connectionFadeOpacity = fadeProgress;
                } else {
                    // まだ遅延期間中
                    this.connectionFadeOpacity = 0.0;
                }
                
                // 相互作用の準備
                this.connections = [];
                
                // パーティクル間相互作用（動的なネットワーク形成）
                particles.forEach(other => {
                    if (other === this) return;
                    
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // 適度な距離を保つための反発力（自律性の維持）
                    const minDistance = 40; // 最小距離（個人空間の確保）
                    if (distance < minDistance && distance > 0) {
                        const repulsionForce = 0.002 * (1 - distance / minDistance);
                        this.vx -= (dx / distance) * repulsionForce;
                        this.vy -= (dy / distance) * repulsionForce;
                    }
                    
                    // 中距離での動的な接続（調和的なネットワーク）
                    const optimalDistance = 80; // 最適な接続距離
                    const maxConnectionDistance = 120; // 最大接続距離
                    
                    if (distance < maxConnectionDistance && distance > minDistance) {
                        // 接続の記録（描画用）
                        this.connections.push({
                            particle: other,
                            strength: Math.max(0, 1 - distance / maxConnectionDistance)
                        });
                        
                        // 最適距離への穏やかな調整力
                        if (distance < optimalDistance) {
                            // 少し離れる方向へ
                            const adjustForce = 0.0003 * (1 - distance / optimalDistance);
                            this.vx -= (dx / distance) * adjustForce;
                            this.vy -= (dy / distance) * adjustForce;
                        } else {
                            // 少し近づく方向へ（弱い引力）
                            const harmonyForce = 0.0004 * (1 - distance / maxConnectionDistance);
                            this.vx += (dx / distance) * harmonyForce;
                            this.vy += (dy / distance) * harmonyForce;
                        }
                    }
                });

                // 最大自律性
                this.autonomy = Math.min(1.0, this.autonomy + 0.002);
                
                // 独自軌道の維持（個性の表現）
                this.personalDirection += 0.008 + (Math.sin(Date.now() * 0.001 + this.originalHue) * 0.008);
                const selfForce = 0.003; // 自律性を強化
                this.vx += Math.cos(this.personalDirection) * selfForce;
                this.vy += Math.sin(this.personalDirection) * selfForce;
                
                // 個人的な振動パターン（独自性の維持） - 方向性を均等に分散
                const personalOscillationX = 0.001 * Math.sin(Date.now() * 0.002 + this.originalHue * 0.1);
                const personalOscillationY = 0.001 * Math.sin(Date.now() * 0.002 + this.originalHue * 0.1 + Math.PI * 0.5);
                this.vx += personalOscillationX;
                this.vy += personalOscillationY;
                
                // 中心への復帰力（画面全体の均等な分布を促進）
                const canvas = document.getElementById('journey-canvas');
                if (canvas) {
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const toCenterX = centerX - this.x;
                    const toCenterY = centerY - this.y;
                    const distanceToCenter = Math.sqrt(toCenterX * toCenterX + toCenterY * toCenterY);
                    
                    // 中心から遠すぎる場合、非常に弱い復帰力を適用
                    const maxRadius = Math.min(canvas.width, canvas.height) * 0.4;
                    if (distanceToCenter > maxRadius) {
                        const returnForce = 0.0002 * (distanceToCenter - maxRadius) / maxRadius;
                        this.vx += (toCenterX / distanceToCenter) * returnForce;
                        this.vy += (toCenterY / distanceToCenter) * returnForce;
                    }
                }

                // 調和的な脈動
                this.vibrationPhase += this.personalFrequency * 1.5;
                this.size = this.baseSize + Math.sin(this.vibrationPhase) * 0.8;
                
                // 成熟した個性的な色彩（多様性の表現）
                const individualityFactor = Math.sin(this.vibrationPhase * 0.3 + this.originalHue * 0.05);
                this.currentHue = this.originalHue + (individualityFactor * 40); // より広い色彩範囲
                this.saturation = 75 + (Math.sin(this.vibrationPhase * 0.7) * 15); // 彩度の変動
                this.lightness = 75 + (Math.sin(this.vibrationPhase * 0.5) * 15); // 明度の変動
                this.glow = 0.4 + (Math.sin(this.vibrationPhase * 0.3) * 0.4); // より動的な輝き
                
                // 創造的な形状変化（創造的散乱と同様のキラキラ効果）
                if (isFinite(this.personalDirection) && isFinite(this.vibrationPhase)) {
                    const harmonicShape = Math.sin(this.personalDirection * 1.5 + this.vibrationPhase * 0.8);
                    const dynamicShape = Math.cos(this.vibrationPhase * 1.2 + this.originalHue * 0.1);
                    
                    // より洗練された形状変化パターン
                    if (harmonicShape > 0.7) {
                        this.shape = 'triangle';
                    } else if (harmonicShape > 0.3) {
                        this.shape = 'square';
                    } else if (dynamicShape > 0.4) {
                        this.shape = 'ellipse';
                    } else {
                        this.shape = 'circle';
                    }
                } else {
                    this.shape = 'circle';
                }
            }

            handleBoundaries() {
                const canvas = document.getElementById('journey-canvas');
                if (!canvas) return;
                
                const margin = this.size + 10;
                
                // 境界での反発を強化し、偏りを防ぐ
                if (this.x < margin) {
                    this.x = margin;
                    this.vx = Math.abs(this.vx) * 0.9; // 反発力を強化
                    // 軽微な上下のランダム要素を追加
                    this.vy += (Math.random() - 0.5) * 0.1;
                }
                if (this.x > canvas.width - margin) {
                    this.x = canvas.width - margin;
                    this.vx = -Math.abs(this.vx) * 0.9; // 反発力を強化
                    // 軽微な上下のランダム要素を追加
                    this.vy += (Math.random() - 0.5) * 0.1;
                }
                if (this.y < margin) {
                    this.y = margin;
                    this.vy = Math.abs(this.vy) * 0.9; // 反発力を強化
                    // 軽微な左右のランダム要素を追加
                    this.vx += (Math.random() - 0.5) * 0.1;
                }
                if (this.y > canvas.height - margin) {
                    this.y = canvas.height - margin;
                    this.vy = -Math.abs(this.vy) * 0.9; // 反発力を強化
                    // 軽微な左右のランダム要素を追加
                    this.vx += (Math.random() - 0.5) * 0.1;
                }
            }

            draw(ctx, stage) {
                // 軌跡描画
                if (stage >= 1) {
                    this.drawTrail(ctx, stage);
                }
                
                // グロー効果
                if (this.glow > 0 && stage >= 2) {
                    this.drawGlow(ctx);
                }
                
                // メインパーティクル
                this.drawParticle(ctx);
                
                // 接続線（最終段階のみ）
                if (stage === 3) {
                    this.drawConnections(ctx);
                }
            }

            drawTrail(ctx, stage) {
                if (this.trail.length < 2) return;
                
                ctx.save();
                
                switch(stage) {
                    case 0:
                        ctx.strokeStyle = `hsla(${this.currentHue}, 30%, 50%, 0.2)`;
                        ctx.lineWidth = 1;
                        break;
                    case 1:
                        ctx.strokeStyle = `hsla(${this.currentHue}, 50%, 60%, 0.3)`;
                        ctx.lineWidth = 1.5;
                        break;
                    case 2:
                        ctx.strokeStyle = `hsla(${this.currentHue}, 70%, 70%, 0.5)`;
                        ctx.lineWidth = 2;
                        break;
                    case 3:
                        const gradient = ctx.createLinearGradient(
                            this.trail[0].x, this.trail[0].y,
                            this.x, this.y
                        );
                        gradient.addColorStop(0, `hsla(${this.currentHue}, 80%, 80%, 0)`);
                        gradient.addColorStop(1, `hsla(${this.currentHue}, 80%, 80%, 0.6)`);
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 3;
                        break;
                }
                
                ctx.beginPath();
                for (let i = 1; i < this.trail.length; i++) {
                    const point = this.trail[i];
                    ctx.globalAlpha = point.life * 0.5;
                    
                    if (i === 1) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                }
                ctx.stroke();
                ctx.restore();
            }

            drawGlow(ctx) {
                ctx.save();
                
                // Stage 3では特に強いグロー効果を適用
                const stage = journeyCurrentStage;
                const glowIntensity = stage === 3 ? this.glow * 0.4 : this.glow * 0.2;
                const glowMultiplier = stage === 3 ? 2.5 : 1.5;
                
                ctx.globalAlpha = glowIntensity;
                const glowSize = this.size * (1.5 + this.glow * glowMultiplier);
                
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, glowSize
                );
                
                // Stage 3では多層グロー効果
                if (stage === 3) {
                    gradient.addColorStop(0, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 20}%, 0.6)`);
                    gradient.addColorStop(0.3, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 15}%, 0.3)`);
                    gradient.addColorStop(0.7, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 10}%, 0.1)`);
                    gradient.addColorStop(1, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 15}%, 0)`);
                } else {
                    gradient.addColorStop(0, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 15}%, 0.4)`);
                    gradient.addColorStop(1, `hsla(${this.currentHue}, ${this.saturation}%, ${this.lightness + 15}%, 0)`);
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            drawParticle(ctx) {
                try {
                    ctx.save();
                    ctx.globalAlpha = 1.0;
                    
                    // 値の安全性チェック
                    const hue = isFinite(this.currentHue) ? this.currentHue % 360 : 0;
                    const sat = Math.max(0, Math.min(100, this.saturation || 50));
                    const light = Math.max(0, Math.min(100, this.lightness || 50));
                    const size = Math.max(0.5, Math.min(20, this.size || 2));
                    const rotationAngle = isFinite(this.vibrationPhase) ? this.vibrationPhase : 0;
                    
                    // 位置の安全性チェック
                    const x = isFinite(this.x) ? this.x : 0;
                    const y = isFinite(this.y) ? this.y : 0;
                    
                    // Stage 3では特別なキラキラ効果を追加
                    const stage = journeyCurrentStage;
                    const sparkleIntensity = stage === 3 ? this.glow * 0.8 : 0;
                    
                    ctx.fillStyle = `hsl(${hue}, ${sat}%, ${light}%)`;
                    ctx.strokeStyle = `hsl(${hue}, ${sat}%, ${Math.max(20, light - 20)}%)`;
                    ctx.lineWidth = stage === 3 ? 1.0 : 0.5; // Stage 3では輪郭を強化
                    
                    ctx.translate(x, y);
                    ctx.rotate(rotationAngle);
                    
                    // Stage 3では追加のキラキラエフェクト
                    if (stage === 3 && sparkleIntensity > 0.3) {
                        this.drawSparkles(ctx, size, hue, sat, light);
                    }
                    
                    ctx.beginPath();
                    switch(this.shape) {
                        case 'circle':
                            ctx.arc(0, 0, size, 0, Math.PI * 2);
                            break;
                        case 'ellipse':
                            ctx.scale(1, 0.6);
                            ctx.arc(0, 0, size, 0, Math.PI * 2);
                            break;
                        case 'triangle':
                            ctx.moveTo(0, -size);
                            ctx.lineTo(-size * 0.866, size * 0.5);
                            ctx.lineTo(size * 0.866, size * 0.5);
                            ctx.closePath();
                            break;
                        case 'square':
                            ctx.rect(-size * 0.7, -size * 0.7, size * 1.4, size * 1.4);
                            break;
                        default:
                            // 不明な形状の場合は円にフォールバック
                            ctx.arc(0, 0, size, 0, Math.PI * 2);
                            break;
                    }
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.restore();
                } catch (error) {
                    console.error('drawParticle error:', error);
                    // エラー時は最小限の描画
                    try {
                        ctx.save();
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(this.x || 0, this.y || 0, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    } catch (fallbackError) {
                        console.error('Fallback drawing also failed:', fallbackError);
                    }
                }
            }

            drawConnections(ctx) {
                if (this.connections.length === 0 || this.connectionFadeOpacity <= 0) return;
                
                ctx.save();
                this.connections.forEach((connection, index) => {
                    if (Date.now() % 2 === 0 && index % 2 === 1) return;
                    
                    // フェードイン透明度を適用
                    const baseOpacity = Math.min(0.6, connection.strength * 0.5);
                    ctx.globalAlpha = baseOpacity * this.connectionFadeOpacity;
                    
                    const avgHue = (this.currentHue + connection.particle.currentHue) / 2;
                    ctx.strokeStyle = `hsl(${avgHue % 360}, 60%, 70%)`;
                    ctx.lineWidth = Math.max(0.5, connection.strength * 2);
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(connection.particle.x, connection.particle.y);
                    ctx.stroke();
                });
                ctx.restore();
            }
            
            drawSparkles(ctx, size, hue, sat, light) {
                // キラキラエフェクト用の小さな星状の図形を描画
                ctx.save();
                
                const sparkleCount = 4 + Math.floor(this.glow * 4); // 輝きに応じてスパークル数を調整
                const sparkleRadius = size * 0.3;
                
                for (let i = 0; i < sparkleCount; i++) {
                    const angle = (i / sparkleCount) * Math.PI * 2 + this.vibrationPhase * 0.5;
                    const distance = sparkleRadius + Math.sin(this.vibrationPhase * 2 + i) * sparkleRadius * 0.3;
                    
                    const sparkleX = Math.cos(angle) * distance;
                    const sparkleY = Math.sin(angle) * distance;
                    
                    // スパークルの色は基本色より明るく
                    const sparkleHue = (hue + Math.sin(this.vibrationPhase + i) * 30) % 360;
                    const sparkleBrightness = Math.min(95, light + 20);
                    
                    ctx.globalAlpha = 0.3 + Math.sin(this.vibrationPhase * 3 + i) * 0.3;
                    ctx.fillStyle = `hsl(${sparkleHue}, ${sat}%, ${sparkleBrightness}%)`;
                    
                    // 小さな星形を描画
                    const sparkleSize = size * 0.15 * (0.5 + Math.sin(this.vibrationPhase * 2 + i) * 0.5);
                    ctx.beginPath();
                    for (let j = 0; j < 4; j++) {
                        const starAngle = (j / 4) * Math.PI * 2;
                        const x = sparkleX + Math.cos(starAngle) * sparkleSize;
                        const y = sparkleY + Math.sin(starAngle) * sparkleSize;
                        
                        if (j === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // Canvas 2D ビジュアライゼーション管理
        let journeyCanvas = null;
        let journeyCtx = null;
        let journeyParticles = [];
        let journeyMouseX = 0;
        let journeyMouseY = 0;
        let journeyCurrentStage = 0;
        let journeyAnimationId = null;

        const journeyStageDescriptions = [
            {
                title: "重力の支配",
                description: "外部の権威に従属している状態"
            },
            {
                title: "揺らぎと境界状態", 
                description: "内なる声に耳を傾け、揺らぎが生まれる"
            },
            {
                title: "創造的な散乱",
                description: "個性が芽吹き、自律的な動きを始める"
            },
            {
                title: "創発的相互作用",
                description: "自律的な主体の相互ネットワークの創発"
            }
        ];

        function initJourneyVisualization() {
            console.log('Canvas 2D ビジュアライゼーション初期化開始');
            
            try {
                journeyCanvas = document.getElementById('journey-canvas');
                if (!journeyCanvas) {
                    console.error('Canvas要素が見つかりません');
                    return;
                }
                
                journeyCtx = journeyCanvas.getContext('2d');
                if (!journeyCtx) {
                    console.error('Canvas 2Dコンテキストの取得に失敗');
                    return;
                }
                
                initJourneyCanvas();
                createJourneyParticles();
                updateJourneyStageUI();
                updateJourneyButtonStates();
                addJourneyEventListeners();
                startJourneyAnimation();
                
                console.log('Canvas 2D ビジュアライゼーション初期化完了');
            } catch (error) {
                console.error('Canvas 2D ビジュアライゼーション初期化エラー:', error);
            }
        }

        function cleanupJourneyVisualization() {
            console.log('Canvas 2D ビジュアライゼーション クリーンアップ開始');
            
            if (journeyAnimationId) {
                cancelAnimationFrame(journeyAnimationId);
                journeyAnimationId = null;
            }
            
            journeyParticles = [];
            journeyCurrentStage = 0;
            
            removeJourneyEventListeners();
            
            console.log('Canvas 2D ビジュアライゼーション クリーンアップ完了');
        }

        function initJourneyCanvas() {
            if (!journeyCanvas) return;
            
            const container = journeyCanvas.parentElement;
            journeyCanvas.width = container.clientWidth;
            journeyCanvas.height = container.clientHeight;
            
            journeyMouseX = journeyCanvas.width / 2;
            journeyMouseY = journeyCanvas.height / 2;
        }

        function createJourneyParticles() {
            journeyParticles = [];
            if (!journeyCanvas) return;
            
            const numParticles = Math.min(100, Math.floor(journeyCanvas.width * journeyCanvas.height / 10000));
            
            for (let i = 0; i < numParticles; i++) {
                journeyParticles.push(new EnhancedParticle(
                    Math.random() * journeyCanvas.width,
                    Math.random() * journeyCanvas.height
                ));
            }
        }

        function updateJourneyPhysicsInfo() {
            const avgAutonomy = journeyParticles.reduce((sum, p) => sum + p.autonomy, 0) / journeyParticles.length;
            const gravityStrength = journeyCurrentStage === 0 ? "強" : journeyCurrentStage === 1 ? "中" : journeyCurrentStage === 2 ? "弱" : "無";
            
            let harmony = 0;
            if (journeyCurrentStage === 3) {
                // 適度な距離を保った質の高い接続を評価
                let qualityConnections = 0;
                let totalParticles = journeyParticles.length;
                
                journeyParticles.forEach(particle => {
                    particle.connections.forEach(connection => {
                        const dx = connection.particle.x - particle.x;
                        const dy = connection.particle.y - particle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // 適度な距離（60-100ピクセル）の接続により高いスコアを与える
                        if (distance >= 60 && distance <= 100) {
                            qualityConnections += connection.strength * 1.5; // 質の高い接続に高いスコア
                        } else if (distance >= 40 && distance <= 120) {
                            qualityConnections += connection.strength; // 通常のスコア
                        } else {
                            qualityConnections += connection.strength * 0.5; // 近すぎる/遠すぎる接続は低いスコア
                        }
                    });
                });
                
                harmony = Math.min(100, (qualityConnections / totalParticles) * 8);
            }
            
            const physicsInfo = document.getElementById('journey-physicsInfo');
            if (physicsInfo) {
                physicsInfo.innerHTML = 
                    `重力強度: ${gravityStrength}<br>` +
                    `自律性: ${Math.round(avgAutonomy * 100)}%<br>` +
                    `調和度: ${Math.round(harmony)}%`;
            }
        }

        function updateJourneyStageUI() {
            const stageInfo = document.getElementById('journey-stageInfo');
            if (stageInfo) {
                const stage = journeyStageDescriptions[journeyCurrentStage];
                stageInfo.innerHTML = `${stage.title}<br><small>${stage.description}</small>`;
            }
            
            // ドット更新
            for (let i = 0; i < 4; i++) {
                const dot = document.getElementById(`journey-dot${i}`);
                if (dot) {
                    dot.classList.toggle('active', i === journeyCurrentStage);
                }
            }
        }

        function updateJourneyButtonStates() {
            const prevButton = document.getElementById('journey-prevButton');
            const nextButton = document.getElementById('journey-nextButton');
            
            if (prevButton) {
                prevButton.disabled = journeyCurrentStage === 0;
                prevButton.style.opacity = journeyCurrentStage === 0 ? '0.5' : '1';
            }
            
            if (nextButton) {
                nextButton.disabled = journeyCurrentStage === 3;
                nextButton.style.opacity = journeyCurrentStage === 3 ? '0.5' : '1';
            }
        }

        function nextJourneyStage() {
            if (journeyCurrentStage < 3) {
                console.log(`Switching from stage ${journeyCurrentStage} to ${journeyCurrentStage + 1}`);
                journeyCurrentStage++;
                updateJourneyStageUI();
                adjustJourneyParticlesForStage();
                updateJourneyButtonStates();
                console.log(`Stage switch completed. Current stage: ${journeyCurrentStage}`);
            }
        }

        function previousJourneyStage() {
            if (journeyCurrentStage > 0) {
                console.log(`Switching from stage ${journeyCurrentStage} to ${journeyCurrentStage - 1}`);
                journeyCurrentStage--;
                updateJourneyStageUI();
                adjustJourneyParticlesForStage();
                updateJourneyButtonStates();
                console.log(`Stage switch completed. Current stage: ${journeyCurrentStage}`);
            }
        }

        function resetJourney() {
            console.log('Resetting journey to stage 0');
            journeyCurrentStage = 0;
            createJourneyParticles();
            updateJourneyStageUI();
            updateJourneyButtonStates();
            console.log('Journey reset completed');
        }

        function toggleInstructions() {
            const instructionsElement = document.getElementById('journey-instructions');
            const detailElement = document.getElementById('instructions-detail');
            const arrowElement = document.getElementById('instructions-arrow');
            
            if (detailElement.classList.contains('show')) {
                // 閉じる
                detailElement.classList.remove('show');
                arrowElement.textContent = '▼';
                console.log('Instructions collapsed');
            } else {
                // 開く
                detailElement.classList.add('show');
                arrowElement.textContent = '▲';
                console.log('Instructions expanded');
            }
        }

        function adjustJourneyParticlesForStage() {
            try {
                console.log(`Adjusting particles for stage ${journeyCurrentStage}`);
                if (journeyParticles.length > 0) {
                    journeyParticles.forEach((particle, index) => {
                        const maxVelocity = journeyCurrentStage === 3 ? 2.5 : 2; // Stage 3の速度制限を緩和
                        particle.vx = Math.max(-maxVelocity, Math.min(maxVelocity, particle.vx));
                        particle.vy = Math.max(-maxVelocity, Math.min(maxVelocity, particle.vy));
                        
                        particle.size = particle.baseSize;
                        particle.connections = [];
                        
                        if (journeyCurrentStage === 0) {
                            particle.autonomy = 0;
                            // 接続フェード状態リセット
                            particle.connectionFadeStartTime = null;
                            particle.connectionFadeOpacity = 0.0;
                        } else if (journeyCurrentStage === 1) {
                            particle.autonomy = Math.max(0, particle.autonomy);
                            // 接続フェード状態リセット
                            particle.connectionFadeStartTime = null;
                            particle.connectionFadeOpacity = 0.0;
                        } else if (journeyCurrentStage === 2) {
                            particle.autonomy = Math.max(0.1, particle.autonomy);
                            // 創造的散乱ステージ移行時の初期化
                            particle.hasInitialDispersed = false;
                            particle.initialDispersionTimer = 0;
                            particle.dispersalDirection = Math.random() * Math.PI * 2;
                            particle.dispersalForce = 0.4 + Math.random() * 0.3; // 穏やかな拡散力に調整
                            // 接続フェード状態リセット
                            particle.connectionFadeStartTime = null;
                            particle.connectionFadeOpacity = 0.0;
                        } else if (journeyCurrentStage === 3) {
                            particle.autonomy = Math.max(0.8, particle.autonomy);
                            
                            // 創発的相互作用ステージ移行時の接続フェードイン初期化
                            particle.connectionFadeStartTime = null;
                            particle.connectionFadeOpacity = 0.0;
                            
                            // Stage 3移行時の分散促進
                            const canvas = document.getElementById('journey-canvas');
                            if (canvas) {
                                const centerX = canvas.width / 2;
                                const centerY = canvas.height / 2;
                                const distanceToCenter = Math.sqrt((particle.x - centerX) ** 2 + (particle.y - centerY) ** 2);
                                
                                // 中心に集まりすぎている場合、外向きの初期速度を与える
                                if (distanceToCenter < Math.min(canvas.width, canvas.height) * 0.15) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const disperseForce = 0.5 + Math.random() * 1.0;
                                    particle.vx += Math.cos(angle) * disperseForce;
                                    particle.vy += Math.sin(angle) * disperseForce;
                                }
                                
                                // 個人的な方向性をランダムに再設定（多様性の確保）
                                particle.personalDirection = Math.random() * Math.PI * 2;
                            }
                        }
                        
                        console.log(`Particle ${index} stage set to ${journeyCurrentStage}`);
                    });
                    console.log(`Particle adjustment completed for stage ${journeyCurrentStage}`);
                } else {
                    console.warn('No particles available for stage adjustment');
                }
                
                if (journeyCurrentStage === 0) {
                    createJourneyParticles();
                }
            } catch (error) {
                console.error('Error adjusting particles for stage:', error);
            }
        }

        function startJourneyAnimation() {
            function animate() {
                try {
                    if (!journeyCanvas || !journeyCtx) {
                        console.warn('Canvas or context not available, stopping animation');
                        return;
                    }
                    
                    // 背景クリア
                    journeyCtx.clearRect(0, 0, journeyCanvas.width, journeyCanvas.height);
                    journeyCtx.fillStyle = '#0a0a0a';
                    journeyCtx.fillRect(0, 0, journeyCanvas.width, journeyCanvas.height);

                    // パーティクル更新と描画（エラーハンドリング付き）
                    journeyParticles.forEach((particle, index) => {
                        try {
                            particle.update(journeyCurrentStage, journeyMouseX, journeyMouseY, journeyParticles);
                            particle.draw(journeyCtx, journeyCurrentStage);
                        } catch (error) {
                            console.error(`Particle ${index} error in stage ${journeyCurrentStage}:`, error);
                            // エラーが発生したパーティクルの値をリセット
                            particle.vx = particle.vx || 0;
                            particle.vy = particle.vy || 0;
                            particle.x = particle.x || journeyCanvas.width / 2;
                            particle.y = particle.y || journeyCanvas.height / 2;
                        }
                    });

                    // 物理情報更新
                    updateJourneyPhysicsInfo();

                    journeyAnimationId = requestAnimationFrame(animate);
                } catch (error) {
                    console.error('Animation loop error:', error);
                    console.error('Error occurred at stage:', journeyCurrentStage);
                    console.error('Animation frame ID:', journeyAnimationId);
                    // アニメーションを停止
                    if (journeyAnimationId) {
                        cancelAnimationFrame(journeyAnimationId);
                        journeyAnimationId = null;
                        console.log('Animation stopped due to error');
                    }
                }
            }
            
            animate();
        }

        // イベントリスナー管理
        let journeyEventListeners = [];

        function addJourneyEventListeners() {
            if (!journeyCanvas) return;
            
            const mouseMoveHandler = (e) => {
                const rect = journeyCanvas.getBoundingClientRect();
                journeyMouseX = e.clientX - rect.left;
                journeyMouseY = e.clientY - rect.top;
            };
            
            const touchMoveHandler = (e) => {
                e.preventDefault();
                const rect = journeyCanvas.getBoundingClientRect();
                journeyMouseX = e.touches[0].clientX - rect.left;
                journeyMouseY = e.touches[0].clientY - rect.top;
            };
            
            const resizeHandler = () => {
                initJourneyCanvas();
                createJourneyParticles();
            };
            
            journeyCanvas.addEventListener('mousemove', mouseMoveHandler);
            journeyCanvas.addEventListener('touchmove', touchMoveHandler);
            window.addEventListener('resize', resizeHandler);
            
            journeyEventListeners.push(
                { element: journeyCanvas, event: 'mousemove', handler: mouseMoveHandler },
                { element: journeyCanvas, event: 'touchmove', handler: touchMoveHandler },
                { element: window, event: 'resize', handler: resizeHandler }
            );
        }

        function removeJourneyEventListeners() {
            journeyEventListeners.forEach(({ element, event, handler }) => {
                element.removeEventListener(event, handler);
            });
            journeyEventListeners = [];
        }

        // Stage click handling for dynamic linking
        document.addEventListener('DOMContentLoaded', function() {
            console.log('セルフ・オーサーシップ3D統合システム準備完了');
            
            // Test toggleSection function availability
            if (typeof toggleSection === 'function') {
                console.log('toggleSection function is available');
                
                // Test with buttons
                const toggleButtons = document.querySelectorAll('button[onclick*="toggleSection"]');
                console.log('Found toggle buttons:', toggleButtons.length);
                
                toggleButtons.forEach((button, index) => {
                    console.log(`Button ${index}:`, button.textContent.trim());
                    button.addEventListener('click', (e) => {
                        console.log('Button clicked:', button.textContent.trim());
                    });
                });
            } else {
                console.error('toggleSection function is NOT available');
            }
            
            // Test DOM elements
            const detailedJourney = document.getElementById('detailed-journey');
            const refinedPhases = document.getElementById('refined-phases');
            
            console.log('detailed-journey element:', detailedJourney);
            console.log('refined-phases element:', refinedPhases);
            
            // Add click handlers to stage headings in text for dynamic linking
            setTimeout(() => {
                const stageHeadings = document.querySelectorAll('.sub-phase h4');
                stageHeadings.forEach(heading => {
                    const text = heading.textContent;
                    const stageMatch = text.match(/^(Ea|Eb|Ec|E\(I\)|E-I|I-E|I\(E\)|Ia|Ib|Ic):/);
                    if (stageMatch) {
                        let stageId = stageMatch[1];
                        // Convert special cases
                        if (stageId === 'E(I)') stageId = 'EI';
                        if (stageId === 'I(E)') stageId = 'IE';
                        
                        heading.style.cursor = 'pointer';
                        heading.style.transition = 'color 0.3s';
                        heading.style.color = '#667eea';
                        
                        heading.addEventListener('click', () => {
                            if (refinedVisualization && refinedVisualization.isInitialized) {
                                refinedVisualization.switchToStage(stageId);
                                
                                // Scroll to 3D area
                                const container = document.getElementById('refined-3d-container');
                                if (container) {
                                    container.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            }
                        });
                        
                        heading.addEventListener('mouseenter', () => {
                            heading.style.color = '#764ba2';
                        });
                        
                        heading.addEventListener('mouseleave', () => {
                            heading.style.color = '#667eea';
                        });
                    }
                });
            }, 1000);
        });
        
        // ジャーニーマップ開閉機能
        function toggleJourneyMap() {
            const container = document.getElementById('journey-map-container');
            const icon = document.getElementById('journey-toggle-icon');
            
            if (container.style.display === 'none') {
                // 開く
                container.style.display = 'block';
                icon.classList.add('rotated');
                icon.textContent = '▲';
                
                // iframe のサイズ調整
                adjustIframeHeight();
            } else {
                // 閉じる
                container.style.display = 'none';
                icon.classList.remove('rotated');
                icon.textContent = '▼';
            }
        }
        
        // フレーズクラウド開閉機能
        function togglePhrasesCloud() {
            const container = document.getElementById('phrases-cloud-container');
            const icon = document.getElementById('phrases-toggle-icon');
            
            if (container.style.display === 'none') {
                // 開く
                container.style.display = 'block';
                icon.classList.add('rotated');
                icon.textContent = '▲';
            } else {
                // 閉じる
                container.style.display = 'none';
                icon.classList.remove('rotated');
                icon.textContent = '▼';
            }
        }
        
        // iframe の動的高さ調整（UX最適化版）
        let lastIframeHeight = 800; // 初期値をグラフが見える高さに
        let heightAdjustmentSetup = false;
        
        function adjustIframeHeight() {
            if (heightAdjustmentSetup) return; // 重複リスナー防止
            heightAdjustmentSetup = true;
            
            const iframe = document.getElementById('journey-map-iframe');
            
            // PostMessage でiframe内の高さを受信
            window.addEventListener('message', function(event) {
                if (event.data.type === 'IFRAME_HEIGHT_CHANGE' && iframe) {
                    let newHeight = event.data.height + 20; // パディングを最小限に
                    
                    // レスポンシブ対応：画面サイズに応じた制限
                    const viewportHeight = window.innerHeight;
                    const maxAllowedHeight = Math.min(viewportHeight * 0.85, 1600);
                    
                    // 最小高さを800px、最大高さを制限
                    newHeight = Math.max(800, Math.min(newHeight, maxAllowedHeight));
                    
                    // 高さの変化が最小限の場合は調整しない
                    if (Math.abs(newHeight - lastIframeHeight) < 5) {
                        return;
                    }
                    
                    lastIframeHeight = newHeight;
                    
                    // スムーズなトランジション
                    iframe.style.transition = 'height 0.3s ease-out';
                    iframe.style.height = newHeight + 'px';
                    
                    console.log('iframe高さ最適化:', {
                        received: event.data.height,
                        applied: newHeight,
                        viewport: viewportHeight
                    });
                    
                    // トランジション終了後にtransitionを削除
                    setTimeout(() => {
                        iframe.style.transition = '';
                    }, 300);
                }
            });
        }
        
        // アイデア独り言ツール機能
        function openIdeaFeedbackTool() {
            // モーダルの作成
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 10000;
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 20px;
                box-sizing: border-box;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 12px;
                width: 100%;
                max-width: 800px;
                max-height: 90vh;
                overflow-y: auto;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            `;
            
            modalContent.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="margin: 0; color: #667eea;">💭 アイデア独り言ツール</h2>
                    <button onclick="this.closest('.idea-feedback-modal').remove()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #999;">×</button>
                </div>
                
                <p style="margin-bottom: 15px; color: #666; font-size: 16px; line-height: 1.6;">
                    <strong>🎯 このツールの目的</strong><br>
                    現在検討中のアイデアについて、セルフ・オーサーシップの観点から生成AIにフィードバックをもらうためのプロンプトを生成します。
                </p>
                
                <div style="background: #e8f4f8; border-left: 4px solid #2196f3; padding: 15px; margin-bottom: 15px; border-radius: 4px;">
                    <p style="margin: 0; color: #1976d2; font-weight: 500;">
                        💡 <strong>効果的な活用方法</strong><br>
                        最終的に生成AIにプロンプトを入力する際は、作成中の企画書・提案書も添付して実行するとより効果的です。
                    </p>
                </div>
                
                <div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin-bottom: 20px; border-radius: 4px;">
                    <p style="margin: 0; color: #856404; font-weight: 500;">
                        ⚠️ <strong>重要な注意事項</strong><br>
                        • 生成AIの利用にあたってはプライバシーや機密情報に十分注意してください<br>
                        • 企画書に対するフィードバックをもらう場合は、セキュリティの観点から<strong>Microsoft Copilot</strong>を利用してください<br>
                        • <strong>GPT-5をオンにした上で実行</strong>してください
                    </p>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #333;">
                        アイデア・企画の概要
                    </label>
                    <textarea id="ideaContent" 
                        placeholder="検討中のアイデアや企画の内容を入力してください。&#10;- 背景・目的&#10;- 具体的な内容&#10;- 対象者&#10;- 期待する効果など"
                        style="width: 100%; height: 200px; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-family: inherit; resize: vertical; box-sizing: border-box;"></textarea>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #333;">
                        フィードバックの観点（複数選択可）
                    </label>
                    <div style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 10px;">
                        <label style="display: flex; align-items: center;">
                            <input type="checkbox" id="recognizing" value="recognizing" checked style="margin-right: 8px;">
                            認識論的次元：私はどのように知るのか？
                        </label>
                        <label style="display: flex; align-items: center;">
                            <input type="checkbox" id="intrapersonal" value="intrapersonal" checked style="margin-right: 8px;">
                            対自関係次元：私は何者か？
                        </label>
                        <label style="display: flex; align-items: center;">
                            <input type="checkbox" id="interpersonal" value="interpersonal" checked style="margin-right: 8px;">
                            対人関係次元：他者とどのように関わるか？
                        </label>
                        <label style="display: flex; align-items: center;">
                            <input type="checkbox" id="phases" value="phases" checked style="margin-right: 8px;">
                            成長段階の考慮
                        </label>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #333;">
                        特に重視したい点
                    </label>
                    <div style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 10px;">
                        <label style="display: flex; align-items: center;">
                            <input type="radio" name="focusArea" value="balanced" checked style="margin-right: 8px;">
                            バランスの取れた総合的な評価
                        </label>
                        <label style="display: flex; align-items: center;">
                            <input type="radio" name="focusArea" value="theory" style="margin-right: 8px;">
                            理念・理論面の深い検討
                        </label>
                        <label style="display: flex; align-items: center;">
                            <input type="radio" name="focusArea" value="practice" style="margin-right: 8px;">
                            実践・実装面の具体的検討
                        </label>
                        <label style="display: flex; align-items: center;">
                            <input type="radio" name="focusArea" value="student-centered" style="margin-right: 8px;">
                            学生の主体性と成長
                        </label>
                    </div>
                </div>
                
                <div style="text-align: center; margin-top: 30px;">
                    <button onclick="generateFeedbackPrompt()" 
                        style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; padding: 12px 30px; border-radius: 8px; font-size: 16px; cursor: pointer; margin-right: 10px;">
                        プロンプトを生成
                    </button>
                    <button onclick="this.closest('.idea-feedback-modal').remove()" 
                        style="background: #ccc; color: #333; border: none; padding: 12px 30px; border-radius: 8px; font-size: 16px; cursor: pointer;">
                        閉じる
                    </button>
                </div>
                
                <div id="generatedPrompt" style="margin-top: 30px; display: none;">
                    <div id="completionMessage" style="background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px; padding: 15px; margin-bottom: 20px; display: none;">
                        <h4 style="color: #155724; margin: 0 0 10px 0; display: flex; align-items: center;">
                            ✅ プロンプト生成完了！
                        </h4>
                        <p style="color: #155724; margin: 0 0 10px 0; font-weight: 500;">
                            以下のプロンプトをコピーして生成AIに投入してください
                        </p>
                        <div style="background: #ffff66; border: 1px solid #f5c6cb; border-radius: 6px; padding: 12px; margin-top: 10px;">
                            <p style="color: #721c24; margin: 0; font-size: 14px; font-weight: 500;">
                                ⚠️ <strong>生成AI投入時の重要な注意点</strong><br>
                                • <strong>Microsoft Copilot</strong>を使用してください（セキュリティ確保のため）<br>
                                • <strong>GPT-5をオンにして実行</strong>してください<br>
                                • 企画書・提案書があれば一緒に添付すると効果的です<br>
                                • プライバシーや機密情報にご注意ください
                            </p>
                        </div>
                    </div>
                    
                    <h3 style="color: #667eea; margin-bottom: 15px;">生成されたプロンプト</h3>
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 5px solid #667eea;">
                        <textarea id="promptOutput" readonly 
                            style="width: 100%; height: 300px; border: none; background: transparent; font-family: monospace; font-size: 14px; resize: vertical; box-sizing: border-box;"></textarea>
                    </div>
                    <button onclick="copyPromptToClipboard()" 
                        style="background: linear-gradient(135deg, #51cf66, #006600); color: white; border: none; padding: 10px 20px; border-radius: 6px; margin-top: 10px; cursor: pointer;">
                        📋 クリップボードにコピー
                    </button>
                </div>
            `;
            
            modal.className = 'idea-feedback-modal';
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // モーダル外クリックで閉じる
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        function generateFeedbackPrompt() {
            const ideaContent = document.getElementById('ideaContent').value.trim();
            const focusArea = document.querySelector('input[name="focusArea"]:checked').value;
            
            if (!ideaContent) {
                alert('アイデア・企画の概要を入力してください。');
                return;
            }
            
            // チェックされた観点を取得
            const selectedAspects = [];
            if (document.getElementById('recognizing').checked) selectedAspects.push('認識論的次元（Epistemological）');
            if (document.getElementById('intrapersonal').checked) selectedAspects.push('対自関係次元（Intrapersonal）');
            if (document.getElementById('interpersonal').checked) selectedAspects.push('対人関係次元（Interpersonal）');
            if (document.getElementById('phases').checked) selectedAspects.push('成長段階の考慮');
            
            const focusDescriptions = {
                'balanced': 'バランスの取れた総合的な評価',
                'theory': '理念・理論面の深い検討',
                'practice': '実践・実装面の具体的検討',
                'student-centered': '学生の主体性と成長',
            };
            
            const prompt = generateDetailedPrompt(ideaContent, selectedAspects, focusDescriptions[focusArea]);
            
            document.getElementById('promptOutput').value = prompt;
            document.getElementById('generatedPrompt').style.display = 'block';
            
            // 完了メッセージを表示
            document.getElementById('completionMessage').style.display = 'block';
            
            // 完了メッセージまでスクロール
            setTimeout(() => {
                document.getElementById('completionMessage').scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'start' 
                });
            }, 100);
        }
        
        function generateDetailedPrompt(ideaContent, aspects, focusArea) {
            return `# セルフ・オーサーシップを重視した学生支援策のアイデア評価

以下の学生支援のアイデア・企画について、セルフ・オーサーシップ理論の観点から建設的なフィードバックをお願いします。

## 評価対象のアイデア・企画
${ideaContent}

## フィードバックの観点
重視する観点：${focusArea}
評価する次元：${aspects.join('、')}

## セルフ・オーサーシップ理論の要点
セルフ・オーサーシップとは「自分自身の信念、価値観、アイデンティティ、社会関係を内的に定義する能力」で、以下の3つの次元があります：

1. **認識論的次元（Epistemological）**: 知識や真理をどう捉えるか
   - 外的権威からの脱却 → 内的な知識構築能力の発達
   - 複数の視点を統合し、文脈に応じた判断ができる

2. **対自関係次元（Intrapersonal）**: 自己概念やアイデンティティ
   - 他者からの承認依存 → 内的な価値観・信念の確立
   - 自分らしさを追求し、一貫したアイデンティティを構築

3. **対人関係次元（Interpersonal）**: 他者との関係性
   - 他者に合わせる → 相互に尊重し合う関係性の構築
   - 自分の価値観を保ちながら、他者と建設的な関係を築く

## 成長段階
- **第1段階（外的定式化）**: 外的権威に依存
- **第2段階（岐路）**: 内的声と外的影響の間で揺れ動く
- **第3段階（セルフ・オーサーシップ）**: 内的に定義された信念・価値観に基づいて行動

## 求めるフィードバック

### 1. 理念面の評価
- このアイデアは学生のセルフ・オーサーシップの変容をどのように後押しする可能性がありますか？
- 各次元（認識論的、対自関係、対人関係）への配慮は十分でしょうか？
- 成長段階に応じた支援になっているでしょうか？

### 2. 実践面の評価
- 実際の実装において、学生の主体性を損なうリスクはありませんか？
- 運営側が外的権威として機能してしまう可能性はありませんか？
- より効果的な実践方法があれば提案してください。

### 3. 企画運営側への問いかけ
このアイデアを実践する自分達自身の成長にもつながるように：
- どのような問いかけや振り返りが必要でしょうか？
- 企画時に滑り込んできやすい思考の癖、言葉遣い、意識下のバイアスは何でしょうか？
- 様々な取り組みが有機的に連携し学生の成長を後押しする環境の創発に必要なことはどのようなものがありますか？

## お願い
遠慮のない率直なフィードバックをお願いします。改善点や懸念点があれば具体的に指摘してください。また、このアイデアをより効果的にするための建設的な提案もお願いします。`;
        }
        
        function copyPromptToClipboard() {
            const promptText = document.getElementById('promptOutput').value;
            navigator.clipboard.writeText(promptText).then(function() {
                alert('プロンプトをクリップボードにコピーしました！');
            }).catch(function(err) {
                console.error('コピーに失敗しました: ', err);
                alert('コピーに失敗しました。手動でテキストを選択してコピーしてください。');
            });
        }
    </script>
</body>
</html>
